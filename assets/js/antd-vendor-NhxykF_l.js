import { i as inject, r as ref, h as h$1, n as nextTick, g as getCurrentInstance, a as reactive, d as defineComponent, c as createVNode, F as Fragment, b as isVNode, C as Comment, T as Text$1, o as onMounted, e as onUpdated, f as onUnmounted, w as watch, j as computed, p as provide, u as unref, s as shallowRef, k as watchEffect, l as onBeforeUnmount, t as triggerRef, m as withDirectives, q as resolveDirective, v as Transition, x as cloneVNode, y as render, z as toRef, A as vShow, B as withModifiers, D as onBeforeMount, E as Teleport, G as createTextVNode, H as isRef, I as toRefs, J as toRaw, K as useAttrs, L as onBeforeUpdate, M as getCurrentScope, N as onScopeDispose, O as TransitionGroup, P as onActivated, Q as createApp } from "./vue-vendor-DA6b90QH.js";
import { i as isEmpty$1 } from "./lodash-vendor-B6NgBDy-.js";
function bound01(n2, max) {
  if (isOnePointZero(n2)) {
    n2 = "100%";
  }
  var isPercent = isPercentage(n2);
  n2 = max === 360 ? n2 : Math.min(max, Math.max(0, parseFloat(n2)));
  if (isPercent) {
    n2 = parseInt(String(n2 * max), 10) / 100;
  }
  if (Math.abs(n2 - max) < 1e-6) {
    return 1;
  }
  if (max === 360) {
    n2 = (n2 < 0 ? n2 % max + max : n2 % max) / parseFloat(String(max));
  } else {
    n2 = n2 % max / parseFloat(String(max));
  }
  return n2;
}
function clamp01(val) {
  return Math.min(1, Math.max(0, val));
}
function isOnePointZero(n2) {
  return typeof n2 === "string" && n2.indexOf(".") !== -1 && parseFloat(n2) === 1;
}
function isPercentage(n2) {
  return typeof n2 === "string" && n2.indexOf("%") !== -1;
}
function boundAlpha(a2) {
  a2 = parseFloat(a2);
  if (isNaN(a2) || a2 < 0 || a2 > 1) {
    a2 = 1;
  }
  return a2;
}
function convertToPercentage(n2) {
  if (n2 <= 1) {
    return "".concat(Number(n2) * 100, "%");
  }
  return n2;
}
function pad2(c2) {
  return c2.length === 1 ? "0" + c2 : String(c2);
}
function rgbToRgb(r2, g2, b2) {
  return {
    r: bound01(r2, 255) * 255,
    g: bound01(g2, 255) * 255,
    b: bound01(b2, 255) * 255
  };
}
function rgbToHsl(r2, g2, b2) {
  r2 = bound01(r2, 255);
  g2 = bound01(g2, 255);
  b2 = bound01(b2, 255);
  var max = Math.max(r2, g2, b2);
  var min = Math.min(r2, g2, b2);
  var h2 = 0;
  var s2 = 0;
  var l2 = (max + min) / 2;
  if (max === min) {
    s2 = 0;
    h2 = 0;
  } else {
    var d2 = max - min;
    s2 = l2 > 0.5 ? d2 / (2 - max - min) : d2 / (max + min);
    switch (max) {
      case r2:
        h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
        break;
      case g2:
        h2 = (b2 - r2) / d2 + 2;
        break;
      case b2:
        h2 = (r2 - g2) / d2 + 4;
        break;
    }
    h2 /= 6;
  }
  return { h: h2, s: s2, l: l2 };
}
function hue2rgb(p, q2, t2) {
  if (t2 < 0) {
    t2 += 1;
  }
  if (t2 > 1) {
    t2 -= 1;
  }
  if (t2 < 1 / 6) {
    return p + (q2 - p) * (6 * t2);
  }
  if (t2 < 1 / 2) {
    return q2;
  }
  if (t2 < 2 / 3) {
    return p + (q2 - p) * (2 / 3 - t2) * 6;
  }
  return p;
}
function hslToRgb(h2, s2, l2) {
  var r2;
  var g2;
  var b2;
  h2 = bound01(h2, 360);
  s2 = bound01(s2, 100);
  l2 = bound01(l2, 100);
  if (s2 === 0) {
    g2 = l2;
    b2 = l2;
    r2 = l2;
  } else {
    var q2 = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
    var p = 2 * l2 - q2;
    r2 = hue2rgb(p, q2, h2 + 1 / 3);
    g2 = hue2rgb(p, q2, h2);
    b2 = hue2rgb(p, q2, h2 - 1 / 3);
  }
  return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
}
function rgbToHsv(r2, g2, b2) {
  r2 = bound01(r2, 255);
  g2 = bound01(g2, 255);
  b2 = bound01(b2, 255);
  var max = Math.max(r2, g2, b2);
  var min = Math.min(r2, g2, b2);
  var h2 = 0;
  var v2 = max;
  var d2 = max - min;
  var s2 = max === 0 ? 0 : d2 / max;
  if (max === min) {
    h2 = 0;
  } else {
    switch (max) {
      case r2:
        h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
        break;
      case g2:
        h2 = (b2 - r2) / d2 + 2;
        break;
      case b2:
        h2 = (r2 - g2) / d2 + 4;
        break;
    }
    h2 /= 6;
  }
  return { h: h2, s: s2, v: v2 };
}
function hsvToRgb(h2, s2, v2) {
  h2 = bound01(h2, 360) * 6;
  s2 = bound01(s2, 100);
  v2 = bound01(v2, 100);
  var i2 = Math.floor(h2);
  var f2 = h2 - i2;
  var p = v2 * (1 - s2);
  var q2 = v2 * (1 - f2 * s2);
  var t2 = v2 * (1 - (1 - f2) * s2);
  var mod = i2 % 6;
  var r2 = [v2, q2, p, p, t2, v2][mod];
  var g2 = [t2, v2, v2, q2, p, p][mod];
  var b2 = [p, p, t2, v2, v2, q2][mod];
  return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
}
function rgbToHex(r2, g2, b2, allow3Char) {
  var hex2 = [
    pad2(Math.round(r2).toString(16)),
    pad2(Math.round(g2).toString(16)),
    pad2(Math.round(b2).toString(16))
  ];
  if (allow3Char && hex2[0].startsWith(hex2[0].charAt(1)) && hex2[1].startsWith(hex2[1].charAt(1)) && hex2[2].startsWith(hex2[2].charAt(1))) {
    return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0);
  }
  return hex2.join("");
}
function rgbaToHex(r2, g2, b2, a2, allow4Char) {
  var hex2 = [
    pad2(Math.round(r2).toString(16)),
    pad2(Math.round(g2).toString(16)),
    pad2(Math.round(b2).toString(16)),
    pad2(convertDecimalToHex(a2))
  ];
  if (allow4Char && hex2[0].startsWith(hex2[0].charAt(1)) && hex2[1].startsWith(hex2[1].charAt(1)) && hex2[2].startsWith(hex2[2].charAt(1)) && hex2[3].startsWith(hex2[3].charAt(1))) {
    return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0) + hex2[3].charAt(0);
  }
  return hex2.join("");
}
function convertDecimalToHex(d2) {
  return Math.round(parseFloat(d2) * 255).toString(16);
}
function convertHexToDecimal(h2) {
  return parseIntFromHex(h2) / 255;
}
function parseIntFromHex(val) {
  return parseInt(val, 16);
}
function numberInputToObject(color) {
  return {
    r: color >> 16,
    g: (color & 65280) >> 8,
    b: color & 255
  };
}
var names = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
function inputToRGB(color) {
  var rgb = { r: 0, g: 0, b: 0 };
  var a2 = 1;
  var s2 = null;
  var v2 = null;
  var l2 = null;
  var ok = false;
  var format2 = false;
  if (typeof color === "string") {
    color = stringInputToObject(color);
  }
  if (typeof color === "object") {
    if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
      rgb = rgbToRgb(color.r, color.g, color.b);
      ok = true;
      format2 = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
      s2 = convertToPercentage(color.s);
      v2 = convertToPercentage(color.v);
      rgb = hsvToRgb(color.h, s2, v2);
      ok = true;
      format2 = "hsv";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
      s2 = convertToPercentage(color.s);
      l2 = convertToPercentage(color.l);
      rgb = hslToRgb(color.h, s2, l2);
      ok = true;
      format2 = "hsl";
    }
    if (Object.prototype.hasOwnProperty.call(color, "a")) {
      a2 = color.a;
    }
  }
  a2 = boundAlpha(a2);
  return {
    ok,
    format: color.format || format2,
    r: Math.min(255, Math.max(rgb.r, 0)),
    g: Math.min(255, Math.max(rgb.g, 0)),
    b: Math.min(255, Math.max(rgb.b, 0)),
    a: a2
  };
}
var CSS_INTEGER = "[-\\+]?\\d+%?";
var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
var CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")");
var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
var matchers = {
  CSS_UNIT: new RegExp(CSS_UNIT),
  rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
  rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
  hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
  hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
  hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
  hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function stringInputToObject(color) {
  color = color.trim().toLowerCase();
  if (color.length === 0) {
    return false;
  }
  var named = false;
  if (names[color]) {
    color = names[color];
    named = true;
  } else if (color === "transparent") {
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  }
  var match2 = matchers.rgb.exec(color);
  if (match2) {
    return { r: match2[1], g: match2[2], b: match2[3] };
  }
  match2 = matchers.rgba.exec(color);
  if (match2) {
    return { r: match2[1], g: match2[2], b: match2[3], a: match2[4] };
  }
  match2 = matchers.hsl.exec(color);
  if (match2) {
    return { h: match2[1], s: match2[2], l: match2[3] };
  }
  match2 = matchers.hsla.exec(color);
  if (match2) {
    return { h: match2[1], s: match2[2], l: match2[3], a: match2[4] };
  }
  match2 = matchers.hsv.exec(color);
  if (match2) {
    return { h: match2[1], s: match2[2], v: match2[3] };
  }
  match2 = matchers.hsva.exec(color);
  if (match2) {
    return { h: match2[1], s: match2[2], v: match2[3], a: match2[4] };
  }
  match2 = matchers.hex8.exec(color);
  if (match2) {
    return {
      r: parseIntFromHex(match2[1]),
      g: parseIntFromHex(match2[2]),
      b: parseIntFromHex(match2[3]),
      a: convertHexToDecimal(match2[4]),
      format: named ? "name" : "hex8"
    };
  }
  match2 = matchers.hex6.exec(color);
  if (match2) {
    return {
      r: parseIntFromHex(match2[1]),
      g: parseIntFromHex(match2[2]),
      b: parseIntFromHex(match2[3]),
      format: named ? "name" : "hex"
    };
  }
  match2 = matchers.hex4.exec(color);
  if (match2) {
    return {
      r: parseIntFromHex(match2[1] + match2[1]),
      g: parseIntFromHex(match2[2] + match2[2]),
      b: parseIntFromHex(match2[3] + match2[3]),
      a: convertHexToDecimal(match2[4] + match2[4]),
      format: named ? "name" : "hex8"
    };
  }
  match2 = matchers.hex3.exec(color);
  if (match2) {
    return {
      r: parseIntFromHex(match2[1] + match2[1]),
      g: parseIntFromHex(match2[2] + match2[2]),
      b: parseIntFromHex(match2[3] + match2[3]),
      format: named ? "name" : "hex"
    };
  }
  return false;
}
function isValidCSSUnit(color) {
  return Boolean(matchers.CSS_UNIT.exec(String(color)));
}
var TinyColor = (
  /** @class */
  function() {
    function TinyColor2(color, opts) {
      if (color === void 0) {
        color = "";
      }
      if (opts === void 0) {
        opts = {};
      }
      var _a2;
      if (color instanceof TinyColor2) {
        return color;
      }
      if (typeof color === "number") {
        color = numberInputToObject(color);
      }
      this.originalInput = color;
      var rgb = inputToRGB(color);
      this.originalInput = color;
      this.r = rgb.r;
      this.g = rgb.g;
      this.b = rgb.b;
      this.a = rgb.a;
      this.roundA = Math.round(100 * this.a) / 100;
      this.format = (_a2 = opts.format) !== null && _a2 !== void 0 ? _a2 : rgb.format;
      this.gradientType = opts.gradientType;
      if (this.r < 1) {
        this.r = Math.round(this.r);
      }
      if (this.g < 1) {
        this.g = Math.round(this.g);
      }
      if (this.b < 1) {
        this.b = Math.round(this.b);
      }
      this.isValid = rgb.ok;
    }
    TinyColor2.prototype.isDark = function() {
      return this.getBrightness() < 128;
    };
    TinyColor2.prototype.isLight = function() {
      return !this.isDark();
    };
    TinyColor2.prototype.getBrightness = function() {
      var rgb = this.toRgb();
      return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
    };
    TinyColor2.prototype.getLuminance = function() {
      var rgb = this.toRgb();
      var R2;
      var G;
      var B2;
      var RsRGB = rgb.r / 255;
      var GsRGB = rgb.g / 255;
      var BsRGB = rgb.b / 255;
      if (RsRGB <= 0.03928) {
        R2 = RsRGB / 12.92;
      } else {
        R2 = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
      }
      if (GsRGB <= 0.03928) {
        G = GsRGB / 12.92;
      } else {
        G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
      }
      if (BsRGB <= 0.03928) {
        B2 = BsRGB / 12.92;
      } else {
        B2 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
      }
      return 0.2126 * R2 + 0.7152 * G + 0.0722 * B2;
    };
    TinyColor2.prototype.getAlpha = function() {
      return this.a;
    };
    TinyColor2.prototype.setAlpha = function(alpha) {
      this.a = boundAlpha(alpha);
      this.roundA = Math.round(100 * this.a) / 100;
      return this;
    };
    TinyColor2.prototype.isMonochrome = function() {
      var s2 = this.toHsl().s;
      return s2 === 0;
    };
    TinyColor2.prototype.toHsv = function() {
      var hsv = rgbToHsv(this.r, this.g, this.b);
      return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
    };
    TinyColor2.prototype.toHsvString = function() {
      var hsv = rgbToHsv(this.r, this.g, this.b);
      var h2 = Math.round(hsv.h * 360);
      var s2 = Math.round(hsv.s * 100);
      var v2 = Math.round(hsv.v * 100);
      return this.a === 1 ? "hsv(".concat(h2, ", ").concat(s2, "%, ").concat(v2, "%)") : "hsva(".concat(h2, ", ").concat(s2, "%, ").concat(v2, "%, ").concat(this.roundA, ")");
    };
    TinyColor2.prototype.toHsl = function() {
      var hsl = rgbToHsl(this.r, this.g, this.b);
      return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };
    };
    TinyColor2.prototype.toHslString = function() {
      var hsl = rgbToHsl(this.r, this.g, this.b);
      var h2 = Math.round(hsl.h * 360);
      var s2 = Math.round(hsl.s * 100);
      var l2 = Math.round(hsl.l * 100);
      return this.a === 1 ? "hsl(".concat(h2, ", ").concat(s2, "%, ").concat(l2, "%)") : "hsla(".concat(h2, ", ").concat(s2, "%, ").concat(l2, "%, ").concat(this.roundA, ")");
    };
    TinyColor2.prototype.toHex = function(allow3Char) {
      if (allow3Char === void 0) {
        allow3Char = false;
      }
      return rgbToHex(this.r, this.g, this.b, allow3Char);
    };
    TinyColor2.prototype.toHexString = function(allow3Char) {
      if (allow3Char === void 0) {
        allow3Char = false;
      }
      return "#" + this.toHex(allow3Char);
    };
    TinyColor2.prototype.toHex8 = function(allow4Char) {
      if (allow4Char === void 0) {
        allow4Char = false;
      }
      return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
    };
    TinyColor2.prototype.toHex8String = function(allow4Char) {
      if (allow4Char === void 0) {
        allow4Char = false;
      }
      return "#" + this.toHex8(allow4Char);
    };
    TinyColor2.prototype.toHexShortString = function(allowShortChar) {
      if (allowShortChar === void 0) {
        allowShortChar = false;
      }
      return this.a === 1 ? this.toHexString(allowShortChar) : this.toHex8String(allowShortChar);
    };
    TinyColor2.prototype.toRgb = function() {
      return {
        r: Math.round(this.r),
        g: Math.round(this.g),
        b: Math.round(this.b),
        a: this.a
      };
    };
    TinyColor2.prototype.toRgbString = function() {
      var r2 = Math.round(this.r);
      var g2 = Math.round(this.g);
      var b2 = Math.round(this.b);
      return this.a === 1 ? "rgb(".concat(r2, ", ").concat(g2, ", ").concat(b2, ")") : "rgba(".concat(r2, ", ").concat(g2, ", ").concat(b2, ", ").concat(this.roundA, ")");
    };
    TinyColor2.prototype.toPercentageRgb = function() {
      var fmt = function(x2) {
        return "".concat(Math.round(bound01(x2, 255) * 100), "%");
      };
      return {
        r: fmt(this.r),
        g: fmt(this.g),
        b: fmt(this.b),
        a: this.a
      };
    };
    TinyColor2.prototype.toPercentageRgbString = function() {
      var rnd = function(x2) {
        return Math.round(bound01(x2, 255) * 100);
      };
      return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
    };
    TinyColor2.prototype.toName = function() {
      if (this.a === 0) {
        return "transparent";
      }
      if (this.a < 1) {
        return false;
      }
      var hex2 = "#" + rgbToHex(this.r, this.g, this.b, false);
      for (var _i = 0, _a2 = Object.entries(names); _i < _a2.length; _i++) {
        var _b = _a2[_i], key2 = _b[0], value = _b[1];
        if (hex2 === value) {
          return key2;
        }
      }
      return false;
    };
    TinyColor2.prototype.toString = function(format2) {
      var formatSet = Boolean(format2);
      format2 = format2 !== null && format2 !== void 0 ? format2 : this.format;
      var formattedString = false;
      var hasAlpha = this.a < 1 && this.a >= 0;
      var needsAlphaFormat = !formatSet && hasAlpha && (format2.startsWith("hex") || format2 === "name");
      if (needsAlphaFormat) {
        if (format2 === "name" && this.a === 0) {
          return this.toName();
        }
        return this.toRgbString();
      }
      if (format2 === "rgb") {
        formattedString = this.toRgbString();
      }
      if (format2 === "prgb") {
        formattedString = this.toPercentageRgbString();
      }
      if (format2 === "hex" || format2 === "hex6") {
        formattedString = this.toHexString();
      }
      if (format2 === "hex3") {
        formattedString = this.toHexString(true);
      }
      if (format2 === "hex4") {
        formattedString = this.toHex8String(true);
      }
      if (format2 === "hex8") {
        formattedString = this.toHex8String();
      }
      if (format2 === "name") {
        formattedString = this.toName();
      }
      if (format2 === "hsl") {
        formattedString = this.toHslString();
      }
      if (format2 === "hsv") {
        formattedString = this.toHsvString();
      }
      return formattedString || this.toHexString();
    };
    TinyColor2.prototype.toNumber = function() {
      return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
    };
    TinyColor2.prototype.clone = function() {
      return new TinyColor2(this.toString());
    };
    TinyColor2.prototype.lighten = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      var hsl = this.toHsl();
      hsl.l += amount / 100;
      hsl.l = clamp01(hsl.l);
      return new TinyColor2(hsl);
    };
    TinyColor2.prototype.brighten = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      var rgb = this.toRgb();
      rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
      rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
      rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
      return new TinyColor2(rgb);
    };
    TinyColor2.prototype.darken = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      var hsl = this.toHsl();
      hsl.l -= amount / 100;
      hsl.l = clamp01(hsl.l);
      return new TinyColor2(hsl);
    };
    TinyColor2.prototype.tint = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      return this.mix("white", amount);
    };
    TinyColor2.prototype.shade = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      return this.mix("black", amount);
    };
    TinyColor2.prototype.desaturate = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      var hsl = this.toHsl();
      hsl.s -= amount / 100;
      hsl.s = clamp01(hsl.s);
      return new TinyColor2(hsl);
    };
    TinyColor2.prototype.saturate = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      var hsl = this.toHsl();
      hsl.s += amount / 100;
      hsl.s = clamp01(hsl.s);
      return new TinyColor2(hsl);
    };
    TinyColor2.prototype.greyscale = function() {
      return this.desaturate(100);
    };
    TinyColor2.prototype.spin = function(amount) {
      var hsl = this.toHsl();
      var hue = (hsl.h + amount) % 360;
      hsl.h = hue < 0 ? 360 + hue : hue;
      return new TinyColor2(hsl);
    };
    TinyColor2.prototype.mix = function(color, amount) {
      if (amount === void 0) {
        amount = 50;
      }
      var rgb1 = this.toRgb();
      var rgb2 = new TinyColor2(color).toRgb();
      var p = amount / 100;
      var rgba = {
        r: (rgb2.r - rgb1.r) * p + rgb1.r,
        g: (rgb2.g - rgb1.g) * p + rgb1.g,
        b: (rgb2.b - rgb1.b) * p + rgb1.b,
        a: (rgb2.a - rgb1.a) * p + rgb1.a
      };
      return new TinyColor2(rgba);
    };
    TinyColor2.prototype.analogous = function(results, slices) {
      if (results === void 0) {
        results = 6;
      }
      if (slices === void 0) {
        slices = 30;
      }
      var hsl = this.toHsl();
      var part = 360 / slices;
      var ret = [this];
      for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
        hsl.h = (hsl.h + part) % 360;
        ret.push(new TinyColor2(hsl));
      }
      return ret;
    };
    TinyColor2.prototype.complement = function() {
      var hsl = this.toHsl();
      hsl.h = (hsl.h + 180) % 360;
      return new TinyColor2(hsl);
    };
    TinyColor2.prototype.monochromatic = function(results) {
      if (results === void 0) {
        results = 6;
      }
      var hsv = this.toHsv();
      var h2 = hsv.h;
      var s2 = hsv.s;
      var v2 = hsv.v;
      var res = [];
      var modification = 1 / results;
      while (results--) {
        res.push(new TinyColor2({ h: h2, s: s2, v: v2 }));
        v2 = (v2 + modification) % 1;
      }
      return res;
    };
    TinyColor2.prototype.splitcomplement = function() {
      var hsl = this.toHsl();
      var h2 = hsl.h;
      return [
        this,
        new TinyColor2({ h: (h2 + 72) % 360, s: hsl.s, l: hsl.l }),
        new TinyColor2({ h: (h2 + 216) % 360, s: hsl.s, l: hsl.l })
      ];
    };
    TinyColor2.prototype.onBackground = function(background) {
      var fg = this.toRgb();
      var bg = new TinyColor2(background).toRgb();
      var alpha = fg.a + bg.a * (1 - fg.a);
      return new TinyColor2({
        r: (fg.r * fg.a + bg.r * bg.a * (1 - fg.a)) / alpha,
        g: (fg.g * fg.a + bg.g * bg.a * (1 - fg.a)) / alpha,
        b: (fg.b * fg.a + bg.b * bg.a * (1 - fg.a)) / alpha,
        a: alpha
      });
    };
    TinyColor2.prototype.triad = function() {
      return this.polyad(3);
    };
    TinyColor2.prototype.tetrad = function() {
      return this.polyad(4);
    };
    TinyColor2.prototype.polyad = function(n2) {
      var hsl = this.toHsl();
      var h2 = hsl.h;
      var result = [this];
      var increment = 360 / n2;
      for (var i2 = 1; i2 < n2; i2++) {
        result.push(new TinyColor2({ h: (h2 + i2 * increment) % 360, s: hsl.s, l: hsl.l }));
      }
      return result;
    };
    TinyColor2.prototype.equals = function(color) {
      return this.toRgbString() === new TinyColor2(color).toRgbString();
    };
    return TinyColor2;
  }()
);
var hueStep = 2;
var saturationStep = 0.16;
var saturationStep2 = 0.05;
var brightnessStep1 = 0.05;
var brightnessStep2 = 0.15;
var lightColorCount = 5;
var darkColorCount = 4;
var darkColorMap = [{
  index: 7,
  opacity: 0.15
}, {
  index: 6,
  opacity: 0.25
}, {
  index: 5,
  opacity: 0.3
}, {
  index: 5,
  opacity: 0.45
}, {
  index: 5,
  opacity: 0.65
}, {
  index: 5,
  opacity: 0.85
}, {
  index: 4,
  opacity: 0.9
}, {
  index: 3,
  opacity: 0.95
}, {
  index: 2,
  opacity: 0.97
}, {
  index: 1,
  opacity: 0.98
}];
function toHsv(_ref) {
  var r2 = _ref.r, g2 = _ref.g, b2 = _ref.b;
  var hsv = rgbToHsv(r2, g2, b2);
  return {
    h: hsv.h * 360,
    s: hsv.s,
    v: hsv.v
  };
}
function toHex(_ref2) {
  var r2 = _ref2.r, g2 = _ref2.g, b2 = _ref2.b;
  return "#".concat(rgbToHex(r2, g2, b2, false));
}
function mix$1(rgb1, rgb2, amount) {
  var p = amount / 100;
  var rgb = {
    r: (rgb2.r - rgb1.r) * p + rgb1.r,
    g: (rgb2.g - rgb1.g) * p + rgb1.g,
    b: (rgb2.b - rgb1.b) * p + rgb1.b
  };
  return rgb;
}
function getHue(hsv, i2, light) {
  var hue;
  if (Math.round(hsv.h) >= 60 && Math.round(hsv.h) <= 240) {
    hue = light ? Math.round(hsv.h) - hueStep * i2 : Math.round(hsv.h) + hueStep * i2;
  } else {
    hue = light ? Math.round(hsv.h) + hueStep * i2 : Math.round(hsv.h) - hueStep * i2;
  }
  if (hue < 0) {
    hue += 360;
  } else if (hue >= 360) {
    hue -= 360;
  }
  return hue;
}
function getSaturation(hsv, i2, light) {
  if (hsv.h === 0 && hsv.s === 0) {
    return hsv.s;
  }
  var saturation;
  if (light) {
    saturation = hsv.s - saturationStep * i2;
  } else if (i2 === darkColorCount) {
    saturation = hsv.s + saturationStep;
  } else {
    saturation = hsv.s + saturationStep2 * i2;
  }
  if (saturation > 1) {
    saturation = 1;
  }
  if (light && i2 === lightColorCount && saturation > 0.1) {
    saturation = 0.1;
  }
  if (saturation < 0.06) {
    saturation = 0.06;
  }
  return Number(saturation.toFixed(2));
}
function getValue$4(hsv, i2, light) {
  var value;
  if (light) {
    value = hsv.v + brightnessStep1 * i2;
  } else {
    value = hsv.v - brightnessStep2 * i2;
  }
  if (value > 1) {
    value = 1;
  }
  return Number(value.toFixed(2));
}
function generate$1(color) {
  var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var patterns = [];
  var pColor = inputToRGB(color);
  for (var i2 = lightColorCount; i2 > 0; i2 -= 1) {
    var hsv = toHsv(pColor);
    var colorString = toHex(inputToRGB({
      h: getHue(hsv, i2, true),
      s: getSaturation(hsv, i2, true),
      v: getValue$4(hsv, i2, true)
    }));
    patterns.push(colorString);
  }
  patterns.push(toHex(pColor));
  for (var _i = 1; _i <= darkColorCount; _i += 1) {
    var _hsv = toHsv(pColor);
    var _colorString = toHex(inputToRGB({
      h: getHue(_hsv, _i),
      s: getSaturation(_hsv, _i),
      v: getValue$4(_hsv, _i)
    }));
    patterns.push(_colorString);
  }
  if (opts.theme === "dark") {
    return darkColorMap.map(function(_ref3) {
      var index2 = _ref3.index, opacity = _ref3.opacity;
      var darkColorString = toHex(mix$1(inputToRGB(opts.backgroundColor || "#141414"), inputToRGB(patterns[index2]), opacity * 100));
      return darkColorString;
    });
  }
  return patterns;
}
var presetPrimaryColors = {
  red: "#F5222D",
  volcano: "#FA541C",
  orange: "#FA8C16",
  gold: "#FAAD14",
  yellow: "#FADB14",
  lime: "#A0D911",
  green: "#52C41A",
  cyan: "#13C2C2",
  blue: "#1890FF",
  geekblue: "#2F54EB",
  purple: "#722ED1",
  magenta: "#EB2F96",
  grey: "#666666"
};
var presetPalettes = {};
var presetDarkPalettes = {};
Object.keys(presetPrimaryColors).forEach(function(key2) {
  presetPalettes[key2] = generate$1(presetPrimaryColors[key2]);
  presetPalettes[key2].primary = presetPalettes[key2][5];
  presetDarkPalettes[key2] = generate$1(presetPrimaryColors[key2], {
    theme: "dark",
    backgroundColor: "#141414"
  });
  presetDarkPalettes[key2].primary = presetDarkPalettes[key2][5];
});
var gold = presetPalettes.gold;
var blue = presetPalettes.blue;
var contextKey = Symbol("iconContext");
var useInjectIconContext = function useInjectIconContext2() {
  return inject(contextKey, {
    prefixCls: ref("anticon"),
    rootClassName: ref(""),
    csp: ref()
  });
};
function canUseDom$1() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
function contains$1(root2, n2) {
  if (!root2) {
    return false;
  }
  if (root2.contains) {
    return root2.contains(n2);
  }
  return false;
}
var APPEND_ORDER$1 = "data-vc-order";
var MARK_KEY$1 = "vc-icon-key";
var containerCache$1 = /* @__PURE__ */ new Map();
function getMark$1() {
  var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, mark = _ref.mark;
  if (mark) {
    return mark.startsWith("data-") ? mark : "data-".concat(mark);
  }
  return MARK_KEY$1;
}
function getContainer$2(option) {
  if (option.attachTo) {
    return option.attachTo;
  }
  var head = document.querySelector("head");
  return head || document.body;
}
function getOrder$1(prepend) {
  if (prepend === "queue") {
    return "prependQueue";
  }
  return prepend ? "prepend" : "append";
}
function findStyles$1(container) {
  return Array.from((containerCache$1.get(container) || container).children).filter(function(node2) {
    return node2.tagName === "STYLE";
  });
}
function injectCSS$1(css2) {
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!canUseDom$1()) {
    return null;
  }
  var csp = option.csp, prepend = option.prepend;
  var styleNode = document.createElement("style");
  styleNode.setAttribute(APPEND_ORDER$1, getOrder$1(prepend));
  if (csp && csp.nonce) {
    styleNode.nonce = csp.nonce;
  }
  styleNode.innerHTML = css2;
  var container = getContainer$2(option);
  var firstChild = container.firstChild;
  if (prepend) {
    if (prepend === "queue") {
      var existStyle = findStyles$1(container).filter(function(node2) {
        return ["prepend", "prependQueue"].includes(node2.getAttribute(APPEND_ORDER$1));
      });
      if (existStyle.length) {
        container.insertBefore(styleNode, existStyle[existStyle.length - 1].nextSibling);
        return styleNode;
      }
    }
    container.insertBefore(styleNode, firstChild);
  } else {
    container.appendChild(styleNode);
  }
  return styleNode;
}
function findExistNode$1(key2) {
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var container = getContainer$2(option);
  return findStyles$1(container).find(function(node2) {
    return node2.getAttribute(getMark$1(option)) === key2;
  });
}
function syncRealContainer$1(container, option) {
  var cachedRealContainer = containerCache$1.get(container);
  if (!cachedRealContainer || !contains$1(document, cachedRealContainer)) {
    var placeholderStyle = injectCSS$1("", option);
    var parentNode = placeholderStyle.parentNode;
    containerCache$1.set(container, parentNode);
    container.removeChild(placeholderStyle);
  }
}
function updateCSS$1(css2, key2) {
  var option = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var container = getContainer$2(option);
  syncRealContainer$1(container, option);
  var existNode = findExistNode$1(key2, option);
  if (existNode) {
    if (option.csp && option.csp.nonce && existNode.nonce !== option.csp.nonce) {
      existNode.nonce = option.csp.nonce;
    }
    if (existNode.innerHTML !== css2) {
      existNode.innerHTML = css2;
    }
    return existNode;
  }
  var newNode = injectCSS$1(css2, option);
  newNode.setAttribute(getMark$1(option), key2);
  return newNode;
}
function _objectSpread$17(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$19(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$19(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
function warning$3(valid, message) {
}
function isIconDefinition(target) {
  return typeof target === "object" && typeof target.name === "string" && typeof target.theme === "string" && (typeof target.icon === "object" || typeof target.icon === "function");
}
function generate(node2, key2, rootProps) {
  if (!rootProps) {
    return h$1(node2.tag, _objectSpread$17({
      key: key2
    }, node2.attrs), (node2.children || []).map(function(child, index2) {
      return generate(child, "".concat(key2, "-").concat(node2.tag, "-").concat(index2));
    }));
  }
  return h$1(node2.tag, _objectSpread$17({
    key: key2
  }, rootProps, node2.attrs), (node2.children || []).map(function(child, index2) {
    return generate(child, "".concat(key2, "-").concat(node2.tag, "-").concat(index2));
  }));
}
function getSecondaryColor(primaryColor) {
  return generate$1(primaryColor)[0];
}
function normalizeTwoToneColors(twoToneColor) {
  if (!twoToneColor) {
    return [];
  }
  return Array.isArray(twoToneColor) ? twoToneColor : [twoToneColor];
}
var iconStyles = "\n.anticon {\n  display: inline-block;\n  color: inherit;\n  font-style: normal;\n  line-height: 0;\n  text-align: center;\n  text-transform: none;\n  vertical-align: -0.125em;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.anticon > * {\n  line-height: 1;\n}\n\n.anticon svg {\n  display: inline-block;\n}\n\n.anticon::before {\n  display: none;\n}\n\n.anticon .anticon-icon {\n  display: block;\n}\n\n.anticon[tabindex] {\n  cursor: pointer;\n}\n\n.anticon-spin::before,\n.anticon-spin {\n  display: inline-block;\n  -webkit-animation: loadingCircle 1s infinite linear;\n  animation: loadingCircle 1s infinite linear;\n}\n\n@-webkit-keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n\n@keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n";
function getRoot(ele) {
  return ele && ele.getRootNode && ele.getRootNode();
}
function inShadow(ele) {
  if (!canUseDom$1()) {
    return false;
  }
  return getRoot(ele) instanceof ShadowRoot;
}
function getShadowRoot(ele) {
  return inShadow(ele) ? getRoot(ele) : null;
}
var useInsertStyles = function useInsertStyles2() {
  var _useInjectIconContext = useInjectIconContext(), prefixCls = _useInjectIconContext.prefixCls, csp = _useInjectIconContext.csp;
  var instance = getCurrentInstance();
  var mergedStyleStr = iconStyles;
  if (prefixCls) {
    mergedStyleStr = mergedStyleStr.replace(/anticon/g, prefixCls.value);
  }
  nextTick(function() {
    if (!canUseDom$1()) {
      return;
    }
    var ele = instance.vnode.el;
    var shadowRoot = getShadowRoot(ele);
    updateCSS$1(mergedStyleStr, "@ant-design-vue-icons", {
      prepend: true,
      csp: csp.value,
      attachTo: shadowRoot
    });
  });
};
var _excluded$1 = ["icon", "primaryColor", "secondaryColor"];
function _objectWithoutProperties$1(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$1(source, excluded);
  var key2, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key2 = sourceSymbolKeys[i2];
      if (excluded.indexOf(key2) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key2)) continue;
      target[key2] = source[key2];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key2, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key2 = sourceKeys[i2];
    if (excluded.indexOf(key2) >= 0) continue;
    target[key2] = source[key2];
  }
  return target;
}
function _objectSpread$16(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$18(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$18(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var twoToneColorPalette = reactive({
  primaryColor: "#333",
  secondaryColor: "#E6E6E6",
  calculated: false
});
function setTwoToneColors(_ref) {
  var primaryColor = _ref.primaryColor, secondaryColor = _ref.secondaryColor;
  twoToneColorPalette.primaryColor = primaryColor;
  twoToneColorPalette.secondaryColor = secondaryColor || getSecondaryColor(primaryColor);
  twoToneColorPalette.calculated = !!secondaryColor;
}
function getTwoToneColors() {
  return _objectSpread$16({}, twoToneColorPalette);
}
var IconBase = function IconBase2(props2, context2) {
  var _props$context$attrs = _objectSpread$16({}, props2, context2.attrs), icon = _props$context$attrs.icon, primaryColor = _props$context$attrs.primaryColor, secondaryColor = _props$context$attrs.secondaryColor, restProps = _objectWithoutProperties$1(_props$context$attrs, _excluded$1);
  var colors = twoToneColorPalette;
  if (primaryColor) {
    colors = {
      primaryColor,
      secondaryColor: secondaryColor || getSecondaryColor(primaryColor)
    };
  }
  warning$3(isIconDefinition(icon));
  if (!isIconDefinition(icon)) {
    return null;
  }
  var target = icon;
  if (target && typeof target.icon === "function") {
    target = _objectSpread$16({}, target, {
      icon: target.icon(colors.primaryColor, colors.secondaryColor)
    });
  }
  return generate(target.icon, "svg-".concat(target.name), _objectSpread$16({}, restProps, {
    "data-icon": target.name,
    width: "1em",
    height: "1em",
    fill: "currentColor",
    "aria-hidden": "true"
  }));
};
IconBase.props = {
  icon: Object,
  primaryColor: String,
  secondaryColor: String,
  focusable: String
};
IconBase.inheritAttrs = false;
IconBase.displayName = "IconBase";
IconBase.getTwoToneColors = getTwoToneColors;
IconBase.setTwoToneColors = setTwoToneColors;
function _slicedToArray$1(arr, i2) {
  return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i2) || _unsupportedIterableToArray$1(arr, i2) || _nonIterableRest$1();
}
function _nonIterableRest$1() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$1(o2, minLen) {
  if (!o2) return;
  if (typeof o2 === "string") return _arrayLikeToArray$1(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor) n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$1(o2, minLen);
}
function _arrayLikeToArray$1(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
function _iterableToArrayLimit$1(arr, i2) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i2 && _arr.length === i2) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$1(arr) {
  if (Array.isArray(arr)) return arr;
}
function setTwoToneColor(twoToneColor) {
  var _normalizeTwoToneColo = normalizeTwoToneColors(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray$1(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
  return IconBase.setTwoToneColors({
    primaryColor,
    secondaryColor
  });
}
function getTwoToneColor() {
  var colors = IconBase.getTwoToneColors();
  if (!colors.calculated) {
    return colors.primaryColor;
  }
  return [colors.primaryColor, colors.secondaryColor];
}
var InsertStyles = defineComponent({
  name: "InsertStyles",
  setup: function setup() {
    useInsertStyles();
    return function() {
      return null;
    };
  }
});
var _excluded = ["class", "icon", "spin", "rotate", "tabindex", "twoToneColor", "onClick"];
function _slicedToArray(arr, i2) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o2, minLen) {
  if (!o2) return;
  if (typeof o2 === "string") return _arrayLikeToArray(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor) n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray(o2, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
function _iterableToArrayLimit(arr, i2) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i2 && _arr.length === i2) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
function _objectSpread$15(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$17(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$17(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key2, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key2 = sourceSymbolKeys[i2];
      if (excluded.indexOf(key2) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key2)) continue;
      target[key2] = source[key2];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key2, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key2 = sourceKeys[i2];
    if (excluded.indexOf(key2) >= 0) continue;
    target[key2] = source[key2];
  }
  return target;
}
setTwoToneColor(blue.primary);
var Icon = function Icon2(props2, context2) {
  var _classObj;
  var _props$context$attrs = _objectSpread$15({}, props2, context2.attrs), cls = _props$context$attrs["class"], icon = _props$context$attrs.icon, spin = _props$context$attrs.spin, rotate = _props$context$attrs.rotate, tabindex = _props$context$attrs.tabindex, twoToneColor = _props$context$attrs.twoToneColor, onClick = _props$context$attrs.onClick, restProps = _objectWithoutProperties(_props$context$attrs, _excluded);
  var _useInjectIconContext = useInjectIconContext(), prefixCls = _useInjectIconContext.prefixCls, rootClassName = _useInjectIconContext.rootClassName;
  var classObj = (_classObj = {}, _defineProperty$17(_classObj, rootClassName.value, !!rootClassName.value), _defineProperty$17(_classObj, prefixCls.value, true), _defineProperty$17(_classObj, "".concat(prefixCls.value, "-").concat(icon.name), Boolean(icon.name)), _defineProperty$17(_classObj, "".concat(prefixCls.value, "-spin"), !!spin || icon.name === "loading"), _classObj);
  var iconTabIndex = tabindex;
  if (iconTabIndex === void 0 && onClick) {
    iconTabIndex = -1;
  }
  var svgStyle = rotate ? {
    msTransform: "rotate(".concat(rotate, "deg)"),
    transform: "rotate(".concat(rotate, "deg)")
  } : void 0;
  var _normalizeTwoToneColo = normalizeTwoToneColors(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
  return createVNode("span", _objectSpread$15({
    "role": "img",
    "aria-label": icon.name
  }, restProps, {
    "onClick": onClick,
    "class": [classObj, cls],
    "tabindex": iconTabIndex
  }), [createVNode(IconBase, {
    "icon": icon,
    "primaryColor": primaryColor,
    "secondaryColor": secondaryColor,
    "style": svgStyle
  }, null), createVNode(InsertStyles, null, null)]);
};
Icon.props = {
  spin: Boolean,
  rotate: Number,
  icon: Object,
  twoToneColor: [String, Array]
};
Icon.displayName = "AntdIcon";
Icon.inheritAttrs = false;
Icon.getTwoToneColor = getTwoToneColor;
Icon.setTwoToneColor = setTwoToneColor;
var ApartmentOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M908 640H804V488c0-4.4-3.6-8-8-8H548v-96h108c8.8 0 16-7.2 16-16V80c0-8.8-7.2-16-16-16H368c-8.8 0-16 7.2-16 16v288c0 8.8 7.2 16 16 16h108v96H228c-4.4 0-8 3.6-8 8v152H116c-8.8 0-16 7.2-16 16v288c0 8.8 7.2 16 16 16h288c8.8 0 16-7.2 16-16V656c0-8.8-7.2-16-16-16H292v-88h440v88H620c-8.8 0-16 7.2-16 16v288c0 8.8 7.2 16 16 16h288c8.8 0 16-7.2 16-16V656c0-8.8-7.2-16-16-16zm-564 76v168H176V716h168zm84-408V140h168v168H428zm420 576H680V716h168v168z" } }] }, "name": "apartment", "theme": "outlined" };
function _objectSpread$14(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$16(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$16(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var ApartmentOutlined = function ApartmentOutlined2(props2, context2) {
  var p = _objectSpread$14({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$14({}, p, {
    "icon": ApartmentOutlined$1
  }), null);
};
ApartmentOutlined.displayName = "ApartmentOutlined";
ApartmentOutlined.inheritAttrs = false;
var BarsOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M912 192H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM104 228a56 56 0 10112 0 56 56 0 10-112 0zm0 284a56 56 0 10112 0 56 56 0 10-112 0zm0 284a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, "name": "bars", "theme": "outlined" };
function _objectSpread$13(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$15(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$15(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var BarsOutlined = function BarsOutlined2(props2, context2) {
  var p = _objectSpread$13({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$13({}, p, {
    "icon": BarsOutlined$1
  }), null);
};
BarsOutlined.displayName = "BarsOutlined";
BarsOutlined.inheritAttrs = false;
var BellOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M816 768h-24V428c0-141.1-104.3-257.7-240-277.1V112c0-22.1-17.9-40-40-40s-40 17.9-40 40v38.9c-135.7 19.4-240 136-240 277.1v340h-24c-17.7 0-32 14.3-32 32v32c0 4.4 3.6 8 8 8h216c0 61.8 50.2 112 112 112s112-50.2 112-112h216c4.4 0 8-3.6 8-8v-32c0-17.7-14.3-32-32-32zM512 888c-26.5 0-48-21.5-48-48h96c0 26.5-21.5 48-48 48zM304 768V428c0-55.6 21.6-107.8 60.9-147.1S456.4 220 512 220c55.6 0 107.8 21.6 147.1 60.9S720 372.4 720 428v340H304z" } }] }, "name": "bell", "theme": "outlined" };
function _objectSpread$12(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$14(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$14(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var BellOutlined = function BellOutlined2(props2, context2) {
  var p = _objectSpread$12({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$12({}, p, {
    "icon": BellOutlined$1
  }), null);
};
BellOutlined.displayName = "BellOutlined";
BellOutlined.inheritAttrs = false;
var BookTwoTone$1 = { "icon": function render2(primaryColor, secondaryColor) {
  return { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M832 64H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V96c0-17.7-14.3-32-32-32zm-260 72h96v209.9L621.5 312 572 347.4V136zM232 888V136h280v296.9c0 3.3 1 6.6 3 9.3a15.9 15.9 0 0022.3 3.7l83.8-59.9 81.4 59.4c2.7 2 6 3.1 9.4 3.1 8.8 0 16-7.2 16-16V136h64v752H232z", "fill": primaryColor } }, { "tag": "path", "attrs": { "d": "M668 345.9V136h-96v211.4l49.5-35.4z", "fill": secondaryColor } }, { "tag": "path", "attrs": { "d": "M727.9 136v296.5c0 8.8-7.2 16-16 16-3.4 0-6.7-1.1-9.4-3.1L621.1 386l-83.8 59.9a15.9 15.9 0 01-22.3-3.7c-2-2.7-3-6-3-9.3V136H232v752h559.9V136h-64z", "fill": secondaryColor } }] };
}, "name": "book", "theme": "twotone" };
function _objectSpread$11(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$13(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$13(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var BookTwoTone = function BookTwoTone2(props2, context2) {
  var p = _objectSpread$11({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$11({}, p, {
    "icon": BookTwoTone$1
  }), null);
};
BookTwoTone.displayName = "BookTwoTone";
BookTwoTone.inheritAttrs = false;
var CalendarOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M880 184H712v-64c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v64H384v-64c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v64H144c-17.7 0-32 14.3-32 32v664c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V216c0-17.7-14.3-32-32-32zm-40 656H184V460h656v380zM184 392V256h128v48c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8v-48h256v48c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8v-48h128v136H184z" } }] }, "name": "calendar", "theme": "outlined" };
function _objectSpread$10(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$12(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$12(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var CalendarOutlined = function CalendarOutlined2(props2, context2) {
  var p = _objectSpread$10({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$10({}, p, {
    "icon": CalendarOutlined$1
  }), null);
};
CalendarOutlined.displayName = "CalendarOutlined";
CalendarOutlined.inheritAttrs = false;
var CaretDownFilled$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z" } }] }, "name": "caret-down", "theme": "filled" };
function _objectSpread$$(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$11(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$11(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var CaretDownFilled = function CaretDownFilled2(props2, context2) {
  var p = _objectSpread$$({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$$({}, p, {
    "icon": CaretDownFilled$1
  }), null);
};
CaretDownFilled.displayName = "CaretDownFilled";
CaretDownFilled.inheritAttrs = false;
var CaretDownOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z" } }] }, "name": "caret-down", "theme": "outlined" };
function _objectSpread$_(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$10(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$10(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var CaretDownOutlined = function CaretDownOutlined2(props2, context2) {
  var p = _objectSpread$_({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$_({}, p, {
    "icon": CaretDownOutlined$1
  }), null);
};
CaretDownOutlined.displayName = "CaretDownOutlined";
CaretDownOutlined.inheritAttrs = false;
var CaretUpOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M858.9 689L530.5 308.2c-9.4-10.9-27.5-10.9-37 0L165.1 689c-12.2 14.2-1.2 35 18.5 35h656.8c19.7 0 30.7-20.8 18.5-35z" } }] }, "name": "caret-up", "theme": "outlined" };
function _objectSpread$Z(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$$(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$$(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var CaretUpOutlined = function CaretUpOutlined2(props2, context2) {
  var p = _objectSpread$Z({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$Z({}, p, {
    "icon": CaretUpOutlined$1
  }), null);
};
CaretUpOutlined.displayName = "CaretUpOutlined";
CaretUpOutlined.inheritAttrs = false;
var CheckCircleFilled$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm193.5 301.7l-210.6 292a31.8 31.8 0 01-51.7 0L318.5 484.9c-3.8-5.3 0-12.7 6.5-12.7h46.9c10.2 0 19.9 4.9 25.9 13.3l71.2 98.8 157.2-218c6-8.3 15.6-13.3 25.9-13.3H699c6.5 0 10.3 7.4 6.5 12.7z" } }] }, "name": "check-circle", "theme": "filled" };
function _objectSpread$Y(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$_(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$_(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var CheckCircleFilled = function CheckCircleFilled2(props2, context2) {
  var p = _objectSpread$Y({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$Y({}, p, {
    "icon": CheckCircleFilled$1
  }), null);
};
CheckCircleFilled.displayName = "CheckCircleFilled";
CheckCircleFilled.inheritAttrs = false;
var CheckCircleOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M699 353h-46.9c-10.2 0-19.9 4.9-25.9 13.3L469 584.3l-71.2-98.8c-6-8.3-15.6-13.3-25.9-13.3H325c-6.5 0-10.3 7.4-6.5 12.7l124.6 172.8a31.8 31.8 0 0051.7 0l210.6-292c3.9-5.3.1-12.7-6.4-12.7z" } }, { "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }] }, "name": "check-circle", "theme": "outlined" };
function _objectSpread$X(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$Z(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$Z(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var CheckCircleOutlined = function CheckCircleOutlined2(props2, context2) {
  var p = _objectSpread$X({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$X({}, p, {
    "icon": CheckCircleOutlined$1
  }), null);
};
CheckCircleOutlined.displayName = "CheckCircleOutlined";
CheckCircleOutlined.inheritAttrs = false;
var CheckOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M912 190h-69.9c-9.8 0-19.1 4.5-25.1 12.2L404.7 724.5 207 474a32 32 0 00-25.1-12.2H112c-6.7 0-10.4 7.7-6.3 12.9l273.9 347c12.8 16.2 37.4 16.2 50.3 0l488.4-618.9c4.1-5.1.4-12.8-6.3-12.8z" } }] }, "name": "check", "theme": "outlined" };
function _objectSpread$W(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$Y(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$Y(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var CheckOutlined = function CheckOutlined2(props2, context2) {
  var p = _objectSpread$W({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$W({}, p, {
    "icon": CheckOutlined$1
  }), null);
};
CheckOutlined.displayName = "CheckOutlined";
CheckOutlined.inheritAttrs = false;
var ClockCircleOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { "tag": "path", "attrs": { "d": "M686.7 638.6L544.1 535.5V288c0-4.4-3.6-8-8-8H488c-4.4 0-8 3.6-8 8v275.4c0 2.6 1.2 5 3.3 6.5l165.4 120.6c3.6 2.6 8.6 1.8 11.2-1.7l28.6-39c2.6-3.7 1.8-8.7-1.8-11.2z" } }] }, "name": "clock-circle", "theme": "outlined" };
function _objectSpread$V(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$X(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$X(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var ClockCircleOutlined = function ClockCircleOutlined2(props2, context2) {
  var p = _objectSpread$V({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$V({}, p, {
    "icon": ClockCircleOutlined$1
  }), null);
};
ClockCircleOutlined.displayName = "ClockCircleOutlined";
ClockCircleOutlined.inheritAttrs = false;
var CloseCircleFilled$1 = { "icon": { "tag": "svg", "attrs": { "fill-rule": "evenodd", "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64c247.4 0 448 200.6 448 448S759.4 960 512 960 64 759.4 64 512 264.6 64 512 64zm127.98 274.82h-.04l-.08.06L512 466.75 384.14 338.88c-.04-.05-.06-.06-.08-.06a.12.12 0 00-.07 0c-.03 0-.05.01-.09.05l-45.02 45.02a.2.2 0 00-.05.09.12.12 0 000 .07v.02a.27.27 0 00.06.06L466.75 512 338.88 639.86c-.05.04-.06.06-.06.08a.12.12 0 000 .07c0 .03.01.05.05.09l45.02 45.02a.2.2 0 00.09.05.12.12 0 00.07 0c.02 0 .04-.01.08-.05L512 557.25l127.86 127.87c.04.04.06.05.08.05a.12.12 0 00.07 0c.03 0 .05-.01.09-.05l45.02-45.02a.2.2 0 00.05-.09.12.12 0 000-.07v-.02a.27.27 0 00-.05-.06L557.25 512l127.87-127.86c.04-.04.05-.06.05-.08a.12.12 0 000-.07c0-.03-.01-.05-.05-.09l-45.02-45.02a.2.2 0 00-.09-.05.12.12 0 00-.07 0z" } }] }, "name": "close-circle", "theme": "filled" };
function _objectSpread$U(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$W(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$W(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var CloseCircleFilled = function CloseCircleFilled2(props2, context2) {
  var p = _objectSpread$U({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$U({}, p, {
    "icon": CloseCircleFilled$1
  }), null);
};
CloseCircleFilled.displayName = "CloseCircleFilled";
CloseCircleFilled.inheritAttrs = false;
var CloseCircleOutlined$1 = { "icon": { "tag": "svg", "attrs": { "fill-rule": "evenodd", "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64c247.4 0 448 200.6 448 448S759.4 960 512 960 64 759.4 64 512 264.6 64 512 64zm0 76c-205.4 0-372 166.6-372 372s166.6 372 372 372 372-166.6 372-372-166.6-372-372-372zm128.01 198.83c.03 0 .05.01.09.06l45.02 45.01a.2.2 0 01.05.09.12.12 0 010 .07c0 .02-.01.04-.05.08L557.25 512l127.87 127.86a.27.27 0 01.05.06v.02a.12.12 0 010 .07c0 .03-.01.05-.05.09l-45.02 45.02a.2.2 0 01-.09.05.12.12 0 01-.07 0c-.02 0-.04-.01-.08-.05L512 557.25 384.14 685.12c-.04.04-.06.05-.08.05a.12.12 0 01-.07 0c-.03 0-.05-.01-.09-.05l-45.02-45.02a.2.2 0 01-.05-.09.12.12 0 010-.07c0-.02.01-.04.06-.08L466.75 512 338.88 384.14a.27.27 0 01-.05-.06l-.01-.02a.12.12 0 010-.07c0-.03.01-.05.05-.09l45.02-45.02a.2.2 0 01.09-.05.12.12 0 01.07 0c.02 0 .04.01.08.06L512 466.75l127.86-127.86c.04-.05.06-.06.08-.06a.12.12 0 01.07 0z" } }] }, "name": "close-circle", "theme": "outlined" };
function _objectSpread$T(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$V(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$V(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var CloseCircleOutlined = function CloseCircleOutlined2(props2, context2) {
  var p = _objectSpread$T({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$T({}, p, {
    "icon": CloseCircleOutlined$1
  }), null);
};
CloseCircleOutlined.displayName = "CloseCircleOutlined";
CloseCircleOutlined.inheritAttrs = false;
var CloseOutlined$1 = { "icon": { "tag": "svg", "attrs": { "fill-rule": "evenodd", "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M799.86 166.31c.02 0 .04.02.08.06l57.69 57.7c.04.03.05.05.06.08a.12.12 0 010 .06c0 .03-.02.05-.06.09L569.93 512l287.7 287.7c.04.04.05.06.06.09a.12.12 0 010 .07c0 .02-.02.04-.06.08l-57.7 57.69c-.03.04-.05.05-.07.06a.12.12 0 01-.07 0c-.03 0-.05-.02-.09-.06L512 569.93l-287.7 287.7c-.04.04-.06.05-.09.06a.12.12 0 01-.07 0c-.02 0-.04-.02-.08-.06l-57.69-57.7c-.04-.03-.05-.05-.06-.07a.12.12 0 010-.07c0-.03.02-.05.06-.09L454.07 512l-287.7-287.7c-.04-.04-.05-.06-.06-.09a.12.12 0 010-.07c0-.02.02-.04.06-.08l57.7-57.69c.03-.04.05-.05.07-.06a.12.12 0 01.07 0c.03 0 .05.02.09.06L512 454.07l287.7-287.7c.04-.04.06-.05.09-.06a.12.12 0 01.07 0z" } }] }, "name": "close", "theme": "outlined" };
function _objectSpread$S(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$U(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$U(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var CloseOutlined = function CloseOutlined2(props2, context2) {
  var p = _objectSpread$S({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$S({}, p, {
    "icon": CloseOutlined$1
  }), null);
};
CloseOutlined.displayName = "CloseOutlined";
CloseOutlined.inheritAttrs = false;
var CopyOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z" } }] }, "name": "copy", "theme": "outlined" };
function _objectSpread$R(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$T(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$T(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var CopyOutlined = function CopyOutlined2(props2, context2) {
  var p = _objectSpread$R({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$R({}, p, {
    "icon": CopyOutlined$1
  }), null);
};
CopyOutlined.displayName = "CopyOutlined";
CopyOutlined.inheritAttrs = false;
var DashboardOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M924.8 385.6a446.7 446.7 0 00-96-142.4 446.7 446.7 0 00-142.4-96C631.1 123.8 572.5 112 512 112s-119.1 11.8-174.4 35.2a446.7 446.7 0 00-142.4 96 446.7 446.7 0 00-96 142.4C75.8 440.9 64 499.5 64 560c0 132.7 58.3 257.7 159.9 343.1l1.7 1.4c5.8 4.8 13.1 7.5 20.6 7.5h531.7c7.5 0 14.8-2.7 20.6-7.5l1.7-1.4C901.7 817.7 960 692.7 960 560c0-60.5-11.9-119.1-35.2-174.4zM761.4 836H262.6A371.12 371.12 0 01140 560c0-99.4 38.7-192.8 109-263 70.3-70.3 163.7-109 263-109 99.4 0 192.8 38.7 263 109 70.3 70.3 109 163.7 109 263 0 105.6-44.5 205.5-122.6 276zM623.5 421.5a8.03 8.03 0 00-11.3 0L527.7 506c-18.7-5-39.4-.2-54.1 14.5a55.95 55.95 0 000 79.2 55.95 55.95 0 0079.2 0 55.87 55.87 0 0014.5-54.1l84.5-84.5c3.1-3.1 3.1-8.2 0-11.3l-28.3-28.3zM490 320h44c4.4 0 8-3.6 8-8v-80c0-4.4-3.6-8-8-8h-44c-4.4 0-8 3.6-8 8v80c0 4.4 3.6 8 8 8zm260 218v44c0 4.4 3.6 8 8 8h80c4.4 0 8-3.6 8-8v-44c0-4.4-3.6-8-8-8h-80c-4.4 0-8 3.6-8 8zm12.7-197.2l-31.1-31.1a8.03 8.03 0 00-11.3 0l-56.6 56.6a8.03 8.03 0 000 11.3l31.1 31.1c3.1 3.1 8.2 3.1 11.3 0l56.6-56.6c3.1-3.1 3.1-8.2 0-11.3zm-458.6-31.1a8.03 8.03 0 00-11.3 0l-31.1 31.1a8.03 8.03 0 000 11.3l56.6 56.6c3.1 3.1 8.2 3.1 11.3 0l31.1-31.1c3.1-3.1 3.1-8.2 0-11.3l-56.6-56.6zM262 530h-80c-4.4 0-8 3.6-8 8v44c0 4.4 3.6 8 8 8h80c4.4 0 8-3.6 8-8v-44c0-4.4-3.6-8-8-8z" } }] }, "name": "dashboard", "theme": "outlined" };
function _objectSpread$Q(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$S(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$S(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var DashboardOutlined = function DashboardOutlined2(props2, context2) {
  var p = _objectSpread$Q({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$Q({}, p, {
    "icon": DashboardOutlined$1
  }), null);
};
DashboardOutlined.displayName = "DashboardOutlined";
DashboardOutlined.inheritAttrs = false;
var DeleteOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M360 184h-8c4.4 0 8-3.6 8-8v8h304v-8c0 4.4 3.6 8 8 8h-8v72h72v-80c0-35.3-28.7-64-64-64H352c-35.3 0-64 28.7-64 64v80h72v-72zm504 72H160c-17.7 0-32 14.3-32 32v32c0 4.4 3.6 8 8 8h60.4l24.7 523c1.6 34.1 29.8 61 63.9 61h454c34.2 0 62.3-26.8 63.9-61l24.7-523H888c4.4 0 8-3.6 8-8v-32c0-17.7-14.3-32-32-32zM731.3 840H292.7l-24.2-512h487l-24.2 512z" } }] }, "name": "delete", "theme": "outlined" };
function _objectSpread$P(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$R(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$R(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var DeleteOutlined = function DeleteOutlined2(props2, context2) {
  var p = _objectSpread$P({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$P({}, p, {
    "icon": DeleteOutlined$1
  }), null);
};
DeleteOutlined.displayName = "DeleteOutlined";
DeleteOutlined.inheritAttrs = false;
var DoubleLeftOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M272.9 512l265.4-339.1c4.1-5.2.4-12.9-6.3-12.9h-77.3c-4.9 0-9.6 2.3-12.6 6.1L186.8 492.3a31.99 31.99 0 000 39.5l255.3 326.1c3 3.9 7.7 6.1 12.6 6.1H532c6.7 0 10.4-7.7 6.3-12.9L272.9 512zm304 0l265.4-339.1c4.1-5.2.4-12.9-6.3-12.9h-77.3c-4.9 0-9.6 2.3-12.6 6.1L490.8 492.3a31.99 31.99 0 000 39.5l255.3 326.1c3 3.9 7.7 6.1 12.6 6.1H836c6.7 0 10.4-7.7 6.3-12.9L576.9 512z" } }] }, "name": "double-left", "theme": "outlined" };
function _objectSpread$O(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$Q(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$Q(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var DoubleLeftOutlined = function DoubleLeftOutlined2(props2, context2) {
  var p = _objectSpread$O({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$O({}, p, {
    "icon": DoubleLeftOutlined$1
  }), null);
};
DoubleLeftOutlined.displayName = "DoubleLeftOutlined";
DoubleLeftOutlined.inheritAttrs = false;
var DoubleRightOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M533.2 492.3L277.9 166.1c-3-3.9-7.7-6.1-12.6-6.1H188c-6.7 0-10.4 7.7-6.3 12.9L447.1 512 181.7 851.1A7.98 7.98 0 00188 864h77.3c4.9 0 9.6-2.3 12.6-6.1l255.3-326.1c9.1-11.7 9.1-27.9 0-39.5zm304 0L581.9 166.1c-3-3.9-7.7-6.1-12.6-6.1H492c-6.7 0-10.4 7.7-6.3 12.9L751.1 512 485.7 851.1A7.98 7.98 0 00492 864h77.3c4.9 0 9.6-2.3 12.6-6.1l255.3-326.1c9.1-11.7 9.1-27.9 0-39.5z" } }] }, "name": "double-right", "theme": "outlined" };
function _objectSpread$N(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$P(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$P(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var DoubleRightOutlined = function DoubleRightOutlined2(props2, context2) {
  var p = _objectSpread$N({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$N({}, p, {
    "icon": DoubleRightOutlined$1
  }), null);
};
DoubleRightOutlined.displayName = "DoubleRightOutlined";
DoubleRightOutlined.inheritAttrs = false;
var DownOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z" } }] }, "name": "down", "theme": "outlined" };
function _objectSpread$M(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$O(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$O(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var DownOutlined = function DownOutlined2(props2, context2) {
  var p = _objectSpread$M({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$M({}, p, {
    "icon": DownOutlined$1
  }), null);
};
DownOutlined.displayName = "DownOutlined";
DownOutlined.inheritAttrs = false;
var DownloadOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M505.7 661a8 8 0 0012.6 0l112-141.7c4.1-5.2.4-12.9-6.3-12.9h-74.1V168c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v338.3H400c-6.7 0-10.4 7.7-6.3 12.9l112 141.8zM878 626h-60c-4.4 0-8 3.6-8 8v154H214V634c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v198c0 17.7 14.3 32 32 32h684c17.7 0 32-14.3 32-32V634c0-4.4-3.6-8-8-8z" } }] }, "name": "download", "theme": "outlined" };
function _objectSpread$L(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$N(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$N(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var DownloadOutlined = function DownloadOutlined2(props2, context2) {
  var p = _objectSpread$L({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$L({}, p, {
    "icon": DownloadOutlined$1
  }), null);
};
DownloadOutlined.displayName = "DownloadOutlined";
DownloadOutlined.inheritAttrs = false;
var EditOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M257.7 752c2 0 4-.2 6-.5L431.9 722c2-.4 3.9-1.3 5.3-2.8l423.9-423.9a9.96 9.96 0 000-14.1L694.9 114.9c-1.9-1.9-4.4-2.9-7.1-2.9s-5.2 1-7.1 2.9L256.8 538.8c-1.5 1.5-2.4 3.3-2.8 5.3l-29.5 168.2a33.5 33.5 0 009.4 29.8c6.6 6.4 14.9 9.9 23.8 9.9zm67.4-174.4L687.8 215l73.3 73.3-362.7 362.6-88.9 15.7 15.6-89zM880 836H144c-17.7 0-32 14.3-32 32v36c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-36c0-17.7-14.3-32-32-32z" } }] }, "name": "edit", "theme": "outlined" };
function _objectSpread$K(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$M(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$M(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var EditOutlined = function EditOutlined2(props2, context2) {
  var p = _objectSpread$K({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$K({}, p, {
    "icon": EditOutlined$1
  }), null);
};
EditOutlined.displayName = "EditOutlined";
EditOutlined.inheritAttrs = false;
var EllipsisOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M176 511a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, "name": "ellipsis", "theme": "outlined" };
function _objectSpread$J(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$L(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$L(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var EllipsisOutlined = function EllipsisOutlined2(props2, context2) {
  var p = _objectSpread$J({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$J({}, p, {
    "icon": EllipsisOutlined$1
  }), null);
};
EllipsisOutlined.displayName = "EllipsisOutlined";
EllipsisOutlined.inheritAttrs = false;
var EnterOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M864 170h-60c-4.4 0-8 3.6-8 8v518H310v-73c0-6.7-7.8-10.5-13-6.3l-141.9 112a8 8 0 000 12.6l141.9 112c5.3 4.2 13 .4 13-6.3v-75h498c35.3 0 64-28.7 64-64V178c0-4.4-3.6-8-8-8z" } }] }, "name": "enter", "theme": "outlined" };
function _objectSpread$I(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$K(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$K(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var EnterOutlined = function EnterOutlined2(props2, context2) {
  var p = _objectSpread$I({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$I({}, p, {
    "icon": EnterOutlined$1
  }), null);
};
EnterOutlined.displayName = "EnterOutlined";
EnterOutlined.inheritAttrs = false;
var EnvironmentOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M854.6 289.1a362.49 362.49 0 00-79.9-115.7 370.83 370.83 0 00-118.2-77.8C610.7 76.6 562.1 67 512 67c-50.1 0-98.7 9.6-144.5 28.5-44.3 18.3-84 44.5-118.2 77.8A363.6 363.6 0 00169.4 289c-19.5 45-29.4 92.8-29.4 142 0 70.6 16.9 140.9 50.1 208.7 26.7 54.5 64 107.6 111 158.1 80.3 86.2 164.5 138.9 188.4 153a43.9 43.9 0 0022.4 6.1c7.8 0 15.5-2 22.4-6.1 23.9-14.1 108.1-66.8 188.4-153 47-50.4 84.3-103.6 111-158.1C867.1 572 884 501.8 884 431.1c0-49.2-9.9-97-29.4-142zM512 880.2c-65.9-41.9-300-207.8-300-449.1 0-77.9 31.1-151.1 87.6-206.3C356.3 169.5 431.7 139 512 139s155.7 30.5 212.4 85.9C780.9 280 812 353.2 812 431.1c0 241.3-234.1 407.2-300 449.1zm0-617.2c-97.2 0-176 78.8-176 176s78.8 176 176 176 176-78.8 176-176-78.8-176-176-176zm79.2 255.2A111.6 111.6 0 01512 551c-29.9 0-58-11.7-79.2-32.8A111.6 111.6 0 01400 439c0-29.9 11.7-58 32.8-79.2C454 338.6 482.1 327 512 327c29.9 0 58 11.6 79.2 32.8C612.4 381 624 409.1 624 439c0 29.9-11.6 58-32.8 79.2z" } }] }, "name": "environment", "theme": "outlined" };
function _objectSpread$H(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$J(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$J(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var EnvironmentOutlined = function EnvironmentOutlined2(props2, context2) {
  var p = _objectSpread$H({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$H({}, p, {
    "icon": EnvironmentOutlined$1
  }), null);
};
EnvironmentOutlined.displayName = "EnvironmentOutlined";
EnvironmentOutlined.inheritAttrs = false;
var ExclamationCircleFilled$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm-32 232c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V296zm32 440a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, "name": "exclamation-circle", "theme": "filled" };
function _objectSpread$G(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$I(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$I(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var ExclamationCircleFilled = function ExclamationCircleFilled2(props2, context2) {
  var p = _objectSpread$G({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$G({}, p, {
    "icon": ExclamationCircleFilled$1
  }), null);
};
ExclamationCircleFilled.displayName = "ExclamationCircleFilled";
ExclamationCircleFilled.inheritAttrs = false;
var ExclamationCircleOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { "tag": "path", "attrs": { "d": "M464 688a48 48 0 1096 0 48 48 0 10-96 0zm24-112h48c4.4 0 8-3.6 8-8V296c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v272c0 4.4 3.6 8 8 8z" } }] }, "name": "exclamation-circle", "theme": "outlined" };
function _objectSpread$F(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$H(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$H(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var ExclamationCircleOutlined = function ExclamationCircleOutlined2(props2, context2) {
  var p = _objectSpread$F({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$F({}, p, {
    "icon": ExclamationCircleOutlined$1
  }), null);
};
ExclamationCircleOutlined.displayName = "ExclamationCircleOutlined";
ExclamationCircleOutlined.inheritAttrs = false;
var EyeInvisibleOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M942.2 486.2Q889.47 375.11 816.7 305l-50.88 50.88C807.31 395.53 843.45 447.4 874.7 512 791.5 684.2 673.4 766 512 766q-72.67 0-133.87-22.38L323 798.75Q408 838 512 838q288.3 0 430.2-300.3a60.29 60.29 0 000-51.5zm-63.57-320.64L836 122.88a8 8 0 00-11.32 0L715.31 232.2Q624.86 186 512 186q-288.3 0-430.2 300.3a60.3 60.3 0 000 51.5q56.69 119.4 136.5 191.41L112.48 835a8 8 0 000 11.31L155.17 889a8 8 0 0011.31 0l712.15-712.12a8 8 0 000-11.32zM149.3 512C232.6 339.8 350.7 258 512 258c54.54 0 104.13 9.36 149.12 28.39l-70.3 70.3a176 176 0 00-238.13 238.13l-83.42 83.42C223.1 637.49 183.3 582.28 149.3 512zm246.7 0a112.11 112.11 0 01146.2-106.69L401.31 546.2A112 112 0 01396 512z" } }, { "tag": "path", "attrs": { "d": "M508 624c-3.46 0-6.87-.16-10.25-.47l-52.82 52.82a176.09 176.09 0 00227.42-227.42l-52.82 52.82c.31 3.38.47 6.79.47 10.25a111.94 111.94 0 01-112 112z" } }] }, "name": "eye-invisible", "theme": "outlined" };
function _objectSpread$E(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$G(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$G(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var EyeInvisibleOutlined = function EyeInvisibleOutlined2(props2, context2) {
  var p = _objectSpread$E({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$E({}, p, {
    "icon": EyeInvisibleOutlined$1
  }), null);
};
EyeInvisibleOutlined.displayName = "EyeInvisibleOutlined";
EyeInvisibleOutlined.inheritAttrs = false;
var EyeOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M942.2 486.2C847.4 286.5 704.1 186 512 186c-192.2 0-335.4 100.5-430.2 300.3a60.3 60.3 0 000 51.5C176.6 737.5 319.9 838 512 838c192.2 0 335.4-100.5 430.2-300.3 7.7-16.2 7.7-35 0-51.5zM512 766c-161.3 0-279.4-81.8-362.7-254C232.6 339.8 350.7 258 512 258c161.3 0 279.4 81.8 362.7 254C791.5 684.2 673.4 766 512 766zm-4-430c-97.2 0-176 78.8-176 176s78.8 176 176 176 176-78.8 176-176-78.8-176-176-176zm0 288c-61.9 0-112-50.1-112-112s50.1-112 112-112 112 50.1 112 112-50.1 112-112 112z" } }] }, "name": "eye", "theme": "outlined" };
function _objectSpread$D(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$F(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$F(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var EyeOutlined = function EyeOutlined2(props2, context2) {
  var p = _objectSpread$D({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$D({}, p, {
    "icon": EyeOutlined$1
  }), null);
};
EyeOutlined.displayName = "EyeOutlined";
EyeOutlined.inheritAttrs = false;
var FileOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM790.2 326H602V137.8L790.2 326zm1.8 562H232V136h302v216a42 42 0 0042 42h216v494z" } }] }, "name": "file", "theme": "outlined" };
function _objectSpread$C(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$E(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$E(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var FileOutlined = function FileOutlined2(props2, context2) {
  var p = _objectSpread$C({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$C({}, p, {
    "icon": FileOutlined$1
  }), null);
};
FileOutlined.displayName = "FileOutlined";
FileOutlined.inheritAttrs = false;
var FileTwoTone$1 = { "icon": function render3(primaryColor, secondaryColor) {
  return { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M534 352V136H232v752h560V394H576a42 42 0 01-42-42z", "fill": secondaryColor } }, { "tag": "path", "attrs": { "d": "M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM602 137.8L790.2 326H602V137.8zM792 888H232V136h302v216a42 42 0 0042 42h216v494z", "fill": primaryColor } }] };
}, "name": "file", "theme": "twotone" };
function _objectSpread$B(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$D(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$D(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var FileTwoTone = function FileTwoTone2(props2, context2) {
  var p = _objectSpread$B({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$B({}, p, {
    "icon": FileTwoTone$1
  }), null);
};
FileTwoTone.displayName = "FileTwoTone";
FileTwoTone.inheritAttrs = false;
var FilterFilled$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M349 838c0 17.7 14.2 32 31.8 32h262.4c17.6 0 31.8-14.3 31.8-32V642H349v196zm531.1-684H143.9c-24.5 0-39.8 26.7-27.5 48l221.3 376h348.8l221.3-376c12.1-21.3-3.2-48-27.7-48z" } }] }, "name": "filter", "theme": "filled" };
function _objectSpread$A(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$C(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$C(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var FilterFilled = function FilterFilled2(props2, context2) {
  var p = _objectSpread$A({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$A({}, p, {
    "icon": FilterFilled$1
  }), null);
};
FilterFilled.displayName = "FilterFilled";
FilterFilled.inheritAttrs = false;
var FlagTwoTone$1 = { "icon": function render4(primaryColor, secondaryColor) {
  return { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M184 232h368v336H184z", "fill": secondaryColor } }, { "tag": "path", "attrs": { "d": "M624 632c0 4.4-3.6 8-8 8H504v73h336V377H624v255z", "fill": secondaryColor } }, { "tag": "path", "attrs": { "d": "M880 305H624V192c0-17.7-14.3-32-32-32H184v-40c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v784c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V640h248v113c0 17.7 14.3 32 32 32h416c17.7 0 32-14.3 32-32V337c0-17.7-14.3-32-32-32zM184 568V232h368v336H184zm656 145H504v-73h112c4.4 0 8-3.6 8-8V377h216v336z", "fill": primaryColor } }] };
}, "name": "flag", "theme": "twotone" };
function _objectSpread$z(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$B(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$B(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var FlagTwoTone = function FlagTwoTone2(props2, context2) {
  var p = _objectSpread$z({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$z({}, p, {
    "icon": FlagTwoTone$1
  }), null);
};
FlagTwoTone.displayName = "FlagTwoTone";
FlagTwoTone.inheritAttrs = false;
var FolderOpenOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M928 444H820V330.4c0-17.7-14.3-32-32-32H473L355.7 186.2a8.15 8.15 0 00-5.5-2.2H96c-17.7 0-32 14.3-32 32v592c0 17.7 14.3 32 32 32h698c13 0 24.8-7.9 29.7-20l134-332c1.5-3.8 2.3-7.9 2.3-12 0-17.7-14.3-32-32-32zM136 256h188.5l119.6 114.4H748V444H238c-13 0-24.8 7.9-29.7 20L136 643.2V256zm635.3 512H159l103.3-256h612.4L771.3 768z" } }] }, "name": "folder-open", "theme": "outlined" };
function _objectSpread$y(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$A(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$A(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var FolderOpenOutlined = function FolderOpenOutlined2(props2, context2) {
  var p = _objectSpread$y({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$y({}, p, {
    "icon": FolderOpenOutlined$1
  }), null);
};
FolderOpenOutlined.displayName = "FolderOpenOutlined";
FolderOpenOutlined.inheritAttrs = false;
var FolderOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M880 298.4H521L403.7 186.2a8.15 8.15 0 00-5.5-2.2H144c-17.7 0-32 14.3-32 32v592c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V330.4c0-17.7-14.3-32-32-32zM840 768H184V256h188.5l119.6 114.4H840V768z" } }] }, "name": "folder", "theme": "outlined" };
function _objectSpread$x(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$z(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$z(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var FolderOutlined = function FolderOutlined2(props2, context2) {
  var p = _objectSpread$x({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$x({}, p, {
    "icon": FolderOutlined$1
  }), null);
};
FolderOutlined.displayName = "FolderOutlined";
FolderOutlined.inheritAttrs = false;
var GlobalOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M854.4 800.9c.2-.3.5-.6.7-.9C920.6 722.1 960 621.7 960 512s-39.4-210.1-104.8-288c-.2-.3-.5-.5-.7-.8-1.1-1.3-2.1-2.5-3.2-3.7-.4-.5-.8-.9-1.2-1.4l-4.1-4.7-.1-.1c-1.5-1.7-3.1-3.4-4.6-5.1l-.1-.1c-3.2-3.4-6.4-6.8-9.7-10.1l-.1-.1-4.8-4.8-.3-.3c-1.5-1.5-3-2.9-4.5-4.3-.5-.5-1-1-1.6-1.5-1-1-2-1.9-3-2.8-.3-.3-.7-.6-1-1C736.4 109.2 629.5 64 512 64s-224.4 45.2-304.3 119.2c-.3.3-.7.6-1 1-1 .9-2 1.9-3 2.9-.5.5-1 1-1.6 1.5-1.5 1.4-3 2.9-4.5 4.3l-.3.3-4.8 4.8-.1.1c-3.3 3.3-6.5 6.7-9.7 10.1l-.1.1c-1.6 1.7-3.1 3.4-4.6 5.1l-.1.1c-1.4 1.5-2.8 3.1-4.1 4.7-.4.5-.8.9-1.2 1.4-1.1 1.2-2.1 2.5-3.2 3.7-.2.3-.5.5-.7.8C103.4 301.9 64 402.3 64 512s39.4 210.1 104.8 288c.2.3.5.6.7.9l3.1 3.7c.4.5.8.9 1.2 1.4l4.1 4.7c0 .1.1.1.1.2 1.5 1.7 3 3.4 4.6 5l.1.1c3.2 3.4 6.4 6.8 9.6 10.1l.1.1c1.6 1.6 3.1 3.2 4.7 4.7l.3.3c3.3 3.3 6.7 6.5 10.1 9.6 80.1 74 187 119.2 304.5 119.2s224.4-45.2 304.3-119.2a300 300 0 0010-9.6l.3-.3c1.6-1.6 3.2-3.1 4.7-4.7l.1-.1c3.3-3.3 6.5-6.7 9.6-10.1l.1-.1c1.5-1.7 3.1-3.3 4.6-5 0-.1.1-.1.1-.2 1.4-1.5 2.8-3.1 4.1-4.7.4-.5.8-.9 1.2-1.4a99 99 0 003.3-3.7zm4.1-142.6c-13.8 32.6-32 62.8-54.2 90.2a444.07 444.07 0 00-81.5-55.9c11.6-46.9 18.8-98.4 20.7-152.6H887c-3 40.9-12.6 80.6-28.5 118.3zM887 484H743.5c-1.9-54.2-9.1-105.7-20.7-152.6 29.3-15.6 56.6-34.4 81.5-55.9A373.86 373.86 0 01887 484zM658.3 165.5c39.7 16.8 75.8 40 107.6 69.2a394.72 394.72 0 01-59.4 41.8c-15.7-45-35.8-84.1-59.2-115.4 3.7 1.4 7.4 2.9 11 4.4zm-90.6 700.6c-9.2 7.2-18.4 12.7-27.7 16.4V697a389.1 389.1 0 01115.7 26.2c-8.3 24.6-17.9 47.3-29 67.8-17.4 32.4-37.8 58.3-59 75.1zm59-633.1c11 20.6 20.7 43.3 29 67.8A389.1 389.1 0 01540 327V141.6c9.2 3.7 18.5 9.1 27.7 16.4 21.2 16.7 41.6 42.6 59 75zM540 640.9V540h147.5c-1.6 44.2-7.1 87.1-16.3 127.8l-.3 1.2A445.02 445.02 0 00540 640.9zm0-156.9V383.1c45.8-2.8 89.8-12.5 130.9-28.1l.3 1.2c9.2 40.7 14.7 83.5 16.3 127.8H540zm-56 56v100.9c-45.8 2.8-89.8 12.5-130.9 28.1l-.3-1.2c-9.2-40.7-14.7-83.5-16.3-127.8H484zm-147.5-56c1.6-44.2 7.1-87.1 16.3-127.8l.3-1.2c41.1 15.6 85 25.3 130.9 28.1V484H336.5zM484 697v185.4c-9.2-3.7-18.5-9.1-27.7-16.4-21.2-16.7-41.7-42.7-59.1-75.1-11-20.6-20.7-43.3-29-67.8 37.2-14.6 75.9-23.3 115.8-26.1zm0-370a389.1 389.1 0 01-115.7-26.2c8.3-24.6 17.9-47.3 29-67.8 17.4-32.4 37.8-58.4 59.1-75.1 9.2-7.2 18.4-12.7 27.7-16.4V327zM365.7 165.5c3.7-1.5 7.3-3 11-4.4-23.4 31.3-43.5 70.4-59.2 115.4-21-12-40.9-26-59.4-41.8 31.8-29.2 67.9-52.4 107.6-69.2zM165.5 365.7c13.8-32.6 32-62.8 54.2-90.2 24.9 21.5 52.2 40.3 81.5 55.9-11.6 46.9-18.8 98.4-20.7 152.6H137c3-40.9 12.6-80.6 28.5-118.3zM137 540h143.5c1.9 54.2 9.1 105.7 20.7 152.6a444.07 444.07 0 00-81.5 55.9A373.86 373.86 0 01137 540zm228.7 318.5c-39.7-16.8-75.8-40-107.6-69.2 18.5-15.8 38.4-29.7 59.4-41.8 15.7 45 35.8 84.1 59.2 115.4-3.7-1.4-7.4-2.9-11-4.4zm292.6 0c-3.7 1.5-7.3 3-11 4.4 23.4-31.3 43.5-70.4 59.2-115.4 21 12 40.9 26 59.4 41.8a373.81 373.81 0 01-107.6 69.2z" } }] }, "name": "global", "theme": "outlined" };
function _objectSpread$w(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$y(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$y(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var GlobalOutlined = function GlobalOutlined2(props2, context2) {
  var p = _objectSpread$w({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$w({}, p, {
    "icon": GlobalOutlined$1
  }), null);
};
GlobalOutlined.displayName = "GlobalOutlined";
GlobalOutlined.inheritAttrs = false;
var InboxOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M885.2 446.3l-.2-.8-112.2-285.1c-5-16.1-19.9-27.2-36.8-27.2H281.2c-17 0-32.1 11.3-36.9 27.6L139.4 443l-.3.7-.2.8c-1.3 4.9-1.7 9.9-1 14.8-.1 1.6-.2 3.2-.2 4.8V830a60.9 60.9 0 0060.8 60.8h627.2c33.5 0 60.8-27.3 60.9-60.8V464.1c0-1.3 0-2.6-.1-3.7.4-4.9 0-9.6-1.3-14.1zm-295.8-43l-.3 15.7c-.8 44.9-31.8 75.1-77.1 75.1-22.1 0-41.1-7.1-54.8-20.6S436 441.2 435.6 419l-.3-15.7H229.5L309 210h399.2l81.7 193.3H589.4zm-375 76.8h157.3c24.3 57.1 76 90.8 140.4 90.8 33.7 0 65-9.4 90.3-27.2 22.2-15.6 39.5-37.4 50.7-63.6h156.5V814H214.4V480.1z" } }] }, "name": "inbox", "theme": "outlined" };
function _objectSpread$v(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$x(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$x(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var InboxOutlined = function InboxOutlined2(props2, context2) {
  var p = _objectSpread$v({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$v({}, p, {
    "icon": InboxOutlined$1
  }), null);
};
InboxOutlined.displayName = "InboxOutlined";
InboxOutlined.inheritAttrs = false;
var InfoCircleFilled$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm32 664c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V456c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272zm-32-344a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, "name": "info-circle", "theme": "filled" };
function _objectSpread$u(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$w(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$w(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var InfoCircleFilled = function InfoCircleFilled2(props2, context2) {
  var p = _objectSpread$u({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$u({}, p, {
    "icon": InfoCircleFilled$1
  }), null);
};
InfoCircleFilled.displayName = "InfoCircleFilled";
InfoCircleFilled.inheritAttrs = false;
var InfoCircleOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { "tag": "path", "attrs": { "d": "M464 336a48 48 0 1096 0 48 48 0 10-96 0zm72 112h-48c-4.4 0-8 3.6-8 8v272c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V456c0-4.4-3.6-8-8-8z" } }] }, "name": "info-circle", "theme": "outlined" };
function _objectSpread$t(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$v(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$v(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var InfoCircleOutlined = function InfoCircleOutlined2(props2, context2) {
  var p = _objectSpread$t({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$t({}, p, {
    "icon": InfoCircleOutlined$1
  }), null);
};
InfoCircleOutlined.displayName = "InfoCircleOutlined";
InfoCircleOutlined.inheritAttrs = false;
var KeyOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M608 112c-167.9 0-304 136.1-304 304 0 70.3 23.9 135 63.9 186.5l-41.1 41.1-62.3-62.3a8.15 8.15 0 00-11.4 0l-39.8 39.8a8.15 8.15 0 000 11.4l62.3 62.3-44.9 44.9-62.3-62.3a8.15 8.15 0 00-11.4 0l-39.8 39.8a8.15 8.15 0 000 11.4l62.3 62.3-65.3 65.3a8.03 8.03 0 000 11.3l42.3 42.3c3.1 3.1 8.2 3.1 11.3 0l253.6-253.6A304.06 304.06 0 00608 720c167.9 0 304-136.1 304-304S775.9 112 608 112zm161.2 465.2C726.2 620.3 668.9 644 608 644c-60.9 0-118.2-23.7-161.2-66.8-43.1-43-66.8-100.3-66.8-161.2 0-60.9 23.7-118.2 66.8-161.2 43-43.1 100.3-66.8 161.2-66.8 60.9 0 118.2 23.7 161.2 66.8 43.1 43 66.8 100.3 66.8 161.2 0 60.9-23.7 118.2-66.8 161.2z" } }] }, "name": "key", "theme": "outlined" };
function _objectSpread$s(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$u(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$u(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var KeyOutlined = function KeyOutlined2(props2, context2) {
  var p = _objectSpread$s({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$s({}, p, {
    "icon": KeyOutlined$1
  }), null);
};
KeyOutlined.displayName = "KeyOutlined";
KeyOutlined.inheritAttrs = false;
var LeftOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 000 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z" } }] }, "name": "left", "theme": "outlined" };
function _objectSpread$r(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$t(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$t(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var LeftOutlined = function LeftOutlined2(props2, context2) {
  var p = _objectSpread$r({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$r({}, p, {
    "icon": LeftOutlined$1
  }), null);
};
LeftOutlined.displayName = "LeftOutlined";
LeftOutlined.inheritAttrs = false;
var LoadingOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z" } }] }, "name": "loading", "theme": "outlined" };
function _objectSpread$q(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$s(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$s(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var LoadingOutlined = function LoadingOutlined2(props2, context2) {
  var p = _objectSpread$q({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$q({}, p, {
    "icon": LoadingOutlined$1
  }), null);
};
LoadingOutlined.displayName = "LoadingOutlined";
LoadingOutlined.inheritAttrs = false;
var LogoutOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M868 732h-70.3c-4.8 0-9.3 2.1-12.3 5.8-7 8.5-14.5 16.7-22.4 24.5a353.84 353.84 0 01-112.7 75.9A352.8 352.8 0 01512.4 866c-47.9 0-94.3-9.4-137.9-27.8a353.84 353.84 0 01-112.7-75.9 353.28 353.28 0 01-76-112.5C167.3 606.2 158 559.9 158 512s9.4-94.2 27.8-137.8c17.8-42.1 43.4-80 76-112.5s70.5-58.1 112.7-75.9c43.6-18.4 90-27.8 137.9-27.8 47.9 0 94.3 9.3 137.9 27.8 42.2 17.8 80.1 43.4 112.7 75.9 7.9 7.9 15.3 16.1 22.4 24.5 3 3.7 7.6 5.8 12.3 5.8H868c6.3 0 10.2-7 6.7-12.3C798 160.5 663.8 81.6 511.3 82 271.7 82.6 79.6 277.1 82 516.4 84.4 751.9 276.2 942 512.4 942c152.1 0 285.7-78.8 362.3-197.7 3.4-5.3-.4-12.3-6.7-12.3zm88.9-226.3L815 393.7c-5.3-4.2-13-.4-13 6.3v76H488c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h314v76c0 6.7 7.8 10.5 13 6.3l141.9-112a8 8 0 000-12.6z" } }] }, "name": "logout", "theme": "outlined" };
function _objectSpread$p(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$r(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$r(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var LogoutOutlined = function LogoutOutlined2(props2, context2) {
  var p = _objectSpread$p({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$p({}, p, {
    "icon": LogoutOutlined$1
  }), null);
};
LogoutOutlined.displayName = "LogoutOutlined";
LogoutOutlined.inheritAttrs = false;
var MenuFoldOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 000 13.8z" } }] }, "name": "menu-fold", "theme": "outlined" };
function _objectSpread$o(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$q(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$q(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var MenuFoldOutlined = function MenuFoldOutlined2(props2, context2) {
  var p = _objectSpread$o({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$o({}, p, {
    "icon": MenuFoldOutlined$1
  }), null);
};
MenuFoldOutlined.displayName = "MenuFoldOutlined";
MenuFoldOutlined.inheritAttrs = false;
var MenuUnfoldOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM142.4 642.1L298.7 519a8.84 8.84 0 000-13.9L142.4 381.9c-5.8-4.6-14.4-.5-14.4 6.9v246.3a8.9 8.9 0 0014.4 7z" } }] }, "name": "menu-unfold", "theme": "outlined" };
function _objectSpread$n(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$p(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$p(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var MenuUnfoldOutlined = function MenuUnfoldOutlined2(props2, context2) {
  var p = _objectSpread$n({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$n({}, p, {
    "icon": MenuUnfoldOutlined$1
  }), null);
};
MenuUnfoldOutlined.displayName = "MenuUnfoldOutlined";
MenuUnfoldOutlined.inheritAttrs = false;
var MinusSquareOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M328 544h368c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H328c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8z" } }, { "tag": "path", "attrs": { "d": "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z" } }] }, "name": "minus-square", "theme": "outlined" };
function _objectSpread$m(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$o(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$o(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var MinusSquareOutlined = function MinusSquareOutlined2(props2, context2) {
  var p = _objectSpread$m({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$m({}, p, {
    "icon": MinusSquareOutlined$1
  }), null);
};
MinusSquareOutlined.displayName = "MinusSquareOutlined";
MinusSquareOutlined.inheritAttrs = false;
var PaperClipOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M779.3 196.6c-94.2-94.2-247.6-94.2-341.7 0l-261 260.8c-1.7 1.7-2.6 4-2.6 6.4s.9 4.7 2.6 6.4l36.9 36.9a9 9 0 0012.7 0l261-260.8c32.4-32.4 75.5-50.2 121.3-50.2s88.9 17.8 121.2 50.2c32.4 32.4 50.2 75.5 50.2 121.2 0 45.8-17.8 88.8-50.2 121.2l-266 265.9-43.1 43.1c-40.3 40.3-105.8 40.3-146.1 0-19.5-19.5-30.2-45.4-30.2-73s10.7-53.5 30.2-73l263.9-263.8c6.7-6.6 15.5-10.3 24.9-10.3h.1c9.4 0 18.1 3.7 24.7 10.3 6.7 6.7 10.3 15.5 10.3 24.9 0 9.3-3.7 18.1-10.3 24.7L372.4 653c-1.7 1.7-2.6 4-2.6 6.4s.9 4.7 2.6 6.4l36.9 36.9a9 9 0 0012.7 0l215.6-215.6c19.9-19.9 30.8-46.3 30.8-74.4s-11-54.6-30.8-74.4c-41.1-41.1-107.9-41-149 0L463 364 224.8 602.1A172.22 172.22 0 00174 724.8c0 46.3 18.1 89.8 50.8 122.5 33.9 33.8 78.3 50.7 122.7 50.7 44.4 0 88.8-16.9 122.6-50.7l309.2-309C824.8 492.7 850 432 850 367.5c.1-64.6-25.1-125.3-70.7-170.9z" } }] }, "name": "paper-clip", "theme": "outlined" };
function _objectSpread$l(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$n(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$n(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var PaperClipOutlined = function PaperClipOutlined2(props2, context2) {
  var p = _objectSpread$l({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$l({}, p, {
    "icon": PaperClipOutlined$1
  }), null);
};
PaperClipOutlined.displayName = "PaperClipOutlined";
PaperClipOutlined.inheritAttrs = false;
var PhoneTwoTone$1 = { "icon": function render5(primaryColor, secondaryColor) {
  return { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M721.7 184.9L610.9 295.8l120.8 120.7-8 21.6A481.29 481.29 0 01438 723.9l-21.6 8-.9-.9-119.8-120-110.8 110.9 104.5 104.5c10.8 10.7 26 15.7 40.8 13.2 117.9-19.5 235.4-82.9 330.9-178.4s158.9-213.1 178.4-331c2.5-14.8-2.5-30-13.3-40.8L721.7 184.9z", "fill": secondaryColor } }, { "tag": "path", "attrs": { "d": "M877.1 238.7L770.6 132.3c-13-13-30.4-20.3-48.8-20.3s-35.8 7.2-48.8 20.3L558.3 246.8c-13 13-20.3 30.5-20.3 48.9 0 18.5 7.2 35.8 20.3 48.9l89.6 89.7a405.46 405.46 0 01-86.4 127.3c-36.7 36.9-79.6 66-127.2 86.6l-89.6-89.7c-13-13-30.4-20.3-48.8-20.3a68.2 68.2 0 00-48.8 20.3L132.3 673c-13 13-20.3 30.5-20.3 48.9 0 18.5 7.2 35.8 20.3 48.9l106.4 106.4c22.2 22.2 52.8 34.9 84.2 34.9 6.5 0 12.8-.5 19.2-1.6 132.4-21.8 263.8-92.3 369.9-198.3C818 606 888.4 474.6 910.4 342.1c6.3-37.6-6.3-76.3-33.3-103.4zm-37.6 91.5c-19.5 117.9-82.9 235.5-178.4 331s-213 158.9-330.9 178.4c-14.8 2.5-30-2.5-40.8-13.2L184.9 721.9 295.7 611l119.8 120 .9.9 21.6-8a481.29 481.29 0 00285.7-285.8l8-21.6-120.8-120.7 110.8-110.9 104.5 104.5c10.8 10.8 15.8 26 13.3 40.8z", "fill": primaryColor } }] };
}, "name": "phone", "theme": "twotone" };
function _objectSpread$k(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$m(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$m(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var PhoneTwoTone = function PhoneTwoTone2(props2, context2) {
  var p = _objectSpread$k({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$k({}, p, {
    "icon": PhoneTwoTone$1
  }), null);
};
PhoneTwoTone.displayName = "PhoneTwoTone";
PhoneTwoTone.inheritAttrs = false;
var PictureTwoTone$1 = { "icon": function render6(primaryColor, secondaryColor) {
  return { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M928 160H96c-17.7 0-32 14.3-32 32v640c0 17.7 14.3 32 32 32h832c17.7 0 32-14.3 32-32V192c0-17.7-14.3-32-32-32zm-40 632H136v-39.9l138.5-164.3 150.1 178L658.1 489 888 761.6V792zm0-129.8L664.2 396.8c-3.2-3.8-9-3.8-12.2 0L424.6 666.4l-144-170.7c-3.2-3.8-9-3.8-12.2 0L136 652.7V232h752v430.2z", "fill": primaryColor } }, { "tag": "path", "attrs": { "d": "M424.6 765.8l-150.1-178L136 752.1V792h752v-30.4L658.1 489z", "fill": secondaryColor } }, { "tag": "path", "attrs": { "d": "M136 652.7l132.4-157c3.2-3.8 9-3.8 12.2 0l144 170.7L652 396.8c3.2-3.8 9-3.8 12.2 0L888 662.2V232H136v420.7zM304 280a88 88 0 110 176 88 88 0 010-176z", "fill": secondaryColor } }, { "tag": "path", "attrs": { "d": "M276 368a28 28 0 1056 0 28 28 0 10-56 0z", "fill": secondaryColor } }, { "tag": "path", "attrs": { "d": "M304 456a88 88 0 100-176 88 88 0 000 176zm0-116c15.5 0 28 12.5 28 28s-12.5 28-28 28-28-12.5-28-28 12.5-28 28-28z", "fill": primaryColor } }] };
}, "name": "picture", "theme": "twotone" };
function _objectSpread$j(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$l(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$l(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var PictureTwoTone = function PictureTwoTone2(props2, context2) {
  var p = _objectSpread$j({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$j({}, p, {
    "icon": PictureTwoTone$1
  }), null);
};
PictureTwoTone.displayName = "PictureTwoTone";
PictureTwoTone.inheritAttrs = false;
var PlusCircleTwoTone$1 = { "icon": function render7(primaryColor, secondaryColor) {
  return { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z", "fill": primaryColor } }, { "tag": "path", "attrs": { "d": "M512 140c-205.4 0-372 166.6-372 372s166.6 372 372 372 372-166.6 372-372-166.6-372-372-372zm192 396c0 4.4-3.6 8-8 8H544v152c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V544H328c-4.4 0-8-3.6-8-8v-48c0-4.4 3.6-8 8-8h152V328c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v152h152c4.4 0 8 3.6 8 8v48z", "fill": secondaryColor } }, { "tag": "path", "attrs": { "d": "M696 480H544V328c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v152H328c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8h152v152c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V544h152c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8z", "fill": primaryColor } }] };
}, "name": "plus-circle", "theme": "twotone" };
function _objectSpread$i(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$k(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$k(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var PlusCircleTwoTone = function PlusCircleTwoTone2(props2, context2) {
  var p = _objectSpread$i({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$i({}, p, {
    "icon": PlusCircleTwoTone$1
  }), null);
};
PlusCircleTwoTone.displayName = "PlusCircleTwoTone";
PlusCircleTwoTone.inheritAttrs = false;
var PlusOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M482 152h60q8 0 8 8v704q0 8-8 8h-60q-8 0-8-8V160q0-8 8-8z" } }, { "tag": "path", "attrs": { "d": "M192 474h672q8 0 8 8v60q0 8-8 8H160q-8 0-8-8v-60q0-8 8-8z" } }] }, "name": "plus", "theme": "outlined" };
function _objectSpread$h(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$j(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$j(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var PlusOutlined = function PlusOutlined2(props2, context2) {
  var p = _objectSpread$h({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$h({}, p, {
    "icon": PlusOutlined$1
  }), null);
};
PlusOutlined.displayName = "PlusOutlined";
PlusOutlined.inheritAttrs = false;
var PlusSquareOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M328 544h152v152c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V544h152c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H544V328c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v152H328c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8z" } }, { "tag": "path", "attrs": { "d": "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z" } }] }, "name": "plus-square", "theme": "outlined" };
function _objectSpread$g(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$i(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$i(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var PlusSquareOutlined = function PlusSquareOutlined2(props2, context2) {
  var p = _objectSpread$g({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$g({}, p, {
    "icon": PlusSquareOutlined$1
  }), null);
};
PlusSquareOutlined.displayName = "PlusSquareOutlined";
PlusSquareOutlined.inheritAttrs = false;
var QuestionCircleOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { "tag": "path", "attrs": { "d": "M623.6 316.7C593.6 290.4 554 276 512 276s-81.6 14.5-111.6 40.7C369.2 344 352 380.7 352 420v7.6c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V420c0-44.1 43.1-80 96-80s96 35.9 96 80c0 31.1-22 59.6-56.1 72.7-21.2 8.1-39.2 22.3-52.1 40.9-13.1 19-19.9 41.8-19.9 64.9V620c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8v-22.7a48.3 48.3 0 0130.9-44.8c59-22.7 97.1-74.7 97.1-132.5.1-39.3-17.1-76-48.3-103.3zM472 732a40 40 0 1080 0 40 40 0 10-80 0z" } }] }, "name": "question-circle", "theme": "outlined" };
function _objectSpread$f(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$h(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$h(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var QuestionCircleOutlined = function QuestionCircleOutlined2(props2, context2) {
  var p = _objectSpread$f({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$f({}, p, {
    "icon": QuestionCircleOutlined$1
  }), null);
};
QuestionCircleOutlined.displayName = "QuestionCircleOutlined";
QuestionCircleOutlined.inheritAttrs = false;
var ReloadOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M909.1 209.3l-56.4 44.1C775.8 155.1 656.2 92 521.9 92 290 92 102.3 279.5 102 511.5 101.7 743.7 289.8 932 521.9 932c181.3 0 335.8-115 394.6-276.1 1.5-4.2-.7-8.9-4.9-10.3l-56.7-19.5a8 8 0 00-10.1 4.8c-1.8 5-3.8 10-5.9 14.9-17.3 41-42.1 77.8-73.7 109.4A344.77 344.77 0 01655.9 829c-42.3 17.9-87.4 27-133.8 27-46.5 0-91.5-9.1-133.8-27A341.5 341.5 0 01279 755.2a342.16 342.16 0 01-73.7-109.4c-17.9-42.4-27-87.4-27-133.9s9.1-91.5 27-133.9c17.3-41 42.1-77.8 73.7-109.4 31.6-31.6 68.4-56.4 109.3-73.8 42.3-17.9 87.4-27 133.8-27 46.5 0 91.5 9.1 133.8 27a341.5 341.5 0 01109.3 73.8c9.9 9.9 19.2 20.4 27.8 31.4l-60.2 47a8 8 0 003 14.1l175.6 43c5 1.2 9.9-2.6 9.9-7.7l.8-180.9c-.1-6.6-7.8-10.3-13-6.2z" } }] }, "name": "reload", "theme": "outlined" };
function _objectSpread$e(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$g(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$g(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var ReloadOutlined = function ReloadOutlined2(props2, context2) {
  var p = _objectSpread$e({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$e({}, p, {
    "icon": ReloadOutlined$1
  }), null);
};
ReloadOutlined.displayName = "ReloadOutlined";
ReloadOutlined.inheritAttrs = false;
var RightOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M765.7 486.8L314.9 134.7A7.97 7.97 0 00302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 000-50.4z" } }] }, "name": "right", "theme": "outlined" };
function _objectSpread$d(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$f(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$f(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var RightOutlined = function RightOutlined2(props2, context2) {
  var p = _objectSpread$d({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$d({}, p, {
    "icon": RightOutlined$1
  }), null);
};
RightOutlined.displayName = "RightOutlined";
RightOutlined.inheritAttrs = false;
var RotateLeftOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "defs", "attrs": {}, "children": [{ "tag": "style", "attrs": {} }] }, { "tag": "path", "attrs": { "d": "M672 418H144c-17.7 0-32 14.3-32 32v414c0 17.7 14.3 32 32 32h528c17.7 0 32-14.3 32-32V450c0-17.7-14.3-32-32-32zm-44 402H188V494h440v326z" } }, { "tag": "path", "attrs": { "d": "M819.3 328.5c-78.8-100.7-196-153.6-314.6-154.2l-.2-64c0-6.5-7.6-10.1-12.6-6.1l-128 101c-4 3.1-3.9 9.1 0 12.3L492 318.6c5.1 4 12.7.4 12.6-6.1v-63.9c12.9.1 25.9.9 38.8 2.5 42.1 5.2 82.1 18.2 119 38.7 38.1 21.2 71.2 49.7 98.4 84.3 27.1 34.7 46.7 73.7 58.1 115.8a325.95 325.95 0 016.5 140.9h74.9c14.8-103.6-11.3-213-81-302.3z" } }] }, "name": "rotate-left", "theme": "outlined" };
function _objectSpread$c(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$e(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$e(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var RotateLeftOutlined = function RotateLeftOutlined2(props2, context2) {
  var p = _objectSpread$c({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$c({}, p, {
    "icon": RotateLeftOutlined$1
  }), null);
};
RotateLeftOutlined.displayName = "RotateLeftOutlined";
RotateLeftOutlined.inheritAttrs = false;
var RotateRightOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "defs", "attrs": {}, "children": [{ "tag": "style", "attrs": {} }] }, { "tag": "path", "attrs": { "d": "M480.5 251.2c13-1.6 25.9-2.4 38.8-2.5v63.9c0 6.5 7.5 10.1 12.6 6.1L660 217.6c4-3.2 4-9.2 0-12.3l-128-101c-5.1-4-12.6-.4-12.6 6.1l-.2 64c-118.6.5-235.8 53.4-314.6 154.2A399.75 399.75 0 00123.5 631h74.9c-.9-5.3-1.7-10.7-2.4-16.1-5.1-42.1-2.1-84.1 8.9-124.8 11.4-42.2 31-81.1 58.1-115.8 27.2-34.7 60.3-63.2 98.4-84.3 37-20.6 76.9-33.6 119.1-38.8z" } }, { "tag": "path", "attrs": { "d": "M880 418H352c-17.7 0-32 14.3-32 32v414c0 17.7 14.3 32 32 32h528c17.7 0 32-14.3 32-32V450c0-17.7-14.3-32-32-32zm-44 402H396V494h440v326z" } }] }, "name": "rotate-right", "theme": "outlined" };
function _objectSpread$b(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$d(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$d(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var RotateRightOutlined = function RotateRightOutlined2(props2, context2) {
  var p = _objectSpread$b({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$b({}, p, {
    "icon": RotateRightOutlined$1
  }), null);
};
RotateRightOutlined.displayName = "RotateRightOutlined";
RotateRightOutlined.inheritAttrs = false;
var SearchOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M909.6 854.5L649.9 594.8C690.2 542.7 712 479 712 412c0-80.2-31.3-155.4-87.9-212.1-56.6-56.7-132-87.9-212.1-87.9s-155.5 31.3-212.1 87.9C143.2 256.5 112 331.8 112 412c0 80.1 31.3 155.5 87.9 212.1C256.5 680.8 331.8 712 412 712c67 0 130.6-21.8 182.7-62l259.7 259.6a8.2 8.2 0 0011.6 0l43.6-43.5a8.2 8.2 0 000-11.6zM570.4 570.4C528 612.7 471.8 636 412 636s-116-23.3-158.4-65.6C211.3 528 188 471.8 188 412s23.3-116.1 65.6-158.4C296 211.3 352.2 188 412 188s116.1 23.2 158.4 65.6S636 352.2 636 412s-23.3 116.1-65.6 158.4z" } }] }, "name": "search", "theme": "outlined" };
function _objectSpread$a(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$c(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$c(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var SearchOutlined = function SearchOutlined2(props2, context2) {
  var p = _objectSpread$a({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$a({}, p, {
    "icon": SearchOutlined$1
  }), null);
};
SearchOutlined.displayName = "SearchOutlined";
SearchOutlined.inheritAttrs = false;
var SettingOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M924.8 625.7l-65.5-56c3.1-19 4.7-38.4 4.7-57.8s-1.6-38.8-4.7-57.8l65.5-56a32.03 32.03 0 009.3-35.2l-.9-2.6a443.74 443.74 0 00-79.7-137.9l-1.8-2.1a32.12 32.12 0 00-35.1-9.5l-81.3 28.9c-30-24.6-63.5-44-99.7-57.6l-15.7-85a32.05 32.05 0 00-25.8-25.7l-2.7-.5c-52.1-9.4-106.9-9.4-159 0l-2.7.5a32.05 32.05 0 00-25.8 25.7l-15.8 85.4a351.86 351.86 0 00-99 57.4l-81.9-29.1a32 32 0 00-35.1 9.5l-1.8 2.1a446.02 446.02 0 00-79.7 137.9l-.9 2.6c-4.5 12.5-.8 26.5 9.3 35.2l66.3 56.6c-3.1 18.8-4.6 38-4.6 57.1 0 19.2 1.5 38.4 4.6 57.1L99 625.5a32.03 32.03 0 00-9.3 35.2l.9 2.6c18.1 50.4 44.9 96.9 79.7 137.9l1.8 2.1a32.12 32.12 0 0035.1 9.5l81.9-29.1c29.8 24.5 63.1 43.9 99 57.4l15.8 85.4a32.05 32.05 0 0025.8 25.7l2.7.5a449.4 449.4 0 00159 0l2.7-.5a32.05 32.05 0 0025.8-25.7l15.7-85a350 350 0 0099.7-57.6l81.3 28.9a32 32 0 0035.1-9.5l1.8-2.1c34.8-41.1 61.6-87.5 79.7-137.9l.9-2.6c4.5-12.3.8-26.3-9.3-35zM788.3 465.9c2.5 15.1 3.8 30.6 3.8 46.1s-1.3 31-3.8 46.1l-6.6 40.1 74.7 63.9a370.03 370.03 0 01-42.6 73.6L721 702.8l-31.4 25.8c-23.9 19.6-50.5 35-79.3 45.8l-38.1 14.3-17.9 97a377.5 377.5 0 01-85 0l-17.9-97.2-37.8-14.5c-28.5-10.8-55-26.2-78.7-45.7l-31.4-25.9-93.4 33.2c-17-22.9-31.2-47.6-42.6-73.6l75.5-64.5-6.5-40c-2.4-14.9-3.7-30.3-3.7-45.5 0-15.3 1.2-30.6 3.7-45.5l6.5-40-75.5-64.5c11.3-26.1 25.6-50.7 42.6-73.6l93.4 33.2 31.4-25.9c23.7-19.5 50.2-34.9 78.7-45.7l37.9-14.3 17.9-97.2c28.1-3.2 56.8-3.2 85 0l17.9 97 38.1 14.3c28.7 10.8 55.4 26.2 79.3 45.8l31.4 25.8 92.8-32.9c17 22.9 31.2 47.6 42.6 73.6L781.8 426l6.5 39.9zM512 326c-97.2 0-176 78.8-176 176s78.8 176 176 176 176-78.8 176-176-78.8-176-176-176zm79.2 255.2A111.6 111.6 0 01512 614c-29.9 0-58-11.7-79.2-32.8A111.6 111.6 0 01400 502c0-29.9 11.7-58 32.8-79.2C454 401.6 482.1 390 512 390c29.9 0 58 11.6 79.2 32.8A111.6 111.6 0 01624 502c0 29.9-11.7 58-32.8 79.2z" } }] }, "name": "setting", "theme": "outlined" };
function _objectSpread$9(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$b(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$b(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var SettingOutlined = function SettingOutlined2(props2, context2) {
  var p = _objectSpread$9({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$9({}, p, {
    "icon": SettingOutlined$1
  }), null);
};
SettingOutlined.displayName = "SettingOutlined";
SettingOutlined.inheritAttrs = false;
var SwapOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M847.9 592H152c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h605.2L612.9 851c-4.1 5.2-.4 13 6.3 13h72.5c4.9 0 9.5-2.2 12.6-6.1l168.8-214.1c16.5-21 1.6-51.8-25.2-51.8zM872 356H266.8l144.3-183c4.1-5.2.4-13-6.3-13h-72.5c-4.9 0-9.5 2.2-12.6 6.1L150.9 380.2c-16.5 21-1.6 51.8 25.1 51.8h696c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8z" } }] }, "name": "swap", "theme": "outlined" };
function _objectSpread$8(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$a(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$a(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var SwapOutlined = function SwapOutlined2(props2, context2) {
  var p = _objectSpread$8({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$8({}, p, {
    "icon": SwapOutlined$1
  }), null);
};
SwapOutlined.displayName = "SwapOutlined";
SwapOutlined.inheritAttrs = false;
var SwapRightOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M873.1 596.2l-164-208A32 32 0 00684 376h-64.8c-6.7 0-10.4 7.7-6.3 13l144.3 183H152c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h695.9c26.8 0 41.7-30.8 25.2-51.8z" } }] }, "name": "swap-right", "theme": "outlined" };
function _objectSpread$7(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$9(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$9(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var SwapRightOutlined = function SwapRightOutlined2(props2, context2) {
  var p = _objectSpread$7({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$7({}, p, {
    "icon": SwapRightOutlined$1
  }), null);
};
SwapRightOutlined.displayName = "SwapRightOutlined";
SwapRightOutlined.inheritAttrs = false;
var TeamOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M824.2 699.9a301.55 301.55 0 00-86.4-60.4C783.1 602.8 812 546.8 812 484c0-110.8-92.4-201.7-203.2-200-109.1 1.7-197 90.6-197 200 0 62.8 29 118.8 74.2 155.5a300.95 300.95 0 00-86.4 60.4C345 754.6 314 826.8 312 903.8a8 8 0 008 8.2h56c4.3 0 7.9-3.4 8-7.7 1.9-58 25.4-112.3 66.7-153.5A226.62 226.62 0 01612 684c60.9 0 118.2 23.7 161.3 66.8C814.5 792 838 846.3 840 904.3c.1 4.3 3.7 7.7 8 7.7h56a8 8 0 008-8.2c-2-77-33-149.2-87.8-203.9zM612 612c-34.2 0-66.4-13.3-90.5-37.5a126.86 126.86 0 01-37.5-91.8c.3-32.8 13.4-64.5 36.3-88 24-24.6 56.1-38.3 90.4-38.7 33.9-.3 66.8 12.9 91 36.6 24.8 24.3 38.4 56.8 38.4 91.4 0 34.2-13.3 66.3-37.5 90.5A127.3 127.3 0 01612 612zM361.5 510.4c-.9-8.7-1.4-17.5-1.4-26.4 0-15.9 1.5-31.4 4.3-46.5.7-3.6-1.2-7.3-4.5-8.8-13.6-6.1-26.1-14.5-36.9-25.1a127.54 127.54 0 01-38.7-95.4c.9-32.1 13.8-62.6 36.3-85.6 24.7-25.3 57.9-39.1 93.2-38.7 31.9.3 62.7 12.6 86 34.4 7.9 7.4 14.7 15.6 20.4 24.4 2 3.1 5.9 4.4 9.3 3.2 17.6-6.1 36.2-10.4 55.3-12.4 5.6-.6 8.8-6.6 6.3-11.6-32.5-64.3-98.9-108.7-175.7-109.9-110.9-1.7-203.3 89.2-203.3 199.9 0 62.8 28.9 118.8 74.2 155.5-31.8 14.7-61.1 35-86.5 60.4-54.8 54.7-85.8 126.9-87.8 204a8 8 0 008 8.2h56.1c4.3 0 7.9-3.4 8-7.7 1.9-58 25.4-112.3 66.7-153.5 29.4-29.4 65.4-49.8 104.7-59.7 3.9-1 6.5-4.7 6-8.7z" } }] }, "name": "team", "theme": "outlined" };
function _objectSpread$6(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$8(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$8(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var TeamOutlined = function TeamOutlined2(props2, context2) {
  var p = _objectSpread$6({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$6({}, p, {
    "icon": TeamOutlined$1
  }), null);
};
TeamOutlined.displayName = "TeamOutlined";
TeamOutlined.inheritAttrs = false;
var UpOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M890.5 755.3L537.9 269.2c-12.8-17.6-39-17.6-51.7 0L133.5 755.3A8 8 0 00140 768h75c5.1 0 9.9-2.5 12.9-6.6L512 369.8l284.1 391.6c3 4.1 7.8 6.6 12.9 6.6h75c6.5 0 10.3-7.4 6.5-12.7z" } }] }, "name": "up", "theme": "outlined" };
function _objectSpread$5(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$7(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$7(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var UpOutlined = function UpOutlined2(props2, context2) {
  var p = _objectSpread$5({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$5({}, p, {
    "icon": UpOutlined$1
  }), null);
};
UpOutlined.displayName = "UpOutlined";
UpOutlined.inheritAttrs = false;
var UploadOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M400 317.7h73.9V656c0 4.4 3.6 8 8 8h60c4.4 0 8-3.6 8-8V317.7H624c6.7 0 10.4-7.7 6.3-12.9L518.3 163a8 8 0 00-12.6 0l-112 141.7c-4.1 5.3-.4 13 6.3 13zM878 626h-60c-4.4 0-8 3.6-8 8v154H214V634c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v198c0 17.7 14.3 32 32 32h684c17.7 0 32-14.3 32-32V634c0-4.4-3.6-8-8-8z" } }] }, "name": "upload", "theme": "outlined" };
function _objectSpread$4(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$6(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$6(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var UploadOutlined = function UploadOutlined2(props2, context2) {
  var p = _objectSpread$4({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$4({}, p, {
    "icon": UploadOutlined$1
  }), null);
};
UploadOutlined.displayName = "UploadOutlined";
UploadOutlined.inheritAttrs = false;
var UserOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M858.5 763.6a374 374 0 00-80.6-119.5 375.63 375.63 0 00-119.5-80.6c-.4-.2-.8-.3-1.2-.5C719.5 518 760 444.7 760 362c0-137-111-248-248-248S264 225 264 362c0 82.7 40.5 156 102.8 201.1-.4.2-.8.3-1.2.5-44.8 18.9-85 46-119.5 80.6a375.63 375.63 0 00-80.6 119.5A371.7 371.7 0 00136 901.8a8 8 0 008 8.2h60c4.4 0 7.9-3.5 8-7.8 2-77.2 33-149.5 87.8-204.3 56.7-56.7 132-87.9 212.2-87.9s155.5 31.2 212.2 87.9C779 752.7 810 825 812 902.2c.1 4.4 3.6 7.8 8 7.8h60a8 8 0 008-8.2c-1-47.8-10.9-94.3-29.5-138.2zM512 534c-45.9 0-89.1-17.9-121.6-50.4S340 407.9 340 362c0-45.9 17.9-89.1 50.4-121.6S466.1 190 512 190s89.1 17.9 121.6 50.4S684 316.1 684 362c0 45.9-17.9 89.1-50.4 121.6S557.9 534 512 534z" } }] }, "name": "user", "theme": "outlined" };
function _objectSpread$3(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$5(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$5(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var UserOutlined = function UserOutlined2(props2, context2) {
  var p = _objectSpread$3({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$3({}, p, {
    "icon": UserOutlined$1
  }), null);
};
UserOutlined.displayName = "UserOutlined";
UserOutlined.inheritAttrs = false;
var WarningFilled$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M955.7 856l-416-720c-6.2-10.7-16.9-16-27.7-16s-21.6 5.3-27.7 16l-416 720C56 877.4 71.4 904 96 904h832c24.6 0 40-26.6 27.7-48zM480 416c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v184c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V416zm32 352a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, "name": "warning", "theme": "filled" };
function _objectSpread$2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$4(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$4(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var WarningFilled = function WarningFilled2(props2, context2) {
  var p = _objectSpread$2({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$2({}, p, {
    "icon": WarningFilled$1
  }), null);
};
WarningFilled.displayName = "WarningFilled";
WarningFilled.inheritAttrs = false;
var ZoomInOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M637 443H519V309c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v134H325c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h118v134c0 4.4 3.6 8 8 8h60c4.4 0 8-3.6 8-8V519h118c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8zm284 424L775 721c122.1-148.9 113.6-369.5-26-509-148-148.1-388.4-148.1-537 0-148.1 148.6-148.1 389 0 537 139.5 139.6 360.1 148.1 509 26l146 146c3.2 2.8 8.3 2.8 11 0l43-43c2.8-2.7 2.8-7.8 0-11zM696 696c-118.8 118.7-311.2 118.7-430 0-118.7-118.8-118.7-311.2 0-430 118.8-118.7 311.2-118.7 430 0 118.7 118.8 118.7 311.2 0 430z" } }] }, "name": "zoom-in", "theme": "outlined" };
function _objectSpread$1(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$3(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$3(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var ZoomInOutlined = function ZoomInOutlined2(props2, context2) {
  var p = _objectSpread$1({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread$1({}, p, {
    "icon": ZoomInOutlined$1
  }), null);
};
ZoomInOutlined.displayName = "ZoomInOutlined";
ZoomInOutlined.inheritAttrs = false;
var ZoomOutOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M637 443H325c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h312c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8zm284 424L775 721c122.1-148.9 113.6-369.5-26-509-148-148.1-388.4-148.1-537 0-148.1 148.6-148.1 389 0 537 139.5 139.6 360.1 148.1 509 26l146 146c3.2 2.8 8.3 2.8 11 0l43-43c2.8-2.7 2.8-7.8 0-11zM696 696c-118.8 118.7-311.2 118.7-430 0-118.7-118.8-118.7-311.2 0-430 118.8-118.7 311.2-118.7 430 0 118.7 118.8 118.7 311.2 0 430z" } }] }, "name": "zoom-out", "theme": "outlined" };
function _objectSpread(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$2(target, key2, source[key2]);
    });
  }
  return target;
}
function _defineProperty$2(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var ZoomOutOutlined = function ZoomOutOutlined2(props2, context2) {
  var p = _objectSpread({}, props2, context2.attrs);
  return createVNode(Icon, _objectSpread({}, p, {
    "icon": ZoomOutOutlined$1
  }), null);
};
ZoomOutOutlined.displayName = "ZoomOutOutlined";
ZoomOutOutlined.inheritAttrs = false;
function _typeof$1(o2) {
  "@babel/helpers - typeof";
  return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof$1(o2);
}
function toPrimitive(t2, r2) {
  if ("object" != _typeof$1(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2 || "default");
    if ("object" != _typeof$1(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function toPropertyKey(t2) {
  var i2 = toPrimitive(t2, "string");
  return "symbol" == _typeof$1(i2) ? i2 : i2 + "";
}
function _defineProperty$1(e2, r2, t2) {
  return (r2 = toPropertyKey(r2)) in e2 ? Object.defineProperty(e2, r2, {
    value: t2,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e2[r2] = t2, e2;
}
function ownKeys$1(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread2$1(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$1(Object(t2), true).forEach(function(r3) {
      _defineProperty$1(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$1(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function _extends$1() {
  return _extends$1 = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var t2 = arguments[e2];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends$1.apply(null, arguments);
}
const isFunction$1 = (val) => typeof val === "function";
const isArray$1 = Array.isArray;
const isString = (val) => typeof val === "string";
const isObject$2 = (val) => val !== null && typeof val === "object";
const onRE = /^on[^a-z]/;
const isOn = (key2) => onRE.test(key2);
const cacheStringFunction = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_2, c2) => c2 ? c2.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction((str) => {
  return str.replace(hyphenateRE, "-$1").toLowerCase();
});
const capitalize = cacheStringFunction((str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
const hasOwnProperty$d = Object.prototype.hasOwnProperty;
const hasOwn = (val, key2) => hasOwnProperty$d.call(val, key2);
function resolvePropValue(options, props2, key2, value) {
  const opt = options[key2];
  if (opt != null) {
    const hasDefault = hasOwn(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      value = opt.type !== Function && isFunction$1(defaultValue) ? defaultValue() : defaultValue;
    }
    if (opt.type === Boolean) {
      if (!hasOwn(props2, key2) && !hasDefault) {
        value = false;
      } else if (value === "") {
        value = true;
      }
    }
  }
  return value;
}
function toPx(val) {
  if (typeof val === "number") return `${val}px`;
  return val;
}
function renderHelper(v2) {
  let props2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  let defaultV = arguments.length > 2 ? arguments[2] : void 0;
  if (typeof v2 === "function") {
    return v2(props2);
  }
  return v2 !== null && v2 !== void 0 ? v2 : defaultV;
}
function wrapPromiseFn(openFn) {
  let closeFn;
  const closePromise = new Promise((resolve) => {
    closeFn = openFn(() => {
      resolve(true);
    });
  });
  const result = () => {
    closeFn === null || closeFn === void 0 ? void 0 : closeFn();
  };
  result.then = (filled, rejected) => closePromise.then(filled, rejected);
  result.promise = closePromise;
  return result;
}
function classNames() {
  const classes = [];
  for (let i2 = 0; i2 < arguments.length; i2++) {
    const value = i2 < 0 || arguments.length <= i2 ? void 0 : arguments[i2];
    if (!value) continue;
    if (isString(value)) {
      classes.push(value);
    } else if (isArray$1(value)) {
      for (let i3 = 0; i3 < value.length; i3++) {
        const inner = classNames(value[i3]);
        if (inner) {
          classes.push(inner);
        }
      }
    } else if (isObject$2(value)) {
      for (const name in value) {
        if (value[name]) {
          classes.push(name);
        }
      }
    }
  }
  return classes.join(" ");
}
var MapShim = function() {
  if (typeof Map !== "undefined") {
    return Map;
  }
  function getIndex(arr, key2) {
    var result = -1;
    arr.some(function(entry, index2) {
      if (entry[0] === key2) {
        result = index2;
        return true;
      }
      return false;
    });
    return result;
  }
  return (
    /** @class */
    function() {
      function class_1() {
        this.__entries__ = [];
      }
      Object.defineProperty(class_1.prototype, "size", {
        /**
         * @returns {boolean}
         */
        get: function() {
          return this.__entries__.length;
        },
        enumerable: true,
        configurable: true
      });
      class_1.prototype.get = function(key2) {
        var index2 = getIndex(this.__entries__, key2);
        var entry = this.__entries__[index2];
        return entry && entry[1];
      };
      class_1.prototype.set = function(key2, value) {
        var index2 = getIndex(this.__entries__, key2);
        if (~index2) {
          this.__entries__[index2][1] = value;
        } else {
          this.__entries__.push([key2, value]);
        }
      };
      class_1.prototype.delete = function(key2) {
        var entries = this.__entries__;
        var index2 = getIndex(entries, key2);
        if (~index2) {
          entries.splice(index2, 1);
        }
      };
      class_1.prototype.has = function(key2) {
        return !!~getIndex(this.__entries__, key2);
      };
      class_1.prototype.clear = function() {
        this.__entries__.splice(0);
      };
      class_1.prototype.forEach = function(callback, ctx) {
        if (ctx === void 0) {
          ctx = null;
        }
        for (var _i = 0, _a2 = this.__entries__; _i < _a2.length; _i++) {
          var entry = _a2[_i];
          callback.call(ctx, entry[1], entry[0]);
        }
      };
      return class_1;
    }()
  );
}();
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
var global$1 = function() {
  if (typeof global !== "undefined" && global.Math === Math) {
    return global;
  }
  if (typeof self !== "undefined" && self.Math === Math) {
    return self;
  }
  if (typeof window !== "undefined" && window.Math === Math) {
    return window;
  }
  return Function("return this")();
}();
var requestAnimationFrame$1 = function() {
  if (typeof requestAnimationFrame === "function") {
    return requestAnimationFrame.bind(global$1);
  }
  return function(callback) {
    return setTimeout(function() {
      return callback(Date.now());
    }, 1e3 / 60);
  };
}();
var trailingTimeout = 2;
function throttle$1(callback, delay) {
  var leadingCall = false, trailingCall = false, lastCallTime = 0;
  function resolvePending() {
    if (leadingCall) {
      leadingCall = false;
      callback();
    }
    if (trailingCall) {
      proxy();
    }
  }
  function timeoutCallback() {
    requestAnimationFrame$1(resolvePending);
  }
  function proxy() {
    var timeStamp = Date.now();
    if (leadingCall) {
      if (timeStamp - lastCallTime < trailingTimeout) {
        return;
      }
      trailingCall = true;
    } else {
      leadingCall = true;
      trailingCall = false;
      setTimeout(timeoutCallback, delay);
    }
    lastCallTime = timeStamp;
  }
  return proxy;
}
var REFRESH_DELAY = 20;
var transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
var mutationObserverSupported = typeof MutationObserver !== "undefined";
var ResizeObserverController = (
  /** @class */
  function() {
    function ResizeObserverController2() {
      this.connected_ = false;
      this.mutationEventsAdded_ = false;
      this.mutationsObserver_ = null;
      this.observers_ = [];
      this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
      this.refresh = throttle$1(this.refresh.bind(this), REFRESH_DELAY);
    }
    ResizeObserverController2.prototype.addObserver = function(observer) {
      if (!~this.observers_.indexOf(observer)) {
        this.observers_.push(observer);
      }
      if (!this.connected_) {
        this.connect_();
      }
    };
    ResizeObserverController2.prototype.removeObserver = function(observer) {
      var observers2 = this.observers_;
      var index2 = observers2.indexOf(observer);
      if (~index2) {
        observers2.splice(index2, 1);
      }
      if (!observers2.length && this.connected_) {
        this.disconnect_();
      }
    };
    ResizeObserverController2.prototype.refresh = function() {
      var changesDetected = this.updateObservers_();
      if (changesDetected) {
        this.refresh();
      }
    };
    ResizeObserverController2.prototype.updateObservers_ = function() {
      var activeObservers = this.observers_.filter(function(observer) {
        return observer.gatherActive(), observer.hasActive();
      });
      activeObservers.forEach(function(observer) {
        return observer.broadcastActive();
      });
      return activeObservers.length > 0;
    };
    ResizeObserverController2.prototype.connect_ = function() {
      if (!isBrowser || this.connected_) {
        return;
      }
      document.addEventListener("transitionend", this.onTransitionEnd_);
      window.addEventListener("resize", this.refresh);
      if (mutationObserverSupported) {
        this.mutationsObserver_ = new MutationObserver(this.refresh);
        this.mutationsObserver_.observe(document, {
          attributes: true,
          childList: true,
          characterData: true,
          subtree: true
        });
      } else {
        document.addEventListener("DOMSubtreeModified", this.refresh);
        this.mutationEventsAdded_ = true;
      }
      this.connected_ = true;
    };
    ResizeObserverController2.prototype.disconnect_ = function() {
      if (!isBrowser || !this.connected_) {
        return;
      }
      document.removeEventListener("transitionend", this.onTransitionEnd_);
      window.removeEventListener("resize", this.refresh);
      if (this.mutationsObserver_) {
        this.mutationsObserver_.disconnect();
      }
      if (this.mutationEventsAdded_) {
        document.removeEventListener("DOMSubtreeModified", this.refresh);
      }
      this.mutationsObserver_ = null;
      this.mutationEventsAdded_ = false;
      this.connected_ = false;
    };
    ResizeObserverController2.prototype.onTransitionEnd_ = function(_a2) {
      var _b = _a2.propertyName, propertyName = _b === void 0 ? "" : _b;
      var isReflowProperty = transitionKeys.some(function(key2) {
        return !!~propertyName.indexOf(key2);
      });
      if (isReflowProperty) {
        this.refresh();
      }
    };
    ResizeObserverController2.getInstance = function() {
      if (!this.instance_) {
        this.instance_ = new ResizeObserverController2();
      }
      return this.instance_;
    };
    ResizeObserverController2.instance_ = null;
    return ResizeObserverController2;
  }()
);
var defineConfigurable = function(target, props2) {
  for (var _i = 0, _a2 = Object.keys(props2); _i < _a2.length; _i++) {
    var key2 = _a2[_i];
    Object.defineProperty(target, key2, {
      value: props2[key2],
      enumerable: false,
      writable: false,
      configurable: true
    });
  }
  return target;
};
var getWindowOf = function(target) {
  var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
  return ownerGlobal || global$1;
};
var emptyRect = createRectInit(0, 0, 0, 0);
function toFloat(value) {
  return parseFloat(value) || 0;
}
function getBordersSize(styles) {
  var positions = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    positions[_i - 1] = arguments[_i];
  }
  return positions.reduce(function(size, position2) {
    var value = styles["border-" + position2 + "-width"];
    return size + toFloat(value);
  }, 0);
}
function getPaddings(styles) {
  var positions = ["top", "right", "bottom", "left"];
  var paddings = {};
  for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
    var position2 = positions_1[_i];
    var value = styles["padding-" + position2];
    paddings[position2] = toFloat(value);
  }
  return paddings;
}
function getSVGContentRect(target) {
  var bbox = target.getBBox();
  return createRectInit(0, 0, bbox.width, bbox.height);
}
function getHTMLElementContentRect(target) {
  var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
  if (!clientWidth && !clientHeight) {
    return emptyRect;
  }
  var styles = getWindowOf(target).getComputedStyle(target);
  var paddings = getPaddings(styles);
  var horizPad = paddings.left + paddings.right;
  var vertPad = paddings.top + paddings.bottom;
  var width = toFloat(styles.width), height = toFloat(styles.height);
  if (styles.boxSizing === "border-box") {
    if (Math.round(width + horizPad) !== clientWidth) {
      width -= getBordersSize(styles, "left", "right") + horizPad;
    }
    if (Math.round(height + vertPad) !== clientHeight) {
      height -= getBordersSize(styles, "top", "bottom") + vertPad;
    }
  }
  if (!isDocumentElement(target)) {
    var vertScrollbar = Math.round(width + horizPad) - clientWidth;
    var horizScrollbar = Math.round(height + vertPad) - clientHeight;
    if (Math.abs(vertScrollbar) !== 1) {
      width -= vertScrollbar;
    }
    if (Math.abs(horizScrollbar) !== 1) {
      height -= horizScrollbar;
    }
  }
  return createRectInit(paddings.left, paddings.top, width, height);
}
var isSVGGraphicsElement = function() {
  if (typeof SVGGraphicsElement !== "undefined") {
    return function(target) {
      return target instanceof getWindowOf(target).SVGGraphicsElement;
    };
  }
  return function(target) {
    return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === "function";
  };
}();
function isDocumentElement(target) {
  return target === getWindowOf(target).document.documentElement;
}
function getContentRect(target) {
  if (!isBrowser) {
    return emptyRect;
  }
  if (isSVGGraphicsElement(target)) {
    return getSVGContentRect(target);
  }
  return getHTMLElementContentRect(target);
}
function createReadOnlyRect(_a2) {
  var x2 = _a2.x, y2 = _a2.y, width = _a2.width, height = _a2.height;
  var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
  var rect = Object.create(Constr.prototype);
  defineConfigurable(rect, {
    x: x2,
    y: y2,
    width,
    height,
    top: y2,
    right: x2 + width,
    bottom: height + y2,
    left: x2
  });
  return rect;
}
function createRectInit(x2, y2, width, height) {
  return { x: x2, y: y2, width, height };
}
var ResizeObservation = (
  /** @class */
  function() {
    function ResizeObservation2(target) {
      this.broadcastWidth = 0;
      this.broadcastHeight = 0;
      this.contentRect_ = createRectInit(0, 0, 0, 0);
      this.target = target;
    }
    ResizeObservation2.prototype.isActive = function() {
      var rect = getContentRect(this.target);
      this.contentRect_ = rect;
      return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
    };
    ResizeObservation2.prototype.broadcastRect = function() {
      var rect = this.contentRect_;
      this.broadcastWidth = rect.width;
      this.broadcastHeight = rect.height;
      return rect;
    };
    return ResizeObservation2;
  }()
);
var ResizeObserverEntry = (
  /** @class */
  /* @__PURE__ */ function() {
    function ResizeObserverEntry2(target, rectInit) {
      var contentRect = createReadOnlyRect(rectInit);
      defineConfigurable(this, { target, contentRect });
    }
    return ResizeObserverEntry2;
  }()
);
var ResizeObserverSPI = (
  /** @class */
  function() {
    function ResizeObserverSPI2(callback, controller, callbackCtx) {
      this.activeObservations_ = [];
      this.observations_ = new MapShim();
      if (typeof callback !== "function") {
        throw new TypeError("The callback provided as parameter 1 is not a function.");
      }
      this.callback_ = callback;
      this.controller_ = controller;
      this.callbackCtx_ = callbackCtx;
    }
    ResizeObserverSPI2.prototype.observe = function(target) {
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      if (typeof Element === "undefined" || !(Element instanceof Object)) {
        return;
      }
      if (!(target instanceof getWindowOf(target).Element)) {
        throw new TypeError('parameter 1 is not of type "Element".');
      }
      var observations = this.observations_;
      if (observations.has(target)) {
        return;
      }
      observations.set(target, new ResizeObservation(target));
      this.controller_.addObserver(this);
      this.controller_.refresh();
    };
    ResizeObserverSPI2.prototype.unobserve = function(target) {
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      if (typeof Element === "undefined" || !(Element instanceof Object)) {
        return;
      }
      if (!(target instanceof getWindowOf(target).Element)) {
        throw new TypeError('parameter 1 is not of type "Element".');
      }
      var observations = this.observations_;
      if (!observations.has(target)) {
        return;
      }
      observations.delete(target);
      if (!observations.size) {
        this.controller_.removeObserver(this);
      }
    };
    ResizeObserverSPI2.prototype.disconnect = function() {
      this.clearActive();
      this.observations_.clear();
      this.controller_.removeObserver(this);
    };
    ResizeObserverSPI2.prototype.gatherActive = function() {
      var _this = this;
      this.clearActive();
      this.observations_.forEach(function(observation) {
        if (observation.isActive()) {
          _this.activeObservations_.push(observation);
        }
      });
    };
    ResizeObserverSPI2.prototype.broadcastActive = function() {
      if (!this.hasActive()) {
        return;
      }
      var ctx = this.callbackCtx_;
      var entries = this.activeObservations_.map(function(observation) {
        return new ResizeObserverEntry(observation.target, observation.broadcastRect());
      });
      this.callback_.call(ctx, entries, ctx);
      this.clearActive();
    };
    ResizeObserverSPI2.prototype.clearActive = function() {
      this.activeObservations_.splice(0);
    };
    ResizeObserverSPI2.prototype.hasActive = function() {
      return this.activeObservations_.length > 0;
    };
    return ResizeObserverSPI2;
  }()
);
var observers = typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim();
var ResizeObserver$2 = (
  /** @class */
  /* @__PURE__ */ function() {
    function ResizeObserver2(callback) {
      if (!(this instanceof ResizeObserver2)) {
        throw new TypeError("Cannot call a class as a function.");
      }
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      var controller = ResizeObserverController.getInstance();
      var observer = new ResizeObserverSPI(callback, controller, this);
      observers.set(this, observer);
    }
    return ResizeObserver2;
  }()
);
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(method4) {
  ResizeObserver$2.prototype[method4] = function() {
    var _a2;
    return (_a2 = observers.get(this))[method4].apply(_a2, arguments);
  };
});
var index$1 = function() {
  if (typeof global$1.ResizeObserver !== "undefined") {
    return global$1.ResizeObserver;
  }
  return ResizeObserver$2;
}();
const isValid$2 = (value) => {
  return value !== void 0 && value !== null && value !== "";
};
const initDefaultProps = (types2, defaultProps2) => {
  const propTypes2 = _extends$1({}, types2);
  Object.keys(defaultProps2).forEach((k2) => {
    const prop = propTypes2[k2];
    if (prop) {
      if (prop.type || prop.default) {
        prop.default = defaultProps2[k2];
      } else if (prop.def) {
        prop.def(defaultProps2[k2]);
      } else {
        propTypes2[k2] = {
          type: prop,
          default: defaultProps2[k2]
        };
      }
    } else {
      throw new Error(`not have ${k2} prop`);
    }
  });
  return propTypes2;
};
const splitAttrs = (attrs) => {
  const allAttrs = Object.keys(attrs);
  const eventAttrs = {};
  const onEvents = {};
  const extraAttrs = {};
  for (let i2 = 0, l2 = allAttrs.length; i2 < l2; i2++) {
    const key2 = allAttrs[i2];
    if (isOn(key2)) {
      eventAttrs[key2[2].toLowerCase() + key2.slice(3)] = attrs[key2];
      onEvents[key2] = attrs[key2];
    } else {
      extraAttrs[key2] = attrs[key2];
    }
  }
  return {
    onEvents,
    events: eventAttrs,
    extraAttrs
  };
};
const parseStyleText = function() {
  let cssText = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  let camel = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  const res = {};
  const listDelimiter = /;(?![^(]*\))/g;
  const propertyDelimiter = /:(.+)/;
  if (typeof cssText === "object") return cssText;
  cssText.split(listDelimiter).forEach(function(item) {
    if (item) {
      const tmp = item.split(propertyDelimiter);
      if (tmp.length > 1) {
        const k2 = camel ? camelize(tmp[0].trim()) : tmp[0].trim();
        res[k2] = tmp[1].trim();
      }
    }
  });
  return res;
};
const hasProp = (instance, prop) => {
  return instance[prop] !== void 0;
};
const skipFlattenKey = Symbol("skipFlatten");
const flattenChildren = function() {
  let children = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  let filterEmpty2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  const temp = Array.isArray(children) ? children : [children];
  const res = [];
  temp.forEach((child) => {
    if (Array.isArray(child)) {
      res.push(...flattenChildren(child, filterEmpty2));
    } else if (child && child.type === Fragment) {
      if (child.key === skipFlattenKey) {
        res.push(child);
      } else {
        res.push(...flattenChildren(child.children, filterEmpty2));
      }
    } else if (child && isVNode(child)) {
      if (filterEmpty2 && !isEmptyElement(child)) {
        res.push(child);
      } else if (!filterEmpty2) {
        res.push(child);
      }
    } else if (isValid$2(child)) {
      res.push(child);
    }
  });
  return res;
};
const getSlot = function(self2) {
  let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "default";
  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (isVNode(self2)) {
    if (self2.type === Fragment) {
      return name === "default" ? flattenChildren(self2.children) : [];
    } else if (self2.children && self2.children[name]) {
      return flattenChildren(self2.children[name](options));
    } else {
      return [];
    }
  } else {
    const res = self2.$slots[name] && self2.$slots[name](options);
    return flattenChildren(res);
  }
};
const findDOMNode = (instance) => {
  var _a2;
  let node2 = ((_a2 = instance === null || instance === void 0 ? void 0 : instance.vnode) === null || _a2 === void 0 ? void 0 : _a2.el) || instance && (instance.$el || instance);
  while (node2 && !node2.tagName) {
    node2 = node2.nextSibling;
  }
  return node2;
};
const getOptionProps = (instance) => {
  const res = {};
  if (instance.$ && instance.$.vnode) {
    const props2 = instance.$.vnode.props || {};
    Object.keys(instance.$props).forEach((k2) => {
      const v2 = instance.$props[k2];
      const hyphenateKey = hyphenate(k2);
      if (v2 !== void 0 || hyphenateKey in props2) {
        res[k2] = v2;
      }
    });
  } else if (isVNode(instance) && typeof instance.type === "object") {
    const originProps = instance.props || {};
    const props2 = {};
    Object.keys(originProps).forEach((key2) => {
      props2[camelize(key2)] = originProps[key2];
    });
    const options = instance.type.props || {};
    Object.keys(options).forEach((k2) => {
      const v2 = resolvePropValue(options, props2, k2, props2[k2]);
      if (v2 !== void 0 || k2 in props2) {
        res[k2] = v2;
      }
    });
  }
  return res;
};
const getComponent = function(instance) {
  let prop = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "default";
  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : instance;
  let execute = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
  let com = void 0;
  if (instance.$) {
    const temp = instance[prop];
    if (temp !== void 0) {
      return typeof temp === "function" && execute ? temp(options) : temp;
    } else {
      com = instance.$slots[prop];
      com = execute && com ? com(options) : com;
    }
  } else if (isVNode(instance)) {
    const temp = instance.props && instance.props[prop];
    if (temp !== void 0 && instance.props !== null) {
      return typeof temp === "function" && execute ? temp(options) : temp;
    } else if (instance.type === Fragment) {
      com = instance.children;
    } else if (instance.children && instance.children[prop]) {
      com = instance.children[prop];
      com = execute && com ? com(options) : com;
    }
  }
  if (Array.isArray(com)) {
    com = flattenChildren(com);
    com = com.length === 1 ? com[0] : com;
    com = com.length === 0 ? void 0 : com;
  }
  return com;
};
function getEvents() {
  let ele = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  let on = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  let props2 = {};
  if (ele.$) {
    props2 = _extends$1(_extends$1({}, props2), ele.$attrs);
  } else {
    props2 = _extends$1(_extends$1({}, props2), ele.props);
  }
  return splitAttrs(props2)[on ? "onEvents" : "events"];
}
function getStyle$3(ele, camel) {
  const props2 = (isVNode(ele) ? ele.props : ele.$attrs) || {};
  let style = props2.style || {};
  if (typeof style === "string") {
    style = parseStyleText(style, camel);
  }
  return style;
}
function isFragment(c2) {
  return c2.length === 1 && c2[0].type === Fragment;
}
function isEmptyElement(c2) {
  return c2 && (c2.type === Comment || c2.type === Fragment && c2.children.length === 0 || c2.type === Text$1 && c2.children.trim() === "");
}
function isStringElement(c2) {
  return c2 && c2.type === Text$1;
}
function filterEmpty() {
  let children = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  const res = [];
  children.forEach((child) => {
    if (Array.isArray(child)) {
      res.push(...child);
    } else if ((child === null || child === void 0 ? void 0 : child.type) === Fragment) {
      res.push(...filterEmpty(child.children));
    } else {
      res.push(child);
    }
  });
  return res.filter((c2) => !isEmptyElement(c2));
}
function filterEmptyWithUndefined(children) {
  if (children) {
    const coms = filterEmpty(children);
    return coms.length ? coms : void 0;
  } else {
    return children;
  }
}
function isValidElement(element) {
  if (Array.isArray(element) && element.length === 1) {
    element = element[0];
  }
  return element && element.__v_isVNode && typeof element.type !== "symbol";
}
function getPropsSlot(slots, props2) {
  let prop = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "default";
  var _a2, _b;
  return (_a2 = props2[prop]) !== null && _a2 !== void 0 ? _a2 : (_b = slots[prop]) === null || _b === void 0 ? void 0 : _b.call(slots);
}
const ResizeObserver$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ResizeObserver",
  props: {
    disabled: Boolean,
    onResize: Function
  },
  emits: ["resize"],
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const state = reactive({
      width: 0,
      height: 0,
      offsetHeight: 0,
      offsetWidth: 0
    });
    let currentElement = null;
    let resizeObserver = null;
    const destroyObserver = () => {
      if (resizeObserver) {
        resizeObserver.disconnect();
        resizeObserver = null;
      }
    };
    const onResize = (entries) => {
      const {
        onResize: onResize2
      } = props2;
      const target = entries[0].target;
      const {
        width,
        height
      } = target.getBoundingClientRect();
      const {
        offsetWidth,
        offsetHeight
      } = target;
      const fixedWidth = Math.floor(width);
      const fixedHeight = Math.floor(height);
      if (state.width !== fixedWidth || state.height !== fixedHeight || state.offsetWidth !== offsetWidth || state.offsetHeight !== offsetHeight) {
        const size = {
          width: fixedWidth,
          height: fixedHeight,
          offsetWidth,
          offsetHeight
        };
        _extends$1(state, size);
        if (onResize2) {
          Promise.resolve().then(() => {
            onResize2(_extends$1(_extends$1({}, size), {
              offsetWidth,
              offsetHeight
            }), target);
          });
        }
      }
    };
    const instance = getCurrentInstance();
    const registerObserver = () => {
      const {
        disabled
      } = props2;
      if (disabled) {
        destroyObserver();
        return;
      }
      const element = findDOMNode(instance);
      const elementChanged = element !== currentElement;
      if (elementChanged) {
        destroyObserver();
        currentElement = element;
      }
      if (!resizeObserver && element) {
        resizeObserver = new index$1(onResize);
        resizeObserver.observe(element);
      }
    };
    onMounted(() => {
      registerObserver();
    });
    onUpdated(() => {
      registerObserver();
    });
    onUnmounted(() => {
      destroyObserver();
    });
    watch(() => props2.disabled, () => {
      registerObserver();
    }, {
      flush: "post"
    });
    return () => {
      var _a2;
      return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)[0];
    };
  }
});
let raf = (callback) => setTimeout(callback, 16);
let caf = (num) => clearTimeout(num);
if (typeof window !== "undefined" && "requestAnimationFrame" in window) {
  raf = (callback) => window.requestAnimationFrame(callback);
  caf = (handle) => window.cancelAnimationFrame(handle);
}
let rafUUID = 0;
const rafIds = /* @__PURE__ */ new Map();
function cleanup(id) {
  rafIds.delete(id);
}
function wrapperRaf(callback) {
  let times = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  rafUUID += 1;
  const id = rafUUID;
  function callRef(leftTimes) {
    if (leftTimes === 0) {
      cleanup(id);
      callback();
    } else {
      const realId = raf(() => {
        callRef(leftTimes - 1);
      });
      rafIds.set(id, realId);
    }
  }
  callRef(times);
  return id;
}
wrapperRaf.cancel = (id) => {
  const realId = rafIds.get(id);
  cleanup(realId);
  return caf(realId);
};
const tuple$1 = function() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return args;
};
const tupleNum = function() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }
  return args;
};
const withInstall = (comp) => {
  const c2 = comp;
  c2.install = function(app) {
    app.component(c2.displayName || c2.name, comp);
  };
  return comp;
};
function eventType() {
  return {
    type: [Function, Array]
  };
}
function objectType(defaultVal) {
  return {
    type: Object,
    default: defaultVal
  };
}
function booleanType(defaultVal) {
  return {
    type: Boolean,
    default: defaultVal
  };
}
function functionType(defaultVal) {
  return {
    type: Function,
    default: defaultVal
  };
}
function anyType(defaultVal, required4) {
  const type4 = {
    validator: () => true,
    default: defaultVal
  };
  return required4 ? type4 : type4;
}
function vNodeType() {
  return {
    validator: () => true
  };
}
function arrayType(defaultVal) {
  return {
    type: Array,
    default: defaultVal
  };
}
function stringType(defaultVal) {
  return {
    type: String,
    default: defaultVal
  };
}
function someType(types2, defaultVal) {
  return types2 ? {
    type: types2,
    default: defaultVal
  } : anyType(defaultVal);
}
let supportsPassive = false;
try {
  const opts = Object.defineProperty({}, "passive", {
    get() {
      supportsPassive = true;
    }
  });
  window.addEventListener("testPassive", null, opts);
  window.removeEventListener("testPassive", null, opts);
} catch (e2) {
}
function addEventListenerWrap(target, eventType2, cb, option) {
  if (target && target.addEventListener) {
    let opt = option;
    if (opt === void 0 && supportsPassive && (eventType2 === "touchstart" || eventType2 === "touchmove" || eventType2 === "wheel")) {
      opt = {
        passive: false
      };
    }
    target.addEventListener(eventType2, cb, opt);
  }
  return {
    remove: () => {
      if (target && target.removeEventListener) {
        target.removeEventListener(eventType2, cb);
      }
    }
  };
}
const defaultIconPrefixCls = "anticon";
const GlobalFormContextKey = Symbol("GlobalFormContextKey");
const useProvideGlobalForm = (state) => {
  provide(GlobalFormContextKey, state);
};
const useInjectGlobalForm = () => {
  return inject(GlobalFormContextKey, {
    validateMessages: computed(() => void 0)
  });
};
const configProviderProps = () => ({
  iconPrefixCls: String,
  getTargetContainer: {
    type: Function
  },
  getPopupContainer: {
    type: Function
  },
  prefixCls: String,
  getPrefixCls: {
    type: Function
  },
  renderEmpty: {
    type: Function
  },
  transformCellText: {
    type: Function
  },
  csp: objectType(),
  input: objectType(),
  autoInsertSpaceInButton: {
    type: Boolean,
    default: void 0
  },
  locale: objectType(),
  pageHeader: objectType(),
  componentSize: {
    type: String
  },
  componentDisabled: {
    type: Boolean,
    default: void 0
  },
  direction: {
    type: String,
    default: "ltr"
  },
  space: objectType(),
  virtual: {
    type: Boolean,
    default: void 0
  },
  dropdownMatchSelectWidth: {
    type: [Number, Boolean],
    default: true
  },
  form: objectType(),
  pagination: objectType(),
  theme: objectType(),
  select: objectType(),
  wave: objectType()
});
const configProviderKey = Symbol("configProvider");
const defaultConfigProvider = {
  getPrefixCls: (suffixCls, customizePrefixCls) => {
    if (customizePrefixCls) return customizePrefixCls;
    return suffixCls ? `ant-${suffixCls}` : "ant";
  },
  iconPrefixCls: computed(() => defaultIconPrefixCls),
  getPopupContainer: computed(() => () => document.body),
  direction: computed(() => "ltr")
};
const useConfigContextInject = () => {
  return inject(configProviderKey, defaultConfigProvider);
};
const useConfigContextProvider = (props2) => {
  return provide(configProviderKey, props2);
};
const DisabledContextKey = Symbol("DisabledContextKey");
const useInjectDisabled = () => {
  return inject(DisabledContextKey, ref(void 0));
};
const useProviderDisabled = (disabled) => {
  const parentDisabled = useInjectDisabled();
  provide(DisabledContextKey, computed(() => {
    var _a2;
    return (_a2 = disabled.value) !== null && _a2 !== void 0 ? _a2 : parentDisabled.value;
  }));
  return disabled;
};
const enUS = {
  // Options.jsx
  items_per_page: "/ page",
  jump_to: "Go to",
  jump_to_confirm: "confirm",
  page: "",
  // Pagination.jsx
  prev_page: "Previous Page",
  next_page: "Next Page",
  prev_5: "Previous 5 Pages",
  next_5: "Next 5 Pages",
  prev_3: "Previous 3 Pages",
  next_3: "Next 3 Pages"
};
const locale$3 = {
  locale: "en_US",
  today: "Today",
  now: "Now",
  backToToday: "Back to today",
  ok: "Ok",
  clear: "Clear",
  month: "Month",
  year: "Year",
  timeSelect: "select time",
  dateSelect: "select date",
  weekSelect: "Choose a week",
  monthSelect: "Choose a month",
  yearSelect: "Choose a year",
  decadeSelect: "Choose a decade",
  yearFormat: "YYYY",
  dateFormat: "M/D/YYYY",
  dayFormat: "D",
  dateTimeFormat: "M/D/YYYY HH:mm:ss",
  monthBeforeYear: true,
  previousMonth: "Previous month (PageUp)",
  nextMonth: "Next month (PageDown)",
  previousYear: "Last year (Control + left)",
  nextYear: "Next year (Control + right)",
  previousDecade: "Last decade",
  nextDecade: "Next decade",
  previousCentury: "Last century",
  nextCentury: "Next century"
};
const locale$2 = {
  placeholder: "Select time",
  rangePlaceholder: ["Start time", "End time"]
};
const locale$1 = {
  lang: _extends$1({
    placeholder: "Select date",
    yearPlaceholder: "Select year",
    quarterPlaceholder: "Select quarter",
    monthPlaceholder: "Select month",
    weekPlaceholder: "Select week",
    rangePlaceholder: ["Start date", "End date"],
    rangeYearPlaceholder: ["Start year", "End year"],
    rangeQuarterPlaceholder: ["Start quarter", "End quarter"],
    rangeMonthPlaceholder: ["Start month", "End month"],
    rangeWeekPlaceholder: ["Start week", "End week"]
  }, locale$3),
  timePickerLocale: _extends$1({}, locale$2)
};
const typeTemplate$1 = "${label} is not a valid ${type}";
const localeValues = {
  locale: "en",
  Pagination: enUS,
  DatePicker: locale$1,
  TimePicker: locale$2,
  Calendar: locale$1,
  global: {
    placeholder: "Please select"
  },
  Table: {
    filterTitle: "Filter menu",
    filterConfirm: "OK",
    filterReset: "Reset",
    filterEmptyText: "No filters",
    filterCheckall: "Select all items",
    filterSearchPlaceholder: "Search in filters",
    emptyText: "No data",
    selectAll: "Select current page",
    selectInvert: "Invert current page",
    selectNone: "Clear all data",
    selectionAll: "Select all data",
    sortTitle: "Sort",
    expand: "Expand row",
    collapse: "Collapse row",
    triggerDesc: "Click to sort descending",
    triggerAsc: "Click to sort ascending",
    cancelSort: "Click to cancel sorting"
  },
  Tour: {
    Next: "Next",
    Previous: "Previous",
    Finish: "Finish"
  },
  Modal: {
    okText: "OK",
    cancelText: "Cancel",
    justOkText: "OK"
  },
  Popconfirm: {
    okText: "OK",
    cancelText: "Cancel"
  },
  Transfer: {
    titles: ["", ""],
    searchPlaceholder: "Search here",
    itemUnit: "item",
    itemsUnit: "items",
    remove: "Remove",
    selectCurrent: "Select current page",
    removeCurrent: "Remove current page",
    selectAll: "Select all data",
    removeAll: "Remove all data",
    selectInvert: "Invert current page"
  },
  Upload: {
    uploading: "Uploading...",
    removeFile: "Remove file",
    uploadError: "Upload error",
    previewFile: "Preview file",
    downloadFile: "Download file"
  },
  Empty: {
    description: "No data"
  },
  Icon: {
    icon: "icon"
  },
  Text: {
    edit: "Edit",
    copy: "Copy",
    copied: "Copied",
    expand: "Expand"
  },
  PageHeader: {
    back: "Back"
  },
  Form: {
    optional: "(optional)",
    defaultValidateMessages: {
      default: "Field validation error for ${label}",
      required: "Please enter ${label}",
      enum: "${label} must be one of [${enum}]",
      whitespace: "${label} cannot be a blank character",
      date: {
        format: "${label} date format is invalid",
        parse: "${label} cannot be converted to a date",
        invalid: "${label} is an invalid date"
      },
      types: {
        string: typeTemplate$1,
        method: typeTemplate$1,
        array: typeTemplate$1,
        object: typeTemplate$1,
        number: typeTemplate$1,
        date: typeTemplate$1,
        boolean: typeTemplate$1,
        integer: typeTemplate$1,
        float: typeTemplate$1,
        regexp: typeTemplate$1,
        email: typeTemplate$1,
        url: typeTemplate$1,
        hex: typeTemplate$1
      },
      string: {
        len: "${label} must be ${len} characters",
        min: "${label} must be at least ${min} characters",
        max: "${label} must be up to ${max} characters",
        range: "${label} must be between ${min}-${max} characters"
      },
      number: {
        len: "${label} must be equal to ${len}",
        min: "${label} must be minimum ${min}",
        max: "${label} must be maximum ${max}",
        range: "${label} must be between ${min}-${max}"
      },
      array: {
        len: "Must be ${len} ${label}",
        min: "At least ${min} ${label}",
        max: "At most ${max} ${label}",
        range: "The amount of ${label} must be between ${min}-${max}"
      },
      pattern: {
        mismatch: "${label} does not match the pattern ${pattern}"
      }
    }
  },
  Image: {
    preview: "Preview"
  },
  QRCode: {
    expired: "QR code expired",
    refresh: "Refresh",
    scanned: "Scanned"
  }
};
const LocaleReceiver = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "LocaleReceiver",
  props: {
    componentName: String,
    defaultLocale: {
      type: [Object, Function]
    },
    children: {
      type: Function
    }
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const localeData2 = inject("localeData", {});
    const locale2 = computed(() => {
      const {
        componentName = "global",
        defaultLocale
      } = props2;
      const locale3 = defaultLocale || localeValues[componentName || "global"];
      const {
        antLocale
      } = localeData2;
      const localeFromContext = componentName && antLocale ? antLocale[componentName] : {};
      return _extends$1(_extends$1({}, typeof locale3 === "function" ? locale3() : locale3), localeFromContext || {});
    });
    const localeCode = computed(() => {
      const {
        antLocale
      } = localeData2;
      const localeCode2 = antLocale && antLocale.locale;
      if (antLocale && antLocale.exist && !localeCode2) {
        return localeValues.locale;
      }
      return localeCode2;
    });
    return () => {
      const children = props2.children || slots.default;
      const {
        antLocale
      } = localeData2;
      return children === null || children === void 0 ? void 0 : children(locale2.value, localeCode.value, antLocale);
    };
  }
});
function useLocaleReceiver(componentName, defaultLocale, propsLocale) {
  const localeData2 = inject("localeData", {});
  const componentLocale = computed(() => {
    const {
      antLocale
    } = localeData2;
    const locale2 = unref(defaultLocale) || localeValues[componentName || "global"];
    const localeFromContext = componentName && antLocale ? antLocale[componentName] : {};
    return _extends$1(_extends$1(_extends$1({}, typeof locale2 === "function" ? locale2() : locale2), localeFromContext || {}), unref(propsLocale) || {});
  });
  return [componentLocale];
}
function murmur2(str) {
  var h2 = 0;
  var k2, i2 = 0, len = str.length;
  for (; len >= 4; ++i2, len -= 4) {
    k2 = str.charCodeAt(i2) & 255 | (str.charCodeAt(++i2) & 255) << 8 | (str.charCodeAt(++i2) & 255) << 16 | (str.charCodeAt(++i2) & 255) << 24;
    k2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
    k2 ^= /* k >>> r: */
    k2 >>> 24;
    h2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h2 ^= (str.charCodeAt(i2 + 2) & 255) << 16;
    case 2:
      h2 ^= (str.charCodeAt(i2 + 1) & 255) << 8;
    case 1:
      h2 ^= str.charCodeAt(i2) & 255;
      h2 = /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  h2 ^= h2 >>> 13;
  h2 = /* Math.imul(h, m): */
  (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
}
const SPLIT = "%";
class Entity {
  constructor(instanceId) {
    this.cache = /* @__PURE__ */ new Map();
    this.instanceId = instanceId;
  }
  get(keys2) {
    return this.cache.get(Array.isArray(keys2) ? keys2.join(SPLIT) : keys2) || null;
  }
  update(keys2, valueFn) {
    const path2 = Array.isArray(keys2) ? keys2.join(SPLIT) : keys2;
    const prevValue = this.cache.get(path2);
    const nextValue = valueFn(prevValue);
    if (nextValue === null) {
      this.cache.delete(path2);
    } else {
      this.cache.set(path2, nextValue);
    }
  }
}
const ATTR_TOKEN = "data-token-hash";
const ATTR_MARK = "data-css-hash";
const CSS_IN_JS_INSTANCE = "__cssinjs_instance__";
function createCache() {
  const cssinjsInstanceId = Math.random().toString(12).slice(2);
  if (typeof document !== "undefined" && document.head && document.body) {
    const styles = document.body.querySelectorAll(`style[${ATTR_MARK}]`) || [];
    const {
      firstChild
    } = document.head;
    Array.from(styles).forEach((style) => {
      style[CSS_IN_JS_INSTANCE] = style[CSS_IN_JS_INSTANCE] || cssinjsInstanceId;
      if (style[CSS_IN_JS_INSTANCE] === cssinjsInstanceId) {
        document.head.insertBefore(style, firstChild);
      }
    });
    const styleHash = {};
    Array.from(document.querySelectorAll(`style[${ATTR_MARK}]`)).forEach((style) => {
      var _a2;
      const hash = style.getAttribute(ATTR_MARK);
      if (styleHash[hash]) {
        if (style[CSS_IN_JS_INSTANCE] === cssinjsInstanceId) {
          (_a2 = style.parentNode) === null || _a2 === void 0 ? void 0 : _a2.removeChild(style);
        }
      } else {
        styleHash[hash] = true;
      }
    });
  }
  return new Entity(cssinjsInstanceId);
}
const StyleContextKey = Symbol("StyleContextKey");
const getCache = () => {
  var _a2, _b, _c;
  const instance = getCurrentInstance();
  let cache;
  if (instance && instance.appContext) {
    const globalCache = (_c = (_b = (_a2 = instance.appContext) === null || _a2 === void 0 ? void 0 : _a2.config) === null || _b === void 0 ? void 0 : _b.globalProperties) === null || _c === void 0 ? void 0 : _c.__ANTDV_CSSINJS_CACHE__;
    if (globalCache) {
      cache = globalCache;
    } else {
      cache = createCache();
      if (instance.appContext.config.globalProperties) {
        instance.appContext.config.globalProperties.__ANTDV_CSSINJS_CACHE__ = cache;
      }
    }
  } else {
    cache = createCache();
  }
  return cache;
};
const defaultStyleContext = {
  cache: createCache(),
  defaultCache: true,
  hashPriority: "low"
};
const useStyleInject = () => {
  const cache = getCache();
  return inject(StyleContextKey, shallowRef(_extends$1(_extends$1({}, defaultStyleContext), {
    cache
  })));
};
const useStyleProvider = (props2) => {
  const parentContext = useStyleInject();
  const context2 = shallowRef(_extends$1(_extends$1({}, defaultStyleContext), {
    cache: createCache()
  }));
  watch([() => unref(props2), parentContext], () => {
    const mergedContext = _extends$1({}, parentContext.value);
    const propsValue = unref(props2);
    Object.keys(propsValue).forEach((key2) => {
      const value = propsValue[key2];
      if (propsValue[key2] !== void 0) {
        mergedContext[key2] = value;
      }
    });
    const {
      cache
    } = propsValue;
    mergedContext.cache = mergedContext.cache || createCache();
    mergedContext.defaultCache = !cache && parentContext.value.defaultCache;
    context2.value = mergedContext;
  }, {
    immediate: true
  });
  provide(StyleContextKey, context2);
  return context2;
};
const styleProviderProps = () => ({
  autoClear: booleanType(),
  /** @private Test only. Not work in production. */
  mock: stringType(),
  /**
   * Only set when you need ssr to extract style on you own.
   * If not provided, it will auto create <style /> on the end of Provider in server side.
   */
  cache: objectType(),
  /** Tell children that this context is default generated context */
  defaultCache: booleanType(),
  /** Use `:where` selector to reduce hashId css selector priority */
  hashPriority: stringType(),
  /** Tell cssinjs where to inject style in */
  container: someType(),
  /** Component wil render inline  `<style />` for fallback in SSR. Not recommend. */
  ssrInline: booleanType(),
  /** Transform css before inject in document. Please note that `transformers` do not support dynamic update */
  transformers: arrayType(),
  /**
   * Linters to lint css before inject in document.
   * Styles will be linted after transforming.
   * Please note that `linters` do not support dynamic update.
   */
  linters: arrayType()
});
withInstall(defineComponent({
  name: "AStyleProvider",
  inheritAttrs: false,
  props: styleProviderProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    useStyleProvider(props2);
    return () => {
      var _a2;
      return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
    };
  }
}));
function useClientCache(prefix, keyPath, cacheFn, onCacheRemove) {
  const styleContext = useStyleInject();
  const fullPathStr = shallowRef("");
  const res = shallowRef();
  watchEffect(() => {
    fullPathStr.value = [prefix, ...keyPath.value].join("%");
  });
  const clearCache = (pathStr) => {
    styleContext.value.cache.update(pathStr, (prevCache) => {
      const [times = 0, cache] = prevCache || [];
      const nextCount = times - 1;
      if (nextCount === 0) {
        onCacheRemove === null || onCacheRemove === void 0 ? void 0 : onCacheRemove(cache, false);
        return null;
      }
      return [times - 1, cache];
    });
  };
  watch(fullPathStr, (newStr, oldStr) => {
    if (oldStr) clearCache(oldStr);
    styleContext.value.cache.update(newStr, (prevCache) => {
      const [times = 0, cache] = prevCache || [];
      let tmpCache = cache;
      const mergedCache = tmpCache || cacheFn();
      return [times + 1, mergedCache];
    });
    res.value = styleContext.value.cache.get(fullPathStr.value)[1];
  }, {
    immediate: true
  });
  onBeforeUnmount(() => {
    clearCache(fullPathStr.value);
  });
  return res;
}
function canUseDom() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
function contains(root2, n2) {
  if (!root2) {
    return false;
  }
  if (root2.contains) {
    return root2.contains(n2);
  }
  return false;
}
const APPEND_ORDER = "data-vc-order";
const MARK_KEY = `vc-util-key`;
const containerCache = /* @__PURE__ */ new Map();
function getMark() {
  let {
    mark
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  if (mark) {
    return mark.startsWith("data-") ? mark : `data-${mark}`;
  }
  return MARK_KEY;
}
function getContainer$1(option) {
  if (option.attachTo) {
    return option.attachTo;
  }
  const head = document.querySelector("head");
  return head || document.body;
}
function getOrder(prepend) {
  if (prepend === "queue") {
    return "prependQueue";
  }
  return prepend ? "prepend" : "append";
}
function findStyles(container) {
  return Array.from((containerCache.get(container) || container).children).filter((node2) => node2.tagName === "STYLE");
}
function injectCSS(css2) {
  let option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!canUseDom()) {
    return null;
  }
  const {
    csp,
    prepend
  } = option;
  const styleNode = document.createElement("style");
  styleNode.setAttribute(APPEND_ORDER, getOrder(prepend));
  if (csp === null || csp === void 0 ? void 0 : csp.nonce) {
    styleNode.nonce = csp === null || csp === void 0 ? void 0 : csp.nonce;
  }
  styleNode.innerHTML = css2;
  const container = getContainer$1(option);
  const {
    firstChild
  } = container;
  if (prepend) {
    if (prepend === "queue") {
      const existStyle = findStyles(container).filter((node2) => ["prepend", "prependQueue"].includes(node2.getAttribute(APPEND_ORDER)));
      if (existStyle.length) {
        container.insertBefore(styleNode, existStyle[existStyle.length - 1].nextSibling);
        return styleNode;
      }
    }
    container.insertBefore(styleNode, firstChild);
  } else {
    container.appendChild(styleNode);
  }
  return styleNode;
}
function findExistNode(key2) {
  let option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const container = getContainer$1(option);
  return findStyles(container).find((node2) => node2.getAttribute(getMark(option)) === key2);
}
function removeCSS(key2) {
  let option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const existNode = findExistNode(key2, option);
  if (existNode) {
    const container = getContainer$1(option);
    container.removeChild(existNode);
  }
}
function syncRealContainer(container, option) {
  const cachedRealContainer = containerCache.get(container);
  if (!cachedRealContainer || !contains(document, cachedRealContainer)) {
    const placeholderStyle = injectCSS("", option);
    const {
      parentNode
    } = placeholderStyle;
    containerCache.set(container, parentNode);
    container.removeChild(placeholderStyle);
  }
}
function updateCSS(css2, key2) {
  let option = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var _a2, _b, _c;
  const container = getContainer$1(option);
  syncRealContainer(container, option);
  const existNode = findExistNode(key2, option);
  if (existNode) {
    if (((_a2 = option.csp) === null || _a2 === void 0 ? void 0 : _a2.nonce) && existNode.nonce !== ((_b = option.csp) === null || _b === void 0 ? void 0 : _b.nonce)) {
      existNode.nonce = (_c = option.csp) === null || _c === void 0 ? void 0 : _c.nonce;
    }
    if (existNode.innerHTML !== css2) {
      existNode.innerHTML = css2;
    }
    return existNode;
  }
  const newNode = injectCSS(css2, option);
  newNode.setAttribute(getMark(option), key2);
  return newNode;
}
function sameDerivativeOption(left, right) {
  if (left.length !== right.length) {
    return false;
  }
  for (let i2 = 0; i2 < left.length; i2++) {
    if (left[i2] !== right[i2]) {
      return false;
    }
  }
  return true;
}
class ThemeCache {
  constructor() {
    this.cache = /* @__PURE__ */ new Map();
    this.keys = [];
    this.cacheCallTimes = 0;
  }
  size() {
    return this.keys.length;
  }
  internalGet(derivativeOption) {
    let updateCallTimes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    let cache = {
      map: this.cache
    };
    derivativeOption.forEach((derivative2) => {
      var _a2;
      if (!cache) {
        cache = void 0;
      } else {
        cache = (_a2 = cache === null || cache === void 0 ? void 0 : cache.map) === null || _a2 === void 0 ? void 0 : _a2.get(derivative2);
      }
    });
    if ((cache === null || cache === void 0 ? void 0 : cache.value) && updateCallTimes) {
      cache.value[1] = this.cacheCallTimes++;
    }
    return cache === null || cache === void 0 ? void 0 : cache.value;
  }
  get(derivativeOption) {
    var _a2;
    return (_a2 = this.internalGet(derivativeOption, true)) === null || _a2 === void 0 ? void 0 : _a2[0];
  }
  has(derivativeOption) {
    return !!this.internalGet(derivativeOption);
  }
  set(derivativeOption, value) {
    if (!this.has(derivativeOption)) {
      if (this.size() + 1 > ThemeCache.MAX_CACHE_SIZE + ThemeCache.MAX_CACHE_OFFSET) {
        const [targetKey] = this.keys.reduce((result, key2) => {
          const [, callTimes] = result;
          if (this.internalGet(key2)[1] < callTimes) {
            return [key2, this.internalGet(key2)[1]];
          }
          return result;
        }, [this.keys[0], this.cacheCallTimes]);
        this.delete(targetKey);
      }
      this.keys.push(derivativeOption);
    }
    let cache = this.cache;
    derivativeOption.forEach((derivative2, index2) => {
      if (index2 === derivativeOption.length - 1) {
        cache.set(derivative2, {
          value: [value, this.cacheCallTimes++]
        });
      } else {
        const cacheValue = cache.get(derivative2);
        if (!cacheValue) {
          cache.set(derivative2, {
            map: /* @__PURE__ */ new Map()
          });
        } else if (!cacheValue.map) {
          cacheValue.map = /* @__PURE__ */ new Map();
        }
        cache = cache.get(derivative2).map;
      }
    });
  }
  deleteByPath(currentCache, derivatives) {
    var _a2;
    const cache = currentCache.get(derivatives[0]);
    if (derivatives.length === 1) {
      if (!cache.map) {
        currentCache.delete(derivatives[0]);
      } else {
        currentCache.set(derivatives[0], {
          map: cache.map
        });
      }
      return (_a2 = cache.value) === null || _a2 === void 0 ? void 0 : _a2[0];
    }
    const result = this.deleteByPath(cache.map, derivatives.slice(1));
    if ((!cache.map || cache.map.size === 0) && !cache.value) {
      currentCache.delete(derivatives[0]);
    }
    return result;
  }
  delete(derivativeOption) {
    if (this.has(derivativeOption)) {
      this.keys = this.keys.filter((item) => !sameDerivativeOption(item, derivativeOption));
      return this.deleteByPath(this.cache, derivativeOption);
    }
    return void 0;
  }
}
ThemeCache.MAX_CACHE_SIZE = 20;
ThemeCache.MAX_CACHE_OFFSET = 5;
let warned = {};
function warning$2(valid, message) {
}
function note(valid, message) {
}
function call(method4, valid, message) {
  if (!valid && !warned[message]) {
    method4(false, message);
    warned[message] = true;
  }
}
function warningOnce(valid, message) {
  call(warning$2, valid, message);
}
function noteOnce(valid, message) {
  call(note, valid, message);
}
function noop$6() {
}
let warning$1 = noop$6;
let uuid$6 = 0;
class Theme {
  constructor(derivatives) {
    this.derivatives = Array.isArray(derivatives) ? derivatives : [derivatives];
    this.id = uuid$6;
    if (derivatives.length === 0) {
      warning$1(derivatives.length > 0);
    }
    uuid$6 += 1;
  }
  getDerivativeToken(token2) {
    return this.derivatives.reduce((result, derivative2) => derivative2(token2, result), void 0);
  }
}
const cacheThemes = new ThemeCache();
function createTheme(derivatives) {
  const derivativeArr = Array.isArray(derivatives) ? derivatives : [derivatives];
  if (!cacheThemes.has(derivativeArr)) {
    cacheThemes.set(derivativeArr, new Theme(derivativeArr));
  }
  return cacheThemes.get(derivativeArr);
}
const flattenTokenCache = /* @__PURE__ */ new WeakMap();
function flattenToken(token2) {
  let str = flattenTokenCache.get(token2) || "";
  if (!str) {
    Object.keys(token2).forEach((key2) => {
      const value = token2[key2];
      str += key2;
      if (value instanceof Theme) {
        str += value.id;
      } else if (value && typeof value === "object") {
        str += flattenToken(value);
      } else {
        str += value;
      }
    });
    flattenTokenCache.set(token2, str);
  }
  return str;
}
function token2key(token2, salt) {
  return murmur2(`${salt}_${flattenToken(token2)}`);
}
const randomSelectorKey = `random-${Date.now()}-${Math.random()}`.replace(/\./g, "");
const checkContent = "_bAmBoO_";
function supportSelector(styleStr, handleElement, supportCheck) {
  var _a2, _b;
  if (canUseDom()) {
    updateCSS(styleStr, randomSelectorKey);
    const ele = document.createElement("div");
    ele.style.position = "fixed";
    ele.style.left = "0";
    ele.style.top = "0";
    handleElement === null || handleElement === void 0 ? void 0 : handleElement(ele);
    document.body.appendChild(ele);
    const support = supportCheck ? supportCheck(ele) : (_a2 = getComputedStyle(ele).content) === null || _a2 === void 0 ? void 0 : _a2.includes(checkContent);
    (_b = ele.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(ele);
    removeCSS(randomSelectorKey);
    return support;
  }
  return false;
}
let canLayer = void 0;
function supportLayer() {
  if (canLayer === void 0) {
    canLayer = supportSelector(`@layer ${randomSelectorKey} { .${randomSelectorKey} { content: "${checkContent}"!important; } }`, (ele) => {
      ele.className = randomSelectorKey;
    });
  }
  return canLayer;
}
const EMPTY_OVERRIDE = {};
const hashPrefix = "css";
const tokenKeys = /* @__PURE__ */ new Map();
function recordCleanToken(tokenKey) {
  tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) + 1);
}
function removeStyleTags(key2, instanceId) {
  if (typeof document !== "undefined") {
    const styles = document.querySelectorAll(`style[${ATTR_TOKEN}="${key2}"]`);
    styles.forEach((style) => {
      var _a2;
      if (style[CSS_IN_JS_INSTANCE] === instanceId) {
        (_a2 = style.parentNode) === null || _a2 === void 0 ? void 0 : _a2.removeChild(style);
      }
    });
  }
}
const TOKEN_THRESHOLD = 0;
function cleanTokenStyle(tokenKey, instanceId) {
  tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) - 1);
  const tokenKeyList = Array.from(tokenKeys.keys());
  const cleanableKeyList = tokenKeyList.filter((key2) => {
    const count = tokenKeys.get(key2) || 0;
    return count <= 0;
  });
  if (tokenKeyList.length - cleanableKeyList.length > TOKEN_THRESHOLD) {
    cleanableKeyList.forEach((key2) => {
      removeStyleTags(key2, instanceId);
      tokenKeys.delete(key2);
    });
  }
}
const getComputedToken = (originToken, overrideToken, theme2, format2) => {
  const derivativeToken = theme2.getDerivativeToken(originToken);
  let mergedDerivativeToken = _extends$1(_extends$1({}, derivativeToken), overrideToken);
  if (format2) {
    mergedDerivativeToken = format2(mergedDerivativeToken);
  }
  return mergedDerivativeToken;
};
function useCacheToken(theme2, tokens) {
  let option = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ref({});
  const style = useStyleInject();
  const mergedToken = computed(() => _extends$1({}, ...tokens.value));
  const tokenStr = computed(() => flattenToken(mergedToken.value));
  const overrideTokenStr = computed(() => flattenToken(option.value.override || EMPTY_OVERRIDE));
  const cachedToken = useClientCache("token", computed(() => [option.value.salt || "", theme2.value.id, tokenStr.value, overrideTokenStr.value]), () => {
    const {
      salt = "",
      override = EMPTY_OVERRIDE,
      formatToken: formatToken2,
      getComputedToken: compute
    } = option.value;
    const mergedDerivativeToken = compute ? compute(mergedToken.value, override, theme2.value) : getComputedToken(mergedToken.value, override, theme2.value, formatToken2);
    const tokenKey = token2key(mergedDerivativeToken, salt);
    mergedDerivativeToken._tokenKey = tokenKey;
    recordCleanToken(tokenKey);
    const hashId = `${hashPrefix}-${murmur2(tokenKey)}`;
    mergedDerivativeToken._hashId = hashId;
    return [mergedDerivativeToken, hashId];
  }, (cache) => {
    var _a2;
    cleanTokenStyle(cache[0]._tokenKey, (_a2 = style.value) === null || _a2 === void 0 ? void 0 : _a2.cache.instanceId);
  });
  return cachedToken;
}
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";
var abs = Math.abs;
var from = String.fromCharCode;
function trim(value) {
  return value.trim();
}
function replace(value, pattern4, replacement) {
  return value.replace(pattern4, replacement);
}
function indexof(value, search, position2) {
  return value.indexOf(search, position2);
}
function charat(value, index2) {
  return value.charCodeAt(index2) | 0;
}
function substr(value, begin, end) {
  return value.slice(begin, end);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array4) {
  return array4.push(value), value;
}
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node(value, root2, parent2, type4, props2, children, length2, siblings) {
  return { value, root: root2, parent: parent2, type: type4, props: props2, children, line, column, length: length2, return: "", siblings };
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(begin, end) {
  return substr(characters, begin, end);
}
function token(type4) {
  switch (type4) {
    // \0 \t \n \r \s whitespace token
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    // ! + , / > @ ~ isolate token
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    // ; { } breakpoint token
    case 59:
    case 123:
    case 125:
      return 4;
    // : accompanied token
    case 58:
      return 3;
    // " ' ( [ opening delimit token
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    // ) ] closing delimit token
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type4) {
  return trim(slice(position - 1, delimiter(type4 === 91 ? type4 + 2 : type4 === 40 ? type4 + 1 : type4)));
}
function whitespace$1(type4) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type4) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index2, count) {
  while (--count && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index2, caret() + (count < 6 && peek() == 32 && next() == 32));
}
function delimiter(type4) {
  while (next())
    switch (character) {
      // ] ) " '
      case type4:
        return position;
      // " '
      case 34:
      case 39:
        if (type4 !== 34 && type4 !== 39)
          delimiter(character);
        break;
      // (
      case 40:
        if (type4 === 41)
          delimiter(type4);
        break;
      // \
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type4, index2) {
  while (next())
    if (type4 + character === 47 + 10)
      break;
    else if (type4 + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index2, position - 1) + "*" + from(type4 === 47 ? type4 : next());
}
function identifier(index2) {
  while (!token(peek()))
    next();
  return slice(index2, position);
}
function compile(value) {
  return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse(value, root2, parent2, rule, rules2, rulesets, pseudo, points, declarations) {
  var index2 = 0;
  var offset3 = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property2 = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type4 = "";
  var props2 = rules2;
  var children = rulesets;
  var reference = rule;
  var characters2 = type4;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      // (
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f", abs(index2 ? points[index2 - 1] : 0)) != -1)
            ampersand = -1;
          break;
        }
      // " ' [
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      // \t \n \r \s
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace$1(previous);
        break;
      // \
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      // /
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root2, parent2, declarations), declarations);
            if ((token(previous || 1) == 5 || token(peek() || 1) == 5) && strlen(characters2) && substr(characters2, -1, void 0) !== " ") characters2 += " ";
            break;
          default:
            characters2 += "/";
        }
        break;
      // {
      case 123 * variable:
        points[index2++] = strlen(characters2) * ampersand;
      // } ; \0
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          // \0 }
          case 0:
          case 125:
            scanning = 0;
          // ;
          case 59 + offset3:
            if (ampersand == -1) characters2 = replace(characters2, /\f/g, "");
            if (property2 > 0 && (strlen(characters2) - length2 || variable === 0 && previous === 47))
              append(property2 > 32 ? declaration(characters2 + ";", rule, parent2, length2 - 1, declarations) : declaration(replace(characters2, " ", "") + ";", rule, parent2, length2 - 2, declarations), declarations);
            break;
          // @ ;
          case 59:
            characters2 += ";";
          // { rule/at-rule
          default:
            append(reference = ruleset(characters2, root2, parent2, index2, offset3, rules2, points, type4, props2 = [], children = [], length2, rulesets), rulesets);
            if (character2 === 123)
              if (offset3 === 0)
                parse(characters2, root2, reference, reference, props2, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  // d l m s
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules2, points, type4, rules2, props2 = [], length2, children), children), rules2, children, length2, points, rule ? props2 : children);
                    break;
                  default:
                    parse(characters2, reference, reference, reference, [""], children, 0, points, children);
                }
        }
        index2 = offset3 = property2 = 0, variable = ampersand = 1, type4 = characters2 = "", length2 = pseudo;
        break;
      // :
      case 58:
        length2 = 1 + strlen(characters2), property2 = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          // &
          case 38:
            ampersand = offset3 > 0 ? 1 : (characters2 += "\f", -1);
            break;
          // ,
          case 44:
            points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          // @
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset3 = length2 = strlen(type4 = characters2 += identifier(caret())), character2++;
            break;
          // -
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root2, parent2, index2, offset3, rules2, points, type4, props2, children, length2, siblings) {
  var post = offset3 - 1;
  var rule = offset3 === 0 ? rules2 : [""];
  var size = sizeof(rule);
  for (var i2 = 0, j2 = 0, k2 = 0; i2 < index2; ++i2)
    for (var x2 = 0, y2 = substr(value, post + 1, post = abs(j2 = points[i2])), z2 = value; x2 < size; ++x2)
      if (z2 = trim(j2 > 0 ? rule[x2] + " " + y2 : replace(y2, /&\f/g, rule[x2])))
        props2[k2++] = z2;
  return node(value, root2, parent2, offset3 === 0 ? RULESET : type4, props2, children, length2, siblings);
}
function comment(value, root2, parent2, siblings) {
  return node(value, root2, parent2, COMMENT, from(char()), substr(value, 2, -2), 0, siblings);
}
function declaration(value, root2, parent2, length2, siblings) {
  return node(value, root2, parent2, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2, siblings);
}
function serialize(children, callback) {
  var output = "";
  for (var i2 = 0; i2 < children.length; i2++)
    output += callback(children[i2], i2, children, callback) || "";
  return output;
}
function stringify(element, index2, children, callback) {
  switch (element.type) {
    case LAYER:
      if (element.children.length) break;
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback) + "}";
    case RULESET:
      if (!strlen(element.value = element.props.join(","))) return "";
  }
  return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}
const ATTR_CACHE_MAP = "data-ant-cssinjs-cache-path";
const CSS_FILE_STYLE = "_FILE_STYLE__";
let cachePathMap;
let fromCSSFile = true;
function prepare() {
  var _a2;
  if (!cachePathMap) {
    cachePathMap = {};
    if (canUseDom()) {
      const div = document.createElement("div");
      div.className = ATTR_CACHE_MAP;
      div.style.position = "fixed";
      div.style.visibility = "hidden";
      div.style.top = "-9999px";
      document.body.appendChild(div);
      let content = getComputedStyle(div).content || "";
      content = content.replace(/^"/, "").replace(/"$/, "");
      content.split(";").forEach((item) => {
        const [path2, hash] = item.split(":");
        cachePathMap[path2] = hash;
      });
      const inlineMapStyle = document.querySelector(`style[${ATTR_CACHE_MAP}]`);
      if (inlineMapStyle) {
        fromCSSFile = false;
        (_a2 = inlineMapStyle.parentNode) === null || _a2 === void 0 ? void 0 : _a2.removeChild(inlineMapStyle);
      }
      document.body.removeChild(div);
    }
  }
}
function existPath(path2) {
  prepare();
  return !!cachePathMap[path2];
}
function getStyleAndHash(path2) {
  const hash = cachePathMap[path2];
  let styleStr = null;
  if (hash && canUseDom()) {
    if (fromCSSFile) {
      styleStr = CSS_FILE_STYLE;
    } else {
      const style = document.querySelector(`style[${ATTR_MARK}="${cachePathMap[path2]}"]`);
      if (style) {
        styleStr = style.innerHTML;
      } else {
        delete cachePathMap[path2];
      }
    }
  }
  return [styleStr, hash];
}
const isClientSide = canUseDom();
const SKIP_CHECK = "_skip_check_";
const MULTI_VALUE = "_multi_value_";
function normalizeStyle(styleStr) {
  const serialized = serialize(compile(styleStr), stringify);
  return serialized.replace(/\{%%%\:[^;];}/g, ";");
}
function isCompoundCSSProperty(value) {
  return typeof value === "object" && value && (SKIP_CHECK in value || MULTI_VALUE in value);
}
function injectSelectorHash(key2, hashId, hashPriority) {
  if (!hashId) {
    return key2;
  }
  const hashClassName = `.${hashId}`;
  const hashSelector = hashPriority === "low" ? `:where(${hashClassName})` : hashClassName;
  const keys2 = key2.split(",").map((k2) => {
    var _a2;
    const fullPath = k2.trim().split(/\s+/);
    let firstPath = fullPath[0] || "";
    const htmlElement = ((_a2 = firstPath.match(/^\w+/)) === null || _a2 === void 0 ? void 0 : _a2[0]) || "";
    firstPath = `${htmlElement}${hashSelector}${firstPath.slice(htmlElement.length)}`;
    return [firstPath, ...fullPath.slice(1)].join(" ");
  });
  return keys2.join(",");
}
const globalEffectStyleKeys = /* @__PURE__ */ new Set();
const parseStyle = function(interpolation) {
  let config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  let {
    root: root2,
    injectHash,
    parentSelectors
  } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
    root: true,
    parentSelectors: []
  };
  const {
    hashId,
    layer,
    path: path2,
    hashPriority,
    transformers = [],
    linters = []
  } = config;
  let styleStr = "";
  let effectStyle = {};
  function parseKeyframes(keyframes) {
    const animationName = keyframes.getName(hashId);
    if (!effectStyle[animationName]) {
      const [parsedStr] = parseStyle(keyframes.style, config, {
        root: false,
        parentSelectors
      });
      effectStyle[animationName] = `@keyframes ${keyframes.getName(hashId)}${parsedStr}`;
    }
  }
  function flattenList(list) {
    let fullList = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    list.forEach((item) => {
      if (Array.isArray(item)) {
        flattenList(item, fullList);
      } else if (item) {
        fullList.push(item);
      }
    });
    return fullList;
  }
  const flattenStyleList = flattenList(Array.isArray(interpolation) ? interpolation : [interpolation]);
  flattenStyleList.forEach((originStyle) => {
    const style = typeof originStyle === "string" && !root2 ? {} : originStyle;
    if (typeof style === "string") {
      styleStr += `${style}
`;
    } else if (style._keyframe) {
      parseKeyframes(style);
    } else {
      const mergedStyle = transformers.reduce((prev2, trans) => {
        var _a2;
        return ((_a2 = trans === null || trans === void 0 ? void 0 : trans.visit) === null || _a2 === void 0 ? void 0 : _a2.call(trans, prev2)) || prev2;
      }, style);
      Object.keys(mergedStyle).forEach((key2) => {
        var _a2;
        const value = mergedStyle[key2];
        if (typeof value === "object" && value && (key2 !== "animationName" || !value._keyframe) && !isCompoundCSSProperty(value)) {
          let subInjectHash = false;
          let mergedKey = key2.trim();
          let nextRoot = false;
          if ((root2 || injectHash) && hashId) {
            if (mergedKey.startsWith("@")) {
              subInjectHash = true;
            } else {
              mergedKey = injectSelectorHash(key2, hashId, hashPriority);
            }
          } else if (root2 && !hashId && (mergedKey === "&" || mergedKey === "")) {
            mergedKey = "";
            nextRoot = true;
          }
          const [parsedStr, childEffectStyle] = parseStyle(value, config, {
            root: nextRoot,
            injectHash: subInjectHash,
            parentSelectors: [...parentSelectors, mergedKey]
          });
          effectStyle = _extends$1(_extends$1({}, effectStyle), childEffectStyle);
          styleStr += `${mergedKey}${parsedStr}`;
        } else {
          let appendStyle = function(cssKey, cssValue) {
            const styleName = cssKey.replace(/[A-Z]/g, (match2) => `-${match2.toLowerCase()}`);
            let formatValue2 = cssValue;
            if (!unitlessKeys[cssKey] && typeof formatValue2 === "number" && formatValue2 !== 0) {
              formatValue2 = `${formatValue2}px`;
            }
            if (cssKey === "animationName" && (cssValue === null || cssValue === void 0 ? void 0 : cssValue._keyframe)) {
              parseKeyframes(cssValue);
              formatValue2 = cssValue.getName(hashId);
            }
            styleStr += `${styleName}:${formatValue2};`;
          };
          const actualValue = (_a2 = value === null || value === void 0 ? void 0 : value.value) !== null && _a2 !== void 0 ? _a2 : value;
          if (typeof value === "object" && (value === null || value === void 0 ? void 0 : value[MULTI_VALUE]) && Array.isArray(actualValue)) {
            actualValue.forEach((item) => {
              appendStyle(key2, item);
            });
          } else {
            appendStyle(key2, actualValue);
          }
        }
      });
    }
  });
  if (!root2) {
    styleStr = `{${styleStr}}`;
  } else if (layer && supportLayer()) {
    const layerCells = layer.split(",");
    const layerName = layerCells[layerCells.length - 1].trim();
    styleStr = `@layer ${layerName} {${styleStr}}`;
    if (layerCells.length > 1) {
      styleStr = `@layer ${layer}{%%%:%}${styleStr}`;
    }
  }
  return [styleStr, effectStyle];
};
function uniqueHash(path2, styleStr) {
  return murmur2(`${path2.join("%")}${styleStr}`);
}
function useStyleRegister(info, styleFn) {
  const styleContext = useStyleInject();
  const tokenKey = computed(() => info.value.token._tokenKey);
  const fullPath = computed(() => [tokenKey.value, ...info.value.path]);
  let isMergedClientSide = isClientSide;
  useClientCache(
    "style",
    fullPath,
    // Create cache if needed
    () => {
      const {
        path: path2,
        hashId,
        layer,
        nonce,
        clientOnly,
        order = 0
      } = info.value;
      const cachePath = fullPath.value.join("|");
      if (existPath(cachePath)) {
        const [inlineCacheStyleStr, styleHash] = getStyleAndHash(cachePath);
        if (inlineCacheStyleStr) {
          return [inlineCacheStyleStr, tokenKey.value, styleHash, {}, clientOnly, order];
        }
      }
      const styleObj = styleFn();
      const {
        hashPriority,
        container,
        transformers,
        linters,
        cache
      } = styleContext.value;
      const [parsedStyle, effectStyle] = parseStyle(styleObj, {
        hashId,
        hashPriority,
        layer,
        path: path2.join("-"),
        transformers,
        linters
      });
      const styleStr = normalizeStyle(parsedStyle);
      const styleId = uniqueHash(fullPath.value, styleStr);
      if (isMergedClientSide) {
        const mergedCSSConfig = {
          mark: ATTR_MARK,
          prepend: "queue",
          attachTo: container,
          priority: order
        };
        const nonceStr = typeof nonce === "function" ? nonce() : nonce;
        if (nonceStr) {
          mergedCSSConfig.csp = {
            nonce: nonceStr
          };
        }
        const style = updateCSS(styleStr, styleId, mergedCSSConfig);
        style[CSS_IN_JS_INSTANCE] = cache.instanceId;
        style.setAttribute(ATTR_TOKEN, tokenKey.value);
        Object.keys(effectStyle).forEach((effectKey) => {
          if (!globalEffectStyleKeys.has(effectKey)) {
            globalEffectStyleKeys.add(effectKey);
            updateCSS(normalizeStyle(effectStyle[effectKey]), `_effect-${effectKey}`, {
              mark: ATTR_MARK,
              prepend: "queue",
              attachTo: container
            });
          }
        });
      }
      return [styleStr, tokenKey.value, styleId, effectStyle, clientOnly, order];
    },
    // Remove cache if no need
    (_ref, fromHMR) => {
      let [, , styleId] = _ref;
      if ((fromHMR || styleContext.value.autoClear) && isClientSide) {
        removeCSS(styleId, {
          mark: ATTR_MARK
        });
      }
    }
  );
  return (node2) => {
    return node2;
  };
}
class Keyframe {
  constructor(name, style) {
    this._keyframe = true;
    this.name = name;
    this.style = style;
  }
  getName() {
    let hashId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    return hashId ? `${hashId}-${this.name}` : this.name;
  }
}
function noSplit(list) {
  list.notSplit = true;
  return list;
}
({
  // Inset
  inset: ["top", "right", "bottom", "left"],
  insetBlock: ["top", "bottom"],
  insetBlockStart: ["top"],
  insetBlockEnd: ["bottom"],
  insetInline: ["left", "right"],
  insetInlineStart: ["left"],
  insetInlineEnd: ["right"],
  // Margin
  marginBlock: ["marginTop", "marginBottom"],
  marginBlockStart: ["marginTop"],
  marginBlockEnd: ["marginBottom"],
  marginInline: ["marginLeft", "marginRight"],
  marginInlineStart: ["marginLeft"],
  marginInlineEnd: ["marginRight"],
  // Padding
  paddingBlock: ["paddingTop", "paddingBottom"],
  paddingBlockStart: ["paddingTop"],
  paddingBlockEnd: ["paddingBottom"],
  paddingInline: ["paddingLeft", "paddingRight"],
  paddingInlineStart: ["paddingLeft"],
  paddingInlineEnd: ["paddingRight"],
  // Border
  borderBlock: noSplit(["borderTop", "borderBottom"]),
  borderBlockStart: noSplit(["borderTop"]),
  borderBlockEnd: noSplit(["borderBottom"]),
  borderInline: noSplit(["borderLeft", "borderRight"]),
  borderInlineStart: noSplit(["borderLeft"]),
  borderInlineEnd: noSplit(["borderRight"]),
  // Border width
  borderBlockWidth: ["borderTopWidth", "borderBottomWidth"],
  borderBlockStartWidth: ["borderTopWidth"],
  borderBlockEndWidth: ["borderBottomWidth"],
  borderInlineWidth: ["borderLeftWidth", "borderRightWidth"],
  borderInlineStartWidth: ["borderLeftWidth"],
  borderInlineEndWidth: ["borderRightWidth"],
  // Border style
  borderBlockStyle: ["borderTopStyle", "borderBottomStyle"],
  borderBlockStartStyle: ["borderTopStyle"],
  borderBlockEndStyle: ["borderBottomStyle"],
  borderInlineStyle: ["borderLeftStyle", "borderRightStyle"],
  borderInlineStartStyle: ["borderLeftStyle"],
  borderInlineEndStyle: ["borderRightStyle"],
  // Border color
  borderBlockColor: ["borderTopColor", "borderBottomColor"],
  borderBlockStartColor: ["borderTopColor"],
  borderBlockEndColor: ["borderBottomColor"],
  borderInlineColor: ["borderLeftColor", "borderRightColor"],
  borderInlineStartColor: ["borderLeftColor"],
  borderInlineEndColor: ["borderRightColor"],
  // Border radius
  borderStartStartRadius: ["borderTopLeftRadius"],
  borderStartEndRadius: ["borderTopRightRadius"],
  borderEndStartRadius: ["borderBottomLeftRadius"],
  borderEndEndRadius: ["borderBottomRightRadius"]
});
const version = "4.2.6";
const PresetColors = ["blue", "purple", "cyan", "green", "magenta", "pink", "red", "orange", "yellow", "volcano", "geekblue", "lime", "gold"];
const genControlHeight = (token2) => {
  const {
    controlHeight
  } = token2;
  return {
    controlHeightSM: controlHeight * 0.75,
    controlHeightXS: controlHeight * 0.5,
    controlHeightLG: controlHeight * 1.25
  };
};
function genSizeMapToken$1(token2) {
  const {
    sizeUnit,
    sizeStep
  } = token2;
  return {
    sizeXXL: sizeUnit * (sizeStep + 8),
    sizeXL: sizeUnit * (sizeStep + 4),
    sizeLG: sizeUnit * (sizeStep + 2),
    sizeMD: sizeUnit * (sizeStep + 1),
    sizeMS: sizeUnit * sizeStep,
    size: sizeUnit * sizeStep,
    sizeSM: sizeUnit * (sizeStep - 1),
    sizeXS: sizeUnit * (sizeStep - 2),
    sizeXXS: sizeUnit * (sizeStep - 3)
    // 4
  };
}
const defaultPresetColors = {
  blue: "#1677ff",
  purple: "#722ED1",
  cyan: "#13C2C2",
  green: "#52C41A",
  magenta: "#EB2F96",
  pink: "#eb2f96",
  red: "#F5222D",
  orange: "#FA8C16",
  yellow: "#FADB14",
  volcano: "#FA541C",
  geekblue: "#2F54EB",
  gold: "#FAAD14",
  lime: "#A0D911"
};
const seedToken = _extends$1(_extends$1({}, defaultPresetColors), {
  // Color
  colorPrimary: "#1677ff",
  colorSuccess: "#52c41a",
  colorWarning: "#faad14",
  colorError: "#ff4d4f",
  colorInfo: "#1677ff",
  colorTextBase: "",
  colorBgBase: "",
  // Font
  fontFamily: `-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
'Noto Color Emoji'`,
  fontSize: 14,
  // Line
  lineWidth: 1,
  lineType: "solid",
  // Motion
  motionUnit: 0.1,
  motionBase: 0,
  motionEaseOutCirc: "cubic-bezier(0.08, 0.82, 0.17, 1)",
  motionEaseInOutCirc: "cubic-bezier(0.78, 0.14, 0.15, 0.86)",
  motionEaseOut: "cubic-bezier(0.215, 0.61, 0.355, 1)",
  motionEaseInOut: "cubic-bezier(0.645, 0.045, 0.355, 1)",
  motionEaseOutBack: "cubic-bezier(0.12, 0.4, 0.29, 1.46)",
  motionEaseInBack: "cubic-bezier(0.71, -0.46, 0.88, 0.6)",
  motionEaseInQuint: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
  motionEaseOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
  // Radius
  borderRadius: 6,
  // Size
  sizeUnit: 4,
  sizeStep: 4,
  sizePopupArrow: 16,
  // Control Base
  controlHeight: 32,
  // zIndex
  zIndexBase: 0,
  zIndexPopupBase: 1e3,
  // Image
  opacityImage: 1,
  // Wireframe
  wireframe: false
});
function genColorMapToken(seed2, _ref) {
  let {
    generateColorPalettes: generateColorPalettes2,
    generateNeutralColorPalettes: generateNeutralColorPalettes2
  } = _ref;
  const {
    colorSuccess: colorSuccessBase,
    colorWarning: colorWarningBase,
    colorError: colorErrorBase,
    colorInfo: colorInfoBase,
    colorPrimary: colorPrimaryBase,
    colorBgBase,
    colorTextBase
  } = seed2;
  const primaryColors = generateColorPalettes2(colorPrimaryBase);
  const successColors = generateColorPalettes2(colorSuccessBase);
  const warningColors = generateColorPalettes2(colorWarningBase);
  const errorColors = generateColorPalettes2(colorErrorBase);
  const infoColors = generateColorPalettes2(colorInfoBase);
  const neutralColors = generateNeutralColorPalettes2(colorBgBase, colorTextBase);
  return _extends$1(_extends$1({}, neutralColors), {
    colorPrimaryBg: primaryColors[1],
    colorPrimaryBgHover: primaryColors[2],
    colorPrimaryBorder: primaryColors[3],
    colorPrimaryBorderHover: primaryColors[4],
    colorPrimaryHover: primaryColors[5],
    colorPrimary: primaryColors[6],
    colorPrimaryActive: primaryColors[7],
    colorPrimaryTextHover: primaryColors[8],
    colorPrimaryText: primaryColors[9],
    colorPrimaryTextActive: primaryColors[10],
    colorSuccessBg: successColors[1],
    colorSuccessBgHover: successColors[2],
    colorSuccessBorder: successColors[3],
    colorSuccessBorderHover: successColors[4],
    colorSuccessHover: successColors[4],
    colorSuccess: successColors[6],
    colorSuccessActive: successColors[7],
    colorSuccessTextHover: successColors[8],
    colorSuccessText: successColors[9],
    colorSuccessTextActive: successColors[10],
    colorErrorBg: errorColors[1],
    colorErrorBgHover: errorColors[2],
    colorErrorBorder: errorColors[3],
    colorErrorBorderHover: errorColors[4],
    colorErrorHover: errorColors[5],
    colorError: errorColors[6],
    colorErrorActive: errorColors[7],
    colorErrorTextHover: errorColors[8],
    colorErrorText: errorColors[9],
    colorErrorTextActive: errorColors[10],
    colorWarningBg: warningColors[1],
    colorWarningBgHover: warningColors[2],
    colorWarningBorder: warningColors[3],
    colorWarningBorderHover: warningColors[4],
    colorWarningHover: warningColors[4],
    colorWarning: warningColors[6],
    colorWarningActive: warningColors[7],
    colorWarningTextHover: warningColors[8],
    colorWarningText: warningColors[9],
    colorWarningTextActive: warningColors[10],
    colorInfoBg: infoColors[1],
    colorInfoBgHover: infoColors[2],
    colorInfoBorder: infoColors[3],
    colorInfoBorderHover: infoColors[4],
    colorInfoHover: infoColors[4],
    colorInfo: infoColors[6],
    colorInfoActive: infoColors[7],
    colorInfoTextHover: infoColors[8],
    colorInfoText: infoColors[9],
    colorInfoTextActive: infoColors[10],
    colorBgMask: new TinyColor("#000").setAlpha(0.45).toRgbString(),
    colorWhite: "#fff"
  });
}
const genRadius = (radiusBase) => {
  let radiusLG = radiusBase;
  let radiusSM = radiusBase;
  let radiusXS = radiusBase;
  let radiusOuter = radiusBase;
  if (radiusBase < 6 && radiusBase >= 5) {
    radiusLG = radiusBase + 1;
  } else if (radiusBase < 16 && radiusBase >= 6) {
    radiusLG = radiusBase + 2;
  } else if (radiusBase >= 16) {
    radiusLG = 16;
  }
  if (radiusBase < 7 && radiusBase >= 5) {
    radiusSM = 4;
  } else if (radiusBase < 8 && radiusBase >= 7) {
    radiusSM = 5;
  } else if (radiusBase < 14 && radiusBase >= 8) {
    radiusSM = 6;
  } else if (radiusBase < 16 && radiusBase >= 14) {
    radiusSM = 7;
  } else if (radiusBase >= 16) {
    radiusSM = 8;
  }
  if (radiusBase < 6 && radiusBase >= 2) {
    radiusXS = 1;
  } else if (radiusBase >= 6) {
    radiusXS = 2;
  }
  if (radiusBase > 4 && radiusBase < 8) {
    radiusOuter = 4;
  } else if (radiusBase >= 8) {
    radiusOuter = 6;
  }
  return {
    borderRadius: radiusBase > 16 ? 16 : radiusBase,
    borderRadiusXS: radiusXS,
    borderRadiusSM: radiusSM,
    borderRadiusLG: radiusLG,
    borderRadiusOuter: radiusOuter
  };
};
function genCommonMapToken(token2) {
  const {
    motionUnit,
    motionBase,
    borderRadius,
    lineWidth
  } = token2;
  return _extends$1({
    // motion
    motionDurationFast: `${(motionBase + motionUnit).toFixed(1)}s`,
    motionDurationMid: `${(motionBase + motionUnit * 2).toFixed(1)}s`,
    motionDurationSlow: `${(motionBase + motionUnit * 3).toFixed(1)}s`,
    // line
    lineWidthBold: lineWidth + 1
  }, genRadius(borderRadius));
}
const getAlphaColor$2 = (baseColor, alpha) => new TinyColor(baseColor).setAlpha(alpha).toRgbString();
const getSolidColor$1 = (baseColor, brightness) => {
  const instance = new TinyColor(baseColor);
  return instance.darken(brightness).toHexString();
};
const generateColorPalettes$1 = (baseColor) => {
  const colors = generate$1(baseColor);
  return {
    1: colors[0],
    2: colors[1],
    3: colors[2],
    4: colors[3],
    5: colors[4],
    6: colors[5],
    7: colors[6],
    8: colors[4],
    9: colors[5],
    10: colors[6]
    // 8: colors[7],
    // 9: colors[8],
    // 10: colors[9],
  };
};
const generateNeutralColorPalettes$1 = (bgBaseColor, textBaseColor) => {
  const colorBgBase = bgBaseColor || "#fff";
  const colorTextBase = textBaseColor || "#000";
  return {
    colorBgBase,
    colorTextBase,
    colorText: getAlphaColor$2(colorTextBase, 0.88),
    colorTextSecondary: getAlphaColor$2(colorTextBase, 0.65),
    colorTextTertiary: getAlphaColor$2(colorTextBase, 0.45),
    colorTextQuaternary: getAlphaColor$2(colorTextBase, 0.25),
    colorFill: getAlphaColor$2(colorTextBase, 0.15),
    colorFillSecondary: getAlphaColor$2(colorTextBase, 0.06),
    colorFillTertiary: getAlphaColor$2(colorTextBase, 0.04),
    colorFillQuaternary: getAlphaColor$2(colorTextBase, 0.02),
    colorBgLayout: getSolidColor$1(colorBgBase, 4),
    colorBgContainer: getSolidColor$1(colorBgBase, 0),
    colorBgElevated: getSolidColor$1(colorBgBase, 0),
    colorBgSpotlight: getAlphaColor$2(colorTextBase, 0.85),
    colorBorder: getSolidColor$1(colorBgBase, 15),
    colorBorderSecondary: getSolidColor$1(colorBgBase, 6)
  };
};
function getFontSizes(base) {
  const fontSizes = new Array(10).fill(null).map((_2, index2) => {
    const i2 = index2 - 1;
    const baseSize = base * Math.pow(2.71828, i2 / 5);
    const intSize = index2 > 1 ? Math.floor(baseSize) : Math.ceil(baseSize);
    return Math.floor(intSize / 2) * 2;
  });
  fontSizes[1] = base;
  return fontSizes.map((size) => {
    const height = size + 8;
    return {
      size,
      lineHeight: height / size
    };
  });
}
const genFontMapToken = (fontSize) => {
  const fontSizePairs = getFontSizes(fontSize);
  const fontSizes = fontSizePairs.map((pair) => pair.size);
  const lineHeights = fontSizePairs.map((pair) => pair.lineHeight);
  return {
    fontSizeSM: fontSizes[0],
    fontSize: fontSizes[1],
    fontSizeLG: fontSizes[2],
    fontSizeXL: fontSizes[3],
    fontSizeHeading1: fontSizes[6],
    fontSizeHeading2: fontSizes[5],
    fontSizeHeading3: fontSizes[4],
    fontSizeHeading4: fontSizes[3],
    fontSizeHeading5: fontSizes[2],
    lineHeight: lineHeights[1],
    lineHeightLG: lineHeights[2],
    lineHeightSM: lineHeights[0],
    lineHeightHeading1: lineHeights[6],
    lineHeightHeading2: lineHeights[5],
    lineHeightHeading3: lineHeights[4],
    lineHeightHeading4: lineHeights[3],
    lineHeightHeading5: lineHeights[2]
  };
};
function derivative$2(token2) {
  const colorPalettes = Object.keys(defaultPresetColors).map((colorKey) => {
    const colors = generate$1(token2[colorKey]);
    return new Array(10).fill(1).reduce((prev2, _2, i2) => {
      prev2[`${colorKey}-${i2 + 1}`] = colors[i2];
      return prev2;
    }, {});
  }).reduce((prev2, cur) => {
    prev2 = _extends$1(_extends$1({}, prev2), cur);
    return prev2;
  }, {});
  return _extends$1(_extends$1(_extends$1(_extends$1(_extends$1(_extends$1(_extends$1({}, token2), colorPalettes), genColorMapToken(token2, {
    generateColorPalettes: generateColorPalettes$1,
    generateNeutralColorPalettes: generateNeutralColorPalettes$1
  })), genFontMapToken(token2.fontSize)), genSizeMapToken$1(token2)), genControlHeight(token2)), genCommonMapToken(token2));
}
function isStableColor(color) {
  return color >= 0 && color <= 255;
}
function getAlphaColor$1(frontColor, backgroundColor) {
  const {
    r: fR,
    g: fG,
    b: fB,
    a: originAlpha
  } = new TinyColor(frontColor).toRgb();
  if (originAlpha < 1) {
    return frontColor;
  }
  const {
    r: bR,
    g: bG,
    b: bB
  } = new TinyColor(backgroundColor).toRgb();
  for (let fA = 0.01; fA <= 1; fA += 0.01) {
    const r2 = Math.round((fR - bR * (1 - fA)) / fA);
    const g2 = Math.round((fG - bG * (1 - fA)) / fA);
    const b2 = Math.round((fB - bB * (1 - fA)) / fA);
    if (isStableColor(r2) && isStableColor(g2) && isStableColor(b2)) {
      return new TinyColor({
        r: r2,
        g: g2,
        b: b2,
        a: Math.round(fA * 100) / 100
      }).toRgbString();
    }
  }
  return new TinyColor({
    r: fR,
    g: fG,
    b: fB,
    a: 1
  }).toRgbString();
}
var __rest$18 = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
function formatToken(derivativeToken) {
  const {
    override
  } = derivativeToken, restToken = __rest$18(derivativeToken, ["override"]);
  const overrideTokens = _extends$1({}, override);
  Object.keys(seedToken).forEach((token2) => {
    delete overrideTokens[token2];
  });
  const mergedToken = _extends$1(_extends$1({}, restToken), overrideTokens);
  const screenXS = 480;
  const screenSM = 576;
  const screenMD = 768;
  const screenLG = 992;
  const screenXL = 1200;
  const screenXXL = 1600;
  const screenXXXL = 2e3;
  const aliasToken = _extends$1(_extends$1(_extends$1({}, mergedToken), {
    colorLink: mergedToken.colorInfoText,
    colorLinkHover: mergedToken.colorInfoHover,
    colorLinkActive: mergedToken.colorInfoActive,
    // ============== Background ============== //
    colorFillContent: mergedToken.colorFillSecondary,
    colorFillContentHover: mergedToken.colorFill,
    colorFillAlter: mergedToken.colorFillQuaternary,
    colorBgContainerDisabled: mergedToken.colorFillTertiary,
    // ============== Split ============== //
    colorBorderBg: mergedToken.colorBgContainer,
    colorSplit: getAlphaColor$1(mergedToken.colorBorderSecondary, mergedToken.colorBgContainer),
    // ============== Text ============== //
    colorTextPlaceholder: mergedToken.colorTextQuaternary,
    colorTextDisabled: mergedToken.colorTextQuaternary,
    colorTextHeading: mergedToken.colorText,
    colorTextLabel: mergedToken.colorTextSecondary,
    colorTextDescription: mergedToken.colorTextTertiary,
    colorTextLightSolid: mergedToken.colorWhite,
    colorHighlight: mergedToken.colorError,
    colorBgTextHover: mergedToken.colorFillSecondary,
    colorBgTextActive: mergedToken.colorFill,
    colorIcon: mergedToken.colorTextTertiary,
    colorIconHover: mergedToken.colorText,
    colorErrorOutline: getAlphaColor$1(mergedToken.colorErrorBg, mergedToken.colorBgContainer),
    colorWarningOutline: getAlphaColor$1(mergedToken.colorWarningBg, mergedToken.colorBgContainer),
    // Font
    fontSizeIcon: mergedToken.fontSizeSM,
    // Control
    lineWidth: mergedToken.lineWidth,
    controlOutlineWidth: mergedToken.lineWidth * 2,
    // Checkbox size and expand icon size
    controlInteractiveSize: mergedToken.controlHeight / 2,
    controlItemBgHover: mergedToken.colorFillTertiary,
    controlItemBgActive: mergedToken.colorPrimaryBg,
    controlItemBgActiveHover: mergedToken.colorPrimaryBgHover,
    controlItemBgActiveDisabled: mergedToken.colorFill,
    controlTmpOutline: mergedToken.colorFillQuaternary,
    controlOutline: getAlphaColor$1(mergedToken.colorPrimaryBg, mergedToken.colorBgContainer),
    lineType: mergedToken.lineType,
    borderRadius: mergedToken.borderRadius,
    borderRadiusXS: mergedToken.borderRadiusXS,
    borderRadiusSM: mergedToken.borderRadiusSM,
    borderRadiusLG: mergedToken.borderRadiusLG,
    fontWeightStrong: 600,
    opacityLoading: 0.65,
    linkDecoration: "none",
    linkHoverDecoration: "none",
    linkFocusDecoration: "none",
    controlPaddingHorizontal: 12,
    controlPaddingHorizontalSM: 8,
    paddingXXS: mergedToken.sizeXXS,
    paddingXS: mergedToken.sizeXS,
    paddingSM: mergedToken.sizeSM,
    padding: mergedToken.size,
    paddingMD: mergedToken.sizeMD,
    paddingLG: mergedToken.sizeLG,
    paddingXL: mergedToken.sizeXL,
    paddingContentHorizontalLG: mergedToken.sizeLG,
    paddingContentVerticalLG: mergedToken.sizeMS,
    paddingContentHorizontal: mergedToken.sizeMS,
    paddingContentVertical: mergedToken.sizeSM,
    paddingContentHorizontalSM: mergedToken.size,
    paddingContentVerticalSM: mergedToken.sizeXS,
    marginXXS: mergedToken.sizeXXS,
    marginXS: mergedToken.sizeXS,
    marginSM: mergedToken.sizeSM,
    margin: mergedToken.size,
    marginMD: mergedToken.sizeMD,
    marginLG: mergedToken.sizeLG,
    marginXL: mergedToken.sizeXL,
    marginXXL: mergedToken.sizeXXL,
    boxShadow: `
      0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)
    `,
    boxShadowSecondary: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowTertiary: `
      0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)
    `,
    screenXS,
    screenXSMin: screenXS,
    screenXSMax: screenSM - 1,
    screenSM,
    screenSMMin: screenSM,
    screenSMMax: screenMD - 1,
    screenMD,
    screenMDMin: screenMD,
    screenMDMax: screenLG - 1,
    screenLG,
    screenLGMin: screenLG,
    screenLGMax: screenXL - 1,
    screenXL,
    screenXLMin: screenXL,
    screenXLMax: screenXXL - 1,
    screenXXL,
    screenXXLMin: screenXXL,
    screenXXLMax: screenXXXL - 1,
    screenXXXL,
    screenXXXLMin: screenXXXL,
    // FIXME: component box-shadow, should be removed
    boxShadowPopoverArrow: "3px 3px 7px rgba(0, 0, 0, 0.1)",
    boxShadowCard: `
      0 1px 2px -2px ${new TinyColor("rgba(0, 0, 0, 0.16)").toRgbString()},
      0 3px 6px 0 ${new TinyColor("rgba(0, 0, 0, 0.12)").toRgbString()},
      0 5px 12px 4px ${new TinyColor("rgba(0, 0, 0, 0.09)").toRgbString()}
    `,
    boxShadowDrawerRight: `
      -6px 0 16px 0 rgba(0, 0, 0, 0.08),
      -3px 0 6px -4px rgba(0, 0, 0, 0.12),
      -9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerLeft: `
      6px 0 16px 0 rgba(0, 0, 0, 0.08),
      3px 0 6px -4px rgba(0, 0, 0, 0.12),
      9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerUp: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerDown: `
      0 -6px 16px 0 rgba(0, 0, 0, 0.08),
      0 -3px 6px -4px rgba(0, 0, 0, 0.12),
      0 -9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowTabsOverflowLeft: "inset 10px 0 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowRight: "inset -10px 0 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowTop: "inset 0 10px 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowBottom: "inset 0 -10px 8px -8px rgba(0, 0, 0, 0.08)"
  }), overrideTokens);
  return aliasToken;
}
const operationUnit = (token2) => ({
  // FIXME: This use link but is a operation unit. Seems should be a colorPrimary.
  // And Typography use this to generate link style which should not do this.
  color: token2.colorLink,
  textDecoration: "none",
  outline: "none",
  cursor: "pointer",
  transition: `color ${token2.motionDurationSlow}`,
  "&:focus, &:hover": {
    color: token2.colorLinkHover
  },
  "&:active": {
    color: token2.colorLinkActive
  }
});
const roundedArrow = (width, innerRadius, outerRadius, bgColor, boxShadow) => {
  const unitWidth = width / 2;
  const ax = 0;
  const ay = unitWidth;
  const bx = outerRadius * 1 / Math.sqrt(2);
  const by = unitWidth - outerRadius * (1 - 1 / Math.sqrt(2));
  const cx = unitWidth - innerRadius * (1 / Math.sqrt(2));
  const cy = outerRadius * (Math.sqrt(2) - 1) + innerRadius * (1 / Math.sqrt(2));
  const dx = 2 * unitWidth - cx;
  const dy = cy;
  const ex = 2 * unitWidth - bx;
  const ey = by;
  const fx = 2 * unitWidth - ax;
  const fy = ay;
  const shadowWidth = unitWidth * Math.sqrt(2) + outerRadius * (Math.sqrt(2) - 2);
  const polygonOffset = outerRadius * (Math.sqrt(2) - 1);
  return {
    pointerEvents: "none",
    width,
    height: width,
    overflow: "hidden",
    "&::after": {
      content: '""',
      position: "absolute",
      width: shadowWidth,
      height: shadowWidth,
      bottom: 0,
      insetInline: 0,
      margin: "auto",
      borderRadius: {
        _skip_check_: true,
        value: `0 0 ${innerRadius}px 0`
      },
      transform: "translateY(50%) rotate(-135deg)",
      boxShadow,
      zIndex: 0,
      background: "transparent"
    },
    "&::before": {
      position: "absolute",
      bottom: 0,
      insetInlineStart: 0,
      width,
      height: width / 2,
      background: bgColor,
      clipPath: {
        _multi_value_: true,
        value: [`polygon(${polygonOffset}px 100%, 50% ${polygonOffset}px, ${2 * unitWidth - polygonOffset}px 100%, ${polygonOffset}px 100%)`, `path('M ${ax} ${ay} A ${outerRadius} ${outerRadius} 0 0 0 ${bx} ${by} L ${cx} ${cy} A ${innerRadius} ${innerRadius} 0 0 1 ${dx} ${dy} L ${ex} ${ey} A ${outerRadius} ${outerRadius} 0 0 0 ${fx} ${fy} Z')`]
      },
      content: '""'
    }
  };
};
function genPresetColor(token2, genCss) {
  return PresetColors.reduce((prev2, colorKey) => {
    const lightColor = token2[`${colorKey}-1`];
    const lightBorderColor = token2[`${colorKey}-3`];
    const darkColor = token2[`${colorKey}-6`];
    const textColor = token2[`${colorKey}-7`];
    return _extends$1(_extends$1({}, prev2), genCss(colorKey, {
      lightColor,
      lightBorderColor,
      darkColor,
      textColor
    }));
  }, {});
}
const textEllipsis = {
  overflow: "hidden",
  whiteSpace: "nowrap",
  textOverflow: "ellipsis"
};
const resetComponent = (token2) => ({
  boxSizing: "border-box",
  margin: 0,
  padding: 0,
  color: token2.colorText,
  fontSize: token2.fontSize,
  // font-variant: @font-variant-base;
  lineHeight: token2.lineHeight,
  listStyle: "none",
  // font-feature-settings: @font-feature-settings-base;
  fontFamily: token2.fontFamily
});
const resetIcon = () => ({
  display: "inline-flex",
  alignItems: "center",
  color: "inherit",
  fontStyle: "normal",
  lineHeight: 0,
  textAlign: "center",
  textTransform: "none",
  // for SVG icon, see https://blog.prototypr.io/align-svg-icons-to-text-and-say-goodbye-to-font-icons-d44b3d7b26b4
  verticalAlign: "-0.125em",
  textRendering: "optimizeLegibility",
  "-webkit-font-smoothing": "antialiased",
  "-moz-osx-font-smoothing": "grayscale",
  "> *": {
    lineHeight: 1
  },
  svg: {
    display: "inline-block"
  }
});
const clearFix = () => ({
  // https://github.com/ant-design/ant-design/issues/21301#issuecomment-583955229
  "&::before": {
    display: "table",
    content: '""'
  },
  "&::after": {
    // https://github.com/ant-design/ant-design/issues/21864
    display: "table",
    clear: "both",
    content: '""'
  }
});
const genLinkStyle = (token2) => ({
  a: {
    color: token2.colorLink,
    textDecoration: token2.linkDecoration,
    backgroundColor: "transparent",
    outline: "none",
    cursor: "pointer",
    transition: `color ${token2.motionDurationSlow}`,
    "-webkit-text-decoration-skip": "objects",
    "&:hover": {
      color: token2.colorLinkHover
    },
    "&:active": {
      color: token2.colorLinkActive
    },
    [`&:active,
  &:hover`]: {
      textDecoration: token2.linkHoverDecoration,
      outline: 0
    },
    // https://github.com/ant-design/ant-design/issues/22503
    "&:focus": {
      textDecoration: token2.linkFocusDecoration,
      outline: 0
    },
    "&[disabled]": {
      color: token2.colorTextDisabled,
      cursor: "not-allowed"
    }
  }
});
const genCommonStyle = (token2, componentPrefixCls) => {
  const {
    fontFamily,
    fontSize
  } = token2;
  const rootPrefixSelector = `[class^="${componentPrefixCls}"], [class*=" ${componentPrefixCls}"]`;
  return {
    [rootPrefixSelector]: {
      fontFamily,
      fontSize,
      boxSizing: "border-box",
      "&::before, &::after": {
        boxSizing: "border-box"
      },
      [rootPrefixSelector]: {
        boxSizing: "border-box",
        "&::before, &::after": {
          boxSizing: "border-box"
        }
      }
    }
  };
};
const genFocusOutline = (token2) => ({
  outline: `${token2.lineWidthBold}px solid ${token2.colorPrimaryBorder}`,
  outlineOffset: 1,
  transition: "outline-offset 0s, outline 0s"
});
const genFocusStyle = (token2) => ({
  "&:focus-visible": _extends$1({}, genFocusOutline(token2))
});
function genComponentStyleHook(component, styleFn, getDefaultToken) {
  return (_prefixCls) => {
    const prefixCls = computed(() => _prefixCls === null || _prefixCls === void 0 ? void 0 : _prefixCls.value);
    const [theme2, token2, hashId] = useToken$1();
    const {
      getPrefixCls,
      iconPrefixCls
    } = useConfigContextInject();
    const rootPrefixCls = computed(() => getPrefixCls());
    const sharedInfo = computed(() => {
      return {
        theme: theme2.value,
        token: token2.value,
        hashId: hashId.value,
        path: ["Shared", rootPrefixCls.value]
      };
    });
    useStyleRegister(sharedInfo, () => [{
      // Link
      "&": genLinkStyle(token2.value)
    }]);
    const componentInfo = computed(() => {
      return {
        theme: theme2.value,
        token: token2.value,
        hashId: hashId.value,
        path: [component, prefixCls.value, iconPrefixCls.value]
      };
    });
    return [useStyleRegister(componentInfo, () => {
      const {
        token: proxyToken,
        flush
      } = statisticToken(token2.value);
      const defaultComponentToken = typeof getDefaultToken === "function" ? getDefaultToken(proxyToken) : getDefaultToken;
      const mergedComponentToken = _extends$1(_extends$1({}, defaultComponentToken), token2.value[component]);
      const componentCls = `.${prefixCls.value}`;
      const mergedToken = merge(proxyToken, {
        componentCls,
        prefixCls: prefixCls.value,
        iconCls: `.${iconPrefixCls.value}`,
        antCls: `.${rootPrefixCls.value}`
      }, mergedComponentToken);
      const styleInterpolation = styleFn(mergedToken, {
        hashId: hashId.value,
        prefixCls: prefixCls.value,
        rootPrefixCls: rootPrefixCls.value,
        iconPrefixCls: iconPrefixCls.value,
        overrideComponentToken: token2.value[component]
      });
      flush(component, mergedComponentToken);
      return [genCommonStyle(token2.value, prefixCls.value), styleInterpolation];
    }), hashId];
  };
}
const enableStatistic = typeof CSSINJS_STATISTIC !== "undefined";
let recording = true;
function merge() {
  for (var _len = arguments.length, objs = new Array(_len), _key = 0; _key < _len; _key++) {
    objs[_key] = arguments[_key];
  }
  if (!enableStatistic) {
    return _extends$1({}, ...objs);
  }
  recording = false;
  const ret = {};
  objs.forEach((obj) => {
    const keys2 = Object.keys(obj);
    keys2.forEach((key2) => {
      Object.defineProperty(ret, key2, {
        configurable: true,
        enumerable: true,
        get: () => obj[key2]
      });
    });
  });
  recording = true;
  return ret;
}
function noop$5() {
}
function statisticToken(token2) {
  let tokenKeys2;
  let proxy = token2;
  let flush = noop$5;
  if (enableStatistic) {
    tokenKeys2 = /* @__PURE__ */ new Set();
    proxy = new Proxy(token2, {
      get(obj, prop) {
        if (recording) {
          tokenKeys2.add(prop);
        }
        return obj[prop];
      }
    });
    flush = (componentName, componentToken) => {
      ({
        global: Array.from(tokenKeys2),
        component: componentToken
      });
    };
  }
  return {
    token: proxy,
    keys: tokenKeys2,
    flush
  };
}
const defaultTheme = createTheme(derivative$2);
const defaultConfig = {
  token: seedToken,
  hashed: true
};
const DesignTokenContextKey = Symbol("DesignTokenContext");
const globalDesignTokenApi = shallowRef();
const useDesignTokenProvider = (value) => {
  provide(DesignTokenContextKey, value);
  watch(value, () => {
    globalDesignTokenApi.value = unref(value);
    triggerRef(globalDesignTokenApi);
  }, {
    immediate: true,
    deep: true
  });
};
const DesignTokenProvider = defineComponent({
  props: {
    value: objectType()
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    useDesignTokenProvider(computed(() => props2.value));
    return () => {
      var _a2;
      return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
    };
  }
});
function useToken$1() {
  const designTokenContext = inject(DesignTokenContextKey, computed(() => globalDesignTokenApi.value || defaultConfig));
  const salt = computed(() => `${version}-${designTokenContext.value.hashed || ""}`);
  const mergedTheme = computed(() => designTokenContext.value.theme || defaultTheme);
  const cacheToken = useCacheToken(mergedTheme, computed(() => [seedToken, designTokenContext.value.token]), computed(() => ({
    salt: salt.value,
    override: _extends$1({
      override: designTokenContext.value.token
    }, designTokenContext.value.components),
    formatToken
  })));
  return [mergedTheme, computed(() => cacheToken.value[0]), computed(() => designTokenContext.value.hashed ? cacheToken.value[1] : "")];
}
const Empty$2 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  setup() {
    const [, token2] = useToken$1();
    const themeStyle = computed(() => {
      const bgColor = new TinyColor(token2.value.colorBgBase);
      if (bgColor.toHsl().l < 0.5) {
        return {
          opacity: 0.65
        };
      }
      return {};
    });
    return () => createVNode("svg", {
      "style": themeStyle.value,
      "width": "184",
      "height": "152",
      "viewBox": "0 0 184 152",
      "xmlns": "http://www.w3.org/2000/svg"
    }, [createVNode("g", {
      "fill": "none",
      "fill-rule": "evenodd"
    }, [createVNode("g", {
      "transform": "translate(24 31.67)"
    }, [createVNode("ellipse", {
      "fill-opacity": ".8",
      "fill": "#F5F5F7",
      "cx": "67.797",
      "cy": "106.89",
      "rx": "67.797",
      "ry": "12.668"
    }, null), createVNode("path", {
      "d": "M122.034 69.674L98.109 40.229c-1.148-1.386-2.826-2.225-4.593-2.225h-51.44c-1.766 0-3.444.839-4.592 2.225L13.56 69.674v15.383h108.475V69.674z",
      "fill": "#AEB8C2"
    }, null), createVNode("path", {
      "d": "M101.537 86.214L80.63 61.102c-1.001-1.207-2.507-1.867-4.048-1.867H31.724c-1.54 0-3.047.66-4.048 1.867L6.769 86.214v13.792h94.768V86.214z",
      "fill": "url(#linearGradient-1)",
      "transform": "translate(13.56)"
    }, null), createVNode("path", {
      "d": "M33.83 0h67.933a4 4 0 0 1 4 4v93.344a4 4 0 0 1-4 4H33.83a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4z",
      "fill": "#F5F5F7"
    }, null), createVNode("path", {
      "d": "M42.678 9.953h50.237a2 2 0 0 1 2 2V36.91a2 2 0 0 1-2 2H42.678a2 2 0 0 1-2-2V11.953a2 2 0 0 1 2-2zM42.94 49.767h49.713a2.262 2.262 0 1 1 0 4.524H42.94a2.262 2.262 0 0 1 0-4.524zM42.94 61.53h49.713a2.262 2.262 0 1 1 0 4.525H42.94a2.262 2.262 0 0 1 0-4.525zM121.813 105.032c-.775 3.071-3.497 5.36-6.735 5.36H20.515c-3.238 0-5.96-2.29-6.734-5.36a7.309 7.309 0 0 1-.222-1.79V69.675h26.318c2.907 0 5.25 2.448 5.25 5.42v.04c0 2.971 2.37 5.37 5.277 5.37h34.785c2.907 0 5.277-2.421 5.277-5.393V75.1c0-2.972 2.343-5.426 5.25-5.426h26.318v33.569c0 .617-.077 1.216-.221 1.789z",
      "fill": "#DCE0E6"
    }, null)]), createVNode("path", {
      "d": "M149.121 33.292l-6.83 2.65a1 1 0 0 1-1.317-1.23l1.937-6.207c-2.589-2.944-4.109-6.534-4.109-10.408C138.802 8.102 148.92 0 161.402 0 173.881 0 184 8.102 184 18.097c0 9.995-10.118 18.097-22.599 18.097-4.528 0-8.744-1.066-12.28-2.902z",
      "fill": "#DCE0E6"
    }, null), createVNode("g", {
      "transform": "translate(149.65 15.383)",
      "fill": "#FFF"
    }, [createVNode("ellipse", {
      "cx": "20.654",
      "cy": "3.167",
      "rx": "2.849",
      "ry": "2.815"
    }, null), createVNode("path", {
      "d": "M5.698 5.63H0L2.898.704zM9.259.704h4.985V5.63H9.259z"
    }, null)])])]);
  }
});
Empty$2.PRESENTED_IMAGE_DEFAULT = true;
const Simple = defineComponent({
  compatConfig: {
    MODE: 3
  },
  setup() {
    const [, token2] = useToken$1();
    const color = computed(() => {
      const {
        colorFill,
        colorFillTertiary,
        colorFillQuaternary,
        colorBgContainer
      } = token2.value;
      return {
        borderColor: new TinyColor(colorFill).onBackground(colorBgContainer).toHexString(),
        shadowColor: new TinyColor(colorFillTertiary).onBackground(colorBgContainer).toHexString(),
        contentColor: new TinyColor(colorFillQuaternary).onBackground(colorBgContainer).toHexString()
      };
    });
    return () => createVNode("svg", {
      "width": "64",
      "height": "41",
      "viewBox": "0 0 64 41",
      "xmlns": "http://www.w3.org/2000/svg"
    }, [createVNode("g", {
      "transform": "translate(0 1)",
      "fill": "none",
      "fill-rule": "evenodd"
    }, [createVNode("ellipse", {
      "fill": color.value.shadowColor,
      "cx": "32",
      "cy": "33",
      "rx": "32",
      "ry": "7"
    }, null), createVNode("g", {
      "fill-rule": "nonzero",
      "stroke": color.value.borderColor
    }, [createVNode("path", {
      "d": "M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z"
    }, null), createVNode("path", {
      "d": "M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z",
      "fill": color.value.contentColor
    }, null)])])]);
  }
});
Simple.PRESENTED_IMAGE_SIMPLE = true;
const genSharedEmptyStyle = (token2) => {
  const {
    componentCls,
    margin,
    marginXS,
    marginXL,
    fontSize,
    lineHeight
  } = token2;
  return {
    [componentCls]: {
      marginInline: marginXS,
      fontSize,
      lineHeight,
      textAlign: "center",
      // 原来 &-image 没有父子结构，现在为了外层承担我们的hashId，改成父子结果
      [`${componentCls}-image`]: {
        height: token2.emptyImgHeight,
        marginBottom: marginXS,
        opacity: token2.opacityImage,
        img: {
          height: "100%"
        },
        svg: {
          height: "100%",
          margin: "auto"
        }
      },
      // 原来 &-footer 没有父子结构，现在为了外层承担我们的hashId，改成父子结果
      [`${componentCls}-footer`]: {
        marginTop: margin
      },
      "&-normal": {
        marginBlock: marginXL,
        color: token2.colorTextDisabled,
        [`${componentCls}-image`]: {
          height: token2.emptyImgHeightMD
        }
      },
      "&-small": {
        marginBlock: marginXS,
        color: token2.colorTextDisabled,
        [`${componentCls}-image`]: {
          height: token2.emptyImgHeightSM
        }
      }
    }
  };
};
const useStyle$I = genComponentStyleHook("Empty", (token2) => {
  const {
    componentCls,
    controlHeightLG
  } = token2;
  const emptyToken = merge(token2, {
    emptyImgCls: `${componentCls}-img`,
    emptyImgHeight: controlHeightLG * 2.5,
    emptyImgHeightMD: controlHeightLG,
    emptyImgHeightSM: controlHeightLG * 0.875
  });
  return [genSharedEmptyStyle(emptyToken)];
});
var __rest$17 = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const emptyProps = () => ({
  prefixCls: String,
  imageStyle: objectType(),
  image: anyType(),
  description: anyType()
});
const Empty = defineComponent({
  name: "AEmpty",
  compatConfig: {
    MODE: 3
  },
  inheritAttrs: false,
  props: emptyProps(),
  setup(props2, _ref) {
    let {
      slots = {},
      attrs
    } = _ref;
    const {
      direction,
      prefixCls: prefixClsRef
    } = useConfigInject("empty", props2);
    const [wrapSSR, hashId] = useStyle$I(prefixClsRef);
    return () => {
      var _a2, _b;
      const prefixCls = prefixClsRef.value;
      const _c = _extends$1(_extends$1({}, props2), attrs), {
        image: mergedImage = ((_a2 = slots.image) === null || _a2 === void 0 ? void 0 : _a2.call(slots)) || h$1(Empty$2),
        description = ((_b = slots.description) === null || _b === void 0 ? void 0 : _b.call(slots)) || void 0,
        imageStyle,
        class: className = ""
      } = _c, restProps = __rest$17(_c, ["image", "description", "imageStyle", "class"]);
      const image = typeof mergedImage === "function" ? mergedImage() : mergedImage;
      const isNormal = typeof image === "object" && "type" in image && image.type.PRESENTED_IMAGE_SIMPLE;
      return wrapSSR(createVNode(LocaleReceiver, {
        "componentName": "Empty",
        "children": (locale2) => {
          const des = typeof description !== "undefined" ? description : locale2.description;
          const alt = typeof des === "string" ? des : "empty";
          let imageNode = null;
          if (typeof image === "string") {
            imageNode = createVNode("img", {
              "alt": alt,
              "src": image
            }, null);
          } else {
            imageNode = image;
          }
          return createVNode("div", _objectSpread2$1({
            "class": classNames(prefixCls, className, hashId.value, {
              [`${prefixCls}-normal`]: isNormal,
              [`${prefixCls}-rtl`]: direction.value === "rtl"
            })
          }, restProps), [createVNode("div", {
            "class": `${prefixCls}-image`,
            "style": imageStyle
          }, [imageNode]), des && createVNode("p", {
            "class": `${prefixCls}-description`
          }, [des]), slots.default && createVNode("div", {
            "class": `${prefixCls}-footer`
          }, [filterEmpty(slots.default())])]);
        }
      }, null));
    };
  }
});
Empty.PRESENTED_IMAGE_DEFAULT = () => h$1(Empty$2);
Empty.PRESENTED_IMAGE_SIMPLE = () => h$1(Simple);
const Empty$1 = withInstall(Empty);
const DefaultRenderEmpty = (props2) => {
  const {
    prefixCls
  } = useConfigInject("empty", props2);
  const renderHtml = (componentName) => {
    switch (componentName) {
      case "Table":
      case "List":
        return createVNode(Empty$1, {
          "image": Empty$1.PRESENTED_IMAGE_SIMPLE
        }, null);
      case "Select":
      case "TreeSelect":
      case "Cascader":
      case "Transfer":
      case "Mentions":
        return createVNode(Empty$1, {
          "image": Empty$1.PRESENTED_IMAGE_SIMPLE,
          "class": `${prefixCls.value}-small`
        }, null);
      default:
        return createVNode(Empty$1, null, null);
    }
  };
  return renderHtml(props2.componentName);
};
function renderEmpty(componentName) {
  return createVNode(DefaultRenderEmpty, {
    "componentName": componentName
  }, null);
}
const SizeContextKey = Symbol("SizeContextKey");
const useInjectSize = () => {
  return inject(SizeContextKey, ref(void 0));
};
const useProviderSize = (size) => {
  const parentSize = useInjectSize();
  provide(SizeContextKey, computed(() => size.value || parentSize.value));
  return size;
};
const useConfigInject = (name, props2) => {
  const sizeContext = useInjectSize();
  const disabledContext = useInjectDisabled();
  const configProvider = inject(configProviderKey, _extends$1(_extends$1({}, defaultConfigProvider), {
    renderEmpty: (name2) => h$1(DefaultRenderEmpty, {
      componentName: name2
    })
  }));
  const prefixCls = computed(() => configProvider.getPrefixCls(name, props2.prefixCls));
  const direction = computed(() => {
    var _a2, _b;
    return (_a2 = props2.direction) !== null && _a2 !== void 0 ? _a2 : (_b = configProvider.direction) === null || _b === void 0 ? void 0 : _b.value;
  });
  const iconPrefixCls = computed(() => {
    var _a2;
    return (_a2 = props2.iconPrefixCls) !== null && _a2 !== void 0 ? _a2 : configProvider.iconPrefixCls.value;
  });
  const rootPrefixCls = computed(() => configProvider.getPrefixCls());
  const autoInsertSpaceInButton = computed(() => {
    var _a2;
    return (_a2 = configProvider.autoInsertSpaceInButton) === null || _a2 === void 0 ? void 0 : _a2.value;
  });
  const renderEmpty2 = configProvider.renderEmpty;
  const space = configProvider.space;
  const pageHeader = configProvider.pageHeader;
  const form = configProvider.form;
  const getTargetContainer = computed(() => {
    var _a2, _b;
    return (_a2 = props2.getTargetContainer) !== null && _a2 !== void 0 ? _a2 : (_b = configProvider.getTargetContainer) === null || _b === void 0 ? void 0 : _b.value;
  });
  const getPopupContainer = computed(() => {
    var _a2, _b, _c;
    return (_b = (_a2 = props2.getContainer) !== null && _a2 !== void 0 ? _a2 : props2.getPopupContainer) !== null && _b !== void 0 ? _b : (_c = configProvider.getPopupContainer) === null || _c === void 0 ? void 0 : _c.value;
  });
  const dropdownMatchSelectWidth = computed(() => {
    var _a2, _b;
    return (_a2 = props2.dropdownMatchSelectWidth) !== null && _a2 !== void 0 ? _a2 : (_b = configProvider.dropdownMatchSelectWidth) === null || _b === void 0 ? void 0 : _b.value;
  });
  const virtual = computed(() => {
    var _a2;
    return (props2.virtual === void 0 ? ((_a2 = configProvider.virtual) === null || _a2 === void 0 ? void 0 : _a2.value) !== false : props2.virtual !== false) && dropdownMatchSelectWidth.value !== false;
  });
  const size = computed(() => props2.size || sizeContext.value);
  const autocomplete = computed(() => {
    var _a2, _b, _c;
    return (_a2 = props2.autocomplete) !== null && _a2 !== void 0 ? _a2 : (_c = (_b = configProvider.input) === null || _b === void 0 ? void 0 : _b.value) === null || _c === void 0 ? void 0 : _c.autocomplete;
  });
  const disabled = computed(() => {
    var _a2;
    return (_a2 = props2.disabled) !== null && _a2 !== void 0 ? _a2 : disabledContext.value;
  });
  const csp = computed(() => {
    var _a2;
    return (_a2 = props2.csp) !== null && _a2 !== void 0 ? _a2 : configProvider.csp;
  });
  const wave = computed(() => {
    var _a2, _b;
    return (_a2 = props2.wave) !== null && _a2 !== void 0 ? _a2 : (_b = configProvider.wave) === null || _b === void 0 ? void 0 : _b.value;
  });
  return {
    configProvider,
    prefixCls,
    direction,
    size,
    getTargetContainer,
    getPopupContainer,
    space,
    pageHeader,
    form,
    autoInsertSpaceInButton,
    renderEmpty: renderEmpty2,
    virtual,
    dropdownMatchSelectWidth,
    rootPrefixCls,
    getPrefixCls: configProvider.getPrefixCls,
    autocomplete,
    csp,
    iconPrefixCls,
    disabled,
    select: configProvider.select,
    wave
  };
};
function omit$1(obj, fields) {
  const shallowCopy = _extends$1({}, obj);
  for (let i2 = 0; i2 < fields.length; i2 += 1) {
    const key2 = fields[i2];
    delete shallowCopy[key2];
  }
  return shallowCopy;
}
function t$1(t2) {
  return "object" == typeof t2 && null != t2 && 1 === t2.nodeType;
}
function e$1(t2, e2) {
  return (!e2 || "hidden" !== t2) && "visible" !== t2 && "clip" !== t2;
}
function n$1(t2, n2) {
  if (t2.clientHeight < t2.scrollHeight || t2.clientWidth < t2.scrollWidth) {
    var r2 = getComputedStyle(t2, null);
    return e$1(r2.overflowY, n2) || e$1(r2.overflowX, n2) || function(t3) {
      var e2 = function(t4) {
        if (!t4.ownerDocument || !t4.ownerDocument.defaultView) return null;
        try {
          return t4.ownerDocument.defaultView.frameElement;
        } catch (t5) {
          return null;
        }
      }(t3);
      return !!e2 && (e2.clientHeight < t3.scrollHeight || e2.clientWidth < t3.scrollWidth);
    }(t2);
  }
  return false;
}
function r$1(t2, e2, n2, r2, i2, o2, l2, d2) {
  return o2 < t2 && l2 > e2 || o2 > t2 && l2 < e2 ? 0 : o2 <= t2 && d2 <= n2 || l2 >= e2 && d2 >= n2 ? o2 - t2 - r2 : l2 > e2 && d2 < n2 || o2 < t2 && d2 > n2 ? l2 - e2 + i2 : 0;
}
var i$1 = function(e2, i2) {
  var o2 = window, l2 = i2.scrollMode, d2 = i2.block, f2 = i2.inline, h2 = i2.boundary, u2 = i2.skipOverflowHiddenElements, s2 = "function" == typeof h2 ? h2 : function(t2) {
    return t2 !== h2;
  };
  if (!t$1(e2)) throw new TypeError("Invalid target");
  for (var a2, c2, g2 = document.scrollingElement || document.documentElement, p = [], m2 = e2; t$1(m2) && s2(m2); ) {
    if ((m2 = null == (c2 = (a2 = m2).parentElement) ? a2.getRootNode().host || null : c2) === g2) {
      p.push(m2);
      break;
    }
    null != m2 && m2 === document.body && n$1(m2) && !n$1(document.documentElement) || null != m2 && n$1(m2, u2) && p.push(m2);
  }
  for (var w2 = o2.visualViewport ? o2.visualViewport.width : innerWidth, v2 = o2.visualViewport ? o2.visualViewport.height : innerHeight, W = window.scrollX || pageXOffset, H = window.scrollY || pageYOffset, b2 = e2.getBoundingClientRect(), y2 = b2.height, E2 = b2.width, M2 = b2.top, V2 = b2.right, x2 = b2.bottom, I2 = b2.left, C = "start" === d2 || "nearest" === d2 ? M2 : "end" === d2 ? x2 : M2 + y2 / 2, R2 = "center" === f2 ? I2 + E2 / 2 : "end" === f2 ? V2 : I2, T2 = [], k2 = 0; k2 < p.length; k2++) {
    var B2 = p[k2], D2 = B2.getBoundingClientRect(), O2 = D2.height, X = D2.width, Y2 = D2.top, L2 = D2.right, S2 = D2.bottom, j2 = D2.left;
    if ("if-needed" === l2 && M2 >= 0 && I2 >= 0 && x2 <= v2 && V2 <= w2 && M2 >= Y2 && x2 <= S2 && I2 >= j2 && V2 <= L2) return T2;
    var N2 = getComputedStyle(B2), q2 = parseInt(N2.borderLeftWidth, 10), z2 = parseInt(N2.borderTopWidth, 10), A2 = parseInt(N2.borderRightWidth, 10), F2 = parseInt(N2.borderBottomWidth, 10), G = 0, J2 = 0, K = "offsetWidth" in B2 ? B2.offsetWidth - B2.clientWidth - q2 - A2 : 0, P2 = "offsetHeight" in B2 ? B2.offsetHeight - B2.clientHeight - z2 - F2 : 0, Q = "offsetWidth" in B2 ? 0 === B2.offsetWidth ? 0 : X / B2.offsetWidth : 0, U = "offsetHeight" in B2 ? 0 === B2.offsetHeight ? 0 : O2 / B2.offsetHeight : 0;
    if (g2 === B2) G = "start" === d2 ? C : "end" === d2 ? C - v2 : "nearest" === d2 ? r$1(H, H + v2, v2, z2, F2, H + C, H + C + y2, y2) : C - v2 / 2, J2 = "start" === f2 ? R2 : "center" === f2 ? R2 - w2 / 2 : "end" === f2 ? R2 - w2 : r$1(W, W + w2, w2, q2, A2, W + R2, W + R2 + E2, E2), G = Math.max(0, G + H), J2 = Math.max(0, J2 + W);
    else {
      G = "start" === d2 ? C - Y2 - z2 : "end" === d2 ? C - S2 + F2 + P2 : "nearest" === d2 ? r$1(Y2, S2, O2, z2, F2 + P2, C, C + y2, y2) : C - (Y2 + O2 / 2) + P2 / 2, J2 = "start" === f2 ? R2 - j2 - q2 : "center" === f2 ? R2 - (j2 + X / 2) + K / 2 : "end" === f2 ? R2 - L2 + A2 + K : r$1(j2, L2, X, q2, A2 + K, R2, R2 + E2, E2);
      var Z = B2.scrollLeft, $2 = B2.scrollTop;
      C += $2 - (G = Math.max(0, Math.min($2 + G / U, B2.scrollHeight - O2 / U + P2))), R2 += Z - (J2 = Math.max(0, Math.min(Z + J2 / Q, B2.scrollWidth - X / Q + K)));
    }
    T2.push({ el: B2, top: G, left: J2 });
  }
  return T2;
};
function isOptionsObject(options) {
  return options === Object(options) && Object.keys(options).length !== 0;
}
function defaultBehavior(actions, behavior) {
  if (behavior === void 0) {
    behavior = "auto";
  }
  var canSmoothScroll = "scrollBehavior" in document.body.style;
  actions.forEach(function(_ref) {
    var el = _ref.el, top = _ref.top, left = _ref.left;
    if (el.scroll && canSmoothScroll) {
      el.scroll({
        top,
        left,
        behavior
      });
    } else {
      el.scrollTop = top;
      el.scrollLeft = left;
    }
  });
}
function getOptions(options) {
  if (options === false) {
    return {
      block: "end",
      inline: "nearest"
    };
  }
  if (isOptionsObject(options)) {
    return options;
  }
  return {
    block: "start",
    inline: "nearest"
  };
}
function scrollIntoView(target, options) {
  var isTargetAttached = target.isConnected || target.ownerDocument.documentElement.contains(target);
  if (isOptionsObject(options) && typeof options.behavior === "function") {
    return options.behavior(isTargetAttached ? i$1(target, options) : []);
  }
  if (!isTargetAttached) {
    return;
  }
  var computeOptions = getOptions(options);
  return defaultBehavior(i$1(target, computeOptions), computeOptions.behavior);
}
function easeInOutCubic(t2, b2, c2, d2) {
  const cc = c2 - b2;
  t2 /= d2 / 2;
  if (t2 < 1) {
    return cc / 2 * t2 * t2 * t2 + b2;
  }
  return cc / 2 * ((t2 -= 2) * t2 * t2 + 2) + b2;
}
function isWindow$1(obj) {
  return obj !== null && obj !== void 0 && obj === obj.window;
}
function getScroll$2(target, top) {
  var _a2, _b;
  if (typeof window === "undefined") {
    return 0;
  }
  const method4 = "scrollTop";
  let result = 0;
  if (isWindow$1(target)) {
    result = target["scrollY"];
  } else if (target instanceof Document) {
    result = target.documentElement[method4];
  } else if (target instanceof HTMLElement) {
    result = target[method4];
  } else if (target) {
    result = target[method4];
  }
  if (target && !isWindow$1(target) && typeof result !== "number") {
    result = (_b = ((_a2 = target.ownerDocument) !== null && _a2 !== void 0 ? _a2 : target).documentElement) === null || _b === void 0 ? void 0 : _b[method4];
  }
  return result;
}
function scrollTo$1(y2) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    getContainer: getContainer2 = () => window,
    callback,
    duration = 450
  } = options;
  const container = getContainer2();
  const scrollTop = getScroll$2(container);
  const startTime = Date.now();
  const frameFunc = () => {
    const timestamp = Date.now();
    const time = timestamp - startTime;
    const nextScrollTop = easeInOutCubic(time > duration ? duration : time, scrollTop, y2, duration);
    if (isWindow$1(container)) {
      container.scrollTo(window.scrollX, nextScrollTop);
    } else if (container instanceof Document) {
      container.documentElement.scrollTop = nextScrollTop;
    } else {
      container.scrollTop = nextScrollTop;
    }
    if (time < duration) {
      wrapperRaf(frameFunc);
    } else if (typeof callback === "function") {
      callback();
    }
  };
  wrapperRaf(frameFunc);
}
function e(e2, t2) {
  for (var n2 = 0; n2 < t2.length; n2++) {
    var r2 = t2[n2];
    r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(e2, r2.key, r2);
  }
}
function t(t2, n2, r2) {
  return r2 && e(t2, r2), t2;
}
function n() {
  return (n = Object.assign || function(e2) {
    for (var t2 = 1; t2 < arguments.length; t2++) {
      var n2 = arguments[t2];
      for (var r2 in n2) Object.prototype.hasOwnProperty.call(n2, r2) && (e2[r2] = n2[r2]);
    }
    return e2;
  }).apply(this, arguments);
}
function r(e2, t2) {
  e2.prototype = Object.create(t2.prototype), e2.prototype.constructor = e2, e2.__proto__ = t2;
}
function i(e2, t2) {
  if (null == e2) return {};
  var n2, r2, i2 = {}, o2 = Object.keys(e2);
  for (r2 = 0; r2 < o2.length; r2++) t2.indexOf(n2 = o2[r2]) >= 0 || (i2[n2] = e2[n2]);
  return i2;
}
function o(e2) {
  return 1 == (null != (t2 = e2) && "object" == typeof t2 && false === Array.isArray(t2)) && "[object Object]" === Object.prototype.toString.call(e2);
  var t2;
}
var u = Object.prototype, a = u.toString, f = u.hasOwnProperty, c = /^\s*function (\w+)/;
function l(e2) {
  var t2, n2 = null !== (t2 = null == e2 ? void 0 : e2.type) && void 0 !== t2 ? t2 : e2;
  if (n2) {
    var r2 = n2.toString().match(c);
    return r2 ? r2[1] : "";
  }
  return "";
}
var s = function(e2) {
  var t2, n2;
  return false !== o(e2) && "function" == typeof (t2 = e2.constructor) && false !== o(n2 = t2.prototype) && false !== n2.hasOwnProperty("isPrototypeOf");
}, v = function(e2) {
  return e2;
}, y = v;
var d = function(e2, t2) {
  return f.call(e2, t2);
}, h = Number.isInteger || function(e2) {
  return "number" == typeof e2 && isFinite(e2) && Math.floor(e2) === e2;
}, b = Array.isArray || function(e2) {
  return "[object Array]" === a.call(e2);
}, O = function(e2) {
  return "[object Function]" === a.call(e2);
}, g = function(e2) {
  return s(e2) && d(e2, "_vueTypes_name");
}, m = function(e2) {
  return s(e2) && (d(e2, "type") || ["_vueTypes_name", "validator", "default", "required"].some(function(t2) {
    return d(e2, t2);
  }));
};
function j(e2, t2) {
  return Object.defineProperty(e2.bind(t2), "__original", { value: e2 });
}
function _(e2, t2, n2) {
  var r2;
  void 0 === n2 && (n2 = false);
  var i2 = true, o2 = "";
  r2 = s(e2) ? e2 : { type: e2 };
  var u2 = g(r2) ? r2._vueTypes_name + " - " : "";
  if (m(r2) && null !== r2.type) {
    if (void 0 === r2.type || true === r2.type) return i2;
    if (!r2.required && void 0 === t2) return i2;
    b(r2.type) ? (i2 = r2.type.some(function(e3) {
      return true === _(e3, t2, true);
    }), o2 = r2.type.map(function(e3) {
      return l(e3);
    }).join(" or ")) : i2 = "Array" === (o2 = l(r2)) ? b(t2) : "Object" === o2 ? s(t2) : "String" === o2 || "Number" === o2 || "Boolean" === o2 || "Function" === o2 ? function(e3) {
      if (null == e3) return "";
      var t3 = e3.constructor.toString().match(c);
      return t3 ? t3[1] : "";
    }(t2) === o2 : t2 instanceof r2.type;
  }
  if (!i2) {
    var a2 = u2 + 'value "' + t2 + '" should be of type "' + o2 + '"';
    return false === n2 ? (y(a2), false) : a2;
  }
  if (d(r2, "validator") && O(r2.validator)) {
    var f2 = y, v2 = [];
    if (y = function(e3) {
      v2.push(e3);
    }, i2 = r2.validator(t2), y = f2, !i2) {
      var p = (v2.length > 1 ? "* " : "") + v2.join("\n* ");
      return v2.length = 0, false === n2 ? (y(p), i2) : p;
    }
  }
  return i2;
}
function T(e2, t2) {
  var n2 = Object.defineProperties(t2, { _vueTypes_name: { value: e2, writable: true }, isRequired: { get: function() {
    return this.required = true, this;
  } }, def: { value: function(e3) {
    return void 0 !== e3 || this.default ? O(e3) || true === _(this, e3, true) ? (this.default = b(e3) ? function() {
      return [].concat(e3);
    } : s(e3) ? function() {
      return Object.assign({}, e3);
    } : e3, this) : (y(this._vueTypes_name + ' - invalid default value: "' + e3 + '"'), this) : this;
  } } }), r2 = n2.validator;
  return O(r2) && (n2.validator = j(r2, n2)), n2;
}
function w(e2, t2) {
  var n2 = T(e2, t2);
  return Object.defineProperty(n2, "validate", { value: function(e3) {
    return O(this.validator) && y(this._vueTypes_name + " - calling .validate() will overwrite the current custom validator function. Validator info:\n" + JSON.stringify(this)), this.validator = j(e3, this), this;
  } });
}
function k(e2, t2, n2) {
  var r2, o2, u2 = (r2 = t2, o2 = {}, Object.getOwnPropertyNames(r2).forEach(function(e3) {
    o2[e3] = Object.getOwnPropertyDescriptor(r2, e3);
  }), Object.defineProperties({}, o2));
  if (u2._vueTypes_name = e2, !s(n2)) return u2;
  var a2, f2, c2 = n2.validator, l2 = i(n2, ["validator"]);
  if (O(c2)) {
    var v2 = u2.validator;
    v2 && (v2 = null !== (f2 = (a2 = v2).__original) && void 0 !== f2 ? f2 : a2), u2.validator = j(v2 ? function(e3) {
      return v2.call(this, e3) && c2.call(this, e3);
    } : c2, u2);
  }
  return Object.assign(u2, l2);
}
function P(e2) {
  return e2.replace(/^(?!\s*$)/gm, "  ");
}
var x = function() {
  return w("any", {});
}, A = function() {
  return w("function", { type: Function });
}, E = function() {
  return w("boolean", { type: Boolean });
}, N = function() {
  return w("string", { type: String });
}, q = function() {
  return w("number", { type: Number });
}, S = function() {
  return w("array", { type: Array });
}, V = function() {
  return w("object", { type: Object });
}, F = function() {
  return T("integer", { type: Number, validator: function(e2) {
    return h(e2);
  } });
}, D = function() {
  return T("symbol", { validator: function(e2) {
    return "symbol" == typeof e2;
  } });
};
function L(e2, t2) {
  if (void 0 === t2 && (t2 = "custom validation failed"), "function" != typeof e2) throw new TypeError("[VueTypes error]: You must provide a function as argument");
  return T(e2.name || "<<anonymous function>>", { validator: function(n2) {
    var r2 = e2(n2);
    return r2 || y(this._vueTypes_name + " - " + t2), r2;
  } });
}
function Y(e2) {
  if (!b(e2)) throw new TypeError("[VueTypes error]: You must provide an array as argument.");
  var t2 = 'oneOf - value should be one of "' + e2.join('", "') + '".', n2 = e2.reduce(function(e3, t3) {
    if (null != t3) {
      var n3 = t3.constructor;
      -1 === e3.indexOf(n3) && e3.push(n3);
    }
    return e3;
  }, []);
  return T("oneOf", { type: n2.length > 0 ? n2 : void 0, validator: function(n3) {
    var r2 = -1 !== e2.indexOf(n3);
    return r2 || y(t2), r2;
  } });
}
function B(e2) {
  if (!b(e2)) throw new TypeError("[VueTypes error]: You must provide an array as argument");
  for (var t2 = false, n2 = [], r2 = 0; r2 < e2.length; r2 += 1) {
    var i2 = e2[r2];
    if (m(i2)) {
      if (g(i2) && "oneOf" === i2._vueTypes_name) {
        n2 = n2.concat(i2.type);
        continue;
      }
      if (O(i2.validator) && (t2 = true), true !== i2.type && i2.type) {
        n2 = n2.concat(i2.type);
        continue;
      }
    }
    n2.push(i2);
  }
  return n2 = n2.filter(function(e3, t3) {
    return n2.indexOf(e3) === t3;
  }), T("oneOfType", t2 ? { type: n2, validator: function(t3) {
    var n3 = [], r3 = e2.some(function(e3) {
      var r4 = _(g(e3) && "oneOf" === e3._vueTypes_name ? e3.type || null : e3, t3, true);
      return "string" == typeof r4 && n3.push(r4), true === r4;
    });
    return r3 || y("oneOfType - provided value does not match any of the " + n3.length + " passed-in validators:\n" + P(n3.join("\n"))), r3;
  } } : { type: n2 });
}
function I(e2) {
  return T("arrayOf", { type: Array, validator: function(t2) {
    var n2, r2 = t2.every(function(t3) {
      return true === (n2 = _(e2, t3, true));
    });
    return r2 || y("arrayOf - value validation error:\n" + P(n2)), r2;
  } });
}
function J(e2) {
  return T("instanceOf", { type: e2 });
}
function M(e2) {
  return T("objectOf", { type: Object, validator: function(t2) {
    var n2, r2 = Object.keys(t2).every(function(r3) {
      return true === (n2 = _(e2, t2[r3], true));
    });
    return r2 || y("objectOf - value validation error:\n" + P(n2)), r2;
  } });
}
function R(e2) {
  var t2 = Object.keys(e2), n2 = t2.filter(function(t3) {
    var n3;
    return !!(null === (n3 = e2[t3]) || void 0 === n3 ? void 0 : n3.required);
  }), r2 = T("shape", { type: Object, validator: function(r3) {
    var i2 = this;
    if (!s(r3)) return false;
    var o2 = Object.keys(r3);
    if (n2.length > 0 && n2.some(function(e3) {
      return -1 === o2.indexOf(e3);
    })) {
      var u2 = n2.filter(function(e3) {
        return -1 === o2.indexOf(e3);
      });
      return y(1 === u2.length ? 'shape - required property "' + u2[0] + '" is not defined.' : 'shape - required properties "' + u2.join('", "') + '" are not defined.'), false;
    }
    return o2.every(function(n3) {
      if (-1 === t2.indexOf(n3)) return true === i2._vueTypes_isLoose || (y('shape - shape definition does not include a "' + n3 + '" property. Allowed keys: "' + t2.join('", "') + '".'), false);
      var o3 = _(e2[n3], r3[n3], true);
      return "string" == typeof o3 && y('shape - "' + n3 + '" property validation error:\n ' + P(o3)), true === o3;
    });
  } });
  return Object.defineProperty(r2, "_vueTypes_isLoose", { writable: true, value: false }), Object.defineProperty(r2, "loose", { get: function() {
    return this._vueTypes_isLoose = true, this;
  } }), r2;
}
var $ = function() {
  function e2() {
  }
  return e2.extend = function(e3) {
    var t2 = this;
    if (b(e3)) return e3.forEach(function(e4) {
      return t2.extend(e4);
    }), this;
    var n2 = e3.name, r2 = e3.validate, o2 = void 0 !== r2 && r2, u2 = e3.getter, a2 = void 0 !== u2 && u2, f2 = i(e3, ["name", "validate", "getter"]);
    if (d(this, n2)) throw new TypeError('[VueTypes error]: Type "' + n2 + '" already defined');
    var c2, l2 = f2.type;
    return g(l2) ? (delete f2.type, Object.defineProperty(this, n2, a2 ? { get: function() {
      return k(n2, l2, f2);
    } } : { value: function() {
      var e4, t3 = k(n2, l2, f2);
      return t3.validator && (t3.validator = (e4 = t3.validator).bind.apply(e4, [t3].concat([].slice.call(arguments)))), t3;
    } })) : (c2 = a2 ? { get: function() {
      var e4 = Object.assign({}, f2);
      return o2 ? w(n2, e4) : T(n2, e4);
    }, enumerable: true } : { value: function() {
      var e4, t3, r3 = Object.assign({}, f2);
      return e4 = o2 ? w(n2, r3) : T(n2, r3), r3.validator && (e4.validator = (t3 = r3.validator).bind.apply(t3, [e4].concat([].slice.call(arguments)))), e4;
    }, enumerable: true }, Object.defineProperty(this, n2, c2));
  }, t(e2, null, [{ key: "any", get: function() {
    return x();
  } }, { key: "func", get: function() {
    return A().def(this.defaults.func);
  } }, { key: "bool", get: function() {
    return E().def(this.defaults.bool);
  } }, { key: "string", get: function() {
    return N().def(this.defaults.string);
  } }, { key: "number", get: function() {
    return q().def(this.defaults.number);
  } }, { key: "array", get: function() {
    return S().def(this.defaults.array);
  } }, { key: "object", get: function() {
    return V().def(this.defaults.object);
  } }, { key: "integer", get: function() {
    return F().def(this.defaults.integer);
  } }, { key: "symbol", get: function() {
    return D();
  } }]), e2;
}();
function z(e2) {
  var i2;
  return void 0 === e2 && (e2 = { func: function() {
  }, bool: true, string: "", number: 0, array: function() {
    return [];
  }, object: function() {
    return {};
  }, integer: 0 }), (i2 = function(i3) {
    function o2() {
      return i3.apply(this, arguments) || this;
    }
    return r(o2, i3), t(o2, null, [{ key: "sensibleDefaults", get: function() {
      return n({}, this.defaults);
    }, set: function(t2) {
      this.defaults = false !== t2 ? n({}, true !== t2 ? t2 : e2) : {};
    } }]), o2;
  }($)).defaults = n({}, e2), i2;
}
$.defaults = {}, $.custom = L, $.oneOf = Y, $.instanceOf = J, $.oneOfType = B, $.arrayOf = I, $.objectOf = M, $.shape = R, $.utils = { validate: function(e2, t2) {
  return true === _(t2, e2, true);
}, toType: function(e2, t2, n2) {
  return void 0 === n2 && (n2 = false), n2 ? w(e2, t2) : T(e2, t2);
} };
(function(e2) {
  function t2() {
    return e2.apply(this, arguments) || this;
  }
  return r(t2, e2), t2;
})(z());
const PropTypes = z({
  func: void 0,
  bool: void 0,
  string: void 0,
  number: void 0,
  array: void 0,
  object: void 0,
  integer: void 0
});
PropTypes.extend([{
  name: "looseBool",
  getter: true,
  type: Boolean,
  default: void 0
}, {
  name: "style",
  getter: true,
  type: [String, Object],
  default: void 0
}, {
  name: "VueNode",
  getter: true,
  type: null
}]);
function withUndefined(type4) {
  type4.default = void 0;
  return type4;
}
const devWarning = (valid, component, message) => {
  warningOnce(valid, `[ant-design-vue: ${component}] ${message}`);
};
function getKey$1(data, index2) {
  const {
    key: key2
  } = data;
  let value;
  if ("value" in data) {
    ({
      value
    } = data);
  }
  if (key2 !== null && key2 !== void 0) {
    return key2;
  }
  if (value !== void 0) {
    return value;
  }
  return `rc-index-key-${index2}`;
}
function fillFieldNames$2(fieldNames, childrenAsData) {
  const {
    label,
    value,
    options
  } = fieldNames || {};
  return {
    label: label || (childrenAsData ? "children" : "label"),
    value: value || "value",
    options: options || "options"
  };
}
function flattenOptions(options) {
  let {
    fieldNames,
    childrenAsData
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const flattenList = [];
  const {
    label: fieldLabel,
    value: fieldValue,
    options: fieldOptions
  } = fillFieldNames$2(fieldNames, false);
  function dig(list, isGroupOption) {
    list.forEach((data) => {
      const label = data[fieldLabel];
      if (isGroupOption || !(fieldOptions in data)) {
        const value = data[fieldValue];
        flattenList.push({
          key: getKey$1(data, flattenList.length),
          groupOption: isGroupOption,
          data,
          label,
          value
        });
      } else {
        let grpLabel = label;
        if (grpLabel === void 0 && childrenAsData) {
          grpLabel = data.label;
        }
        flattenList.push({
          key: getKey$1(data, flattenList.length),
          group: true,
          data,
          label: grpLabel
        });
        dig(data[fieldOptions], true);
      }
    });
  }
  dig(options, false);
  return flattenList;
}
function injectPropsWithOption(option) {
  const newOption = _extends$1({}, option);
  if (!("props" in newOption)) {
    Object.defineProperty(newOption, "props", {
      get() {
        return newOption;
      }
    });
  }
  return newOption;
}
function getSeparatedContent(text, tokens) {
  if (!tokens || !tokens.length) {
    return null;
  }
  let match2 = false;
  function separate(str, _ref) {
    let [token2, ...restTokens] = _ref;
    if (!token2) {
      return [str];
    }
    const list2 = str.split(token2);
    match2 = match2 || list2.length > 1;
    return list2.reduce((prevList, unitStr) => [...prevList, ...separate(unitStr, restTokens)], []).filter((unit) => unit);
  }
  const list = separate(text, tokens);
  return match2 ? list : null;
}
function returnEmptyString() {
  return "";
}
function returnDocument(element) {
  if (element) {
    return element.ownerDocument;
  }
  return window.document;
}
function noop$4() {
}
const triggerProps = () => ({
  action: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]).def([]),
  showAction: PropTypes.any.def([]),
  hideAction: PropTypes.any.def([]),
  getPopupClassNameFromAlign: PropTypes.any.def(returnEmptyString),
  onPopupVisibleChange: Function,
  afterPopupVisibleChange: PropTypes.func.def(noop$4),
  popup: PropTypes.any,
  arrow: PropTypes.bool.def(true),
  popupStyle: {
    type: Object,
    default: void 0
  },
  prefixCls: PropTypes.string.def("rc-trigger-popup"),
  popupClassName: PropTypes.string.def(""),
  popupPlacement: String,
  builtinPlacements: PropTypes.object,
  popupTransitionName: String,
  popupAnimation: PropTypes.any,
  mouseEnterDelay: PropTypes.number.def(0),
  mouseLeaveDelay: PropTypes.number.def(0.1),
  zIndex: Number,
  focusDelay: PropTypes.number.def(0),
  blurDelay: PropTypes.number.def(0.15),
  getPopupContainer: Function,
  getDocument: PropTypes.func.def(returnDocument),
  forceRender: {
    type: Boolean,
    default: void 0
  },
  destroyPopupOnHide: {
    type: Boolean,
    default: false
  },
  mask: {
    type: Boolean,
    default: false
  },
  maskClosable: {
    type: Boolean,
    default: true
  },
  // onPopupAlign: PropTypes.func.def(noop),
  popupAlign: PropTypes.object.def(() => ({})),
  popupVisible: {
    type: Boolean,
    default: void 0
  },
  defaultPopupVisible: {
    type: Boolean,
    default: false
  },
  maskTransitionName: String,
  maskAnimation: String,
  stretch: String,
  alignPoint: {
    type: Boolean,
    default: void 0
  },
  autoDestroy: {
    type: Boolean,
    default: false
  },
  mobile: Object,
  getTriggerDOMNode: Function
});
const innerProps = {
  visible: Boolean,
  prefixCls: String,
  zIndex: Number,
  destroyPopupOnHide: Boolean,
  forceRender: Boolean,
  arrow: {
    type: Boolean,
    default: true
  },
  // Legacy Motion
  animation: [String, Object],
  transitionName: String,
  // Measure
  stretch: {
    type: String
  },
  // Align
  align: {
    type: Object
  },
  point: {
    type: Object
  },
  getRootDomNode: {
    type: Function
  },
  getClassNameFromAlign: {
    type: Function
  },
  onAlign: {
    type: Function
  },
  onMouseenter: {
    type: Function
  },
  onMouseleave: {
    type: Function
  },
  onMousedown: {
    type: Function
  },
  onTouchstart: {
    type: Function
  }
};
const mobileProps = _extends$1(_extends$1({}, innerProps), {
  mobile: {
    type: Object
  }
});
const popupProps = _extends$1(_extends$1({}, innerProps), {
  mask: Boolean,
  mobile: {
    type: Object
  },
  maskAnimation: String,
  maskTransitionName: String
});
function getMotion$1(_ref) {
  let {
    prefixCls,
    animation,
    transitionName: transitionName2
  } = _ref;
  if (animation) {
    return {
      name: `${prefixCls}-${animation}`
    };
  }
  if (transitionName2) {
    return {
      name: transitionName2
    };
  }
  return {};
}
function Mask$1(props2) {
  const {
    prefixCls,
    visible,
    zIndex,
    mask,
    maskAnimation,
    maskTransitionName
  } = props2;
  if (!mask) {
    return null;
  }
  let motion = {};
  if (maskTransitionName || maskAnimation) {
    motion = getMotion$1({
      prefixCls,
      transitionName: maskTransitionName,
      animation: maskAnimation
    });
  }
  return createVNode(Transition, _objectSpread2$1({
    "appear": true
  }, motion), {
    default: () => [withDirectives(createVNode("div", {
      "style": {
        zIndex
      },
      "class": `${prefixCls}-mask`
    }, null), [[resolveDirective("if"), visible]])]
  });
}
Mask$1.displayName = "Mask";
const MobilePopupInner = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "MobilePopupInner",
  inheritAttrs: false,
  props: mobileProps,
  emits: ["mouseenter", "mouseleave", "mousedown", "touchstart", "align"],
  setup(props2, _ref) {
    let {
      expose,
      slots
    } = _ref;
    const elementRef = ref();
    expose({
      forceAlign: () => {
      },
      getElement: () => elementRef.value
    });
    return () => {
      var _a2;
      const {
        zIndex,
        visible,
        prefixCls,
        mobile: {
          popupClassName,
          popupStyle,
          popupMotion = {},
          popupRender
        } = {}
      } = props2;
      const mergedStyle = _extends$1({
        zIndex
      }, popupStyle);
      let childNode = flattenChildren((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots));
      if (childNode.length > 1) {
        childNode = createVNode("div", {
          "class": `${prefixCls}-content`
        }, [childNode]);
      }
      if (popupRender) {
        childNode = popupRender(childNode);
      }
      const mergedClassName = classNames(prefixCls, popupClassName);
      return createVNode(Transition, _objectSpread2$1({
        "ref": elementRef
      }, popupMotion), {
        default: () => [visible ? createVNode("div", {
          "class": mergedClassName,
          "style": mergedStyle
        }, [childNode]) : null]
      });
    };
  }
});
var __awaiter$3 = function(thisArg, _arguments, P2, generator2) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator2.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator2["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator2 = generator2.apply(thisArg, _arguments || [])).next());
  });
};
const StatusQueue = ["measure", "align", null, "motion"];
const useVisibleStatus = (visible, doMeasure) => {
  const status = shallowRef(null);
  const rafRef = shallowRef();
  const destroyRef = shallowRef(false);
  function setStatus(nextStatus) {
    if (!destroyRef.value) {
      status.value = nextStatus;
    }
  }
  function cancelRaf() {
    wrapperRaf.cancel(rafRef.value);
  }
  function goNextStatus(callback) {
    cancelRaf();
    rafRef.value = wrapperRaf(() => {
      let newStatus = status.value;
      switch (status.value) {
        case "align":
          newStatus = "motion";
          break;
        case "motion":
          newStatus = "stable";
          break;
      }
      setStatus(newStatus);
      callback === null || callback === void 0 ? void 0 : callback();
    });
  }
  watch(visible, () => {
    setStatus("measure");
  }, {
    immediate: true,
    flush: "post"
  });
  onMounted(() => {
    watch(status, () => {
      switch (status.value) {
        case "measure":
          doMeasure();
          break;
      }
      if (status.value) {
        rafRef.value = wrapperRaf(() => __awaiter$3(void 0, void 0, void 0, function* () {
          const index2 = StatusQueue.indexOf(status.value);
          const nextStatus = StatusQueue[index2 + 1];
          if (nextStatus && index2 !== -1) {
            setStatus(nextStatus);
          }
        }));
      }
    }, {
      immediate: true,
      flush: "post"
    });
  });
  onBeforeUnmount(() => {
    destroyRef.value = true;
    cancelRaf();
  });
  return [status, goNextStatus];
};
const useStretchStyle = (stretch) => {
  const targetSize = shallowRef({
    width: 0,
    height: 0
  });
  function measureStretch(element) {
    targetSize.value = {
      width: element.offsetWidth,
      height: element.offsetHeight
    };
  }
  const style = computed(() => {
    const sizeStyle = {};
    if (stretch.value) {
      const {
        width,
        height
      } = targetSize.value;
      if (stretch.value.indexOf("height") !== -1 && height) {
        sizeStyle.height = `${height}px`;
      } else if (stretch.value.indexOf("minHeight") !== -1 && height) {
        sizeStyle.minHeight = `${height}px`;
      }
      if (stretch.value.indexOf("width") !== -1 && width) {
        sizeStyle.width = `${width}px`;
      } else if (stretch.value.indexOf("minWidth") !== -1 && width) {
        sizeStyle.minWidth = `${width}px`;
      }
    }
    return sizeStyle;
  });
  return [style, measureStretch];
};
function ownKeys(object4, enumerableOnly) {
  var keys2 = Object.keys(object4);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object4);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys(Object(source), true).forEach(function(key2) {
      _defineProperty(target, key2, source[key2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key2) {
      Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
    });
  }
  return target;
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
function _defineProperty(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var vendorPrefix;
var jsCssMap = {
  Webkit: "-webkit-",
  Moz: "-moz-",
  // IE did it wrong again ...
  ms: "-ms-",
  O: "-o-"
};
function getVendorPrefix() {
  if (vendorPrefix !== void 0) {
    return vendorPrefix;
  }
  vendorPrefix = "";
  var style = document.createElement("p").style;
  var testProp = "Transform";
  for (var key2 in jsCssMap) {
    if (key2 + testProp in style) {
      vendorPrefix = key2;
    }
  }
  return vendorPrefix;
}
function getTransitionName$1() {
  return getVendorPrefix() ? "".concat(getVendorPrefix(), "TransitionProperty") : "transitionProperty";
}
function getTransformName() {
  return getVendorPrefix() ? "".concat(getVendorPrefix(), "Transform") : "transform";
}
function setTransitionProperty(node2, value) {
  var name = getTransitionName$1();
  if (name) {
    node2.style[name] = value;
    if (name !== "transitionProperty") {
      node2.style.transitionProperty = value;
    }
  }
}
function setTransform(node2, value) {
  var name = getTransformName();
  if (name) {
    node2.style[name] = value;
    if (name !== "transform") {
      node2.style.transform = value;
    }
  }
}
function getTransitionProperty(node2) {
  return node2.style.transitionProperty || node2.style[getTransitionName$1()];
}
function getTransformXY(node2) {
  var style = window.getComputedStyle(node2, null);
  var transform = style.getPropertyValue("transform") || style.getPropertyValue(getTransformName());
  if (transform && transform !== "none") {
    var matrix = transform.replace(/[^0-9\-.,]/g, "").split(",");
    return {
      x: parseFloat(matrix[12] || matrix[4], 0),
      y: parseFloat(matrix[13] || matrix[5], 0)
    };
  }
  return {
    x: 0,
    y: 0
  };
}
var matrix2d = /matrix\((.*)\)/;
var matrix3d = /matrix3d\((.*)\)/;
function setTransformXY(node2, xy) {
  var style = window.getComputedStyle(node2, null);
  var transform = style.getPropertyValue("transform") || style.getPropertyValue(getTransformName());
  if (transform && transform !== "none") {
    var arr;
    var match2d = transform.match(matrix2d);
    if (match2d) {
      match2d = match2d[1];
      arr = match2d.split(",").map(function(item) {
        return parseFloat(item, 10);
      });
      arr[4] = xy.x;
      arr[5] = xy.y;
      setTransform(node2, "matrix(".concat(arr.join(","), ")"));
    } else {
      var match3d = transform.match(matrix3d)[1];
      arr = match3d.split(",").map(function(item) {
        return parseFloat(item, 10);
      });
      arr[12] = xy.x;
      arr[13] = xy.y;
      setTransform(node2, "matrix3d(".concat(arr.join(","), ")"));
    }
  } else {
    setTransform(node2, "translateX(".concat(xy.x, "px) translateY(").concat(xy.y, "px) translateZ(0)"));
  }
}
var RE_NUM = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source;
var getComputedStyleX;
function forceRelayout(elem) {
  var originalStyle = elem.style.display;
  elem.style.display = "none";
  elem.offsetHeight;
  elem.style.display = originalStyle;
}
function css(el, name, v2) {
  var value = v2;
  if (_typeof(name) === "object") {
    for (var i2 in name) {
      if (name.hasOwnProperty(i2)) {
        css(el, i2, name[i2]);
      }
    }
    return void 0;
  }
  if (typeof value !== "undefined") {
    if (typeof value === "number") {
      value = "".concat(value, "px");
    }
    el.style[name] = value;
    return void 0;
  }
  return getComputedStyleX(el, name);
}
function getClientPosition(elem) {
  var box2;
  var x2;
  var y2;
  var doc = elem.ownerDocument;
  var body = doc.body;
  var docElem = doc && doc.documentElement;
  box2 = elem.getBoundingClientRect();
  x2 = Math.floor(box2.left);
  y2 = Math.floor(box2.top);
  x2 -= docElem.clientLeft || body.clientLeft || 0;
  y2 -= docElem.clientTop || body.clientTop || 0;
  return {
    left: x2,
    top: y2
  };
}
function getScroll$1(w2, top) {
  var ret = w2["page".concat(top ? "Y" : "X", "Offset")];
  var method4 = "scroll".concat(top ? "Top" : "Left");
  if (typeof ret !== "number") {
    var d2 = w2.document;
    ret = d2.documentElement[method4];
    if (typeof ret !== "number") {
      ret = d2.body[method4];
    }
  }
  return ret;
}
function getScrollLeft(w2) {
  return getScroll$1(w2);
}
function getScrollTop(w2) {
  return getScroll$1(w2, true);
}
function getOffset$2(el) {
  var pos = getClientPosition(el);
  var doc = el.ownerDocument;
  var w2 = doc.defaultView || doc.parentWindow;
  pos.left += getScrollLeft(w2);
  pos.top += getScrollTop(w2);
  return pos;
}
function isWindow(obj) {
  return obj !== null && obj !== void 0 && obj == obj.window;
}
function getDocument(node2) {
  if (isWindow(node2)) {
    return node2.document;
  }
  if (node2.nodeType === 9) {
    return node2;
  }
  return node2.ownerDocument;
}
function _getComputedStyle(elem, name, cs) {
  var computedStyle = cs;
  var val = "";
  var d2 = getDocument(elem);
  computedStyle = computedStyle || d2.defaultView.getComputedStyle(elem, null);
  if (computedStyle) {
    val = computedStyle.getPropertyValue(name) || computedStyle[name];
  }
  return val;
}
var _RE_NUM_NO_PX = new RegExp("^(".concat(RE_NUM, ")(?!px)[a-z%]+$"), "i");
var RE_POS = /^(top|right|bottom|left)$/;
var CURRENT_STYLE = "currentStyle";
var RUNTIME_STYLE = "runtimeStyle";
var LEFT = "left";
var PX = "px";
function _getComputedStyleIE(elem, name) {
  var ret = elem[CURRENT_STYLE] && elem[CURRENT_STYLE][name];
  if (_RE_NUM_NO_PX.test(ret) && !RE_POS.test(name)) {
    var style = elem.style;
    var left = style[LEFT];
    var rsLeft = elem[RUNTIME_STYLE][LEFT];
    elem[RUNTIME_STYLE][LEFT] = elem[CURRENT_STYLE][LEFT];
    style[LEFT] = name === "fontSize" ? "1em" : ret || 0;
    ret = style.pixelLeft + PX;
    style[LEFT] = left;
    elem[RUNTIME_STYLE][LEFT] = rsLeft;
  }
  return ret === "" ? "auto" : ret;
}
if (typeof window !== "undefined") {
  getComputedStyleX = window.getComputedStyle ? _getComputedStyle : _getComputedStyleIE;
}
function getOffsetDirection(dir, option) {
  if (dir === "left") {
    return option.useCssRight ? "right" : dir;
  }
  return option.useCssBottom ? "bottom" : dir;
}
function oppositeOffsetDirection(dir) {
  if (dir === "left") {
    return "right";
  } else if (dir === "right") {
    return "left";
  } else if (dir === "top") {
    return "bottom";
  } else if (dir === "bottom") {
    return "top";
  }
}
function setLeftTop(elem, offset3, option) {
  if (css(elem, "position") === "static") {
    elem.style.position = "relative";
  }
  var presetH = -999;
  var presetV = -999;
  var horizontalProperty = getOffsetDirection("left", option);
  var verticalProperty = getOffsetDirection("top", option);
  var oppositeHorizontalProperty = oppositeOffsetDirection(horizontalProperty);
  var oppositeVerticalProperty = oppositeOffsetDirection(verticalProperty);
  if (horizontalProperty !== "left") {
    presetH = 999;
  }
  if (verticalProperty !== "top") {
    presetV = 999;
  }
  var originalTransition = "";
  var originalOffset = getOffset$2(elem);
  if ("left" in offset3 || "top" in offset3) {
    originalTransition = getTransitionProperty(elem) || "";
    setTransitionProperty(elem, "none");
  }
  if ("left" in offset3) {
    elem.style[oppositeHorizontalProperty] = "";
    elem.style[horizontalProperty] = "".concat(presetH, "px");
  }
  if ("top" in offset3) {
    elem.style[oppositeVerticalProperty] = "";
    elem.style[verticalProperty] = "".concat(presetV, "px");
  }
  forceRelayout(elem);
  var old = getOffset$2(elem);
  var originalStyle = {};
  for (var key2 in offset3) {
    if (offset3.hasOwnProperty(key2)) {
      var dir = getOffsetDirection(key2, option);
      var preset = key2 === "left" ? presetH : presetV;
      var off = originalOffset[key2] - old[key2];
      if (dir === key2) {
        originalStyle[dir] = preset + off;
      } else {
        originalStyle[dir] = preset - off;
      }
    }
  }
  css(elem, originalStyle);
  forceRelayout(elem);
  if ("left" in offset3 || "top" in offset3) {
    setTransitionProperty(elem, originalTransition);
  }
  var ret = {};
  for (var _key in offset3) {
    if (offset3.hasOwnProperty(_key)) {
      var _dir = getOffsetDirection(_key, option);
      var _off = offset3[_key] - originalOffset[_key];
      if (_key === _dir) {
        ret[_dir] = originalStyle[_dir] + _off;
      } else {
        ret[_dir] = originalStyle[_dir] - _off;
      }
    }
  }
  css(elem, ret);
}
function setTransform$1(elem, offset3) {
  var originalOffset = getOffset$2(elem);
  var originalXY = getTransformXY(elem);
  var resultXY = {
    x: originalXY.x,
    y: originalXY.y
  };
  if ("left" in offset3) {
    resultXY.x = originalXY.x + offset3.left - originalOffset.left;
  }
  if ("top" in offset3) {
    resultXY.y = originalXY.y + offset3.top - originalOffset.top;
  }
  setTransformXY(elem, resultXY);
}
function setOffset(elem, offset3, option) {
  if (option.ignoreShake) {
    var oriOffset = getOffset$2(elem);
    var oLeft = oriOffset.left.toFixed(0);
    var oTop = oriOffset.top.toFixed(0);
    var tLeft = offset3.left.toFixed(0);
    var tTop = offset3.top.toFixed(0);
    if (oLeft === tLeft && oTop === tTop) {
      return;
    }
  }
  if (option.useCssRight || option.useCssBottom) {
    setLeftTop(elem, offset3, option);
  } else if (option.useCssTransform && getTransformName() in document.body.style) {
    setTransform$1(elem, offset3);
  } else {
    setLeftTop(elem, offset3, option);
  }
}
function each(arr, fn) {
  for (var i2 = 0; i2 < arr.length; i2++) {
    fn(arr[i2]);
  }
}
function isBorderBoxFn(elem) {
  return getComputedStyleX(elem, "boxSizing") === "border-box";
}
var BOX_MODELS = ["margin", "border", "padding"];
var CONTENT_INDEX = -1;
var PADDING_INDEX = 2;
var BORDER_INDEX = 1;
var MARGIN_INDEX = 0;
function swap(elem, options, callback) {
  var old = {};
  var style = elem.style;
  var name;
  for (name in options) {
    if (options.hasOwnProperty(name)) {
      old[name] = style[name];
      style[name] = options[name];
    }
  }
  callback.call(elem);
  for (name in options) {
    if (options.hasOwnProperty(name)) {
      style[name] = old[name];
    }
  }
}
function getPBMWidth(elem, props2, which) {
  var value = 0;
  var prop;
  var j2;
  var i2;
  for (j2 = 0; j2 < props2.length; j2++) {
    prop = props2[j2];
    if (prop) {
      for (i2 = 0; i2 < which.length; i2++) {
        var cssProp = void 0;
        if (prop === "border") {
          cssProp = "".concat(prop).concat(which[i2], "Width");
        } else {
          cssProp = prop + which[i2];
        }
        value += parseFloat(getComputedStyleX(elem, cssProp)) || 0;
      }
    }
  }
  return value;
}
var domUtils = {
  getParent: function getParent(element) {
    var parent2 = element;
    do {
      if (parent2.nodeType === 11 && parent2.host) {
        parent2 = parent2.host;
      } else {
        parent2 = parent2.parentNode;
      }
    } while (parent2 && parent2.nodeType !== 1 && parent2.nodeType !== 9);
    return parent2;
  }
};
each(["Width", "Height"], function(name) {
  domUtils["doc".concat(name)] = function(refWin) {
    var d2 = refWin.document;
    return Math.max(
      // firefox chrome documentElement.scrollHeight< body.scrollHeight
      // ie standard mode : documentElement.scrollHeight> body.scrollHeight
      d2.documentElement["scroll".concat(name)],
      // quirks : documentElement.scrollHeight 最大等于可视窗口多一点？
      d2.body["scroll".concat(name)],
      domUtils["viewport".concat(name)](d2)
    );
  };
  domUtils["viewport".concat(name)] = function(win) {
    var prop = "client".concat(name);
    var doc = win.document;
    var body = doc.body;
    var documentElement = doc.documentElement;
    var documentElementProp = documentElement[prop];
    return doc.compatMode === "CSS1Compat" && documentElementProp || body && body[prop] || documentElementProp;
  };
});
function getWH(elem, name, ex) {
  var extra = ex;
  if (isWindow(elem)) {
    return name === "width" ? domUtils.viewportWidth(elem) : domUtils.viewportHeight(elem);
  } else if (elem.nodeType === 9) {
    return name === "width" ? domUtils.docWidth(elem) : domUtils.docHeight(elem);
  }
  var which = name === "width" ? ["Left", "Right"] : ["Top", "Bottom"];
  var borderBoxValue = name === "width" ? Math.floor(elem.getBoundingClientRect().width) : Math.floor(elem.getBoundingClientRect().height);
  var isBorderBox = isBorderBoxFn(elem);
  var cssBoxValue = 0;
  if (borderBoxValue === null || borderBoxValue === void 0 || borderBoxValue <= 0) {
    borderBoxValue = void 0;
    cssBoxValue = getComputedStyleX(elem, name);
    if (cssBoxValue === null || cssBoxValue === void 0 || Number(cssBoxValue) < 0) {
      cssBoxValue = elem.style[name] || 0;
    }
    cssBoxValue = Math.floor(parseFloat(cssBoxValue)) || 0;
  }
  if (extra === void 0) {
    extra = isBorderBox ? BORDER_INDEX : CONTENT_INDEX;
  }
  var borderBoxValueOrIsBorderBox = borderBoxValue !== void 0 || isBorderBox;
  var val = borderBoxValue || cssBoxValue;
  if (extra === CONTENT_INDEX) {
    if (borderBoxValueOrIsBorderBox) {
      return val - getPBMWidth(elem, ["border", "padding"], which);
    }
    return cssBoxValue;
  } else if (borderBoxValueOrIsBorderBox) {
    if (extra === BORDER_INDEX) {
      return val;
    }
    return val + (extra === PADDING_INDEX ? -getPBMWidth(elem, ["border"], which) : getPBMWidth(elem, ["margin"], which));
  }
  return cssBoxValue + getPBMWidth(elem, BOX_MODELS.slice(extra), which);
}
var cssShow = {
  position: "absolute",
  visibility: "hidden",
  display: "block"
};
function getWHIgnoreDisplay() {
  for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
    args[_key2] = arguments[_key2];
  }
  var val;
  var elem = args[0];
  if (elem.offsetWidth !== 0) {
    val = getWH.apply(void 0, args);
  } else {
    swap(elem, cssShow, function() {
      val = getWH.apply(void 0, args);
    });
  }
  return val;
}
each(["width", "height"], function(name) {
  var first = name.charAt(0).toUpperCase() + name.slice(1);
  domUtils["outer".concat(first)] = function(el, includeMargin) {
    return el && getWHIgnoreDisplay(el, name, includeMargin ? MARGIN_INDEX : BORDER_INDEX);
  };
  var which = name === "width" ? ["Left", "Right"] : ["Top", "Bottom"];
  domUtils[name] = function(elem, v2) {
    var val = v2;
    if (val !== void 0) {
      if (elem) {
        var isBorderBox = isBorderBoxFn(elem);
        if (isBorderBox) {
          val += getPBMWidth(elem, ["padding", "border"], which);
        }
        return css(elem, name, val);
      }
      return void 0;
    }
    return elem && getWHIgnoreDisplay(elem, name, CONTENT_INDEX);
  };
});
function mix(to, from2) {
  for (var i2 in from2) {
    if (from2.hasOwnProperty(i2)) {
      to[i2] = from2[i2];
    }
  }
  return to;
}
var utils = {
  getWindow: function getWindow(node2) {
    if (node2 && node2.document && node2.setTimeout) {
      return node2;
    }
    var doc = node2.ownerDocument || node2;
    return doc.defaultView || doc.parentWindow;
  },
  getDocument,
  offset: function offset(el, value, option) {
    if (typeof value !== "undefined") {
      setOffset(el, value, option || {});
    } else {
      return getOffset$2(el);
    }
  },
  isWindow,
  each,
  css,
  clone: function clone(obj) {
    var i2;
    var ret = {};
    for (i2 in obj) {
      if (obj.hasOwnProperty(i2)) {
        ret[i2] = obj[i2];
      }
    }
    var overflow = obj.overflow;
    if (overflow) {
      for (i2 in obj) {
        if (obj.hasOwnProperty(i2)) {
          ret.overflow[i2] = obj.overflow[i2];
        }
      }
    }
    return ret;
  },
  mix,
  getWindowScrollLeft: function getWindowScrollLeft(w2) {
    return getScrollLeft(w2);
  },
  getWindowScrollTop: function getWindowScrollTop(w2) {
    return getScrollTop(w2);
  },
  merge: function merge2() {
    var ret = {};
    for (var i2 = 0; i2 < arguments.length; i2++) {
      utils.mix(ret, i2 < 0 || arguments.length <= i2 ? void 0 : arguments[i2]);
    }
    return ret;
  },
  viewportWidth: 0,
  viewportHeight: 0
};
mix(utils, domUtils);
var getParent$1 = utils.getParent;
function getOffsetParent(element) {
  if (utils.isWindow(element) || element.nodeType === 9) {
    return null;
  }
  var doc = utils.getDocument(element);
  var body = doc.body;
  var parent2;
  var positionStyle = utils.css(element, "position");
  var skipStatic = positionStyle === "fixed" || positionStyle === "absolute";
  if (!skipStatic) {
    return element.nodeName.toLowerCase() === "html" ? null : getParent$1(element);
  }
  for (parent2 = getParent$1(element); parent2 && parent2 !== body && parent2.nodeType !== 9; parent2 = getParent$1(parent2)) {
    positionStyle = utils.css(parent2, "position");
    if (positionStyle !== "static") {
      return parent2;
    }
  }
  return null;
}
var getParent$1$1 = utils.getParent;
function isAncestorFixed(element) {
  if (utils.isWindow(element) || element.nodeType === 9) {
    return false;
  }
  var doc = utils.getDocument(element);
  var body = doc.body;
  var parent2 = null;
  for (
    parent2 = getParent$1$1(element);
    // 修复元素位于 document.documentElement 下导致崩溃问题
    parent2 && parent2 !== body && parent2 !== doc;
    parent2 = getParent$1$1(parent2)
  ) {
    var positionStyle = utils.css(parent2, "position");
    if (positionStyle === "fixed") {
      return true;
    }
  }
  return false;
}
function getVisibleRectForElement(element, alwaysByViewport) {
  var visibleRect = {
    left: 0,
    right: Infinity,
    top: 0,
    bottom: Infinity
  };
  var el = getOffsetParent(element);
  var doc = utils.getDocument(element);
  var win = doc.defaultView || doc.parentWindow;
  var body = doc.body;
  var documentElement = doc.documentElement;
  while (el) {
    if ((navigator.userAgent.indexOf("MSIE") === -1 || el.clientWidth !== 0) && // body may have overflow set on it, yet we still get the entire
    // viewport. In some browsers, el.offsetParent may be
    // document.documentElement, so check for that too.
    el !== body && el !== documentElement && utils.css(el, "overflow") !== "visible") {
      var pos = utils.offset(el);
      pos.left += el.clientLeft;
      pos.top += el.clientTop;
      visibleRect.top = Math.max(visibleRect.top, pos.top);
      visibleRect.right = Math.min(
        visibleRect.right,
        // consider area without scrollBar
        pos.left + el.clientWidth
      );
      visibleRect.bottom = Math.min(visibleRect.bottom, pos.top + el.clientHeight);
      visibleRect.left = Math.max(visibleRect.left, pos.left);
    } else if (el === body || el === documentElement) {
      break;
    }
    el = getOffsetParent(el);
  }
  var originalPosition = null;
  if (!utils.isWindow(element) && element.nodeType !== 9) {
    originalPosition = element.style.position;
    var position2 = utils.css(element, "position");
    if (position2 === "absolute") {
      element.style.position = "fixed";
    }
  }
  var scrollX = utils.getWindowScrollLeft(win);
  var scrollY = utils.getWindowScrollTop(win);
  var viewportWidth = utils.viewportWidth(win);
  var viewportHeight = utils.viewportHeight(win);
  var documentWidth = documentElement.scrollWidth;
  var documentHeight = documentElement.scrollHeight;
  var bodyStyle = window.getComputedStyle(body);
  if (bodyStyle.overflowX === "hidden") {
    documentWidth = win.innerWidth;
  }
  if (bodyStyle.overflowY === "hidden") {
    documentHeight = win.innerHeight;
  }
  if (element.style) {
    element.style.position = originalPosition;
  }
  if (alwaysByViewport || isAncestorFixed(element)) {
    visibleRect.left = Math.max(visibleRect.left, scrollX);
    visibleRect.top = Math.max(visibleRect.top, scrollY);
    visibleRect.right = Math.min(visibleRect.right, scrollX + viewportWidth);
    visibleRect.bottom = Math.min(visibleRect.bottom, scrollY + viewportHeight);
  } else {
    var maxVisibleWidth = Math.max(documentWidth, scrollX + viewportWidth);
    visibleRect.right = Math.min(visibleRect.right, maxVisibleWidth);
    var maxVisibleHeight = Math.max(documentHeight, scrollY + viewportHeight);
    visibleRect.bottom = Math.min(visibleRect.bottom, maxVisibleHeight);
  }
  return visibleRect.top >= 0 && visibleRect.left >= 0 && visibleRect.bottom > visibleRect.top && visibleRect.right > visibleRect.left ? visibleRect : null;
}
function adjustForViewport(elFuturePos, elRegion, visibleRect, overflow) {
  var pos = utils.clone(elFuturePos);
  var size = {
    width: elRegion.width,
    height: elRegion.height
  };
  if (overflow.adjustX && pos.left < visibleRect.left) {
    pos.left = visibleRect.left;
  }
  if (overflow.resizeWidth && pos.left >= visibleRect.left && pos.left + size.width > visibleRect.right) {
    size.width -= pos.left + size.width - visibleRect.right;
  }
  if (overflow.adjustX && pos.left + size.width > visibleRect.right) {
    pos.left = Math.max(visibleRect.right - size.width, visibleRect.left);
  }
  if (overflow.adjustY && pos.top < visibleRect.top) {
    pos.top = visibleRect.top;
  }
  if (overflow.resizeHeight && pos.top >= visibleRect.top && pos.top + size.height > visibleRect.bottom) {
    size.height -= pos.top + size.height - visibleRect.bottom;
  }
  if (overflow.adjustY && pos.top + size.height > visibleRect.bottom) {
    pos.top = Math.max(visibleRect.bottom - size.height, visibleRect.top);
  }
  return utils.mix(pos, size);
}
function getRegion(node2) {
  var offset3;
  var w2;
  var h2;
  if (!utils.isWindow(node2) && node2.nodeType !== 9) {
    offset3 = utils.offset(node2);
    w2 = utils.outerWidth(node2);
    h2 = utils.outerHeight(node2);
  } else {
    var win = utils.getWindow(node2);
    offset3 = {
      left: utils.getWindowScrollLeft(win),
      top: utils.getWindowScrollTop(win)
    };
    w2 = utils.viewportWidth(win);
    h2 = utils.viewportHeight(win);
  }
  offset3.width = w2;
  offset3.height = h2;
  return offset3;
}
function getAlignOffset(region, align) {
  var V2 = align.charAt(0);
  var H = align.charAt(1);
  var w2 = region.width;
  var h2 = region.height;
  var x2 = region.left;
  var y2 = region.top;
  if (V2 === "c") {
    y2 += h2 / 2;
  } else if (V2 === "b") {
    y2 += h2;
  }
  if (H === "c") {
    x2 += w2 / 2;
  } else if (H === "r") {
    x2 += w2;
  }
  return {
    left: x2,
    top: y2
  };
}
function getElFuturePos(elRegion, refNodeRegion, points, offset3, targetOffset2) {
  var p1 = getAlignOffset(refNodeRegion, points[1]);
  var p2 = getAlignOffset(elRegion, points[0]);
  var diff = [p2.left - p1.left, p2.top - p1.top];
  return {
    left: Math.round(elRegion.left - diff[0] + offset3[0] - targetOffset2[0]),
    top: Math.round(elRegion.top - diff[1] + offset3[1] - targetOffset2[1])
  };
}
function isFailX(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.left < visibleRect.left || elFuturePos.left + elRegion.width > visibleRect.right;
}
function isFailY(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.top < visibleRect.top || elFuturePos.top + elRegion.height > visibleRect.bottom;
}
function isCompleteFailX(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.left > visibleRect.right || elFuturePos.left + elRegion.width < visibleRect.left;
}
function isCompleteFailY(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.top > visibleRect.bottom || elFuturePos.top + elRegion.height < visibleRect.top;
}
function flip(points, reg, map) {
  var ret = [];
  utils.each(points, function(p) {
    ret.push(p.replace(reg, function(m2) {
      return map[m2];
    }));
  });
  return ret;
}
function flipOffset(offset3, index2) {
  offset3[index2] = -offset3[index2];
  return offset3;
}
function convertOffset(str, offsetLen) {
  var n2;
  if (/%$/.test(str)) {
    n2 = parseInt(str.substring(0, str.length - 1), 10) / 100 * offsetLen;
  } else {
    n2 = parseInt(str, 10);
  }
  return n2 || 0;
}
function normalizeOffset(offset3, el) {
  offset3[0] = convertOffset(offset3[0], el.width);
  offset3[1] = convertOffset(offset3[1], el.height);
}
function doAlign(el, tgtRegion, align, isTgtRegionVisible) {
  var points = align.points;
  var offset3 = align.offset || [0, 0];
  var targetOffset2 = align.targetOffset || [0, 0];
  var overflow = align.overflow;
  var source = align.source || el;
  offset3 = [].concat(offset3);
  targetOffset2 = [].concat(targetOffset2);
  overflow = overflow || {};
  var newOverflowCfg = {};
  var fail = 0;
  var alwaysByViewport = !!(overflow && overflow.alwaysByViewport);
  var visibleRect = getVisibleRectForElement(source, alwaysByViewport);
  var elRegion = getRegion(source);
  normalizeOffset(offset3, elRegion);
  normalizeOffset(targetOffset2, tgtRegion);
  var elFuturePos = getElFuturePos(elRegion, tgtRegion, points, offset3, targetOffset2);
  var newElRegion = utils.merge(elRegion, elFuturePos);
  if (visibleRect && (overflow.adjustX || overflow.adjustY) && isTgtRegionVisible) {
    if (overflow.adjustX) {
      if (isFailX(elFuturePos, elRegion, visibleRect)) {
        var newPoints = flip(points, /[lr]/gi, {
          l: "r",
          r: "l"
        });
        var newOffset = flipOffset(offset3, 0);
        var newTargetOffset = flipOffset(targetOffset2, 0);
        var newElFuturePos = getElFuturePos(elRegion, tgtRegion, newPoints, newOffset, newTargetOffset);
        if (!isCompleteFailX(newElFuturePos, elRegion, visibleRect)) {
          fail = 1;
          points = newPoints;
          offset3 = newOffset;
          targetOffset2 = newTargetOffset;
        }
      }
    }
    if (overflow.adjustY) {
      if (isFailY(elFuturePos, elRegion, visibleRect)) {
        var _newPoints = flip(points, /[tb]/gi, {
          t: "b",
          b: "t"
        });
        var _newOffset = flipOffset(offset3, 1);
        var _newTargetOffset = flipOffset(targetOffset2, 1);
        var _newElFuturePos = getElFuturePos(elRegion, tgtRegion, _newPoints, _newOffset, _newTargetOffset);
        if (!isCompleteFailY(_newElFuturePos, elRegion, visibleRect)) {
          fail = 1;
          points = _newPoints;
          offset3 = _newOffset;
          targetOffset2 = _newTargetOffset;
        }
      }
    }
    if (fail) {
      elFuturePos = getElFuturePos(elRegion, tgtRegion, points, offset3, targetOffset2);
      utils.mix(newElRegion, elFuturePos);
    }
    var isStillFailX = isFailX(elFuturePos, elRegion, visibleRect);
    var isStillFailY = isFailY(elFuturePos, elRegion, visibleRect);
    if (isStillFailX || isStillFailY) {
      var _newPoints2 = points;
      if (isStillFailX) {
        _newPoints2 = flip(points, /[lr]/gi, {
          l: "r",
          r: "l"
        });
      }
      if (isStillFailY) {
        _newPoints2 = flip(points, /[tb]/gi, {
          t: "b",
          b: "t"
        });
      }
      points = _newPoints2;
      offset3 = align.offset || [0, 0];
      targetOffset2 = align.targetOffset || [0, 0];
    }
    newOverflowCfg.adjustX = overflow.adjustX && isStillFailX;
    newOverflowCfg.adjustY = overflow.adjustY && isStillFailY;
    if (newOverflowCfg.adjustX || newOverflowCfg.adjustY) {
      newElRegion = adjustForViewport(elFuturePos, elRegion, visibleRect, newOverflowCfg);
    }
  }
  if (newElRegion.width !== elRegion.width) {
    utils.css(source, "width", utils.width(source) + newElRegion.width - elRegion.width);
  }
  if (newElRegion.height !== elRegion.height) {
    utils.css(source, "height", utils.height(source) + newElRegion.height - elRegion.height);
  }
  utils.offset(source, {
    left: newElRegion.left,
    top: newElRegion.top
  }, {
    useCssRight: align.useCssRight,
    useCssBottom: align.useCssBottom,
    useCssTransform: align.useCssTransform,
    ignoreShake: align.ignoreShake
  });
  return {
    points,
    offset: offset3,
    targetOffset: targetOffset2,
    overflow: newOverflowCfg
  };
}
function isOutOfVisibleRect(target, alwaysByViewport) {
  var visibleRect = getVisibleRectForElement(target, alwaysByViewport);
  var targetRegion = getRegion(target);
  return !visibleRect || targetRegion.left + targetRegion.width <= visibleRect.left || targetRegion.top + targetRegion.height <= visibleRect.top || targetRegion.left >= visibleRect.right || targetRegion.top >= visibleRect.bottom;
}
function alignElement(el, refNode, align) {
  var target = align.target || refNode;
  var refNodeRegion = getRegion(target);
  var isTargetNotOutOfVisible = !isOutOfVisibleRect(target, align.overflow && align.overflow.alwaysByViewport);
  return doAlign(el, refNodeRegion, align, isTargetNotOutOfVisible);
}
alignElement.__getOffsetParent = getOffsetParent;
alignElement.__getVisibleRectForElement = getVisibleRectForElement;
function alignPoint(el, tgtPoint, align) {
  var pageX;
  var pageY;
  var doc = utils.getDocument(el);
  var win = doc.defaultView || doc.parentWindow;
  var scrollX = utils.getWindowScrollLeft(win);
  var scrollY = utils.getWindowScrollTop(win);
  var viewportWidth = utils.viewportWidth(win);
  var viewportHeight = utils.viewportHeight(win);
  if ("pageX" in tgtPoint) {
    pageX = tgtPoint.pageX;
  } else {
    pageX = scrollX + tgtPoint.clientX;
  }
  if ("pageY" in tgtPoint) {
    pageY = tgtPoint.pageY;
  } else {
    pageY = scrollY + tgtPoint.clientY;
  }
  var tgtRegion = {
    left: pageX,
    top: pageY,
    width: 0,
    height: 0
  };
  var pointInView = pageX >= 0 && pageX <= scrollX + viewportWidth && pageY >= 0 && pageY <= scrollY + viewportHeight;
  var points = [align.points[0], "cc"];
  return doAlign(el, tgtRegion, _objectSpread2(_objectSpread2({}, align), {}, {
    points
  }), pointInView);
}
function cloneElement(vnode) {
  let nodeProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  let override = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  let mergeRef = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  let ele = vnode;
  if (Array.isArray(vnode)) {
    ele = filterEmpty(vnode)[0];
  }
  if (!ele) {
    return null;
  }
  const node2 = cloneVNode(ele, nodeProps, mergeRef);
  node2.props = override ? _extends$1(_extends$1({}, node2.props), nodeProps) : node2.props;
  warning$1(typeof node2.props.class !== "object");
  return node2;
}
function cloneVNodes(vnodes) {
  let nodeProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  let override = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  return vnodes.map((vnode) => cloneElement(vnode, nodeProps, override));
}
function triggerVNodeUpdate(vm, attrs, dom) {
  render(cloneVNode(vm, _extends$1({}, attrs)), dom);
}
const ensureValidVNode = (slot) => {
  return (slot || []).some((child) => {
    if (!isVNode(child)) return true;
    if (child.type === Comment) return false;
    if (child.type === Fragment && !ensureValidVNode(child.children)) return false;
    return true;
  }) ? slot : null;
};
function customRenderSlot(slots, name, props2, fallback) {
  var _a2;
  const slot = (_a2 = slots[name]) === null || _a2 === void 0 ? void 0 : _a2.call(slots, props2);
  if (ensureValidVNode(slot)) {
    return slot;
  }
  return fallback === null || fallback === void 0 ? void 0 : fallback();
}
const isVisible = (element) => {
  if (!element) {
    return false;
  }
  if (element.offsetParent) {
    return true;
  }
  if (element.getBBox) {
    const box2 = element.getBBox();
    if (box2.width || box2.height) {
      return true;
    }
  }
  if (element.getBoundingClientRect) {
    const box2 = element.getBoundingClientRect();
    if (box2.width || box2.height) {
      return true;
    }
  }
  return false;
};
function isSamePoint(prev2, next2) {
  if (prev2 === next2) return true;
  if (!prev2 || !next2) return false;
  if ("pageX" in next2 && "pageY" in next2) {
    return prev2.pageX === next2.pageX && prev2.pageY === next2.pageY;
  }
  if ("clientX" in next2 && "clientY" in next2) {
    return prev2.clientX === next2.clientX && prev2.clientY === next2.clientY;
  }
  return false;
}
function restoreFocus(activeElement, container) {
  if (activeElement !== document.activeElement && contains(container, activeElement) && typeof activeElement.focus === "function") {
    activeElement.focus();
  }
}
function monitorResize(element, callback) {
  let prevWidth = null;
  let prevHeight = null;
  function onResize(_ref) {
    let [{
      target
    }] = _ref;
    if (!document.documentElement.contains(target)) return;
    const {
      width,
      height
    } = target.getBoundingClientRect();
    const fixedWidth = Math.floor(width);
    const fixedHeight = Math.floor(height);
    if (prevWidth !== fixedWidth || prevHeight !== fixedHeight) {
      Promise.resolve().then(() => {
        callback({
          width: fixedWidth,
          height: fixedHeight
        });
      });
    }
    prevWidth = fixedWidth;
    prevHeight = fixedHeight;
  }
  const resizeObserver = new index$1(onResize);
  if (element) {
    resizeObserver.observe(element);
  }
  return () => {
    resizeObserver.disconnect();
  };
}
const useBuffer = (callback, buffer) => {
  let called = false;
  let timeout = null;
  function cancelTrigger() {
    clearTimeout(timeout);
  }
  function trigger(force) {
    if (!called || force === true) {
      if (callback() === false) {
        return;
      }
      called = true;
      cancelTrigger();
      timeout = setTimeout(() => {
        called = false;
      }, buffer.value);
    } else {
      cancelTrigger();
      timeout = setTimeout(() => {
        called = false;
        trigger();
      }, buffer.value);
    }
  }
  return [trigger, () => {
    called = false;
    cancelTrigger();
  }];
};
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
function assocIndexOf(array4, key2) {
  var length2 = array4.length;
  while (length2--) {
    if (eq(array4[length2][0], key2)) {
      return length2;
    }
  }
  return -1;
}
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key2) {
  var data = this.__data__, index2 = assocIndexOf(data, key2);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index2, 1);
  }
  --this.size;
  return true;
}
function listCacheGet(key2) {
  var data = this.__data__, index2 = assocIndexOf(data, key2);
  return index2 < 0 ? void 0 : data[index2][1];
}
function listCacheHas(key2) {
  return assocIndexOf(this.__data__, key2) > -1;
}
function listCacheSet(key2, value) {
  var data = this.__data__, index2 = assocIndexOf(data, key2);
  if (index2 < 0) {
    ++this.size;
    data.push([key2, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
function ListCache(entries) {
  var index2 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}
function stackDelete(key2) {
  var data = this.__data__, result = data["delete"](key2);
  this.size = data.size;
  return result;
}
function stackGet(key2) {
  return this.__data__.get(key2);
}
function stackHas(key2) {
  return this.__data__.has(key2);
}
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal || freeSelf || Function("return this")();
var Symbol$1 = root.Symbol;
var objectProto$f = Object.prototype;
var hasOwnProperty$c = objectProto$f.hasOwnProperty;
var nativeObjectToString$1 = objectProto$f.toString;
var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty$c.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e2) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var objectProto$e = Object.prototype;
var nativeObjectToString = objectProto$e.toString;
function objectToString(value) {
  return nativeObjectToString.call(value);
}
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
function isObject$1(value) {
  var type4 = typeof value;
  return value != null && (type4 == "object" || type4 == "function");
}
var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction(value) {
  if (!isObject$1(value)) {
    return false;
  }
  var tag = baseGetTag(value);
  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
}
var coreJsData = root["__core-js_shared__"];
var maskSrcKey = function() {
  var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid2 ? "Symbol(src)_1." + uid2 : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var funcProto$2 = Function.prototype;
var funcToString$2 = funcProto$2.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e2) {
    }
    try {
      return func + "";
    } catch (e2) {
    }
  }
  return "";
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto$1 = Function.prototype, objectProto$d = Object.prototype;
var funcToString$1 = funcProto$1.toString;
var hasOwnProperty$b = objectProto$d.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString$1.call(hasOwnProperty$b).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value) {
  if (!isObject$1(value) || isMasked(value)) {
    return false;
  }
  var pattern4 = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern4.test(toSource(value));
}
function getValue$3(object4, key2) {
  return object4 == null ? void 0 : object4[key2];
}
function getNative(object4, key2) {
  var value = getValue$3(object4, key2);
  return baseIsNative(value) ? value : void 0;
}
var Map$1 = getNative(root, "Map");
var nativeCreate = getNative(Object, "create");
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}
function hashDelete(key2) {
  var result = this.has(key2) && delete this.__data__[key2];
  this.size -= result ? 1 : 0;
  return result;
}
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$c = Object.prototype;
var hasOwnProperty$a = objectProto$c.hasOwnProperty;
function hashGet(key2) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key2];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$a.call(data, key2) ? data[key2] : void 0;
}
var objectProto$b = Object.prototype;
var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
function hashHas(key2) {
  var data = this.__data__;
  return nativeCreate ? data[key2] !== void 0 : hasOwnProperty$9.call(data, key2);
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet(key2, value) {
  var data = this.__data__;
  this.size += this.has(key2) ? 0 : 1;
  data[key2] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}
function Hash(entries) {
  var index2 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$1 || ListCache)(),
    "string": new Hash()
  };
}
function isKeyable(value) {
  var type4 = typeof value;
  return type4 == "string" || type4 == "number" || type4 == "symbol" || type4 == "boolean" ? value !== "__proto__" : value === null;
}
function getMapData(map, key2) {
  var data = map.__data__;
  return isKeyable(key2) ? data[typeof key2 == "string" ? "string" : "hash"] : data.map;
}
function mapCacheDelete(key2) {
  var result = getMapData(this, key2)["delete"](key2);
  this.size -= result ? 1 : 0;
  return result;
}
function mapCacheGet(key2) {
  return getMapData(this, key2).get(key2);
}
function mapCacheHas(key2) {
  return getMapData(this, key2).has(key2);
}
function mapCacheSet(key2, value) {
  var data = getMapData(this, key2), size = data.size;
  data.set(key2, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
function MapCache(entries) {
  var index2 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
var LARGE_ARRAY_SIZE$1 = 200;
function stackSet(key2, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE$1 - 1) {
      pairs.push([key2, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key2, value);
  this.size = data.size;
  return this;
}
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
Stack.prototype.clear = stackClear;
Stack.prototype["delete"] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}
function setCacheHas(value) {
  return this.__data__.has(value);
}
function SetCache(values) {
  var index2 = -1, length2 = values == null ? 0 : values.length;
  this.__data__ = new MapCache();
  while (++index2 < length2) {
    this.add(values[index2]);
  }
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
function arraySome(array4, predicate) {
  var index2 = -1, length2 = array4 == null ? 0 : array4.length;
  while (++index2 < length2) {
    if (predicate(array4[index2], index2, array4)) {
      return true;
    }
  }
  return false;
}
function cacheHas(cache, key2) {
  return cache.has(key2);
}
var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
function equalArrays(array4, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array4.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array4);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array4;
  }
  var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
  stack.set(array4, other);
  stack.set(other, array4);
  while (++index2 < arrLength) {
    var arrValue = array4[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array4, stack) : customizer(arrValue, othValue, index2, array4, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome(other, function(othValue2, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array4);
  stack["delete"](other);
  return result;
}
var Uint8Array = root.Uint8Array;
function mapToArray(map) {
  var index2 = -1, result = Array(map.size);
  map.forEach(function(value, key2) {
    result[++index2] = [key2, value];
  });
  return result;
}
function setToArray(set2) {
  var index2 = -1, result = Array(set2.size);
  set2.forEach(function(value) {
    result[++index2] = value;
  });
  return result;
}
var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
var boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$2 = "[object Error]", mapTag$5 = "[object Map]", numberTag$4 = "[object Number]", regexpTag$3 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$3 = "[object String]", symbolTag$3 = "[object Symbol]";
var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]";
var symbolProto$2 = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : void 0;
function equalByTag(object4, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag$4:
      if (object4.byteLength != other.byteLength || object4.byteOffset != other.byteOffset) {
        return false;
      }
      object4 = object4.buffer;
      other = other.buffer;
    case arrayBufferTag$3:
      if (object4.byteLength != other.byteLength || !equalFunc(new Uint8Array(object4), new Uint8Array(other))) {
        return false;
      }
      return true;
    case boolTag$3:
    case dateTag$3:
    case numberTag$4:
      return eq(+object4, +other);
    case errorTag$2:
      return object4.name == other.name && object4.message == other.message;
    case regexpTag$3:
    case stringTag$3:
      return object4 == other + "";
    case mapTag$5:
      var convert = mapToArray;
    case setTag$5:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
      convert || (convert = setToArray);
      if (object4.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object4);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$2;
      stack.set(object4, other);
      var result = equalArrays(convert(object4), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object4);
      return result;
    case symbolTag$3:
      if (symbolValueOf$1) {
        return symbolValueOf$1.call(object4) == symbolValueOf$1.call(other);
      }
  }
  return false;
}
function arrayPush(array4, values) {
  var index2 = -1, length2 = values.length, offset3 = array4.length;
  while (++index2 < length2) {
    array4[offset3 + index2] = values[index2];
  }
  return array4;
}
var isArray = Array.isArray;
function baseGetAllKeys(object4, keysFunc, symbolsFunc) {
  var result = keysFunc(object4);
  return isArray(object4) ? result : arrayPush(result, symbolsFunc(object4));
}
function arrayFilter(array4, predicate) {
  var index2 = -1, length2 = array4 == null ? 0 : array4.length, resIndex = 0, result = [];
  while (++index2 < length2) {
    var value = array4[index2];
    if (predicate(value, index2, array4)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
function stubArray() {
  return [];
}
var objectProto$a = Object.prototype;
var propertyIsEnumerable$1 = objectProto$a.propertyIsEnumerable;
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object4) {
  if (object4 == null) {
    return [];
  }
  object4 = Object(object4);
  return arrayFilter(nativeGetSymbols$1(object4), function(symbol) {
    return propertyIsEnumerable$1.call(object4, symbol);
  });
};
function baseTimes(n2, iteratee) {
  var index2 = -1, result = Array(n2);
  while (++index2 < n2) {
    result[index2] = iteratee(index2);
  }
  return result;
}
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var argsTag$3 = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag$3;
}
var objectProto$9 = Object.prototype;
var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
var propertyIsEnumerable = objectProto$9.propertyIsEnumerable;
var isArguments = baseIsArguments(/* @__PURE__ */ function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty$8.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
};
function stubFalse() {
  return false;
}
var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
var Buffer$1 = moduleExports$2 ? root.Buffer : void 0;
var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse;
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length2) {
  var type4 = typeof value;
  length2 = length2 == null ? MAX_SAFE_INTEGER$1 : length2;
  return !!length2 && (type4 == "number" || type4 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
}
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
var argsTag$2 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", errorTag$1 = "[object Error]", funcTag$1 = "[object Function]", mapTag$4 = "[object Map]", numberTag$3 = "[object Number]", objectTag$4 = "[object Object]", regexpTag$2 = "[object RegExp]", setTag$4 = "[object Set]", stringTag$2 = "[object String]", weakMapTag$2 = "[object WeakMap]";
var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$3 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$2] = typedArrayTags[boolTag$2] = typedArrayTags[dataViewTag$3] = typedArrayTags[dateTag$2] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$4] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$2] = typedArrayTags[setTag$4] = typedArrayTags[stringTag$2] = typedArrayTags[weakMapTag$2] = false;
function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
var freeProcess = moduleExports$1 && freeGlobal.process;
var nodeUtil = function() {
  try {
    var types2 = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
    if (types2) {
      return types2;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e2) {
  }
}();
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
var objectProto$8 = Object.prototype;
var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
  for (var key2 in value) {
    if ((inherited || hasOwnProperty$7.call(value, key2)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key2 == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key2 == "offset" || key2 == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || // Skip index properties.
    isIndex(key2, length2)))) {
      result.push(key2);
    }
  }
  return result;
}
var objectProto$7 = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$7;
  return value === proto;
}
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var nativeKeys = overArg(Object.keys, Object);
var objectProto$6 = Object.prototype;
var hasOwnProperty$6 = objectProto$6.hasOwnProperty;
function baseKeys(object4) {
  if (!isPrototype(object4)) {
    return nativeKeys(object4);
  }
  var result = [];
  for (var key2 in Object(object4)) {
    if (hasOwnProperty$6.call(object4, key2) && key2 != "constructor") {
      result.push(key2);
    }
  }
  return result;
}
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}
function keys(object4) {
  return isArrayLike(object4) ? arrayLikeKeys(object4) : baseKeys(object4);
}
function getAllKeys(object4) {
  return baseGetAllKeys(object4, keys, getSymbols);
}
var COMPARE_PARTIAL_FLAG$3 = 1;
var objectProto$5 = Object.prototype;
var hasOwnProperty$5 = objectProto$5.hasOwnProperty;
function equalObjects(object4, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object4), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key2 = objProps[index2];
    if (!(isPartial ? key2 in other : hasOwnProperty$5.call(other, key2))) {
      return false;
    }
  }
  var objStacked = stack.get(object4);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object4;
  }
  var result = true;
  stack.set(object4, other);
  stack.set(other, object4);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key2 = objProps[index2];
    var objValue = object4[key2], othValue = other[key2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key2, other, object4, stack) : customizer(objValue, othValue, key2, object4, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key2 == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object4.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object4 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object4);
  stack["delete"](other);
  return result;
}
var DataView = getNative(root, "DataView");
var Promise$1 = getNative(root, "Promise");
var Set$1 = getNative(root, "Set");
var WeakMap$1 = getNative(root, "WeakMap");
var mapTag$3 = "[object Map]", objectTag$3 = "[object Object]", promiseTag = "[object Promise]", setTag$3 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
var dataViewTag$2 = "[object DataView]";
var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1);
var getTag = baseGetTag;
if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$2 || Map$1 && getTag(new Map$1()) != mapTag$3 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$3 || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag$1) {
  getTag = function(value) {
    var result = baseGetTag(value), Ctor = result == objectTag$3 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$2;
        case mapCtorString:
          return mapTag$3;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$3;
        case weakMapCtorString:
          return weakMapTag$1;
      }
    }
    return result;
  };
}
var COMPARE_PARTIAL_FLAG$2 = 1;
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", objectTag$2 = "[object Object]";
var objectProto$4 = Object.prototype;
var hasOwnProperty$4 = objectProto$4.hasOwnProperty;
function baseIsEqualDeep(object4, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object4), othIsArr = isArray(other), objTag = objIsArr ? arrayTag$1 : getTag(object4), othTag = othIsArr ? arrayTag$1 : getTag(other);
  objTag = objTag == argsTag$1 ? objectTag$2 : objTag;
  othTag = othTag == argsTag$1 ? objectTag$2 : othTag;
  var objIsObj = objTag == objectTag$2, othIsObj = othTag == objectTag$2, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer(object4)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray(object4) ? equalArrays(object4, other, bitmask, customizer, equalFunc, stack) : equalByTag(object4, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
    var objIsWrapped = objIsObj && hasOwnProperty$4.call(object4, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$4.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object4.value() : object4, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack());
  return equalObjects(object4, other, bitmask, customizer, equalFunc, stack);
}
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}
function isEqual$2(value, other) {
  return baseIsEqual(value, other);
}
const alignProps = {
  align: Object,
  target: [Object, Function],
  onAlign: Function,
  monitorBufferTime: Number,
  monitorWindowResize: Boolean,
  disabled: Boolean
};
function getElement(func) {
  if (typeof func !== "function") return null;
  return func();
}
function getPoint(point) {
  if (typeof point !== "object" || !point) return null;
  return point;
}
const Align = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Align",
  props: alignProps,
  emits: ["align"],
  setup(props2, _ref) {
    let {
      expose,
      slots
    } = _ref;
    const cacheRef = ref({});
    const nodeRef = ref();
    const [forceAlign, cancelForceAlign] = useBuffer(() => {
      const {
        disabled: latestDisabled,
        target: latestTarget,
        align: latestAlign,
        onAlign: latestOnAlign
      } = props2;
      if (!latestDisabled && latestTarget && nodeRef.value) {
        const source = nodeRef.value;
        let result;
        const element = getElement(latestTarget);
        const point = getPoint(latestTarget);
        cacheRef.value.element = element;
        cacheRef.value.point = point;
        cacheRef.value.align = latestAlign;
        const {
          activeElement
        } = document;
        if (element && isVisible(element)) {
          result = alignElement(source, element, latestAlign);
        } else if (point) {
          result = alignPoint(source, point, latestAlign);
        }
        restoreFocus(activeElement, source);
        if (latestOnAlign && result) {
          latestOnAlign(source, result);
        }
        return true;
      }
      return false;
    }, computed(() => props2.monitorBufferTime));
    const resizeMonitor = ref({
      cancel: () => {
      }
    });
    const sourceResizeMonitor = ref({
      cancel: () => {
      }
    });
    const goAlign = () => {
      const target = props2.target;
      const element = getElement(target);
      const point = getPoint(target);
      if (nodeRef.value !== sourceResizeMonitor.value.element) {
        sourceResizeMonitor.value.cancel();
        sourceResizeMonitor.value.element = nodeRef.value;
        sourceResizeMonitor.value.cancel = monitorResize(nodeRef.value, forceAlign);
      }
      if (cacheRef.value.element !== element || !isSamePoint(cacheRef.value.point, point) || !isEqual$2(cacheRef.value.align, props2.align)) {
        forceAlign();
        if (resizeMonitor.value.element !== element) {
          resizeMonitor.value.cancel();
          resizeMonitor.value.element = element;
          resizeMonitor.value.cancel = monitorResize(element, forceAlign);
        }
      }
    };
    onMounted(() => {
      nextTick(() => {
        goAlign();
      });
    });
    onUpdated(() => {
      nextTick(() => {
        goAlign();
      });
    });
    watch(() => props2.disabled, (disabled) => {
      if (!disabled) {
        forceAlign();
      } else {
        cancelForceAlign();
      }
    }, {
      immediate: true,
      flush: "post"
    });
    const winResizeRef = ref(null);
    watch(() => props2.monitorWindowResize, (monitorWindowResize) => {
      if (monitorWindowResize) {
        if (!winResizeRef.value) {
          winResizeRef.value = addEventListenerWrap(window, "resize", forceAlign);
        }
      } else if (winResizeRef.value) {
        winResizeRef.value.remove();
        winResizeRef.value = null;
      }
    }, {
      flush: "post"
    });
    onUnmounted(() => {
      resizeMonitor.value.cancel();
      sourceResizeMonitor.value.cancel();
      if (winResizeRef.value) winResizeRef.value.remove();
      cancelForceAlign();
    });
    expose({
      forceAlign: () => forceAlign(true)
    });
    return () => {
      const child = slots === null || slots === void 0 ? void 0 : slots.default();
      if (child) {
        return cloneElement(child[0], {
          ref: nodeRef
        }, true, true);
      }
      return null;
    };
  }
});
tuple$1("bottomLeft", "bottomRight", "topLeft", "topRight");
const getTransitionDirection = (placement) => {
  if (placement !== void 0 && (placement === "topLeft" || placement === "topRight")) {
    return `slide-down`;
  }
  return `slide-up`;
};
const getTransitionProps = function(transitionName2) {
  let opt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const transitionProps = transitionName2 ? _extends$1({
    name: transitionName2,
    appear: true,
    // type: 'animation',
    // appearFromClass: `${transitionName}-appear ${transitionName}-appear-prepare`,
    // appearActiveClass: `antdv-base-transtion`,
    // appearToClass: `${transitionName}-appear ${transitionName}-appear-active`,
    enterFromClass: `${transitionName2}-enter ${transitionName2}-enter-prepare ${transitionName2}-enter-start`,
    enterActiveClass: `${transitionName2}-enter ${transitionName2}-enter-prepare`,
    enterToClass: `${transitionName2}-enter ${transitionName2}-enter-active`,
    leaveFromClass: ` ${transitionName2}-leave`,
    leaveActiveClass: `${transitionName2}-leave ${transitionName2}-leave-active`,
    leaveToClass: `${transitionName2}-leave ${transitionName2}-leave-active`
  }, opt) : _extends$1({
    css: false
  }, opt);
  return transitionProps;
};
const getTransitionGroupProps = function(transitionName2) {
  let opt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const transitionProps = transitionName2 ? _extends$1({
    name: transitionName2,
    appear: true,
    // appearFromClass: `${transitionName}-appear ${transitionName}-appear-prepare`,
    appearActiveClass: `${transitionName2}`,
    appearToClass: `${transitionName2}-appear ${transitionName2}-appear-active`,
    enterFromClass: `${transitionName2}-appear ${transitionName2}-enter ${transitionName2}-appear-prepare ${transitionName2}-enter-prepare`,
    enterActiveClass: `${transitionName2}`,
    enterToClass: `${transitionName2}-enter ${transitionName2}-appear ${transitionName2}-appear-active ${transitionName2}-enter-active`,
    leaveActiveClass: `${transitionName2} ${transitionName2}-leave`,
    leaveToClass: `${transitionName2}-leave-active`
  }, opt) : _extends$1({
    css: false
  }, opt);
  return transitionProps;
};
const getTransitionName = (rootPrefixCls, motion, transitionName2) => {
  if (transitionName2 !== void 0) {
    return transitionName2;
  }
  return `${rootPrefixCls}-${motion}`;
};
const PopupInner = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "PopupInner",
  inheritAttrs: false,
  props: innerProps,
  emits: ["mouseenter", "mouseleave", "mousedown", "touchstart", "align"],
  setup(props2, _ref) {
    let {
      expose,
      attrs,
      slots
    } = _ref;
    const alignRef = shallowRef();
    const elementRef = shallowRef();
    const alignedClassName = shallowRef();
    const [stretchStyle, measureStretchStyle] = useStretchStyle(toRef(props2, "stretch"));
    const doMeasure = () => {
      if (props2.stretch) {
        measureStretchStyle(props2.getRootDomNode());
      }
    };
    const visible = shallowRef(false);
    let timeoutId;
    watch(() => props2.visible, (val) => {
      clearTimeout(timeoutId);
      if (val) {
        timeoutId = setTimeout(() => {
          visible.value = props2.visible;
        });
      } else {
        visible.value = false;
      }
    }, {
      immediate: true
    });
    const [status, goNextStatus] = useVisibleStatus(visible, doMeasure);
    const prepareResolveRef = shallowRef();
    const getAlignTarget = () => {
      if (props2.point) {
        return props2.point;
      }
      return props2.getRootDomNode;
    };
    const forceAlign = () => {
      var _a2;
      (_a2 = alignRef.value) === null || _a2 === void 0 ? void 0 : _a2.forceAlign();
    };
    const onInternalAlign = (popupDomNode, matchAlign) => {
      var _a2;
      const nextAlignedClassName = props2.getClassNameFromAlign(matchAlign);
      const preAlignedClassName = alignedClassName.value;
      if (alignedClassName.value !== nextAlignedClassName) {
        alignedClassName.value = nextAlignedClassName;
      }
      if (status.value === "align") {
        if (preAlignedClassName !== nextAlignedClassName) {
          Promise.resolve().then(() => {
            forceAlign();
          });
        } else {
          goNextStatus(() => {
            var _a3;
            (_a3 = prepareResolveRef.value) === null || _a3 === void 0 ? void 0 : _a3.call(prepareResolveRef);
          });
        }
        (_a2 = props2.onAlign) === null || _a2 === void 0 ? void 0 : _a2.call(props2, popupDomNode, matchAlign);
      }
    };
    const motion = computed(() => {
      const m2 = typeof props2.animation === "object" ? props2.animation : getMotion$1(props2);
      ["onAfterEnter", "onAfterLeave"].forEach((eventName) => {
        const originFn = m2[eventName];
        m2[eventName] = (node2) => {
          goNextStatus();
          status.value = "stable";
          originFn === null || originFn === void 0 ? void 0 : originFn(node2);
        };
      });
      return m2;
    });
    const onShowPrepare = () => {
      return new Promise((resolve) => {
        prepareResolveRef.value = resolve;
      });
    };
    watch([motion, status], () => {
      if (!motion.value && status.value === "motion") {
        goNextStatus();
      }
    }, {
      immediate: true
    });
    expose({
      forceAlign,
      getElement: () => {
        return elementRef.value.$el || elementRef.value;
      }
    });
    const alignDisabled = computed(() => {
      var _a2;
      if (((_a2 = props2.align) === null || _a2 === void 0 ? void 0 : _a2.points) && (status.value === "align" || status.value === "stable")) {
        return false;
      }
      return true;
    });
    return () => {
      var _a2;
      const {
        zIndex,
        align,
        prefixCls,
        destroyPopupOnHide,
        onMouseenter,
        onMouseleave,
        onTouchstart = () => {
        },
        onMousedown
      } = props2;
      const statusValue = status.value;
      const mergedStyle = [_extends$1(_extends$1({}, stretchStyle.value), {
        zIndex,
        opacity: statusValue === "motion" || statusValue === "stable" || !visible.value ? null : 0,
        // pointerEvents: statusValue === 'stable' ? null : 'none',
        pointerEvents: !visible.value && statusValue !== "stable" ? "none" : null
      }), attrs.style];
      let childNode = flattenChildren((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots, {
        visible: props2.visible
      }));
      if (childNode.length > 1) {
        childNode = createVNode("div", {
          "class": `${prefixCls}-content`
        }, [childNode]);
      }
      const mergedClassName = classNames(prefixCls, attrs.class, alignedClassName.value, !props2.arrow && `${prefixCls}-arrow-hidden`);
      const hasAnimate = visible.value || !props2.visible;
      const transitionProps = hasAnimate ? getTransitionProps(motion.value.name, motion.value) : {};
      return createVNode(Transition, _objectSpread2$1(_objectSpread2$1({
        "ref": elementRef
      }, transitionProps), {}, {
        "onBeforeEnter": onShowPrepare
      }), {
        default: () => {
          return !destroyPopupOnHide || props2.visible ? withDirectives(createVNode(Align, {
            "target": getAlignTarget(),
            "key": "popup",
            "ref": alignRef,
            "monitorWindowResize": true,
            "disabled": alignDisabled.value,
            "align": align,
            "onAlign": onInternalAlign
          }, {
            default: () => createVNode("div", {
              "class": mergedClassName,
              "onMouseenter": onMouseenter,
              "onMouseleave": onMouseleave,
              "onMousedown": withModifiers(onMousedown, ["capture"]),
              [supportsPassive ? "onTouchstartPassive" : "onTouchstart"]: withModifiers(onTouchstart, ["capture"]),
              "style": mergedStyle
            }, [childNode])
          }), [[vShow, visible.value]]) : null;
        }
      });
    };
  }
});
const Popup = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Popup",
  inheritAttrs: false,
  props: popupProps,
  setup(props2, _ref) {
    let {
      attrs,
      slots,
      expose
    } = _ref;
    const innerVisible = shallowRef(false);
    const inMobile = shallowRef(false);
    const popupRef = shallowRef();
    const rootRef = shallowRef();
    watch([() => props2.visible, () => props2.mobile], () => {
      innerVisible.value = props2.visible;
      if (props2.visible && props2.mobile) {
        inMobile.value = true;
      }
    }, {
      immediate: true,
      flush: "post"
    });
    expose({
      forceAlign: () => {
        var _a2;
        (_a2 = popupRef.value) === null || _a2 === void 0 ? void 0 : _a2.forceAlign();
      },
      getElement: () => {
        var _a2;
        return (_a2 = popupRef.value) === null || _a2 === void 0 ? void 0 : _a2.getElement();
      }
    });
    return () => {
      const cloneProps = _extends$1(_extends$1(_extends$1({}, props2), attrs), {
        visible: innerVisible.value
      });
      const popupNode = inMobile.value ? createVNode(MobilePopupInner, _objectSpread2$1(_objectSpread2$1({}, cloneProps), {}, {
        "mobile": props2.mobile,
        "ref": popupRef
      }), {
        default: slots.default
      }) : createVNode(PopupInner, _objectSpread2$1(_objectSpread2$1({}, cloneProps), {}, {
        "ref": popupRef
      }), {
        default: slots.default
      });
      return createVNode("div", {
        "ref": rootRef
      }, [createVNode(Mask$1, cloneProps, null), popupNode]);
    };
  }
});
function isPointsEq(a1, a2, isAlignPoint) {
  if (isAlignPoint) {
    return a1[0] === a2[0];
  }
  return a1[0] === a2[0] && a1[1] === a2[1];
}
function getAlignFromPlacement(builtinPlacements, placementStr, align) {
  const baseAlign = builtinPlacements[placementStr] || {};
  return _extends$1(_extends$1({}, baseAlign), align);
}
function getAlignPopupClassName(builtinPlacements, prefixCls, align, isAlignPoint) {
  const {
    points
  } = align;
  const placements2 = Object.keys(builtinPlacements);
  for (let i2 = 0; i2 < placements2.length; i2 += 1) {
    const placement = placements2[i2];
    if (isPointsEq(builtinPlacements[placement].points, points, isAlignPoint)) {
      return `${prefixCls}-placement-${placement}`;
    }
  }
  return "";
}
const BaseMixin = {
  methods: {
    setState() {
      let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      let callback = arguments.length > 1 ? arguments[1] : void 0;
      let newState = typeof state === "function" ? state(this.$data, this.$props) : state;
      if (this.getDerivedStateFromProps) {
        const s2 = this.getDerivedStateFromProps(getOptionProps(this), _extends$1(_extends$1({}, this.$data), newState));
        if (s2 === null) {
          return;
        } else {
          newState = _extends$1(_extends$1({}, newState), s2 || {});
        }
      }
      _extends$1(this.$data, newState);
      if (this._.isMounted) {
        this.$forceUpdate();
      }
      nextTick(() => {
        callback && callback();
      });
    },
    __emit() {
      const args = [].slice.call(arguments, 0);
      let eventName = args[0];
      eventName = `on${eventName[0].toUpperCase()}${eventName.substring(1)}`;
      const event = this.$props[eventName] || this.$attrs[eventName];
      if (args.length && event) {
        if (Array.isArray(event)) {
          for (let i2 = 0, l2 = event.length; i2 < l2; i2++) {
            event[i2](...args.slice(1));
          }
        } else {
          event(...args.slice(1));
        }
      }
    }
  }
};
const PortalContextKey = Symbol("PortalContextKey");
const useProvidePortal = function(instance) {
  let config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    inTriggerContext: true
  };
  provide(PortalContextKey, {
    inTriggerContext: config.inTriggerContext,
    shouldRender: computed(() => {
      const {
        sPopupVisible,
        popupRef,
        forceRender,
        autoDestroy
      } = instance || {};
      let shouldRender = false;
      if (sPopupVisible || popupRef || forceRender) {
        shouldRender = true;
      }
      if (!sPopupVisible && autoDestroy) {
        shouldRender = false;
      }
      return shouldRender;
    })
  });
};
const useInjectPortal = () => {
  useProvidePortal({}, {
    inTriggerContext: false
  });
  const portalContext = inject(PortalContextKey, {
    shouldRender: computed(() => false),
    inTriggerContext: false
  });
  return {
    shouldRender: computed(() => portalContext.shouldRender.value || portalContext.inTriggerContext === false)
  };
};
const Portal$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Portal",
  inheritAttrs: false,
  props: {
    getContainer: PropTypes.func.isRequired,
    didUpdate: Function
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    let isSSR = true;
    let container;
    const {
      shouldRender
    } = useInjectPortal();
    function setContainer() {
      if (shouldRender.value) {
        container = props2.getContainer();
      }
    }
    onBeforeMount(() => {
      isSSR = false;
      setContainer();
    });
    onMounted(() => {
      if (container) return;
      setContainer();
    });
    const stopWatch = watch(shouldRender, () => {
      if (shouldRender.value && !container) {
        container = props2.getContainer();
      }
      if (container) {
        stopWatch();
      }
    });
    onUpdated(() => {
      nextTick(() => {
        var _a2;
        if (shouldRender.value) {
          (_a2 = props2.didUpdate) === null || _a2 === void 0 ? void 0 : _a2.call(props2, props2);
        }
      });
    });
    return () => {
      var _a2;
      if (!shouldRender.value) return null;
      if (isSSR) {
        return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
      }
      return container ? createVNode(Teleport, {
        "to": container
      }, slots) : null;
    };
  }
});
let cached;
function getScrollBarSize(fresh) {
  if (typeof document === "undefined") {
    return 0;
  }
  if (cached === void 0) {
    const inner = document.createElement("div");
    inner.style.width = "100%";
    inner.style.height = "200px";
    const outer = document.createElement("div");
    const outerStyle = outer.style;
    outerStyle.position = "absolute";
    outerStyle.top = "0";
    outerStyle.left = "0";
    outerStyle.pointerEvents = "none";
    outerStyle.visibility = "hidden";
    outerStyle.width = "200px";
    outerStyle.height = "150px";
    outerStyle.overflow = "hidden";
    outer.appendChild(inner);
    document.body.appendChild(outer);
    const widthContained = inner.offsetWidth;
    outer.style.overflow = "scroll";
    let widthScroll = inner.offsetWidth;
    if (widthContained === widthScroll) {
      widthScroll = outer.clientWidth;
    }
    document.body.removeChild(outer);
    cached = widthContained - widthScroll;
  }
  return cached;
}
function ensureSize(str) {
  const match2 = str.match(/^(.*)px$/);
  const value = Number(match2 === null || match2 === void 0 ? void 0 : match2[1]);
  return Number.isNaN(value) ? getScrollBarSize() : value;
}
function getTargetScrollBarSize(target) {
  if (typeof document === "undefined" || !target || !(target instanceof Element)) {
    return {
      width: 0,
      height: 0
    };
  }
  const {
    width,
    height
  } = getComputedStyle(target, "::-webkit-scrollbar");
  return {
    width: ensureSize(width),
    height: ensureSize(height)
  };
}
const UNIQUE_ID = `vc-util-locker-${Date.now()}`;
let uuid$5 = 0;
function isBodyOverflowing() {
  return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight) && window.innerWidth > document.body.offsetWidth;
}
function useScrollLocker(lock) {
  const mergedLock = computed(() => !!lock && !!lock.value);
  uuid$5 += 1;
  const id = `${UNIQUE_ID}_${uuid$5}`;
  watchEffect((onClear) => {
    if (!canUseDom()) {
      return;
    }
    if (mergedLock.value) {
      const scrollbarSize = getScrollBarSize();
      const isOverflow = isBodyOverflowing();
      updateCSS(`
html body {
  overflow-y: hidden;
  ${isOverflow ? `width: calc(100% - ${scrollbarSize}px);` : ""}
}`, id);
    } else {
      removeCSS(id);
    }
    onClear(() => {
      removeCSS(id);
    });
  }, {
    flush: "post"
  });
}
let openCount = 0;
const supportDom = canUseDom();
const getParent2 = (getContainer2) => {
  if (!supportDom) {
    return null;
  }
  if (getContainer2) {
    if (typeof getContainer2 === "string") {
      return document.querySelectorAll(getContainer2)[0];
    }
    if (typeof getContainer2 === "function") {
      return getContainer2();
    }
    if (typeof getContainer2 === "object" && getContainer2 instanceof window.HTMLElement) {
      return getContainer2;
    }
  }
  return document.body;
};
const Portal = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "PortalWrapper",
  inheritAttrs: false,
  props: {
    wrapperClassName: String,
    forceRender: {
      type: Boolean,
      default: void 0
    },
    getContainer: PropTypes.any,
    visible: {
      type: Boolean,
      default: void 0
    },
    autoLock: booleanType(),
    didUpdate: Function
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const container = shallowRef();
    const componentRef = shallowRef();
    const rafId = shallowRef();
    const triggerUpdate = shallowRef(1);
    const defaultContainer2 = canUseDom() && document.createElement("div");
    const removeCurrentContainer = () => {
      var _a2, _b;
      if (container.value === defaultContainer2) {
        (_b = (_a2 = container.value) === null || _a2 === void 0 ? void 0 : _a2.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(container.value);
      }
      container.value = null;
    };
    let parent2 = null;
    const attachToParent = function() {
      let force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      if (force || container.value && !container.value.parentNode) {
        parent2 = getParent2(props2.getContainer);
        if (parent2) {
          parent2.appendChild(container.value);
          return true;
        }
        return false;
      }
      return true;
    };
    const getContainer2 = () => {
      if (!supportDom) {
        return null;
      }
      if (!container.value) {
        container.value = defaultContainer2;
        attachToParent(true);
      }
      setWrapperClassName();
      return container.value;
    };
    const setWrapperClassName = () => {
      const {
        wrapperClassName
      } = props2;
      if (container.value && wrapperClassName && wrapperClassName !== container.value.className) {
        container.value.className = wrapperClassName;
      }
    };
    onUpdated(() => {
      setWrapperClassName();
      attachToParent();
    });
    useScrollLocker(computed(() => {
      return props2.autoLock && props2.visible && canUseDom() && (container.value === document.body || container.value === defaultContainer2);
    }));
    onMounted(() => {
      let init = false;
      watch([() => props2.visible, () => props2.getContainer], (_ref2, _ref3) => {
        let [visible, getContainer22] = _ref2;
        let [prevVisible, prevGetContainer] = _ref3;
        if (supportDom) {
          parent2 = getParent2(props2.getContainer);
          if (parent2 === document.body) {
            if (visible && !prevVisible) {
              openCount += 1;
            } else if (init) {
              openCount -= 1;
            }
          }
        }
        if (init) {
          const getContainerIsFunc = typeof getContainer22 === "function" && typeof prevGetContainer === "function";
          if (getContainerIsFunc ? getContainer22.toString() !== prevGetContainer.toString() : getContainer22 !== prevGetContainer) {
            removeCurrentContainer();
          }
        }
        init = true;
      }, {
        immediate: true,
        flush: "post"
      });
      nextTick(() => {
        if (!attachToParent()) {
          rafId.value = wrapperRaf(() => {
            triggerUpdate.value += 1;
          });
        }
      });
    });
    onBeforeUnmount(() => {
      const {
        visible
      } = props2;
      if (supportDom && parent2 === document.body) {
        openCount = visible && openCount ? openCount - 1 : openCount;
      }
      removeCurrentContainer();
      wrapperRaf.cancel(rafId.value);
    });
    return () => {
      const {
        forceRender,
        visible
      } = props2;
      let portal = null;
      const childProps = {
        getOpenCount: () => openCount,
        getContainer: getContainer2
      };
      if (triggerUpdate.value && (forceRender || visible || componentRef.value)) {
        portal = createVNode(Portal$1, {
          "getContainer": getContainer2,
          "ref": componentRef,
          "didUpdate": props2.didUpdate
        }, {
          default: () => {
            var _a2;
            return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots, childProps);
          }
        });
      }
      return portal;
    };
  }
});
const ALL_HANDLERS = ["onClick", "onMousedown", "onTouchstart", "onMouseenter", "onMouseleave", "onFocus", "onBlur", "onContextmenu"];
const Trigger = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Trigger",
  mixins: [BaseMixin],
  inheritAttrs: false,
  props: triggerProps(),
  setup(props2) {
    const align = computed(() => {
      const {
        popupPlacement,
        popupAlign,
        builtinPlacements
      } = props2;
      if (popupPlacement && builtinPlacements) {
        return getAlignFromPlacement(builtinPlacements, popupPlacement, popupAlign);
      }
      return popupAlign;
    });
    const popupRef = shallowRef(null);
    const setPopupRef = (val) => {
      popupRef.value = val;
    };
    return {
      vcTriggerContext: inject("vcTriggerContext", {}),
      popupRef,
      setPopupRef,
      triggerRef: shallowRef(null),
      align,
      focusTime: null,
      clickOutsideHandler: null,
      contextmenuOutsideHandler1: null,
      contextmenuOutsideHandler2: null,
      touchOutsideHandler: null,
      attachId: null,
      delayTimer: null,
      hasPopupMouseDown: false,
      preClickTime: null,
      preTouchTime: null,
      mouseDownTimeout: null,
      childOriginEvents: {}
    };
  },
  data() {
    const props2 = this.$props;
    let popupVisible;
    if (this.popupVisible !== void 0) {
      popupVisible = !!props2.popupVisible;
    } else {
      popupVisible = !!props2.defaultPopupVisible;
    }
    ALL_HANDLERS.forEach((h2) => {
      this[`fire${h2}`] = (e2) => {
        this.fireEvents(h2, e2);
      };
    });
    return {
      prevPopupVisible: popupVisible,
      sPopupVisible: popupVisible,
      point: null
    };
  },
  watch: {
    popupVisible(val) {
      if (val !== void 0) {
        this.prevPopupVisible = this.sPopupVisible;
        this.sPopupVisible = val;
      }
    }
  },
  created() {
    provide("vcTriggerContext", {
      onPopupMouseDown: this.onPopupMouseDown,
      onPopupMouseenter: this.onPopupMouseenter,
      onPopupMouseleave: this.onPopupMouseleave
    });
    useProvidePortal(this);
  },
  deactivated() {
    this.setPopupVisible(false);
  },
  mounted() {
    this.$nextTick(() => {
      this.updatedCal();
    });
  },
  updated() {
    this.$nextTick(() => {
      this.updatedCal();
    });
  },
  beforeUnmount() {
    this.clearDelayTimer();
    this.clearOutsideHandler();
    clearTimeout(this.mouseDownTimeout);
    wrapperRaf.cancel(this.attachId);
  },
  methods: {
    updatedCal() {
      const props2 = this.$props;
      const state = this.$data;
      if (state.sPopupVisible) {
        let currentDocument;
        if (!this.clickOutsideHandler && (this.isClickToHide() || this.isContextmenuToShow())) {
          currentDocument = props2.getDocument(this.getRootDomNode());
          this.clickOutsideHandler = addEventListenerWrap(currentDocument, "mousedown", this.onDocumentClick);
        }
        if (!this.touchOutsideHandler) {
          currentDocument = currentDocument || props2.getDocument(this.getRootDomNode());
          this.touchOutsideHandler = addEventListenerWrap(currentDocument, "touchstart", this.onDocumentClick, supportsPassive ? {
            passive: false
          } : false);
        }
        if (!this.contextmenuOutsideHandler1 && this.isContextmenuToShow()) {
          currentDocument = currentDocument || props2.getDocument(this.getRootDomNode());
          this.contextmenuOutsideHandler1 = addEventListenerWrap(currentDocument, "scroll", this.onContextmenuClose);
        }
        if (!this.contextmenuOutsideHandler2 && this.isContextmenuToShow()) {
          this.contextmenuOutsideHandler2 = addEventListenerWrap(window, "blur", this.onContextmenuClose);
        }
      } else {
        this.clearOutsideHandler();
      }
    },
    onMouseenter(e2) {
      const {
        mouseEnterDelay
      } = this.$props;
      this.fireEvents("onMouseenter", e2);
      this.delaySetPopupVisible(true, mouseEnterDelay, mouseEnterDelay ? null : e2);
    },
    onMouseMove(e2) {
      this.fireEvents("onMousemove", e2);
      this.setPoint(e2);
    },
    onMouseleave(e2) {
      this.fireEvents("onMouseleave", e2);
      this.delaySetPopupVisible(false, this.$props.mouseLeaveDelay);
    },
    onPopupMouseenter() {
      const {
        vcTriggerContext = {}
      } = this;
      if (vcTriggerContext.onPopupMouseenter) {
        vcTriggerContext.onPopupMouseenter();
      }
      this.clearDelayTimer();
    },
    onPopupMouseleave(e2) {
      var _a2;
      if (e2 && e2.relatedTarget && !e2.relatedTarget.setTimeout && contains((_a2 = this.popupRef) === null || _a2 === void 0 ? void 0 : _a2.getElement(), e2.relatedTarget)) {
        return;
      }
      if (this.isMouseLeaveToHide()) {
        this.delaySetPopupVisible(false, this.$props.mouseLeaveDelay);
      }
      const {
        vcTriggerContext = {}
      } = this;
      if (vcTriggerContext.onPopupMouseleave) {
        vcTriggerContext.onPopupMouseleave(e2);
      }
    },
    onFocus(e2) {
      this.fireEvents("onFocus", e2);
      this.clearDelayTimer();
      if (this.isFocusToShow()) {
        this.focusTime = Date.now();
        this.delaySetPopupVisible(true, this.$props.focusDelay);
      }
    },
    onMousedown(e2) {
      this.fireEvents("onMousedown", e2);
      this.preClickTime = Date.now();
    },
    onTouchstart(e2) {
      this.fireEvents("onTouchstart", e2);
      this.preTouchTime = Date.now();
    },
    onBlur(e2) {
      if (!contains(e2.target, e2.relatedTarget || document.activeElement)) {
        this.fireEvents("onBlur", e2);
        this.clearDelayTimer();
        if (this.isBlurToHide()) {
          this.delaySetPopupVisible(false, this.$props.blurDelay);
        }
      }
    },
    onContextmenu(e2) {
      e2.preventDefault();
      this.fireEvents("onContextmenu", e2);
      this.setPopupVisible(true, e2);
    },
    onContextmenuClose() {
      if (this.isContextmenuToShow()) {
        this.close();
      }
    },
    onClick(event) {
      this.fireEvents("onClick", event);
      if (this.focusTime) {
        let preTime;
        if (this.preClickTime && this.preTouchTime) {
          preTime = Math.min(this.preClickTime, this.preTouchTime);
        } else if (this.preClickTime) {
          preTime = this.preClickTime;
        } else if (this.preTouchTime) {
          preTime = this.preTouchTime;
        }
        if (Math.abs(preTime - this.focusTime) < 20) {
          return;
        }
        this.focusTime = 0;
      }
      this.preClickTime = 0;
      this.preTouchTime = 0;
      if (this.isClickToShow() && (this.isClickToHide() || this.isBlurToHide()) && event && event.preventDefault) {
        event.preventDefault();
      }
      if (event && event.domEvent) {
        event.domEvent.preventDefault();
      }
      const nextVisible = !this.$data.sPopupVisible;
      if (this.isClickToHide() && !nextVisible || nextVisible && this.isClickToShow()) {
        this.setPopupVisible(!this.$data.sPopupVisible, event);
      }
    },
    onPopupMouseDown() {
      const {
        vcTriggerContext = {}
      } = this;
      this.hasPopupMouseDown = true;
      clearTimeout(this.mouseDownTimeout);
      this.mouseDownTimeout = setTimeout(() => {
        this.hasPopupMouseDown = false;
      }, 0);
      if (vcTriggerContext.onPopupMouseDown) {
        vcTriggerContext.onPopupMouseDown(...arguments);
      }
    },
    onDocumentClick(event) {
      if (this.$props.mask && !this.$props.maskClosable) {
        return;
      }
      const target = event.target;
      const root2 = this.getRootDomNode();
      const popupNode = this.getPopupDomNode();
      if (
        // mousedown on the target should also close popup when action is contextMenu.
        // https://github.com/ant-design/ant-design/issues/29853
        (!contains(root2, target) || this.isContextMenuOnly()) && !contains(popupNode, target) && !this.hasPopupMouseDown
      ) {
        this.delaySetPopupVisible(false, 0.1);
      }
    },
    getPopupDomNode() {
      var _a2;
      return ((_a2 = this.popupRef) === null || _a2 === void 0 ? void 0 : _a2.getElement()) || null;
    },
    getRootDomNode() {
      var _a2, _b, _c, _d;
      const {
        getTriggerDOMNode
      } = this.$props;
      if (getTriggerDOMNode) {
        const domNode = ((_b = (_a2 = this.triggerRef) === null || _a2 === void 0 ? void 0 : _a2.$el) === null || _b === void 0 ? void 0 : _b.nodeName) === "#comment" ? null : findDOMNode(this.triggerRef);
        return findDOMNode(getTriggerDOMNode(domNode));
      }
      try {
        const domNode = ((_d = (_c = this.triggerRef) === null || _c === void 0 ? void 0 : _c.$el) === null || _d === void 0 ? void 0 : _d.nodeName) === "#comment" ? null : findDOMNode(this.triggerRef);
        if (domNode) {
          return domNode;
        }
      } catch (err) {
      }
      return findDOMNode(this);
    },
    handleGetPopupClassFromAlign(align) {
      const className = [];
      const props2 = this.$props;
      const {
        popupPlacement,
        builtinPlacements,
        prefixCls,
        alignPoint: alignPoint2,
        getPopupClassNameFromAlign
      } = props2;
      if (popupPlacement && builtinPlacements) {
        className.push(getAlignPopupClassName(builtinPlacements, prefixCls, align, alignPoint2));
      }
      if (getPopupClassNameFromAlign) {
        className.push(getPopupClassNameFromAlign(align));
      }
      return className.join(" ");
    },
    getPopupAlign() {
      const props2 = this.$props;
      const {
        popupPlacement,
        popupAlign,
        builtinPlacements
      } = props2;
      if (popupPlacement && builtinPlacements) {
        return getAlignFromPlacement(builtinPlacements, popupPlacement, popupAlign);
      }
      return popupAlign;
    },
    getComponent() {
      const mouseProps = {};
      if (this.isMouseEnterToShow()) {
        mouseProps.onMouseenter = this.onPopupMouseenter;
      }
      if (this.isMouseLeaveToHide()) {
        mouseProps.onMouseleave = this.onPopupMouseleave;
      }
      mouseProps.onMousedown = this.onPopupMouseDown;
      mouseProps[supportsPassive ? "onTouchstartPassive" : "onTouchstart"] = this.onPopupMouseDown;
      const {
        handleGetPopupClassFromAlign,
        getRootDomNode,
        $attrs
      } = this;
      const {
        prefixCls,
        destroyPopupOnHide,
        popupClassName,
        popupAnimation,
        popupTransitionName,
        popupStyle,
        mask,
        maskAnimation,
        maskTransitionName,
        zIndex,
        stretch,
        alignPoint: alignPoint2,
        mobile,
        arrow,
        forceRender
      } = this.$props;
      const {
        sPopupVisible,
        point
      } = this.$data;
      const popupProps2 = _extends$1(_extends$1({
        prefixCls,
        arrow,
        destroyPopupOnHide,
        visible: sPopupVisible,
        point: alignPoint2 ? point : null,
        align: this.align,
        animation: popupAnimation,
        getClassNameFromAlign: handleGetPopupClassFromAlign,
        stretch,
        getRootDomNode,
        mask,
        zIndex,
        transitionName: popupTransitionName,
        maskAnimation,
        maskTransitionName,
        class: popupClassName,
        style: popupStyle,
        onAlign: $attrs.onPopupAlign || noop$4
      }, mouseProps), {
        ref: this.setPopupRef,
        mobile,
        forceRender
      });
      return createVNode(Popup, popupProps2, {
        default: this.$slots.popup || (() => getComponent(this, "popup"))
      });
    },
    attachParent(popupContainer) {
      wrapperRaf.cancel(this.attachId);
      const {
        getPopupContainer,
        getDocument: getDocument2
      } = this.$props;
      const domNode = this.getRootDomNode();
      let mountNode;
      if (!getPopupContainer) {
        mountNode = getDocument2(this.getRootDomNode()).body;
      } else if (domNode || getPopupContainer.length === 0) {
        mountNode = getPopupContainer(domNode);
      }
      if (mountNode) {
        mountNode.appendChild(popupContainer);
      } else {
        this.attachId = wrapperRaf(() => {
          this.attachParent(popupContainer);
        });
      }
    },
    getContainer() {
      const {
        $props: props2
      } = this;
      const {
        getDocument: getDocument2
      } = props2;
      const popupContainer = getDocument2(this.getRootDomNode()).createElement("div");
      popupContainer.style.position = "absolute";
      popupContainer.style.top = "0";
      popupContainer.style.left = "0";
      popupContainer.style.width = "100%";
      this.attachParent(popupContainer);
      return popupContainer;
    },
    setPopupVisible(sPopupVisible, event) {
      const {
        alignPoint: alignPoint2,
        sPopupVisible: prevPopupVisible,
        onPopupVisibleChange
      } = this;
      this.clearDelayTimer();
      if (prevPopupVisible !== sPopupVisible) {
        if (!hasProp(this, "popupVisible")) {
          this.setState({
            sPopupVisible,
            prevPopupVisible
          });
        }
        onPopupVisibleChange && onPopupVisibleChange(sPopupVisible);
      }
      if (alignPoint2 && event && sPopupVisible) {
        this.setPoint(event);
      }
    },
    setPoint(point) {
      const {
        alignPoint: alignPoint2
      } = this.$props;
      if (!alignPoint2 || !point) return;
      this.setState({
        point: {
          pageX: point.pageX,
          pageY: point.pageY
        }
      });
    },
    handlePortalUpdate() {
      if (this.prevPopupVisible !== this.sPopupVisible) {
        this.afterPopupVisibleChange(this.sPopupVisible);
      }
    },
    delaySetPopupVisible(visible, delayS, event) {
      const delay = delayS * 1e3;
      this.clearDelayTimer();
      if (delay) {
        const point = event ? {
          pageX: event.pageX,
          pageY: event.pageY
        } : null;
        this.delayTimer = setTimeout(() => {
          this.setPopupVisible(visible, point);
          this.clearDelayTimer();
        }, delay);
      } else {
        this.setPopupVisible(visible, event);
      }
    },
    clearDelayTimer() {
      if (this.delayTimer) {
        clearTimeout(this.delayTimer);
        this.delayTimer = null;
      }
    },
    clearOutsideHandler() {
      if (this.clickOutsideHandler) {
        this.clickOutsideHandler.remove();
        this.clickOutsideHandler = null;
      }
      if (this.contextmenuOutsideHandler1) {
        this.contextmenuOutsideHandler1.remove();
        this.contextmenuOutsideHandler1 = null;
      }
      if (this.contextmenuOutsideHandler2) {
        this.contextmenuOutsideHandler2.remove();
        this.contextmenuOutsideHandler2 = null;
      }
      if (this.touchOutsideHandler) {
        this.touchOutsideHandler.remove();
        this.touchOutsideHandler = null;
      }
    },
    createTwoChains(event) {
      let fn = () => {
      };
      const events2 = getEvents(this);
      if (this.childOriginEvents[event] && events2[event]) {
        return this[`fire${event}`];
      }
      fn = this.childOriginEvents[event] || events2[event] || fn;
      return fn;
    },
    isClickToShow() {
      const {
        action,
        showAction
      } = this.$props;
      return action.indexOf("click") !== -1 || showAction.indexOf("click") !== -1;
    },
    isContextMenuOnly() {
      const {
        action
      } = this.$props;
      return action === "contextmenu" || action.length === 1 && action[0] === "contextmenu";
    },
    isContextmenuToShow() {
      const {
        action,
        showAction
      } = this.$props;
      return action.indexOf("contextmenu") !== -1 || showAction.indexOf("contextmenu") !== -1;
    },
    isClickToHide() {
      const {
        action,
        hideAction
      } = this.$props;
      return action.indexOf("click") !== -1 || hideAction.indexOf("click") !== -1;
    },
    isMouseEnterToShow() {
      const {
        action,
        showAction
      } = this.$props;
      return action.indexOf("hover") !== -1 || showAction.indexOf("mouseenter") !== -1;
    },
    isMouseLeaveToHide() {
      const {
        action,
        hideAction
      } = this.$props;
      return action.indexOf("hover") !== -1 || hideAction.indexOf("mouseleave") !== -1;
    },
    isFocusToShow() {
      const {
        action,
        showAction
      } = this.$props;
      return action.indexOf("focus") !== -1 || showAction.indexOf("focus") !== -1;
    },
    isBlurToHide() {
      const {
        action,
        hideAction
      } = this.$props;
      return action.indexOf("focus") !== -1 || hideAction.indexOf("blur") !== -1;
    },
    forcePopupAlign() {
      var _a2;
      if (this.$data.sPopupVisible) {
        (_a2 = this.popupRef) === null || _a2 === void 0 ? void 0 : _a2.forceAlign();
      }
    },
    fireEvents(type4, e2) {
      if (this.childOriginEvents[type4]) {
        this.childOriginEvents[type4](e2);
      }
      const event = this.$props[type4] || this.$attrs[type4];
      if (event) {
        event(e2);
      }
    },
    close() {
      this.setPopupVisible(false);
    }
  },
  render() {
    const {
      $attrs
    } = this;
    const children = filterEmpty(getSlot(this));
    const {
      alignPoint: alignPoint2,
      getPopupContainer
    } = this.$props;
    const child = children[0];
    this.childOriginEvents = getEvents(child);
    const newChildProps = {
      key: "trigger"
    };
    if (this.isContextmenuToShow()) {
      newChildProps.onContextmenu = this.onContextmenu;
    } else {
      newChildProps.onContextmenu = this.createTwoChains("onContextmenu");
    }
    if (this.isClickToHide() || this.isClickToShow()) {
      newChildProps.onClick = this.onClick;
      newChildProps.onMousedown = this.onMousedown;
      newChildProps[supportsPassive ? "onTouchstartPassive" : "onTouchstart"] = this.onTouchstart;
    } else {
      newChildProps.onClick = this.createTwoChains("onClick");
      newChildProps.onMousedown = this.createTwoChains("onMousedown");
      newChildProps[supportsPassive ? "onTouchstartPassive" : "onTouchstart"] = this.createTwoChains("onTouchstart");
    }
    if (this.isMouseEnterToShow()) {
      newChildProps.onMouseenter = this.onMouseenter;
      if (alignPoint2) {
        newChildProps.onMousemove = this.onMouseMove;
      }
    } else {
      newChildProps.onMouseenter = this.createTwoChains("onMouseenter");
    }
    if (this.isMouseLeaveToHide()) {
      newChildProps.onMouseleave = this.onMouseleave;
    } else {
      newChildProps.onMouseleave = this.createTwoChains("onMouseleave");
    }
    if (this.isFocusToShow() || this.isBlurToHide()) {
      newChildProps.onFocus = this.onFocus;
      newChildProps.onBlur = this.onBlur;
    } else {
      newChildProps.onFocus = this.createTwoChains("onFocus");
      newChildProps.onBlur = (e2) => {
        if (e2 && (!e2.relatedTarget || !contains(e2.target, e2.relatedTarget))) {
          this.createTwoChains("onBlur")(e2);
        }
      };
    }
    const childrenClassName = classNames(child && child.props && child.props.class, $attrs.class);
    if (childrenClassName) {
      newChildProps.class = childrenClassName;
    }
    const trigger = cloneElement(child, _extends$1(_extends$1({}, newChildProps), {
      ref: "triggerRef"
    }), true, true);
    const portal = createVNode(Portal, {
      "key": "portal",
      "getContainer": getPopupContainer && (() => getPopupContainer(this.getRootDomNode())),
      "didUpdate": this.handlePortalUpdate,
      "visible": this.$data.sPopupVisible
    }, {
      default: this.getComponent
    });
    return createVNode(Fragment, null, [trigger, portal]);
  }
});
var __rest$16 = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const getBuiltInPlacements = (dropdownMatchSelectWidth) => {
  const adjustX = dropdownMatchSelectWidth === true ? 0 : 1;
  return {
    bottomLeft: {
      points: ["tl", "bl"],
      offset: [0, 4],
      overflow: {
        adjustX,
        adjustY: 1
      }
    },
    bottomRight: {
      points: ["tr", "br"],
      offset: [0, 4],
      overflow: {
        adjustX,
        adjustY: 1
      }
    },
    topLeft: {
      points: ["bl", "tl"],
      offset: [0, -4],
      overflow: {
        adjustX,
        adjustY: 1
      }
    },
    topRight: {
      points: ["br", "tr"],
      offset: [0, -4],
      overflow: {
        adjustX,
        adjustY: 1
      }
    }
  };
};
const SelectTrigger = defineComponent({
  name: "SelectTrigger",
  inheritAttrs: false,
  props: {
    dropdownAlign: Object,
    visible: {
      type: Boolean,
      default: void 0
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    dropdownClassName: String,
    dropdownStyle: PropTypes.object,
    placement: String,
    empty: {
      type: Boolean,
      default: void 0
    },
    prefixCls: String,
    popupClassName: String,
    animation: String,
    transitionName: String,
    getPopupContainer: Function,
    dropdownRender: Function,
    containerWidth: Number,
    dropdownMatchSelectWidth: PropTypes.oneOfType([Number, Boolean]).def(true),
    popupElement: PropTypes.any,
    direction: String,
    getTriggerDOMNode: Function,
    onPopupVisibleChange: Function,
    onPopupMouseEnter: Function,
    onPopupFocusin: Function,
    onPopupFocusout: Function
  },
  setup(props2, _ref) {
    let {
      slots,
      attrs,
      expose
    } = _ref;
    const builtInPlacements = computed(() => {
      const {
        dropdownMatchSelectWidth
      } = props2;
      return getBuiltInPlacements(dropdownMatchSelectWidth);
    });
    const popupRef = ref();
    expose({
      getPopupElement: () => {
        return popupRef.value;
      }
    });
    return () => {
      const _a2 = _extends$1(_extends$1({}, props2), attrs), {
        empty: empty2 = false
      } = _a2, restProps = __rest$16(_a2, ["empty"]);
      const {
        visible,
        dropdownAlign,
        prefixCls,
        popupElement,
        dropdownClassName,
        dropdownStyle,
        direction = "ltr",
        placement,
        dropdownMatchSelectWidth,
        containerWidth,
        dropdownRender,
        animation,
        transitionName: transitionName2,
        getPopupContainer,
        getTriggerDOMNode,
        onPopupVisibleChange,
        onPopupMouseEnter,
        onPopupFocusin,
        onPopupFocusout
      } = restProps;
      const dropdownPrefixCls = `${prefixCls}-dropdown`;
      let popupNode = popupElement;
      if (dropdownRender) {
        popupNode = dropdownRender({
          menuNode: popupElement,
          props: props2
        });
      }
      const mergedTransitionName = animation ? `${dropdownPrefixCls}-${animation}` : transitionName2;
      const popupStyle = _extends$1({
        minWidth: `${containerWidth}px`
      }, dropdownStyle);
      if (typeof dropdownMatchSelectWidth === "number") {
        popupStyle.width = `${dropdownMatchSelectWidth}px`;
      } else if (dropdownMatchSelectWidth) {
        popupStyle.width = `${containerWidth}px`;
      }
      return createVNode(Trigger, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
        "showAction": onPopupVisibleChange ? ["click"] : [],
        "hideAction": onPopupVisibleChange ? ["click"] : [],
        "popupPlacement": placement || (direction === "rtl" ? "bottomRight" : "bottomLeft"),
        "builtinPlacements": builtInPlacements.value,
        "prefixCls": dropdownPrefixCls,
        "popupTransitionName": mergedTransitionName,
        "popupAlign": dropdownAlign,
        "popupVisible": visible,
        "getPopupContainer": getPopupContainer,
        "popupClassName": classNames(dropdownClassName, {
          [`${dropdownPrefixCls}-empty`]: empty2
        }),
        "popupStyle": popupStyle,
        "getTriggerDOMNode": getTriggerDOMNode,
        "onPopupVisibleChange": onPopupVisibleChange
      }), {
        default: slots.default,
        popup: () => createVNode("div", {
          "ref": popupRef,
          "onMouseenter": onPopupMouseEnter,
          "onFocusin": onPopupFocusin,
          "onFocusout": onPopupFocusout
        }, [popupNode])
      });
    };
  }
});
const KeyCode = {
  /**
   * MAC_ENTER
   */
  MAC_ENTER: 3,
  /**
   * BACKSPACE
   */
  BACKSPACE: 8,
  /**
   * TAB
   */
  TAB: 9,
  /**
   * NUMLOCK on FF/Safari Mac
   */
  NUM_CENTER: 12,
  /**
   * ENTER
   */
  ENTER: 13,
  /**
   * SHIFT
   */
  SHIFT: 16,
  /**
   * CTRL
   */
  CTRL: 17,
  /**
   * ALT
   */
  ALT: 18,
  /**
   * PAUSE
   */
  PAUSE: 19,
  /**
   * CAPS_LOCK
   */
  CAPS_LOCK: 20,
  /**
   * ESC
   */
  ESC: 27,
  /**
   * SPACE
   */
  SPACE: 32,
  /**
   * PAGE_UP
   */
  PAGE_UP: 33,
  /**
   * PAGE_DOWN
   */
  PAGE_DOWN: 34,
  /**
   * END
   */
  END: 35,
  /**
   * HOME
   */
  HOME: 36,
  /**
   * LEFT
   */
  LEFT: 37,
  /**
   * UP
   */
  UP: 38,
  /**
   * RIGHT
   */
  RIGHT: 39,
  /**
   * DOWN
   */
  DOWN: 40,
  /**
   * PRINT_SCREEN
   */
  PRINT_SCREEN: 44,
  /**
   * INSERT
   */
  INSERT: 45,
  /**
   * DELETE
   */
  DELETE: 46,
  /**
   * ZERO
   */
  ZERO: 48,
  /**
   * ONE
   */
  ONE: 49,
  /**
   * TWO
   */
  TWO: 50,
  /**
   * THREE
   */
  THREE: 51,
  /**
   * FOUR
   */
  FOUR: 52,
  /**
   * FIVE
   */
  FIVE: 53,
  /**
   * SIX
   */
  SIX: 54,
  /**
   * SEVEN
   */
  SEVEN: 55,
  /**
   * EIGHT
   */
  EIGHT: 56,
  /**
   * NINE
   */
  NINE: 57,
  /**
   * QUESTION_MARK
   */
  QUESTION_MARK: 63,
  /**
   * A
   */
  A: 65,
  /**
   * B
   */
  B: 66,
  /**
   * C
   */
  C: 67,
  /**
   * D
   */
  D: 68,
  /**
   * E
   */
  E: 69,
  /**
   * F
   */
  F: 70,
  /**
   * G
   */
  G: 71,
  /**
   * H
   */
  H: 72,
  /**
   * I
   */
  I: 73,
  /**
   * J
   */
  J: 74,
  /**
   * K
   */
  K: 75,
  /**
   * L
   */
  L: 76,
  /**
   * M
   */
  M: 77,
  /**
   * N
   */
  N: 78,
  /**
   * O
   */
  O: 79,
  /**
   * P
   */
  P: 80,
  /**
   * Q
   */
  Q: 81,
  /**
   * R
   */
  R: 82,
  /**
   * S
   */
  S: 83,
  /**
   * T
   */
  T: 84,
  /**
   * U
   */
  U: 85,
  /**
   * V
   */
  V: 86,
  /**
   * W
   */
  W: 87,
  /**
   * X
   */
  X: 88,
  /**
   * Y
   */
  Y: 89,
  /**
   * Z
   */
  Z: 90,
  /**
   * META
   */
  META: 91,
  /**
   * WIN_KEY_RIGHT
   */
  WIN_KEY_RIGHT: 92,
  /**
   * CONTEXT_MENU
   */
  CONTEXT_MENU: 93,
  /**
   * NUM_ZERO
   */
  NUM_ZERO: 96,
  /**
   * NUM_ONE
   */
  NUM_ONE: 97,
  /**
   * NUM_TWO
   */
  NUM_TWO: 98,
  /**
   * NUM_THREE
   */
  NUM_THREE: 99,
  /**
   * NUM_FOUR
   */
  NUM_FOUR: 100,
  /**
   * NUM_FIVE
   */
  NUM_FIVE: 101,
  /**
   * NUM_SIX
   */
  NUM_SIX: 102,
  /**
   * NUM_SEVEN
   */
  NUM_SEVEN: 103,
  /**
   * NUM_EIGHT
   */
  NUM_EIGHT: 104,
  /**
   * NUM_NINE
   */
  NUM_NINE: 105,
  /**
   * NUM_MULTIPLY
   */
  NUM_MULTIPLY: 106,
  /**
   * NUM_PLUS
   */
  NUM_PLUS: 107,
  /**
   * NUM_MINUS
   */
  NUM_MINUS: 109,
  /**
   * NUM_PERIOD
   */
  NUM_PERIOD: 110,
  /**
   * NUM_DIVISION
   */
  NUM_DIVISION: 111,
  /**
   * F1
   */
  F1: 112,
  /**
   * F2
   */
  F2: 113,
  /**
   * F3
   */
  F3: 114,
  /**
   * F4
   */
  F4: 115,
  /**
   * F5
   */
  F5: 116,
  /**
   * F6
   */
  F6: 117,
  /**
   * F7
   */
  F7: 118,
  /**
   * F8
   */
  F8: 119,
  /**
   * F9
   */
  F9: 120,
  /**
   * F10
   */
  F10: 121,
  /**
   * F11
   */
  F11: 122,
  /**
   * F12
   */
  F12: 123,
  /**
   * NUMLOCK
   */
  NUMLOCK: 144,
  /**
   * SEMICOLON
   */
  SEMICOLON: 186,
  /**
   * DASH
   */
  DASH: 189,
  /**
   * EQUALS
   */
  EQUALS: 187,
  /**
   * COMMA
   */
  COMMA: 188,
  /**
   * PERIOD
   */
  PERIOD: 190,
  /**
   * SLASH
   */
  SLASH: 191,
  /**
   * APOSTROPHE
   */
  APOSTROPHE: 192,
  /**
   * SINGLE_QUOTE
   */
  SINGLE_QUOTE: 222,
  /**
   * OPEN_SQUARE_BRACKET
   */
  OPEN_SQUARE_BRACKET: 219,
  /**
   * BACKSLASH
   */
  BACKSLASH: 220,
  /**
   * CLOSE_SQUARE_BRACKET
   */
  CLOSE_SQUARE_BRACKET: 221,
  /**
   * WIN_KEY
   */
  WIN_KEY: 224,
  /**
   * MAC_FF_META
   */
  MAC_FF_META: 224,
  /**
   * WIN_IME
   */
  WIN_IME: 229,
  // ======================== Function ========================
  /**
   * whether text and modified key is entered at the same time.
   */
  isTextModifyingKeyEvent: function isTextModifyingKeyEvent(e2) {
    const {
      keyCode
    } = e2;
    if (e2.altKey && !e2.ctrlKey || e2.metaKey || // Function keys don't generate text
    keyCode >= KeyCode.F1 && keyCode <= KeyCode.F12) {
      return false;
    }
    switch (keyCode) {
      case KeyCode.ALT:
      case KeyCode.CAPS_LOCK:
      case KeyCode.CONTEXT_MENU:
      case KeyCode.CTRL:
      case KeyCode.DOWN:
      case KeyCode.END:
      case KeyCode.ESC:
      case KeyCode.HOME:
      case KeyCode.INSERT:
      case KeyCode.LEFT:
      case KeyCode.MAC_FF_META:
      case KeyCode.META:
      case KeyCode.NUMLOCK:
      case KeyCode.NUM_CENTER:
      case KeyCode.PAGE_DOWN:
      case KeyCode.PAGE_UP:
      case KeyCode.PAUSE:
      case KeyCode.PRINT_SCREEN:
      case KeyCode.RIGHT:
      case KeyCode.SHIFT:
      case KeyCode.UP:
      case KeyCode.WIN_KEY:
      case KeyCode.WIN_KEY_RIGHT:
        return false;
      default:
        return true;
    }
  },
  /**
   * whether character is entered.
   */
  isCharacterKey: function isCharacterKey(keyCode) {
    if (keyCode >= KeyCode.ZERO && keyCode <= KeyCode.NINE) {
      return true;
    }
    if (keyCode >= KeyCode.NUM_ZERO && keyCode <= KeyCode.NUM_MULTIPLY) {
      return true;
    }
    if (keyCode >= KeyCode.A && keyCode <= KeyCode.Z) {
      return true;
    }
    if (window.navigator.userAgent.indexOf("WebKit") !== -1 && keyCode === 0) {
      return true;
    }
    switch (keyCode) {
      case KeyCode.SPACE:
      case KeyCode.QUESTION_MARK:
      case KeyCode.NUM_PLUS:
      case KeyCode.NUM_MINUS:
      case KeyCode.NUM_PERIOD:
      case KeyCode.NUM_DIVISION:
      case KeyCode.SEMICOLON:
      case KeyCode.DASH:
      case KeyCode.EQUALS:
      case KeyCode.COMMA:
      case KeyCode.PERIOD:
      case KeyCode.SLASH:
      case KeyCode.APOSTROPHE:
      case KeyCode.SINGLE_QUOTE:
      case KeyCode.OPEN_SQUARE_BRACKET:
      case KeyCode.BACKSLASH:
      case KeyCode.CLOSE_SQUARE_BRACKET:
        return true;
      default:
        return false;
    }
  }
};
const TransBtn = (props2, _ref) => {
  let {
    slots
  } = _ref;
  var _a2;
  const {
    class: className,
    customizeIcon,
    customizeIconProps,
    onMousedown,
    onClick
  } = props2;
  let icon;
  if (typeof customizeIcon === "function") {
    icon = customizeIcon(customizeIconProps);
  } else {
    icon = isVNode(customizeIcon) ? cloneVNode(customizeIcon) : customizeIcon;
  }
  return createVNode("span", {
    "class": className,
    "onMousedown": (event) => {
      event.preventDefault();
      if (onMousedown) {
        onMousedown(event);
      }
    },
    "style": {
      userSelect: "none",
      WebkitUserSelect: "none"
    },
    "unselectable": "on",
    "onClick": onClick,
    "aria-hidden": true
  }, [icon !== void 0 ? icon : createVNode("span", {
    "class": className.split(/\s+/).map((cls) => `${cls}-icon`)
  }, [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)])]);
};
TransBtn.inheritAttrs = false;
TransBtn.displayName = "TransBtn";
TransBtn.props = {
  class: String,
  customizeIcon: PropTypes.any,
  customizeIconProps: PropTypes.any,
  onMousedown: Function,
  onClick: Function
};
var __rest$15 = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const BaseInputInner = defineComponent({
  compatConfig: {
    MODE: 3
  },
  // inheritAttrs: false,
  props: {
    disabled: PropTypes.looseBool,
    type: PropTypes.string,
    value: PropTypes.any,
    tag: {
      type: String,
      default: "input"
    },
    size: PropTypes.string,
    onChange: Function,
    onInput: Function,
    onBlur: Function,
    onFocus: Function,
    onKeydown: Function,
    onCompositionstart: Function,
    onCompositionend: Function,
    onKeyup: Function,
    onPaste: Function,
    onMousedown: Function
  },
  emits: ["change", "input", "blur", "keydown", "focus", "compositionstart", "compositionend", "keyup", "paste", "mousedown"],
  setup(props2, _ref) {
    let {
      expose
    } = _ref;
    const inputRef = shallowRef(null);
    const focus = () => {
      if (inputRef.value) {
        inputRef.value.focus();
      }
    };
    const blur = () => {
      if (inputRef.value) {
        inputRef.value.blur();
      }
    };
    const setSelectionRange = (start, end, direction) => {
      var _a2;
      (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.setSelectionRange(start, end, direction);
    };
    const select = () => {
      var _a2;
      (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.select();
    };
    expose({
      focus,
      blur,
      input: inputRef,
      setSelectionRange,
      select,
      getSelectionStart: () => {
        var _a2;
        return (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.selectionStart;
      },
      getSelectionEnd: () => {
        var _a2;
        return (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.selectionEnd;
      },
      getScrollTop: () => {
        var _a2;
        return (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.scrollTop;
      }
    });
    return () => {
      const {
        tag: Tag2,
        value
      } = props2, restProps = __rest$15(props2, ["tag", "value"]);
      return createVNode(Tag2, _objectSpread2$1(_objectSpread2$1({}, restProps), {}, {
        "ref": inputRef,
        "value": value
      }), null);
    };
  }
});
function getClientSize() {
  const width = document.documentElement.clientWidth;
  const height = window.innerHeight || document.documentElement.clientHeight;
  return {
    width,
    height
  };
}
function getOffset$1(node2) {
  const box2 = node2.getBoundingClientRect();
  const docElem = document.documentElement;
  return {
    left: box2.left + (window.scrollX || docElem.scrollLeft) - (docElem.clientLeft || document.body.clientLeft || 0),
    top: box2.top + (window.scrollY || docElem.scrollTop) - (docElem.clientTop || document.body.clientTop || 0)
  };
}
function styleToString(style) {
  const styleNames = Array.prototype.slice.apply(style);
  return styleNames.map((name) => `${name}: ${style.getPropertyValue(name)};`).join("");
}
function styleObjectToString(style) {
  return Object.keys(style).reduce((acc, name) => {
    const styleValue = style[name];
    if (typeof styleValue === "undefined" || styleValue === null) {
      return acc;
    }
    acc += `${name}: ${style[name]};`;
    return acc;
  }, "");
}
var __rest$14 = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const BaseInput$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  inheritAttrs: false,
  props: {
    disabled: PropTypes.looseBool,
    type: PropTypes.string,
    value: PropTypes.any,
    lazy: PropTypes.bool.def(true),
    tag: {
      type: String,
      default: "input"
    },
    size: PropTypes.string,
    style: PropTypes.oneOfType([String, Object]),
    class: PropTypes.string
  },
  emits: ["change", "input", "blur", "keydown", "focus", "compositionstart", "compositionend", "keyup", "paste", "mousedown"],
  setup(props2, _ref) {
    let {
      emit,
      attrs,
      expose
    } = _ref;
    const inputRef = shallowRef(null);
    const renderValue = ref();
    const isComposing = ref(false);
    watch([() => props2.value, isComposing], () => {
      if (isComposing.value) return;
      renderValue.value = props2.value;
    }, {
      immediate: true
    });
    const handleChange = (e2) => {
      emit("change", e2);
    };
    const onCompositionstart = (e2) => {
      isComposing.value = true;
      e2.target.composing = true;
      emit("compositionstart", e2);
    };
    const onCompositionend = (e2) => {
      isComposing.value = false;
      e2.target.composing = false;
      emit("compositionend", e2);
      const event = document.createEvent("HTMLEvents");
      event.initEvent("input", true, true);
      e2.target.dispatchEvent(event);
      handleChange(e2);
    };
    const handleInput = (e2) => {
      if (isComposing.value && props2.lazy) {
        renderValue.value = e2.target.value;
        return;
      }
      emit("input", e2);
    };
    const handleBlur = (e2) => {
      emit("blur", e2);
    };
    const handleFocus = (e2) => {
      emit("focus", e2);
    };
    const focus = () => {
      if (inputRef.value) {
        inputRef.value.focus();
      }
    };
    const blur = () => {
      if (inputRef.value) {
        inputRef.value.blur();
      }
    };
    const handleKeyDown = (e2) => {
      emit("keydown", e2);
    };
    const handleKeyUp = (e2) => {
      emit("keyup", e2);
    };
    const setSelectionRange = (start, end, direction) => {
      var _a2;
      (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.setSelectionRange(start, end, direction);
    };
    const select = () => {
      var _a2;
      (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.select();
    };
    expose({
      focus,
      blur,
      input: computed(() => {
        var _a2;
        return (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.input;
      }),
      setSelectionRange,
      select,
      getSelectionStart: () => {
        var _a2;
        return (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.getSelectionStart();
      },
      getSelectionEnd: () => {
        var _a2;
        return (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.getSelectionEnd();
      },
      getScrollTop: () => {
        var _a2;
        return (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.getScrollTop();
      }
    });
    const handleMousedown = (e2) => {
      emit("mousedown", e2);
    };
    const handlePaste = (e2) => {
      emit("paste", e2);
    };
    const styleString = computed(() => {
      return props2.style && typeof props2.style !== "string" ? styleObjectToString(props2.style) : props2.style;
    });
    return () => {
      const restProps = __rest$14(props2, ["style", "lazy"]);
      return createVNode(BaseInputInner, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, restProps), attrs), {}, {
        "style": styleString.value,
        "onInput": handleInput,
        "onChange": handleChange,
        "onBlur": handleBlur,
        "onFocus": handleFocus,
        "ref": inputRef,
        "value": renderValue.value,
        "onCompositionstart": onCompositionstart,
        "onCompositionend": onCompositionend,
        "onKeyup": handleKeyUp,
        "onKeydown": handleKeyDown,
        "onPaste": handlePaste,
        "onMousedown": handleMousedown
      }), null);
    };
  }
});
const inputProps$2 = {
  inputRef: PropTypes.any,
  prefixCls: String,
  id: String,
  inputElement: PropTypes.VueNode,
  disabled: {
    type: Boolean,
    default: void 0
  },
  autofocus: {
    type: Boolean,
    default: void 0
  },
  autocomplete: String,
  editable: {
    type: Boolean,
    default: void 0
  },
  activeDescendantId: String,
  value: String,
  open: {
    type: Boolean,
    default: void 0
  },
  tabindex: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  /** Pass accessibility props to input */
  attrs: PropTypes.object,
  onKeydown: {
    type: Function
  },
  onMousedown: {
    type: Function
  },
  onChange: {
    type: Function
  },
  onPaste: {
    type: Function
  },
  onCompositionstart: {
    type: Function
  },
  onCompositionend: {
    type: Function
  },
  onFocus: {
    type: Function
  },
  onBlur: {
    type: Function
  }
};
const Input$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "SelectInput",
  inheritAttrs: false,
  props: inputProps$2,
  setup(props2) {
    let blurTimeout = null;
    const VCSelectContainerEvent = inject("VCSelectContainerEvent");
    return () => {
      var _a2;
      const {
        prefixCls,
        id,
        inputElement,
        disabled,
        tabindex,
        autofocus,
        autocomplete,
        editable,
        activeDescendantId,
        value,
        onKeydown,
        onMousedown,
        onChange,
        onPaste,
        onCompositionstart,
        onCompositionend,
        onFocus,
        onBlur,
        open: open2,
        inputRef,
        attrs
      } = props2;
      let inputNode = inputElement || createVNode(BaseInput$1, null, null);
      const inputProps2 = inputNode.props || {};
      const {
        onKeydown: onOriginKeyDown,
        onInput: onOriginInput,
        onFocus: onOriginFocus,
        onBlur: onOriginBlur,
        onMousedown: onOriginMouseDown,
        onCompositionstart: onOriginCompositionStart,
        onCompositionend: onOriginCompositionEnd,
        style
      } = inputProps2;
      inputNode = cloneElement(inputNode, _extends$1(_extends$1(_extends$1(_extends$1(_extends$1({
        type: "search"
      }, inputProps2), {
        id,
        ref: inputRef,
        disabled,
        tabindex,
        lazy: false,
        autocomplete: autocomplete || "off",
        autofocus,
        class: classNames(`${prefixCls}-selection-search-input`, (_a2 = inputNode === null || inputNode === void 0 ? void 0 : inputNode.props) === null || _a2 === void 0 ? void 0 : _a2.class),
        role: "combobox",
        "aria-expanded": open2,
        "aria-haspopup": "listbox",
        "aria-owns": `${id}_list`,
        "aria-autocomplete": "list",
        "aria-controls": `${id}_list`,
        "aria-activedescendant": activeDescendantId
      }), attrs), {
        value: editable ? value : "",
        readonly: !editable,
        unselectable: !editable ? "on" : null,
        style: _extends$1(_extends$1({}, style), {
          opacity: editable ? null : 0
        }),
        onKeydown: (event) => {
          onKeydown(event);
          if (onOriginKeyDown) {
            onOriginKeyDown(event);
          }
        },
        onMousedown: (event) => {
          onMousedown(event);
          if (onOriginMouseDown) {
            onOriginMouseDown(event);
          }
        },
        onInput: (event) => {
          onChange(event);
          if (onOriginInput) {
            onOriginInput(event);
          }
        },
        onCompositionstart(event) {
          onCompositionstart(event);
          if (onOriginCompositionStart) {
            onOriginCompositionStart(event);
          }
        },
        onCompositionend(event) {
          onCompositionend(event);
          if (onOriginCompositionEnd) {
            onOriginCompositionEnd(event);
          }
        },
        onPaste,
        onFocus: function() {
          clearTimeout(blurTimeout);
          onOriginFocus && onOriginFocus(arguments.length <= 0 ? void 0 : arguments[0]);
          onFocus && onFocus(arguments.length <= 0 ? void 0 : arguments[0]);
          VCSelectContainerEvent === null || VCSelectContainerEvent === void 0 ? void 0 : VCSelectContainerEvent.focus(arguments.length <= 0 ? void 0 : arguments[0]);
        },
        onBlur: function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          blurTimeout = setTimeout(() => {
            onOriginBlur && onOriginBlur(args[0]);
            onBlur && onBlur(args[0]);
            VCSelectContainerEvent === null || VCSelectContainerEvent === void 0 ? void 0 : VCSelectContainerEvent.blur(args[0]);
          }, 100);
        }
      }), inputNode.type === "textarea" ? {} : {
        type: "search"
      }), true, true);
      return inputNode;
    };
  }
});
const attributes = `accept acceptcharset accesskey action allowfullscreen allowtransparency
alt async autocomplete autofocus autoplay capture cellpadding cellspacing challenge
charset checked classid classname colspan cols content contenteditable contextmenu
controls coords crossorigin data datetime default defer dir disabled download draggable
enctype form formaction formenctype formmethod formnovalidate formtarget frameborder
headers height hidden high href hreflang htmlfor for httpequiv icon id inputmode integrity
is keyparams keytype kind label lang list loop low manifest marginheight marginwidth max maxlength media
mediagroup method min minlength multiple muted name novalidate nonce open
optimum pattern placeholder poster preload radiogroup readonly rel required
reversed role rowspan rows sandbox scope scoped scrolling seamless selected
shape size sizes span spellcheck src srcdoc srclang srcset start step style
summary tabindex target title type usemap value width wmode wrap`;
const eventsName = `onCopy onCut onPaste onCompositionend onCompositionstart onCompositionupdate onKeydown
    onKeypress onKeyup onFocus onBlur onChange onInput onSubmit onClick onContextmenu onDoubleclick onDblclick
    onDrag onDragend onDragenter onDragexit onDragleave onDragover onDragstart onDrop onMousedown
    onMouseenter onMouseleave onMousemove onMouseout onMouseover onMouseup onSelect onTouchcancel
    onTouchend onTouchmove onTouchstart onTouchstartPassive onTouchmovePassive onScroll onWheel onAbort onCanplay onCanplaythrough
    onDurationchange onEmptied onEncrypted onEnded onError onLoadeddata onLoadedmetadata
    onLoadstart onPause onPlay onPlaying onProgress onRatechange onSeeked onSeeking onStalled onSuspend onTimeupdate onVolumechange onWaiting onLoad onError`;
const propList = `${attributes} ${eventsName}`.split(/[\s\n]+/);
const ariaPrefix = "aria-";
const dataPrefix = "data-";
function match(key2, prefix) {
  return key2.indexOf(prefix) === 0;
}
function pickAttrs(props2) {
  let ariaOnly = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  let mergedConfig;
  if (ariaOnly === false) {
    mergedConfig = {
      aria: true,
      data: true,
      attr: true
    };
  } else if (ariaOnly === true) {
    mergedConfig = {
      aria: true
    };
  } else {
    mergedConfig = _extends$1({}, ariaOnly);
  }
  const attrs = {};
  Object.keys(props2).forEach((key2) => {
    if (
      // Aria
      mergedConfig.aria && (key2 === "role" || match(key2, ariaPrefix)) || // Data
      mergedConfig.data && match(key2, dataPrefix) || // Attr
      mergedConfig.attr && (propList.includes(key2) || propList.includes(key2.toLowerCase()))
    ) {
      attrs[key2] = props2[key2];
    }
  });
  return attrs;
}
const OverflowContextProviderKey = Symbol("OverflowContextProviderKey");
const OverflowContextProvider = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "OverflowContextProvider",
  inheritAttrs: false,
  props: {
    value: {
      type: Object
    }
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    provide(OverflowContextProviderKey, computed(() => props2.value));
    return () => {
      var _a2;
      return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
    };
  }
});
const useInjectOverflowContext = () => {
  return inject(OverflowContextProviderKey, computed(() => null));
};
var __rest$13 = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const UNDEFINED = void 0;
const Item$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Item",
  props: {
    prefixCls: String,
    item: PropTypes.any,
    renderItem: Function,
    responsive: Boolean,
    itemKey: {
      type: [String, Number]
    },
    registerSize: Function,
    display: Boolean,
    order: Number,
    component: PropTypes.any,
    invalidate: Boolean
  },
  setup(props2, _ref) {
    let {
      slots,
      expose
    } = _ref;
    const mergedHidden = computed(() => props2.responsive && !props2.display);
    const itemNodeRef = ref();
    expose({
      itemNodeRef
    });
    function internalRegisterSize(width) {
      props2.registerSize(props2.itemKey, width);
    }
    onUnmounted(() => {
      internalRegisterSize(null);
    });
    return () => {
      var _a2;
      const {
        prefixCls,
        invalidate,
        item,
        renderItem,
        responsive,
        registerSize,
        itemKey: itemKey2,
        display,
        order,
        component: Component = "div"
      } = props2, restProps = __rest$13(props2, ["prefixCls", "invalidate", "item", "renderItem", "responsive", "registerSize", "itemKey", "display", "order", "component"]);
      const children = (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
      const childNode = renderItem && item !== UNDEFINED ? renderItem(item) : children;
      let overflowStyle;
      if (!invalidate) {
        overflowStyle = {
          opacity: mergedHidden.value ? 0 : 1,
          height: mergedHidden.value ? 0 : UNDEFINED,
          overflowY: mergedHidden.value ? "hidden" : UNDEFINED,
          order: responsive ? order : UNDEFINED,
          pointerEvents: mergedHidden.value ? "none" : UNDEFINED,
          position: mergedHidden.value ? "absolute" : UNDEFINED
        };
      }
      const overflowProps2 = {};
      if (mergedHidden.value) {
        overflowProps2["aria-hidden"] = true;
      }
      return createVNode(ResizeObserver$1, {
        "disabled": !responsive,
        "onResize": (_ref2) => {
          let {
            offsetWidth
          } = _ref2;
          internalRegisterSize(offsetWidth);
        }
      }, {
        default: () => createVNode(Component, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
          "class": classNames(!invalidate && prefixCls),
          "style": overflowStyle
        }, overflowProps2), restProps), {}, {
          "ref": itemNodeRef
        }), {
          default: () => [childNode]
        })
      });
    };
  }
});
var __rest$12 = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const RawItem = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "RawItem",
  inheritAttrs: false,
  props: {
    component: PropTypes.any,
    title: PropTypes.any,
    id: String,
    onMouseenter: {
      type: Function
    },
    onMouseleave: {
      type: Function
    },
    onClick: {
      type: Function
    },
    onKeydown: {
      type: Function
    },
    onFocus: {
      type: Function
    },
    role: String,
    tabindex: Number
  },
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const context2 = useInjectOverflowContext();
    return () => {
      var _a2;
      if (!context2.value) {
        const {
          component: Component = "div"
        } = props2, restProps2 = __rest$12(props2, ["component"]);
        return createVNode(Component, _objectSpread2$1(_objectSpread2$1({}, restProps2), attrs), {
          default: () => [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]
        });
      }
      const _b = context2.value, {
        className: contextClassName
      } = _b, restContext = __rest$12(_b, ["className"]);
      const {
        class: className
      } = attrs, restProps = __rest$12(attrs, ["class"]);
      return createVNode(OverflowContextProvider, {
        "value": null
      }, {
        default: () => [createVNode(Item$1, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
          "class": classNames(contextClassName, className)
        }, restContext), restProps), props2), slots)]
      });
    };
  }
});
var __rest$11 = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const RESPONSIVE = "responsive";
const INVALIDATE = "invalidate";
function defaultRenderRest(omittedItems) {
  return `+ ${omittedItems.length} ...`;
}
const overflowProps = () => {
  return {
    id: String,
    prefixCls: String,
    data: Array,
    itemKey: [String, Number, Function],
    /** Used for `responsive`. It will limit render node to avoid perf issue */
    itemWidth: {
      type: Number,
      default: 10
    },
    renderItem: Function,
    /** @private Do not use in your production. Render raw node that need wrap Item by developer self */
    renderRawItem: Function,
    maxCount: [Number, String],
    renderRest: Function,
    /** @private Do not use in your production. Render raw node that need wrap Item by developer self */
    renderRawRest: Function,
    suffix: PropTypes.any,
    component: String,
    itemComponent: PropTypes.any,
    /** @private This API may be refactor since not well design */
    onVisibleChange: Function,
    /** When set to `full`, ssr will render full items by default and remove at client side */
    ssr: String,
    onMousedown: Function,
    role: String
  };
};
const Overflow = defineComponent({
  name: "Overflow",
  inheritAttrs: false,
  props: overflowProps(),
  emits: ["visibleChange"],
  setup(props2, _ref) {
    let {
      attrs,
      emit,
      slots
    } = _ref;
    const fullySSR = computed(() => props2.ssr === "full");
    const containerWidth = shallowRef(null);
    const mergedContainerWidth = computed(() => containerWidth.value || 0);
    const itemWidths = shallowRef(/* @__PURE__ */ new Map());
    const prevRestWidth = shallowRef(0);
    const restWidth = shallowRef(0);
    const suffixWidth = shallowRef(0);
    const suffixFixedStart = shallowRef(null);
    const displayCount = shallowRef(null);
    const mergedDisplayCount = computed(() => {
      if (displayCount.value === null && fullySSR.value) {
        return Number.MAX_SAFE_INTEGER;
      }
      return displayCount.value || 0;
    });
    const restReady = shallowRef(false);
    const itemPrefixCls = computed(() => `${props2.prefixCls}-item`);
    const mergedRestWidth = computed(() => Math.max(prevRestWidth.value, restWidth.value));
    const isResponsive = computed(() => !!(props2.data.length && props2.maxCount === RESPONSIVE));
    const invalidate = computed(() => props2.maxCount === INVALIDATE);
    const showRest = computed(() => isResponsive.value || typeof props2.maxCount === "number" && props2.data.length > props2.maxCount);
    const mergedData = computed(() => {
      let items = props2.data;
      if (isResponsive.value) {
        if (containerWidth.value === null && fullySSR.value) {
          items = props2.data;
        } else {
          items = props2.data.slice(0, Math.min(props2.data.length, mergedContainerWidth.value / props2.itemWidth));
        }
      } else if (typeof props2.maxCount === "number") {
        items = props2.data.slice(0, props2.maxCount);
      }
      return items;
    });
    const omittedItems = computed(() => {
      if (isResponsive.value) {
        return props2.data.slice(mergedDisplayCount.value + 1);
      }
      return props2.data.slice(mergedData.value.length);
    });
    const getKey2 = (item, index2) => {
      var _a2;
      if (typeof props2.itemKey === "function") {
        return props2.itemKey(item);
      }
      return (_a2 = props2.itemKey && (item === null || item === void 0 ? void 0 : item[props2.itemKey])) !== null && _a2 !== void 0 ? _a2 : index2;
    };
    const mergedRenderItem = computed(() => props2.renderItem || ((item) => item));
    const updateDisplayCount = (count, notReady) => {
      displayCount.value = count;
      if (!notReady) {
        restReady.value = count < props2.data.length - 1;
        emit("visibleChange", count);
      }
    };
    const onOverflowResize = (_2, element) => {
      containerWidth.value = element.clientWidth;
    };
    const registerSize = (key2, width) => {
      const clone2 = new Map(itemWidths.value);
      if (width === null) {
        clone2.delete(key2);
      } else {
        clone2.set(key2, width);
      }
      itemWidths.value = clone2;
    };
    const registerOverflowSize = (_2, width) => {
      prevRestWidth.value = restWidth.value;
      restWidth.value = width;
    };
    const registerSuffixSize = (_2, width) => {
      suffixWidth.value = width;
    };
    const getItemWidth = (index2) => {
      return itemWidths.value.get(getKey2(mergedData.value[index2], index2));
    };
    watch([mergedContainerWidth, itemWidths, restWidth, suffixWidth, () => props2.itemKey, mergedData], () => {
      if (mergedContainerWidth.value && mergedRestWidth.value && mergedData.value) {
        let totalWidth = suffixWidth.value;
        const len = mergedData.value.length;
        const lastIndex = len - 1;
        if (!len) {
          updateDisplayCount(0);
          suffixFixedStart.value = null;
          return;
        }
        for (let i2 = 0; i2 < len; i2 += 1) {
          const currentItemWidth = getItemWidth(i2);
          if (currentItemWidth === void 0) {
            updateDisplayCount(i2 - 1, true);
            break;
          }
          totalWidth += currentItemWidth;
          if (
            // Only one means `totalWidth` is the final width
            lastIndex === 0 && totalWidth <= mergedContainerWidth.value || // Last two width will be the final width
            i2 === lastIndex - 1 && totalWidth + getItemWidth(lastIndex) <= mergedContainerWidth.value
          ) {
            updateDisplayCount(lastIndex);
            suffixFixedStart.value = null;
            break;
          } else if (totalWidth + mergedRestWidth.value > mergedContainerWidth.value) {
            updateDisplayCount(i2 - 1);
            suffixFixedStart.value = totalWidth - currentItemWidth - suffixWidth.value + restWidth.value;
            break;
          }
        }
        if (props2.suffix && getItemWidth(0) + suffixWidth.value > mergedContainerWidth.value) {
          suffixFixedStart.value = null;
        }
      }
    });
    return () => {
      const displayRest = restReady.value && !!omittedItems.value.length;
      const {
        itemComponent,
        renderRawItem,
        renderRawRest,
        renderRest,
        prefixCls = "rc-overflow",
        suffix,
        component: Component = "div",
        id,
        onMousedown
      } = props2;
      const {
        class: className,
        style
      } = attrs, restAttrs = __rest$11(attrs, ["class", "style"]);
      let suffixStyle = {};
      if (suffixFixedStart.value !== null && isResponsive.value) {
        suffixStyle = {
          position: "absolute",
          left: `${suffixFixedStart.value}px`,
          top: 0
        };
      }
      const itemSharedProps = {
        prefixCls: itemPrefixCls.value,
        responsive: isResponsive.value,
        component: itemComponent,
        invalidate: invalidate.value
      };
      const internalRenderItemNode = renderRawItem ? (item, index2) => {
        const key2 = getKey2(item, index2);
        return createVNode(OverflowContextProvider, {
          "key": key2,
          "value": _extends$1(_extends$1({}, itemSharedProps), {
            order: index2,
            item,
            itemKey: key2,
            registerSize,
            display: index2 <= mergedDisplayCount.value
          })
        }, {
          default: () => [renderRawItem(item, index2)]
        });
      } : (item, index2) => {
        const key2 = getKey2(item, index2);
        return createVNode(Item$1, _objectSpread2$1(_objectSpread2$1({}, itemSharedProps), {}, {
          "order": index2,
          "key": key2,
          "item": item,
          "renderItem": mergedRenderItem.value,
          "itemKey": key2,
          "registerSize": registerSize,
          "display": index2 <= mergedDisplayCount.value
        }), null);
      };
      let restNode = () => null;
      const restContextProps = {
        order: displayRest ? mergedDisplayCount.value : Number.MAX_SAFE_INTEGER,
        className: `${itemPrefixCls.value} ${itemPrefixCls.value}-rest`,
        registerSize: registerOverflowSize,
        display: displayRest
      };
      if (!renderRawRest) {
        const mergedRenderRest = renderRest || defaultRenderRest;
        restNode = () => createVNode(Item$1, _objectSpread2$1(_objectSpread2$1({}, itemSharedProps), restContextProps), {
          default: () => typeof mergedRenderRest === "function" ? mergedRenderRest(omittedItems.value) : mergedRenderRest
        });
      } else if (renderRawRest) {
        restNode = () => createVNode(OverflowContextProvider, {
          "value": _extends$1(_extends$1({}, itemSharedProps), restContextProps)
        }, {
          default: () => [renderRawRest(omittedItems.value)]
        });
      }
      const overflowNode = () => {
        var _a2;
        return createVNode(Component, _objectSpread2$1({
          "id": id,
          "class": classNames(!invalidate.value && prefixCls, className),
          "style": style,
          "onMousedown": onMousedown,
          "role": props2.role
        }, restAttrs), {
          default: () => [mergedData.value.map(internalRenderItemNode), showRest.value ? restNode() : null, suffix && createVNode(Item$1, _objectSpread2$1(_objectSpread2$1({}, itemSharedProps), {}, {
            "order": mergedDisplayCount.value,
            "class": `${itemPrefixCls.value}-suffix`,
            "registerSize": registerSuffixSize,
            "display": true,
            "style": suffixStyle
          }), {
            default: () => suffix
          }), (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]
        });
      };
      return createVNode(ResizeObserver$1, {
        "disabled": !isResponsive.value,
        "onResize": onOverflowResize
      }, {
        default: overflowNode
      });
    };
  }
});
Overflow.Item = RawItem;
Overflow.RESPONSIVE = RESPONSIVE;
Overflow.INVALIDATE = INVALIDATE;
const TreeSelectLegacyContextPropsKey = Symbol("TreeSelectLegacyContextPropsKey");
function useInjectLegacySelectContext() {
  return inject(TreeSelectLegacyContextPropsKey, {});
}
const props$2 = {
  id: String,
  prefixCls: String,
  values: PropTypes.array,
  open: {
    type: Boolean,
    default: void 0
  },
  searchValue: String,
  inputRef: PropTypes.any,
  placeholder: PropTypes.any,
  disabled: {
    type: Boolean,
    default: void 0
  },
  mode: String,
  showSearch: {
    type: Boolean,
    default: void 0
  },
  autofocus: {
    type: Boolean,
    default: void 0
  },
  autocomplete: String,
  activeDescendantId: String,
  tabindex: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  compositionStatus: Boolean,
  removeIcon: PropTypes.any,
  choiceTransitionName: String,
  maxTagCount: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  maxTagTextLength: Number,
  maxTagPlaceholder: PropTypes.any.def(() => (omittedValues) => `+ ${omittedValues.length} ...`),
  tagRender: Function,
  onToggleOpen: {
    type: Function
  },
  onRemove: Function,
  onInputChange: Function,
  onInputPaste: Function,
  onInputKeyDown: Function,
  onInputMouseDown: Function,
  onInputCompositionStart: Function,
  onInputCompositionEnd: Function
};
const onPreventMouseDown = (event) => {
  event.preventDefault();
  event.stopPropagation();
};
const SelectSelector = defineComponent({
  name: "MultipleSelectSelector",
  inheritAttrs: false,
  props: props$2,
  setup(props2) {
    const measureRef = shallowRef();
    const inputWidth = shallowRef(0);
    const focused = shallowRef(false);
    const legacyTreeSelectContext = useInjectLegacySelectContext();
    const selectionPrefixCls = computed(() => `${props2.prefixCls}-selection`);
    const inputValue = computed(() => props2.open || props2.mode === "tags" ? props2.searchValue : "");
    const inputEditable = computed(() => props2.mode === "tags" || props2.showSearch && (props2.open || focused.value));
    const targetValue = ref("");
    watchEffect(() => {
      targetValue.value = inputValue.value;
    });
    onMounted(() => {
      watch(targetValue, () => {
        inputWidth.value = measureRef.value.scrollWidth;
      }, {
        flush: "post",
        immediate: true
      });
    });
    function defaultRenderSelector(title, content, itemDisabled, closable, onClose) {
      return createVNode("span", {
        "class": classNames(`${selectionPrefixCls.value}-item`, {
          [`${selectionPrefixCls.value}-item-disabled`]: itemDisabled
        }),
        "title": typeof title === "string" || typeof title === "number" ? title.toString() : void 0
      }, [createVNode("span", {
        "class": `${selectionPrefixCls.value}-item-content`
      }, [content]), closable && createVNode(TransBtn, {
        "class": `${selectionPrefixCls.value}-item-remove`,
        "onMousedown": onPreventMouseDown,
        "onClick": onClose,
        "customizeIcon": props2.removeIcon
      }, {
        default: () => [createTextVNode("×")]
      })]);
    }
    function customizeRenderSelector(value, content, itemDisabled, closable, onClose, option) {
      var _a2;
      const onMouseDown = (e2) => {
        onPreventMouseDown(e2);
        props2.onToggleOpen(!open);
      };
      let originData = option;
      if (legacyTreeSelectContext.keyEntities) {
        originData = ((_a2 = legacyTreeSelectContext.keyEntities[value]) === null || _a2 === void 0 ? void 0 : _a2.node) || {};
      }
      return createVNode("span", {
        "key": value,
        "onMousedown": onMouseDown
      }, [props2.tagRender({
        label: content,
        value,
        disabled: itemDisabled,
        closable,
        onClose,
        option: originData
      })]);
    }
    function renderItem(valueItem) {
      const {
        disabled: itemDisabled,
        label,
        value,
        option
      } = valueItem;
      const closable = !props2.disabled && !itemDisabled;
      let displayLabel = label;
      if (typeof props2.maxTagTextLength === "number") {
        if (typeof label === "string" || typeof label === "number") {
          const strLabel = String(displayLabel);
          if (strLabel.length > props2.maxTagTextLength) {
            displayLabel = `${strLabel.slice(0, props2.maxTagTextLength)}...`;
          }
        }
      }
      const onClose = (event) => {
        var _a2;
        if (event) event.stopPropagation();
        (_a2 = props2.onRemove) === null || _a2 === void 0 ? void 0 : _a2.call(props2, valueItem);
      };
      return typeof props2.tagRender === "function" ? customizeRenderSelector(value, displayLabel, itemDisabled, closable, onClose, option) : defaultRenderSelector(label, displayLabel, itemDisabled, closable, onClose);
    }
    function renderRest(omittedValues) {
      const {
        maxTagPlaceholder = (omittedValues2) => `+ ${omittedValues2.length} ...`
      } = props2;
      const content = typeof maxTagPlaceholder === "function" ? maxTagPlaceholder(omittedValues) : maxTagPlaceholder;
      return defaultRenderSelector(content, content, false);
    }
    const handleInput = (e2) => {
      const composing = e2.target.composing;
      targetValue.value = e2.target.value;
      if (!composing) {
        props2.onInputChange(e2);
      }
    };
    return () => {
      const {
        id,
        prefixCls,
        values,
        open: open2,
        inputRef,
        placeholder,
        disabled,
        autofocus,
        autocomplete,
        activeDescendantId,
        tabindex,
        compositionStatus,
        onInputPaste,
        onInputKeyDown,
        onInputMouseDown,
        onInputCompositionStart,
        onInputCompositionEnd
      } = props2;
      const inputNode = createVNode("div", {
        "class": `${selectionPrefixCls.value}-search`,
        "style": {
          width: inputWidth.value + "px"
        },
        "key": "input"
      }, [createVNode(Input$1, {
        "inputRef": inputRef,
        "open": open2,
        "prefixCls": prefixCls,
        "id": id,
        "inputElement": null,
        "disabled": disabled,
        "autofocus": autofocus,
        "autocomplete": autocomplete,
        "editable": inputEditable.value,
        "activeDescendantId": activeDescendantId,
        "value": targetValue.value,
        "onKeydown": onInputKeyDown,
        "onMousedown": onInputMouseDown,
        "onChange": handleInput,
        "onPaste": onInputPaste,
        "onCompositionstart": onInputCompositionStart,
        "onCompositionend": onInputCompositionEnd,
        "tabindex": tabindex,
        "attrs": pickAttrs(props2, true),
        "onFocus": () => focused.value = true,
        "onBlur": () => focused.value = false
      }, null), createVNode("span", {
        "ref": measureRef,
        "class": `${selectionPrefixCls.value}-search-mirror`,
        "aria-hidden": true
      }, [targetValue.value, createTextVNode(" ")])]);
      const selectionNode = createVNode(Overflow, {
        "prefixCls": `${selectionPrefixCls.value}-overflow`,
        "data": values,
        "renderItem": renderItem,
        "renderRest": renderRest,
        "suffix": inputNode,
        "itemKey": "key",
        "maxCount": props2.maxTagCount,
        "key": "overflow"
      }, null);
      return createVNode(Fragment, null, [selectionNode, !values.length && !inputValue.value && !compositionStatus && createVNode("span", {
        "class": `${selectionPrefixCls.value}-placeholder`
      }, [placeholder])]);
    };
  }
});
const props$1 = {
  inputElement: PropTypes.any,
  id: String,
  prefixCls: String,
  values: PropTypes.array,
  open: {
    type: Boolean,
    default: void 0
  },
  searchValue: String,
  inputRef: PropTypes.any,
  placeholder: PropTypes.any,
  compositionStatus: {
    type: Boolean,
    default: void 0
  },
  disabled: {
    type: Boolean,
    default: void 0
  },
  mode: String,
  showSearch: {
    type: Boolean,
    default: void 0
  },
  autofocus: {
    type: Boolean,
    default: void 0
  },
  autocomplete: String,
  activeDescendantId: String,
  tabindex: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  activeValue: String,
  backfill: {
    type: Boolean,
    default: void 0
  },
  optionLabelRender: Function,
  onInputChange: Function,
  onInputPaste: Function,
  onInputKeyDown: Function,
  onInputMouseDown: Function,
  onInputCompositionStart: Function,
  onInputCompositionEnd: Function
};
const SingleSelector = defineComponent({
  name: "SingleSelector",
  setup(props2) {
    const inputChanged = shallowRef(false);
    const combobox = computed(() => props2.mode === "combobox");
    const inputEditable = computed(() => combobox.value || props2.showSearch);
    const inputValue = computed(() => {
      let inputValue2 = props2.searchValue || "";
      if (combobox.value && props2.activeValue && !inputChanged.value) {
        inputValue2 = props2.activeValue;
      }
      return inputValue2;
    });
    const legacyTreeSelectContext = useInjectLegacySelectContext();
    watch([combobox, () => props2.activeValue], () => {
      if (combobox.value) {
        inputChanged.value = false;
      }
    }, {
      immediate: true
    });
    const hasTextInput = computed(() => props2.mode !== "combobox" && !props2.open && !props2.showSearch ? false : !!inputValue.value || props2.compositionStatus);
    const title = computed(() => {
      const item = props2.values[0];
      return item && (typeof item.label === "string" || typeof item.label === "number") ? item.label.toString() : void 0;
    });
    const renderPlaceholder = () => {
      if (props2.values[0]) {
        return null;
      }
      const hiddenStyle = hasTextInput.value ? {
        visibility: "hidden"
      } : void 0;
      return createVNode("span", {
        "class": `${props2.prefixCls}-selection-placeholder`,
        "style": hiddenStyle
      }, [props2.placeholder]);
    };
    const handleInput = (e2) => {
      const composing = e2.target.composing;
      if (!composing) {
        inputChanged.value = true;
        props2.onInputChange(e2);
      }
    };
    return () => {
      var _a2, _b, _c, _d;
      const {
        inputElement,
        prefixCls,
        id,
        values,
        inputRef,
        disabled,
        autofocus,
        autocomplete,
        activeDescendantId,
        open: open2,
        tabindex,
        optionLabelRender,
        onInputKeyDown,
        onInputMouseDown,
        onInputPaste,
        onInputCompositionStart,
        onInputCompositionEnd
      } = props2;
      const item = values[0];
      let titleNode = null;
      if (item && legacyTreeSelectContext.customSlots) {
        const key2 = (_a2 = item.key) !== null && _a2 !== void 0 ? _a2 : item.value;
        const originData = ((_b = legacyTreeSelectContext.keyEntities[key2]) === null || _b === void 0 ? void 0 : _b.node) || {};
        titleNode = legacyTreeSelectContext.customSlots[(_c = originData.slots) === null || _c === void 0 ? void 0 : _c.title] || legacyTreeSelectContext.customSlots.title || item.label;
        if (typeof titleNode === "function") {
          titleNode = titleNode(originData);
        }
      } else {
        titleNode = optionLabelRender && item ? optionLabelRender(item.option) : item === null || item === void 0 ? void 0 : item.label;
      }
      return createVNode(Fragment, null, [createVNode("span", {
        "class": `${prefixCls}-selection-search`
      }, [createVNode(Input$1, {
        "inputRef": inputRef,
        "prefixCls": prefixCls,
        "id": id,
        "open": open2,
        "inputElement": inputElement,
        "disabled": disabled,
        "autofocus": autofocus,
        "autocomplete": autocomplete,
        "editable": inputEditable.value,
        "activeDescendantId": activeDescendantId,
        "value": inputValue.value,
        "onKeydown": onInputKeyDown,
        "onMousedown": onInputMouseDown,
        "onChange": handleInput,
        "onPaste": onInputPaste,
        "onCompositionstart": onInputCompositionStart,
        "onCompositionend": onInputCompositionEnd,
        "tabindex": tabindex,
        "attrs": pickAttrs(props2, true)
      }, null)]), !combobox.value && item && !hasTextInput.value && createVNode("span", {
        "class": `${prefixCls}-selection-item`,
        "title": title.value
      }, [createVNode(Fragment, {
        "key": (_d = item.key) !== null && _d !== void 0 ? _d : item.value
      }, [titleNode])]), renderPlaceholder()]);
    };
  }
});
SingleSelector.props = props$1;
SingleSelector.inheritAttrs = false;
function isValidateOpenKey(currentKeyCode) {
  return ![
    // System function button
    KeyCode.ESC,
    KeyCode.SHIFT,
    KeyCode.BACKSPACE,
    KeyCode.TAB,
    KeyCode.WIN_KEY,
    KeyCode.ALT,
    KeyCode.META,
    KeyCode.WIN_KEY_RIGHT,
    KeyCode.CTRL,
    KeyCode.SEMICOLON,
    KeyCode.EQUALS,
    KeyCode.CAPS_LOCK,
    KeyCode.CONTEXT_MENU,
    // F1-F12
    KeyCode.F1,
    KeyCode.F2,
    KeyCode.F3,
    KeyCode.F4,
    KeyCode.F5,
    KeyCode.F6,
    KeyCode.F7,
    KeyCode.F8,
    KeyCode.F9,
    KeyCode.F10,
    KeyCode.F11,
    KeyCode.F12
  ].includes(currentKeyCode);
}
function useLock() {
  let duration = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 250;
  let lock = null;
  let timeout;
  onBeforeUnmount(() => {
    clearTimeout(timeout);
  });
  function doLock(locked) {
    if (locked || lock === null) {
      lock = locked;
    }
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      lock = null;
    }, duration);
  }
  return [() => lock, doLock];
}
function createRef() {
  const func = (node2) => {
    func.current = node2;
  };
  return func;
}
const Selector = defineComponent({
  name: "Selector",
  inheritAttrs: false,
  props: {
    id: String,
    prefixCls: String,
    showSearch: {
      type: Boolean,
      default: void 0
    },
    open: {
      type: Boolean,
      default: void 0
    },
    /** Display in the Selector value, it's not same as `value` prop */
    values: PropTypes.array,
    multiple: {
      type: Boolean,
      default: void 0
    },
    mode: String,
    searchValue: String,
    activeValue: String,
    inputElement: PropTypes.any,
    autofocus: {
      type: Boolean,
      default: void 0
    },
    activeDescendantId: String,
    tabindex: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    disabled: {
      type: Boolean,
      default: void 0
    },
    placeholder: PropTypes.any,
    removeIcon: PropTypes.any,
    // Tags
    maxTagCount: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    maxTagTextLength: Number,
    maxTagPlaceholder: PropTypes.any,
    tagRender: Function,
    optionLabelRender: Function,
    /** Check if `tokenSeparators` contains `\n` or `\r\n` */
    tokenWithEnter: {
      type: Boolean,
      default: void 0
    },
    // Motion
    choiceTransitionName: String,
    onToggleOpen: {
      type: Function
    },
    /** `onSearch` returns go next step boolean to check if need do toggle open */
    onSearch: Function,
    onSearchSubmit: Function,
    onRemove: Function,
    onInputKeyDown: {
      type: Function
    },
    /**
     * @private get real dom for trigger align.
     * This may be removed after React provides replacement of `findDOMNode`
     */
    domRef: Function
  },
  setup(props2, _ref) {
    let {
      expose
    } = _ref;
    const inputRef = createRef();
    const compositionStatus = ref(false);
    const [getInputMouseDown, setInputMouseDown] = useLock(0);
    const onInternalInputKeyDown = (event) => {
      const {
        which
      } = event;
      if (which === KeyCode.UP || which === KeyCode.DOWN) {
        event.preventDefault();
      }
      if (props2.onInputKeyDown) {
        props2.onInputKeyDown(event);
      }
      if (which === KeyCode.ENTER && props2.mode === "tags" && !compositionStatus.value && !props2.open) {
        props2.onSearchSubmit(event.target.value);
      }
      if (isValidateOpenKey(which)) {
        props2.onToggleOpen(true);
      }
    };
    const onInternalInputMouseDown = () => {
      setInputMouseDown(true);
    };
    let pastedText = null;
    const triggerOnSearch = (value) => {
      if (props2.onSearch(value, true, compositionStatus.value) !== false) {
        props2.onToggleOpen(true);
      }
    };
    const onInputCompositionStart = () => {
      compositionStatus.value = true;
    };
    const onInputCompositionEnd = (e2) => {
      compositionStatus.value = false;
      if (props2.mode !== "combobox") {
        triggerOnSearch(e2.target.value);
      }
    };
    const onInputChange = (event) => {
      let {
        target: {
          value
        }
      } = event;
      if (props2.tokenWithEnter && pastedText && /[\r\n]/.test(pastedText)) {
        const replacedText = pastedText.replace(/[\r\n]+$/, "").replace(/\r\n/g, " ").replace(/[\r\n]/g, " ");
        value = value.replace(replacedText, pastedText);
      }
      pastedText = null;
      triggerOnSearch(value);
    };
    const onInputPaste = (e2) => {
      const {
        clipboardData
      } = e2;
      const value = clipboardData.getData("text");
      pastedText = value;
    };
    const onClick = (_ref2) => {
      let {
        target
      } = _ref2;
      if (target !== inputRef.current) {
        const isIE = document.body.style.msTouchAction !== void 0;
        if (isIE) {
          setTimeout(() => {
            inputRef.current.focus();
          });
        } else {
          inputRef.current.focus();
        }
      }
    };
    const onMousedown = (event) => {
      const inputMouseDown = getInputMouseDown();
      if (event.target !== inputRef.current && !inputMouseDown) {
        event.preventDefault();
      }
      if (props2.mode !== "combobox" && (!props2.showSearch || !inputMouseDown) || !props2.open) {
        if (props2.open) {
          props2.onSearch("", true, false);
        }
        props2.onToggleOpen();
      }
    };
    expose({
      focus: () => {
        inputRef.current.focus();
      },
      blur: () => {
        inputRef.current.blur();
      }
    });
    return () => {
      const {
        prefixCls,
        domRef,
        mode
      } = props2;
      const sharedProps = {
        inputRef,
        onInputKeyDown: onInternalInputKeyDown,
        onInputMouseDown: onInternalInputMouseDown,
        onInputChange,
        onInputPaste,
        compositionStatus: compositionStatus.value,
        onInputCompositionStart,
        onInputCompositionEnd
      };
      const selectNode = mode === "multiple" || mode === "tags" ? createVNode(SelectSelector, _objectSpread2$1(_objectSpread2$1({}, props2), sharedProps), null) : createVNode(SingleSelector, _objectSpread2$1(_objectSpread2$1({}, props2), sharedProps), null);
      return createVNode("div", {
        "ref": domRef,
        "class": `${prefixCls}-selector`,
        "onClick": onClick,
        "onMousedown": onMousedown
      }, [selectNode]);
    };
  }
});
function useSelectTriggerControl(refs, open2, triggerOpen) {
  function onGlobalMouseDown(event) {
    var _a2, _b, _c;
    let target = event.target;
    if (target.shadowRoot && event.composed) {
      target = event.composedPath()[0] || target;
    }
    const elements = [(_a2 = refs[0]) === null || _a2 === void 0 ? void 0 : _a2.value, (_c = (_b = refs[1]) === null || _b === void 0 ? void 0 : _b.value) === null || _c === void 0 ? void 0 : _c.getPopupElement()];
    if (open2.value && elements.every((element) => element && !element.contains(target) && element !== target)) {
      triggerOpen(false);
    }
  }
  onMounted(() => {
    window.addEventListener("mousedown", onGlobalMouseDown);
  });
  onBeforeUnmount(() => {
    window.removeEventListener("mousedown", onGlobalMouseDown);
  });
}
function useDelayReset() {
  let timeout = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10;
  const bool = shallowRef(false);
  let delay;
  const cancelLatest = () => {
    clearTimeout(delay);
  };
  onMounted(() => {
    cancelLatest();
  });
  const delaySetBool = (value, callback) => {
    cancelLatest();
    delay = setTimeout(() => {
      bool.value = value;
      if (callback) {
        callback();
      }
    }, timeout);
  };
  return [bool, delaySetBool, cancelLatest];
}
const BaseSelectContextKey = Symbol("BaseSelectContextKey");
function useProvideBaseSelectProps(props2) {
  return provide(BaseSelectContextKey, props2);
}
function useBaseProps() {
  return inject(BaseSelectContextKey, {});
}
const isMobile = () => {
  if (typeof navigator === "undefined" || typeof window === "undefined") {
    return false;
  }
  const agent = navigator.userAgent || navigator.vendor || window.opera;
  return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(agent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(agent === null || agent === void 0 ? void 0 : agent.substring(0, 4));
};
function toReactive(objectRef) {
  if (!isRef(objectRef)) return reactive(objectRef);
  const proxy = new Proxy({}, {
    get(_2, p, receiver) {
      return Reflect.get(objectRef.value, p, receiver);
    },
    set(_2, p, value) {
      objectRef.value[p] = value;
      return true;
    },
    deleteProperty(_2, p) {
      return Reflect.deleteProperty(objectRef.value, p);
    },
    has(_2, p) {
      return Reflect.has(objectRef.value, p);
    },
    ownKeys() {
      return Object.keys(objectRef.value);
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: true,
        configurable: true
      };
    }
  });
  return reactive(proxy);
}
var __rest$10 = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const DEFAULT_OMIT_PROPS = ["value", "onChange", "removeIcon", "placeholder", "autofocus", "maxTagCount", "maxTagTextLength", "maxTagPlaceholder", "choiceTransitionName", "onInputKeyDown", "onPopupScroll", "tabindex", "OptionList", "notFoundContent"];
const baseSelectPrivateProps = () => {
  return {
    prefixCls: String,
    id: String,
    omitDomProps: Array,
    // >>> Value
    displayValues: Array,
    onDisplayValuesChange: Function,
    // >>> Active
    /** Current dropdown list active item string value */
    activeValue: String,
    /** Link search input with target element */
    activeDescendantId: String,
    onActiveValueChange: Function,
    // >>> Search
    searchValue: String,
    /** Trigger onSearch, return false to prevent trigger open event */
    onSearch: Function,
    /** Trigger when search text match the `tokenSeparators`. Will provide split content */
    onSearchSplit: Function,
    maxLength: Number,
    OptionList: PropTypes.any,
    /** Tell if provided `options` is empty */
    emptyOptions: Boolean
  };
};
const baseSelectPropsWithoutPrivate = () => {
  return {
    showSearch: {
      type: Boolean,
      default: void 0
    },
    tagRender: {
      type: Function
    },
    optionLabelRender: {
      type: Function
    },
    direction: {
      type: String
    },
    // MISC
    tabindex: Number,
    autofocus: Boolean,
    notFoundContent: PropTypes.any,
    placeholder: PropTypes.any,
    onClear: Function,
    choiceTransitionName: String,
    // >>> Mode
    mode: String,
    // >>> Status
    disabled: {
      type: Boolean,
      default: void 0
    },
    loading: {
      type: Boolean,
      default: void 0
    },
    // >>> Open
    open: {
      type: Boolean,
      default: void 0
    },
    defaultOpen: {
      type: Boolean,
      default: void 0
    },
    onDropdownVisibleChange: {
      type: Function
    },
    // >>> Customize Input
    /** @private Internal usage. Do not use in your production. */
    getInputElement: {
      type: Function
    },
    /** @private Internal usage. Do not use in your production. */
    getRawInputElement: {
      type: Function
    },
    // >>> Selector
    maxTagTextLength: Number,
    maxTagCount: {
      type: [String, Number]
    },
    maxTagPlaceholder: PropTypes.any,
    // >>> Search
    tokenSeparators: {
      type: Array
    },
    // >>> Icons
    allowClear: {
      type: Boolean,
      default: void 0
    },
    showArrow: {
      type: Boolean,
      default: void 0
    },
    inputIcon: PropTypes.any,
    /** Clear all icon */
    clearIcon: PropTypes.any,
    /** Selector remove icon */
    removeIcon: PropTypes.any,
    // >>> Dropdown
    animation: String,
    transitionName: String,
    dropdownStyle: {
      type: Object
    },
    dropdownClassName: String,
    dropdownMatchSelectWidth: {
      type: [Boolean, Number],
      default: void 0
    },
    dropdownRender: {
      type: Function
    },
    dropdownAlign: Object,
    placement: {
      type: String
    },
    getPopupContainer: {
      type: Function
    },
    // >>> Focus
    showAction: {
      type: Array
    },
    onBlur: {
      type: Function
    },
    onFocus: {
      type: Function
    },
    // >>> Rest Events
    onKeyup: Function,
    onKeydown: Function,
    onMousedown: Function,
    onPopupScroll: Function,
    onInputKeyDown: Function,
    onMouseenter: Function,
    onMouseleave: Function,
    onClick: Function
  };
};
const baseSelectProps = () => {
  return _extends$1(_extends$1({}, baseSelectPrivateProps()), baseSelectPropsWithoutPrivate());
};
function isMultiple(mode) {
  return mode === "tags" || mode === "multiple";
}
const BaseSelect = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "BaseSelect",
  inheritAttrs: false,
  props: initDefaultProps(baseSelectProps(), {
    showAction: [],
    notFoundContent: "Not Found"
  }),
  setup(props2, _ref) {
    let {
      attrs,
      expose,
      slots
    } = _ref;
    const multiple = computed(() => isMultiple(props2.mode));
    const mergedShowSearch = computed(() => props2.showSearch !== void 0 ? props2.showSearch : multiple.value || props2.mode === "combobox");
    const mobile = shallowRef(false);
    onMounted(() => {
      mobile.value = isMobile();
    });
    const legacyTreeSelectContext = useInjectLegacySelectContext();
    const containerRef = shallowRef(null);
    const selectorDomRef = createRef();
    const triggerRef2 = shallowRef(null);
    const selectorRef = shallowRef(null);
    const listRef = shallowRef(null);
    const blurRef = ref(false);
    const [mockFocused, setMockFocused, cancelSetMockFocused] = useDelayReset();
    const focus = () => {
      var _a2;
      (_a2 = selectorRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
    };
    const blur = () => {
      var _a2;
      (_a2 = selectorRef.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
    };
    expose({
      focus,
      blur,
      scrollTo: (arg) => {
        var _a2;
        return (_a2 = listRef.value) === null || _a2 === void 0 ? void 0 : _a2.scrollTo(arg);
      }
    });
    const mergedSearchValue = computed(() => {
      var _a2;
      if (props2.mode !== "combobox") {
        return props2.searchValue;
      }
      const val = (_a2 = props2.displayValues[0]) === null || _a2 === void 0 ? void 0 : _a2.value;
      return typeof val === "string" || typeof val === "number" ? String(val) : "";
    });
    const initOpen = props2.open !== void 0 ? props2.open : props2.defaultOpen;
    const innerOpen = shallowRef(initOpen);
    const mergedOpen = shallowRef(initOpen);
    const setInnerOpen = (val) => {
      innerOpen.value = props2.open !== void 0 ? props2.open : val;
      mergedOpen.value = innerOpen.value;
    };
    watch(() => props2.open, () => {
      setInnerOpen(props2.open);
    });
    const emptyListContent = computed(() => !props2.notFoundContent && props2.emptyOptions);
    watchEffect(() => {
      mergedOpen.value = innerOpen.value;
      if (props2.disabled || emptyListContent.value && mergedOpen.value && props2.mode === "combobox") {
        mergedOpen.value = false;
      }
    });
    const triggerOpen = computed(() => emptyListContent.value ? false : mergedOpen.value);
    const onToggleOpen = (newOpen) => {
      const nextOpen = newOpen !== void 0 ? newOpen : !mergedOpen.value;
      if (mergedOpen.value !== nextOpen && !props2.disabled) {
        setInnerOpen(nextOpen);
        props2.onDropdownVisibleChange && props2.onDropdownVisibleChange(nextOpen);
        if (!nextOpen && popupFocused.value) {
          popupFocused.value = false;
          setMockFocused(false, () => {
            focusRef.value = false;
            blurRef.value = false;
          });
        }
      }
    };
    const tokenWithEnter = computed(() => (props2.tokenSeparators || []).some((tokenSeparator) => ["\n", "\r\n"].includes(tokenSeparator)));
    const onInternalSearch = (searchText, fromTyping, isCompositing) => {
      var _a2, _b;
      let ret = true;
      let newSearchText = searchText;
      (_a2 = props2.onActiveValueChange) === null || _a2 === void 0 ? void 0 : _a2.call(props2, null);
      const patchLabels = isCompositing ? null : getSeparatedContent(searchText, props2.tokenSeparators);
      if (props2.mode !== "combobox" && patchLabels) {
        newSearchText = "";
        (_b = props2.onSearchSplit) === null || _b === void 0 ? void 0 : _b.call(props2, patchLabels);
        onToggleOpen(false);
        ret = false;
      }
      if (props2.onSearch && mergedSearchValue.value !== newSearchText) {
        props2.onSearch(newSearchText, {
          source: fromTyping ? "typing" : "effect"
        });
      }
      return ret;
    };
    const onInternalSearchSubmit = (searchText) => {
      var _a2;
      if (!searchText || !searchText.trim()) {
        return;
      }
      (_a2 = props2.onSearch) === null || _a2 === void 0 ? void 0 : _a2.call(props2, searchText, {
        source: "submit"
      });
    };
    watch(mergedOpen, () => {
      if (!mergedOpen.value && !multiple.value && props2.mode !== "combobox") {
        onInternalSearch("", false, false);
      }
    }, {
      immediate: true,
      flush: "post"
    });
    watch(() => props2.disabled, () => {
      if (innerOpen.value && !!props2.disabled) {
        setInnerOpen(false);
      }
      if (props2.disabled && !blurRef.value) {
        setMockFocused(false);
      }
    }, {
      immediate: true
    });
    const [getClearLock, setClearLock] = useLock();
    const onInternalKeyDown = function(event) {
      var _a2;
      const clearLock = getClearLock();
      const {
        which
      } = event;
      if (which === KeyCode.ENTER) {
        if (props2.mode !== "combobox") {
          event.preventDefault();
        }
        if (!mergedOpen.value) {
          onToggleOpen(true);
        }
      }
      setClearLock(!!mergedSearchValue.value);
      if (which === KeyCode.BACKSPACE && !clearLock && multiple.value && !mergedSearchValue.value && props2.displayValues.length) {
        const cloneDisplayValues = [...props2.displayValues];
        let removedDisplayValue = null;
        for (let i2 = cloneDisplayValues.length - 1; i2 >= 0; i2 -= 1) {
          const current = cloneDisplayValues[i2];
          if (!current.disabled) {
            cloneDisplayValues.splice(i2, 1);
            removedDisplayValue = current;
            break;
          }
        }
        if (removedDisplayValue) {
          props2.onDisplayValuesChange(cloneDisplayValues, {
            type: "remove",
            values: [removedDisplayValue]
          });
        }
      }
      for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        rest[_key - 1] = arguments[_key];
      }
      if (mergedOpen.value && listRef.value) {
        listRef.value.onKeydown(event, ...rest);
      }
      (_a2 = props2.onKeydown) === null || _a2 === void 0 ? void 0 : _a2.call(props2, event, ...rest);
    };
    const onInternalKeyUp = function(event) {
      for (var _len2 = arguments.length, rest = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        rest[_key2 - 1] = arguments[_key2];
      }
      if (mergedOpen.value && listRef.value) {
        listRef.value.onKeyup(event, ...rest);
      }
      if (props2.onKeyup) {
        props2.onKeyup(event, ...rest);
      }
    };
    const onSelectorRemove = (val) => {
      const newValues = props2.displayValues.filter((i2) => i2 !== val);
      props2.onDisplayValuesChange(newValues, {
        type: "remove",
        values: [val]
      });
    };
    const focusRef = shallowRef(false);
    const onContainerFocus = function() {
      setMockFocused(true);
      if (!props2.disabled) {
        if (props2.onFocus && !focusRef.value) {
          props2.onFocus(...arguments);
        }
        if (props2.showAction && props2.showAction.includes("focus")) {
          onToggleOpen(true);
        }
      }
      focusRef.value = true;
    };
    const popupFocused = ref(false);
    const onContainerBlur = function() {
      if (popupFocused.value) {
        return;
      }
      blurRef.value = true;
      setMockFocused(false, () => {
        focusRef.value = false;
        blurRef.value = false;
        onToggleOpen(false);
      });
      if (props2.disabled) {
        return;
      }
      const searchVal = mergedSearchValue.value;
      if (searchVal) {
        if (props2.mode === "tags") {
          props2.onSearch(searchVal, {
            source: "submit"
          });
        } else if (props2.mode === "multiple") {
          props2.onSearch("", {
            source: "blur"
          });
        }
      }
      if (props2.onBlur) {
        props2.onBlur(...arguments);
      }
    };
    const onPopupFocusin = () => {
      popupFocused.value = true;
    };
    const onPopupFocusout = () => {
      popupFocused.value = false;
    };
    provide("VCSelectContainerEvent", {
      focus: onContainerFocus,
      blur: onContainerBlur
    });
    const activeTimeoutIds = [];
    onMounted(() => {
      activeTimeoutIds.forEach((timeoutId) => clearTimeout(timeoutId));
      activeTimeoutIds.splice(0, activeTimeoutIds.length);
    });
    onBeforeUnmount(() => {
      activeTimeoutIds.forEach((timeoutId) => clearTimeout(timeoutId));
      activeTimeoutIds.splice(0, activeTimeoutIds.length);
    });
    const onInternalMouseDown = function(event) {
      var _a2, _b;
      const {
        target
      } = event;
      const popupElement = (_a2 = triggerRef2.value) === null || _a2 === void 0 ? void 0 : _a2.getPopupElement();
      if (popupElement && popupElement.contains(target)) {
        const timeoutId = setTimeout(() => {
          var _a3;
          const index2 = activeTimeoutIds.indexOf(timeoutId);
          if (index2 !== -1) {
            activeTimeoutIds.splice(index2, 1);
          }
          cancelSetMockFocused();
          if (!mobile.value && !popupElement.contains(document.activeElement)) {
            (_a3 = selectorRef.value) === null || _a3 === void 0 ? void 0 : _a3.focus();
          }
        });
        activeTimeoutIds.push(timeoutId);
      }
      for (var _len3 = arguments.length, restArgs = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        restArgs[_key3 - 1] = arguments[_key3];
      }
      (_b = props2.onMousedown) === null || _b === void 0 ? void 0 : _b.call(props2, event, ...restArgs);
    };
    const containerWidth = shallowRef(null);
    const onPopupMouseEnter = () => {
    };
    onMounted(() => {
      watch(triggerOpen, () => {
        var _a2;
        if (triggerOpen.value) {
          const newWidth = Math.ceil((_a2 = containerRef.value) === null || _a2 === void 0 ? void 0 : _a2.offsetWidth);
          if (containerWidth.value !== newWidth && !Number.isNaN(newWidth)) {
            containerWidth.value = newWidth;
          }
        }
      }, {
        immediate: true,
        flush: "post"
      });
    });
    useSelectTriggerControl([containerRef, triggerRef2], triggerOpen, onToggleOpen);
    useProvideBaseSelectProps(toReactive(_extends$1(_extends$1({}, toRefs(props2)), {
      open: mergedOpen,
      triggerOpen,
      showSearch: mergedShowSearch,
      multiple,
      toggleOpen: onToggleOpen
    })));
    return () => {
      const _a2 = _extends$1(_extends$1({}, props2), attrs), {
        prefixCls,
        id,
        open: open2,
        defaultOpen,
        mode,
        // Search related
        showSearch,
        searchValue,
        onSearch,
        // Icons
        allowClear,
        clearIcon,
        showArrow,
        inputIcon,
        // Others
        disabled,
        loading,
        getInputElement,
        getPopupContainer,
        placement,
        // Dropdown
        animation,
        transitionName: transitionName2,
        dropdownStyle,
        dropdownClassName,
        dropdownMatchSelectWidth,
        dropdownRender,
        dropdownAlign,
        showAction,
        direction,
        // Tags
        tokenSeparators,
        tagRender,
        optionLabelRender,
        // Events
        onPopupScroll,
        onDropdownVisibleChange,
        onFocus,
        onBlur,
        onKeyup,
        onKeydown,
        onMousedown,
        onClear,
        omitDomProps,
        getRawInputElement,
        displayValues,
        onDisplayValuesChange,
        emptyOptions,
        activeDescendantId,
        activeValue,
        OptionList: OptionList2
      } = _a2, restProps = __rest$10(_a2, ["prefixCls", "id", "open", "defaultOpen", "mode", "showSearch", "searchValue", "onSearch", "allowClear", "clearIcon", "showArrow", "inputIcon", "disabled", "loading", "getInputElement", "getPopupContainer", "placement", "animation", "transitionName", "dropdownStyle", "dropdownClassName", "dropdownMatchSelectWidth", "dropdownRender", "dropdownAlign", "showAction", "direction", "tokenSeparators", "tagRender", "optionLabelRender", "onPopupScroll", "onDropdownVisibleChange", "onFocus", "onBlur", "onKeyup", "onKeydown", "onMousedown", "onClear", "omitDomProps", "getRawInputElement", "displayValues", "onDisplayValuesChange", "emptyOptions", "activeDescendantId", "activeValue", "OptionList"]);
      const customizeInputElement = mode === "combobox" && getInputElement && getInputElement() || null;
      const customizeRawInputElement = typeof getRawInputElement === "function" && getRawInputElement();
      const domProps = _extends$1({}, restProps);
      let onTriggerVisibleChange;
      if (customizeRawInputElement) {
        onTriggerVisibleChange = (newOpen) => {
          onToggleOpen(newOpen);
        };
      }
      DEFAULT_OMIT_PROPS.forEach((propName) => {
        delete domProps[propName];
      });
      omitDomProps === null || omitDomProps === void 0 ? void 0 : omitDomProps.forEach((propName) => {
        delete domProps[propName];
      });
      const mergedShowArrow = showArrow !== void 0 ? showArrow : loading || !multiple.value && mode !== "combobox";
      let arrowNode;
      if (mergedShowArrow) {
        arrowNode = createVNode(TransBtn, {
          "class": classNames(`${prefixCls}-arrow`, {
            [`${prefixCls}-arrow-loading`]: loading
          }),
          "customizeIcon": inputIcon,
          "customizeIconProps": {
            loading,
            searchValue: mergedSearchValue.value,
            open: mergedOpen.value,
            focused: mockFocused.value,
            showSearch: mergedShowSearch.value
          }
        }, null);
      }
      let clearNode;
      const onClearMouseDown = () => {
        onClear === null || onClear === void 0 ? void 0 : onClear();
        onDisplayValuesChange([], {
          type: "clear",
          values: displayValues
        });
        onInternalSearch("", false, false);
      };
      if (!disabled && allowClear && (displayValues.length || mergedSearchValue.value)) {
        clearNode = createVNode(TransBtn, {
          "class": `${prefixCls}-clear`,
          "onMousedown": onClearMouseDown,
          "customizeIcon": clearIcon
        }, {
          default: () => [createTextVNode("×")]
        });
      }
      const optionList = createVNode(OptionList2, {
        "ref": listRef
      }, _extends$1(_extends$1({}, legacyTreeSelectContext.customSlots), {
        option: slots.option
      }));
      const mergedClassName = classNames(prefixCls, attrs.class, {
        [`${prefixCls}-focused`]: mockFocused.value,
        [`${prefixCls}-multiple`]: multiple.value,
        [`${prefixCls}-single`]: !multiple.value,
        [`${prefixCls}-allow-clear`]: allowClear,
        [`${prefixCls}-show-arrow`]: mergedShowArrow,
        [`${prefixCls}-disabled`]: disabled,
        [`${prefixCls}-loading`]: loading,
        [`${prefixCls}-open`]: mergedOpen.value,
        [`${prefixCls}-customize-input`]: customizeInputElement,
        [`${prefixCls}-show-search`]: mergedShowSearch.value
      });
      const selectorNode = createVNode(SelectTrigger, {
        "ref": triggerRef2,
        "disabled": disabled,
        "prefixCls": prefixCls,
        "visible": triggerOpen.value,
        "popupElement": optionList,
        "containerWidth": containerWidth.value,
        "animation": animation,
        "transitionName": transitionName2,
        "dropdownStyle": dropdownStyle,
        "dropdownClassName": dropdownClassName,
        "direction": direction,
        "dropdownMatchSelectWidth": dropdownMatchSelectWidth,
        "dropdownRender": dropdownRender,
        "dropdownAlign": dropdownAlign,
        "placement": placement,
        "getPopupContainer": getPopupContainer,
        "empty": emptyOptions,
        "getTriggerDOMNode": () => selectorDomRef.current,
        "onPopupVisibleChange": onTriggerVisibleChange,
        "onPopupMouseEnter": onPopupMouseEnter,
        "onPopupFocusin": onPopupFocusin,
        "onPopupFocusout": onPopupFocusout
      }, {
        default: () => {
          return customizeRawInputElement ? isValidElement(customizeRawInputElement) && cloneElement(customizeRawInputElement, {
            ref: selectorDomRef
          }, false, true) : createVNode(Selector, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
            "domRef": selectorDomRef,
            "prefixCls": prefixCls,
            "inputElement": customizeInputElement,
            "ref": selectorRef,
            "id": id,
            "showSearch": mergedShowSearch.value,
            "mode": mode,
            "activeDescendantId": activeDescendantId,
            "tagRender": tagRender,
            "optionLabelRender": optionLabelRender,
            "values": displayValues,
            "open": mergedOpen.value,
            "onToggleOpen": onToggleOpen,
            "activeValue": activeValue,
            "searchValue": mergedSearchValue.value,
            "onSearch": onInternalSearch,
            "onSearchSubmit": onInternalSearchSubmit,
            "onRemove": onSelectorRemove,
            "tokenWithEnter": tokenWithEnter.value
          }), null);
        }
      });
      let renderNode;
      if (customizeRawInputElement) {
        renderNode = selectorNode;
      } else {
        renderNode = createVNode("div", _objectSpread2$1(_objectSpread2$1({}, domProps), {}, {
          "class": mergedClassName,
          "ref": containerRef,
          "onMousedown": onInternalMouseDown,
          "onKeydown": onInternalKeyDown,
          "onKeyup": onInternalKeyUp
        }), [mockFocused.value && !mergedOpen.value && createVNode("span", {
          "style": {
            width: 0,
            height: 0,
            position: "absolute",
            overflow: "hidden",
            opacity: 0
          },
          "aria-live": "polite"
        }, [`${displayValues.map((_ref2) => {
          let {
            label,
            value
          } = _ref2;
          return ["number", "string"].includes(typeof label) ? label : value;
        }).join(", ")}`]), selectorNode, arrowNode, clearNode]);
      }
      return renderNode;
    };
  }
});
const Filter = (_ref, _ref2) => {
  let {
    height,
    offset: offset3,
    prefixCls,
    onInnerResize
  } = _ref;
  let {
    slots
  } = _ref2;
  var _a2;
  let outerStyle = {};
  let innerStyle = {
    display: "flex",
    flexDirection: "column"
  };
  if (offset3 !== void 0) {
    outerStyle = {
      height: `${height}px`,
      position: "relative",
      overflow: "hidden"
    };
    innerStyle = _extends$1(_extends$1({}, innerStyle), {
      transform: `translateY(${offset3}px)`,
      position: "absolute",
      left: 0,
      right: 0,
      top: 0
    });
  }
  return createVNode("div", {
    "style": outerStyle
  }, [createVNode(ResizeObserver$1, {
    "onResize": (_ref3) => {
      let {
        offsetHeight
      } = _ref3;
      if (offsetHeight && onInnerResize) {
        onInnerResize();
      }
    }
  }, {
    default: () => [createVNode("div", {
      "style": innerStyle,
      "class": classNames({
        [`${prefixCls}-holder-inner`]: prefixCls
      })
    }, [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)])]
  })]);
};
Filter.displayName = "Filter";
Filter.inheritAttrs = false;
Filter.props = {
  prefixCls: String,
  /** Virtual filler height. Should be `count * itemMinHeight` */
  height: Number,
  /** Set offset of visible items. Should be the top of start item position */
  offset: Number,
  onInnerResize: Function
};
const Item = (_ref, _ref2) => {
  let {
    setRef
  } = _ref;
  let {
    slots
  } = _ref2;
  var _a2;
  const children = flattenChildren((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots));
  return children.length ? cloneVNode(children[0], {
    ref: setRef
  }) : children;
};
Item.props = {
  setRef: {
    type: Function,
    default: () => {
    }
  }
};
const MIN_SIZE = 20;
function getPageY(e2) {
  return "touches" in e2 ? e2.touches[0].pageY : e2.pageY;
}
const ScrollBar = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ScrollBar",
  inheritAttrs: false,
  props: {
    prefixCls: String,
    scrollTop: Number,
    scrollHeight: Number,
    height: Number,
    count: Number,
    onScroll: {
      type: Function
    },
    onStartMove: {
      type: Function
    },
    onStopMove: {
      type: Function
    }
  },
  setup() {
    return {
      moveRaf: null,
      scrollbarRef: createRef(),
      thumbRef: createRef(),
      visibleTimeout: null,
      state: reactive({
        dragging: false,
        pageY: null,
        startTop: null,
        visible: false
      })
    };
  },
  watch: {
    scrollTop: {
      handler() {
        this.delayHidden();
      },
      flush: "post"
    }
  },
  mounted() {
    var _a2, _b;
    (_a2 = this.scrollbarRef.current) === null || _a2 === void 0 ? void 0 : _a2.addEventListener("touchstart", this.onScrollbarTouchStart, supportsPassive ? {
      passive: false
    } : false);
    (_b = this.thumbRef.current) === null || _b === void 0 ? void 0 : _b.addEventListener("touchstart", this.onMouseDown, supportsPassive ? {
      passive: false
    } : false);
  },
  beforeUnmount() {
    this.removeEvents();
    clearTimeout(this.visibleTimeout);
  },
  methods: {
    delayHidden() {
      clearTimeout(this.visibleTimeout);
      this.state.visible = true;
      this.visibleTimeout = setTimeout(() => {
        this.state.visible = false;
      }, 2e3);
    },
    onScrollbarTouchStart(e2) {
      e2.preventDefault();
    },
    onContainerMouseDown(e2) {
      e2.stopPropagation();
      e2.preventDefault();
    },
    // ======================= Clean =======================
    patchEvents() {
      window.addEventListener("mousemove", this.onMouseMove);
      window.addEventListener("mouseup", this.onMouseUp);
      this.thumbRef.current.addEventListener("touchmove", this.onMouseMove, supportsPassive ? {
        passive: false
      } : false);
      this.thumbRef.current.addEventListener("touchend", this.onMouseUp);
    },
    removeEvents() {
      window.removeEventListener("mousemove", this.onMouseMove);
      window.removeEventListener("mouseup", this.onMouseUp);
      this.scrollbarRef.current.removeEventListener("touchstart", this.onScrollbarTouchStart, supportsPassive ? {
        passive: false
      } : false);
      if (this.thumbRef.current) {
        this.thumbRef.current.removeEventListener("touchstart", this.onMouseDown, supportsPassive ? {
          passive: false
        } : false);
        this.thumbRef.current.removeEventListener("touchmove", this.onMouseMove, supportsPassive ? {
          passive: false
        } : false);
        this.thumbRef.current.removeEventListener("touchend", this.onMouseUp);
      }
      wrapperRaf.cancel(this.moveRaf);
    },
    // ======================= Thumb =======================
    onMouseDown(e2) {
      const {
        onStartMove
      } = this.$props;
      _extends$1(this.state, {
        dragging: true,
        pageY: getPageY(e2),
        startTop: this.getTop()
      });
      onStartMove();
      this.patchEvents();
      e2.stopPropagation();
      e2.preventDefault();
    },
    onMouseMove(e2) {
      const {
        dragging,
        pageY,
        startTop
      } = this.state;
      const {
        onScroll
      } = this.$props;
      wrapperRaf.cancel(this.moveRaf);
      if (dragging) {
        const offsetY = getPageY(e2) - pageY;
        const newTop = startTop + offsetY;
        const enableScrollRange = this.getEnableScrollRange();
        const enableHeightRange = this.getEnableHeightRange();
        const ptg = enableHeightRange ? newTop / enableHeightRange : 0;
        const newScrollTop = Math.ceil(ptg * enableScrollRange);
        this.moveRaf = wrapperRaf(() => {
          onScroll(newScrollTop);
        });
      }
    },
    onMouseUp() {
      const {
        onStopMove
      } = this.$props;
      this.state.dragging = false;
      onStopMove();
      this.removeEvents();
    },
    // ===================== Calculate =====================
    getSpinHeight() {
      const {
        height,
        scrollHeight
      } = this.$props;
      let baseHeight = height / scrollHeight * 100;
      baseHeight = Math.max(baseHeight, MIN_SIZE);
      baseHeight = Math.min(baseHeight, height / 2);
      return Math.floor(baseHeight);
    },
    getEnableScrollRange() {
      const {
        scrollHeight,
        height
      } = this.$props;
      return scrollHeight - height || 0;
    },
    getEnableHeightRange() {
      const {
        height
      } = this.$props;
      const spinHeight = this.getSpinHeight();
      return height - spinHeight || 0;
    },
    getTop() {
      const {
        scrollTop
      } = this.$props;
      const enableScrollRange = this.getEnableScrollRange();
      const enableHeightRange = this.getEnableHeightRange();
      if (scrollTop === 0 || enableScrollRange === 0) {
        return 0;
      }
      const ptg = scrollTop / enableScrollRange;
      return ptg * enableHeightRange;
    },
    // Not show scrollbar when height is large than scrollHeight
    showScroll() {
      const {
        height,
        scrollHeight
      } = this.$props;
      return scrollHeight > height;
    }
  },
  render() {
    const {
      dragging,
      visible
    } = this.state;
    const {
      prefixCls
    } = this.$props;
    const spinHeight = this.getSpinHeight() + "px";
    const top = this.getTop() + "px";
    const canScroll = this.showScroll();
    const mergedVisible = canScroll && visible;
    return createVNode("div", {
      "ref": this.scrollbarRef,
      "class": classNames(`${prefixCls}-scrollbar`, {
        [`${prefixCls}-scrollbar-show`]: canScroll
      }),
      "style": {
        width: "8px",
        top: 0,
        bottom: 0,
        right: 0,
        position: "absolute",
        display: mergedVisible ? void 0 : "none"
      },
      "onMousedown": this.onContainerMouseDown,
      "onMousemove": this.delayHidden
    }, [createVNode("div", {
      "ref": this.thumbRef,
      "class": classNames(`${prefixCls}-scrollbar-thumb`, {
        [`${prefixCls}-scrollbar-thumb-moving`]: dragging
      }),
      "style": {
        width: "100%",
        height: spinHeight,
        top,
        left: 0,
        position: "absolute",
        background: "rgba(0, 0, 0, 0.5)",
        borderRadius: "99px",
        cursor: "pointer",
        userSelect: "none"
      },
      "onMousedown": this.onMouseDown
    }, null)]);
  }
});
function useHeights(mergedData, getKey2, onItemAdd, onItemRemove) {
  const instance = /* @__PURE__ */ new Map();
  const heights = /* @__PURE__ */ new Map();
  const updatedMark = ref(Symbol("update"));
  watch(mergedData, () => {
    updatedMark.value = Symbol("update");
  });
  let collectRaf = void 0;
  function cancelRaf() {
    wrapperRaf.cancel(collectRaf);
  }
  function collectHeight() {
    cancelRaf();
    collectRaf = wrapperRaf(() => {
      instance.forEach((element, key2) => {
        if (element && element.offsetParent) {
          const {
            offsetHeight
          } = element;
          if (heights.get(key2) !== offsetHeight) {
            updatedMark.value = Symbol("update");
            heights.set(key2, element.offsetHeight);
          }
        }
      });
    });
  }
  function setInstance(item, ins) {
    const key2 = getKey2(item);
    instance.get(key2);
    if (ins) {
      instance.set(key2, ins.$el || ins);
      collectHeight();
    } else {
      instance.delete(key2);
    }
  }
  onUnmounted(() => {
    cancelRaf();
  });
  return [setInstance, collectHeight, heights, updatedMark];
}
function useScrollTo(containerRef, mergedData, heights, props2, getKey2, collectHeight, syncScrollTop, triggerFlash) {
  let scroll;
  return (arg) => {
    if (arg === null || arg === void 0) {
      triggerFlash();
      return;
    }
    wrapperRaf.cancel(scroll);
    const data = mergedData.value;
    const itemHeight = props2.itemHeight;
    if (typeof arg === "number") {
      syncScrollTop(arg);
    } else if (arg && typeof arg === "object") {
      let index2;
      const {
        align
      } = arg;
      if ("index" in arg) {
        ({
          index: index2
        } = arg);
      } else {
        index2 = data.findIndex((item) => getKey2(item) === arg.key);
      }
      const {
        offset: offset3 = 0
      } = arg;
      const syncScroll = (times, targetAlign) => {
        if (times < 0 || !containerRef.value) return;
        const height = containerRef.value.clientHeight;
        let needCollectHeight = false;
        let newTargetAlign = targetAlign;
        if (height) {
          const mergedAlign = targetAlign || align;
          let stackTop = 0;
          let itemTop = 0;
          let itemBottom = 0;
          const maxLen = Math.min(data.length, index2);
          for (let i2 = 0; i2 <= maxLen; i2 += 1) {
            const key2 = getKey2(data[i2]);
            itemTop = stackTop;
            const cacheHeight = heights.get(key2);
            itemBottom = itemTop + (cacheHeight === void 0 ? itemHeight : cacheHeight);
            stackTop = itemBottom;
            if (i2 === index2 && cacheHeight === void 0) {
              needCollectHeight = true;
            }
          }
          const scrollTop = containerRef.value.scrollTop;
          let targetTop = null;
          switch (mergedAlign) {
            case "top":
              targetTop = itemTop - offset3;
              break;
            case "bottom":
              targetTop = itemBottom - height + offset3;
              break;
            default: {
              const scrollBottom = scrollTop + height;
              if (itemTop < scrollTop) {
                newTargetAlign = "top";
              } else if (itemBottom > scrollBottom) {
                newTargetAlign = "bottom";
              }
            }
          }
          if (targetTop !== null && targetTop !== scrollTop) {
            syncScrollTop(targetTop);
          }
        }
        scroll = wrapperRaf(() => {
          if (needCollectHeight) {
            collectHeight();
          }
          syncScroll(times - 1, newTargetAlign);
        }, 2);
      };
      syncScroll(5);
    }
  };
}
const isFF = typeof navigator === "object" && /Firefox/i.test(navigator.userAgent);
const useOriginScroll = (isScrollAtTop, isScrollAtBottom) => {
  let lock = false;
  let lockTimeout = null;
  function lockScroll() {
    clearTimeout(lockTimeout);
    lock = true;
    lockTimeout = setTimeout(() => {
      lock = false;
    }, 50);
  }
  return function(deltaY) {
    let smoothOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    const originScroll = (
      // Pass origin wheel when on the top
      deltaY < 0 && isScrollAtTop.value || // Pass origin wheel when on the bottom
      deltaY > 0 && isScrollAtBottom.value
    );
    if (smoothOffset && originScroll) {
      clearTimeout(lockTimeout);
      lock = false;
    } else if (!originScroll || lock) {
      lockScroll();
    }
    return !lock && originScroll;
  };
};
function useFrameWheel(inVirtual, isScrollAtTop, isScrollAtBottom, onWheelDelta) {
  let offsetRef = 0;
  let nextFrame = null;
  let wheelValue = null;
  let isMouseScroll = false;
  const originScroll = useOriginScroll(isScrollAtTop, isScrollAtBottom);
  function onWheel(event) {
    if (!inVirtual.value) return;
    wrapperRaf.cancel(nextFrame);
    const {
      deltaY
    } = event;
    offsetRef += deltaY;
    wheelValue = deltaY;
    if (originScroll(deltaY)) return;
    if (!isFF) {
      event.preventDefault();
    }
    nextFrame = wrapperRaf(() => {
      const patchMultiple = isMouseScroll ? 10 : 1;
      onWheelDelta(offsetRef * patchMultiple);
      offsetRef = 0;
    });
  }
  function onFireFoxScroll(event) {
    if (!inVirtual.value) return;
    isMouseScroll = event.detail === wheelValue;
  }
  return [onWheel, onFireFoxScroll];
}
const SMOOTH_PTG = 14 / 15;
function useMobileTouchMove(inVirtual, listRef, callback) {
  let touched = false;
  let touchY = 0;
  let element = null;
  let interval = null;
  const cleanUpEvents = () => {
    if (element) {
      element.removeEventListener("touchmove", onTouchMove);
      element.removeEventListener("touchend", onTouchEnd);
    }
  };
  const onTouchMove = (e2) => {
    if (touched) {
      const currentY = Math.ceil(e2.touches[0].pageY);
      let offsetY = touchY - currentY;
      touchY = currentY;
      if (callback(offsetY)) {
        e2.preventDefault();
      }
      clearInterval(interval);
      interval = setInterval(() => {
        offsetY *= SMOOTH_PTG;
        if (!callback(offsetY, true) || Math.abs(offsetY) <= 0.1) {
          clearInterval(interval);
        }
      }, 16);
    }
  };
  const onTouchEnd = () => {
    touched = false;
    cleanUpEvents();
  };
  const onTouchStart = (e2) => {
    cleanUpEvents();
    if (e2.touches.length === 1 && !touched) {
      touched = true;
      touchY = Math.ceil(e2.touches[0].pageY);
      element = e2.target;
      element.addEventListener("touchmove", onTouchMove, {
        passive: false
      });
      element.addEventListener("touchend", onTouchEnd);
    }
  };
  const noop2 = () => {
  };
  onMounted(() => {
    document.addEventListener("touchmove", noop2, {
      passive: false
    });
    watch(inVirtual, (val) => {
      listRef.value.removeEventListener("touchstart", onTouchStart);
      cleanUpEvents();
      clearInterval(interval);
      if (val) {
        listRef.value.addEventListener("touchstart", onTouchStart, {
          passive: false
        });
      }
    }, {
      immediate: true
    });
  });
  onBeforeUnmount(() => {
    document.removeEventListener("touchmove", noop2);
  });
}
var __rest$$ = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const EMPTY_DATA$1 = [];
const ScrollStyle = {
  overflowY: "auto",
  overflowAnchor: "none"
};
function renderChildren(list, startIndex, endIndex, setNodeRef, renderFunc, _ref) {
  let {
    getKey: getKey2
  } = _ref;
  return list.slice(startIndex, endIndex + 1).map((item, index2) => {
    const eleIndex = startIndex + index2;
    const node2 = renderFunc(item, eleIndex, {
      // style: status === 'MEASURE_START' ? { visibility: 'hidden' } : {},
    });
    const key2 = getKey2(item);
    return createVNode(Item, {
      "key": key2,
      "setRef": (ele) => setNodeRef(item, ele)
    }, {
      default: () => [node2]
    });
  });
}
const List$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "List",
  inheritAttrs: false,
  props: {
    prefixCls: String,
    data: PropTypes.array,
    height: Number,
    itemHeight: Number,
    /** If not match virtual scroll condition, Set List still use height of container. */
    fullHeight: {
      type: Boolean,
      default: void 0
    },
    itemKey: {
      type: [String, Number, Function],
      required: true
    },
    component: {
      type: [String, Object]
    },
    /** Set `false` will always use real scroll instead of virtual one */
    virtual: {
      type: Boolean,
      default: void 0
    },
    children: Function,
    onScroll: Function,
    onMousedown: Function,
    onMouseenter: Function,
    onVisibleChange: Function
  },
  setup(props2, _ref2) {
    let {
      expose
    } = _ref2;
    const useVirtual = computed(() => {
      const {
        height,
        itemHeight,
        virtual
      } = props2;
      return !!(virtual !== false && height && itemHeight);
    });
    const inVirtual = computed(() => {
      const {
        height,
        itemHeight,
        data: data2
      } = props2;
      return useVirtual.value && data2 && itemHeight * data2.length > height;
    });
    const state = reactive({
      scrollTop: 0,
      scrollMoving: false
    });
    const data = computed(() => {
      return props2.data || EMPTY_DATA$1;
    });
    const mergedData = shallowRef([]);
    watch(data, () => {
      mergedData.value = toRaw(data.value).slice();
    }, {
      immediate: true
    });
    const itemKey2 = shallowRef((_item) => void 0);
    watch(() => props2.itemKey, (val) => {
      if (typeof val === "function") {
        itemKey2.value = val;
      } else {
        itemKey2.value = (item) => item === null || item === void 0 ? void 0 : item[val];
      }
    }, {
      immediate: true
    });
    const componentRef = shallowRef();
    const fillerInnerRef = shallowRef();
    const scrollBarRef = shallowRef();
    const getKey2 = (item) => {
      return itemKey2.value(item);
    };
    const sharedConfig = {
      getKey: getKey2
    };
    function syncScrollTop(newTop) {
      let value;
      if (typeof newTop === "function") {
        value = newTop(state.scrollTop);
      } else {
        value = newTop;
      }
      const alignedTop = keepInRange(value);
      if (componentRef.value) {
        componentRef.value.scrollTop = alignedTop;
      }
      state.scrollTop = alignedTop;
    }
    const [setInstance, collectHeight, heights, updatedMark] = useHeights(mergedData, getKey2);
    const calRes = reactive({
      scrollHeight: void 0,
      start: 0,
      end: 0,
      offset: void 0
    });
    const offsetHeight = shallowRef(0);
    onMounted(() => {
      nextTick(() => {
        var _a2;
        offsetHeight.value = ((_a2 = fillerInnerRef.value) === null || _a2 === void 0 ? void 0 : _a2.offsetHeight) || 0;
      });
    });
    onUpdated(() => {
      nextTick(() => {
        var _a2;
        offsetHeight.value = ((_a2 = fillerInnerRef.value) === null || _a2 === void 0 ? void 0 : _a2.offsetHeight) || 0;
      });
    });
    watch([useVirtual, mergedData], () => {
      if (!useVirtual.value) {
        _extends$1(calRes, {
          scrollHeight: void 0,
          start: 0,
          end: mergedData.value.length - 1,
          offset: void 0
        });
      }
    }, {
      immediate: true
    });
    watch([useVirtual, mergedData, offsetHeight, inVirtual], () => {
      if (useVirtual.value && !inVirtual.value) {
        _extends$1(calRes, {
          scrollHeight: offsetHeight.value,
          start: 0,
          end: mergedData.value.length - 1,
          offset: void 0
        });
      }
      if (componentRef.value) {
        state.scrollTop = componentRef.value.scrollTop;
      }
    }, {
      immediate: true
    });
    watch([inVirtual, useVirtual, () => state.scrollTop, mergedData, updatedMark, () => props2.height, offsetHeight], () => {
      if (!useVirtual.value || !inVirtual.value) {
        return;
      }
      let itemTop = 0;
      let startIndex;
      let startOffset;
      let endIndex;
      const dataLen = mergedData.value.length;
      const data2 = mergedData.value;
      const scrollTop = state.scrollTop;
      const {
        itemHeight,
        height
      } = props2;
      const scrollTopHeight = scrollTop + height;
      for (let i2 = 0; i2 < dataLen; i2 += 1) {
        const item = data2[i2];
        const key2 = getKey2(item);
        let cacheHeight = heights.get(key2);
        if (cacheHeight === void 0) {
          cacheHeight = itemHeight;
        }
        const currentItemBottom = itemTop + cacheHeight;
        if (startIndex === void 0 && currentItemBottom >= scrollTop) {
          startIndex = i2;
          startOffset = itemTop;
        }
        if (endIndex === void 0 && currentItemBottom > scrollTopHeight) {
          endIndex = i2;
        }
        itemTop = currentItemBottom;
      }
      if (startIndex === void 0) {
        startIndex = 0;
        startOffset = 0;
        endIndex = Math.ceil(height / itemHeight);
      }
      if (endIndex === void 0) {
        endIndex = dataLen - 1;
      }
      endIndex = Math.min(endIndex + 1, dataLen);
      _extends$1(calRes, {
        scrollHeight: itemTop,
        start: startIndex,
        end: endIndex,
        offset: startOffset
      });
    }, {
      immediate: true
    });
    const maxScrollHeight = computed(() => calRes.scrollHeight - props2.height);
    function keepInRange(newScrollTop) {
      let newTop = newScrollTop;
      if (!Number.isNaN(maxScrollHeight.value)) {
        newTop = Math.min(newTop, maxScrollHeight.value);
      }
      newTop = Math.max(newTop, 0);
      return newTop;
    }
    const isScrollAtTop = computed(() => state.scrollTop <= 0);
    const isScrollAtBottom = computed(() => state.scrollTop >= maxScrollHeight.value);
    const originScroll = useOriginScroll(isScrollAtTop, isScrollAtBottom);
    function onScrollBar(newScrollTop) {
      const newTop = newScrollTop;
      syncScrollTop(newTop);
    }
    function onFallbackScroll(e2) {
      var _a2;
      const {
        scrollTop: newScrollTop
      } = e2.currentTarget;
      if (newScrollTop !== state.scrollTop) {
        syncScrollTop(newScrollTop);
      }
      (_a2 = props2.onScroll) === null || _a2 === void 0 ? void 0 : _a2.call(props2, e2);
    }
    const [onRawWheel, onFireFoxScroll] = useFrameWheel(useVirtual, isScrollAtTop, isScrollAtBottom, (offsetY) => {
      syncScrollTop((top) => {
        const newTop = top + offsetY;
        return newTop;
      });
    });
    useMobileTouchMove(useVirtual, componentRef, (deltaY, smoothOffset) => {
      if (originScroll(deltaY, smoothOffset)) {
        return false;
      }
      onRawWheel({
        preventDefault() {
        },
        deltaY
      });
      return true;
    });
    function onMozMousePixelScroll(e2) {
      if (useVirtual.value) {
        e2.preventDefault();
      }
    }
    const removeEventListener = () => {
      if (componentRef.value) {
        componentRef.value.removeEventListener("wheel", onRawWheel, supportsPassive ? {
          passive: false
        } : false);
        componentRef.value.removeEventListener("DOMMouseScroll", onFireFoxScroll);
        componentRef.value.removeEventListener("MozMousePixelScroll", onMozMousePixelScroll);
      }
    };
    watchEffect(() => {
      nextTick(() => {
        if (componentRef.value) {
          removeEventListener();
          componentRef.value.addEventListener("wheel", onRawWheel, supportsPassive ? {
            passive: false
          } : false);
          componentRef.value.addEventListener("DOMMouseScroll", onFireFoxScroll);
          componentRef.value.addEventListener("MozMousePixelScroll", onMozMousePixelScroll);
        }
      });
    });
    onBeforeUnmount(() => {
      removeEventListener();
    });
    const scrollTo2 = useScrollTo(componentRef, mergedData, heights, props2, getKey2, collectHeight, syncScrollTop, () => {
      var _a2;
      (_a2 = scrollBarRef.value) === null || _a2 === void 0 ? void 0 : _a2.delayHidden();
    });
    expose({
      scrollTo: scrollTo2
    });
    const componentStyle = computed(() => {
      let cs = null;
      if (props2.height) {
        cs = _extends$1({
          [props2.fullHeight ? "height" : "maxHeight"]: props2.height + "px"
        }, ScrollStyle);
        if (useVirtual.value) {
          cs.overflowY = "hidden";
          if (state.scrollMoving) {
            cs.pointerEvents = "none";
          }
        }
      }
      return cs;
    });
    watch([() => calRes.start, () => calRes.end, mergedData], () => {
      if (props2.onVisibleChange) {
        const renderList = mergedData.value.slice(calRes.start, calRes.end + 1);
        props2.onVisibleChange(renderList, mergedData.value);
      }
    }, {
      flush: "post"
    });
    const delayHideScrollBar = () => {
      var _a2;
      (_a2 = scrollBarRef.value) === null || _a2 === void 0 ? void 0 : _a2.delayHidden();
    };
    return {
      state,
      mergedData,
      componentStyle,
      onFallbackScroll,
      onScrollBar,
      componentRef,
      useVirtual,
      calRes,
      collectHeight,
      setInstance,
      sharedConfig,
      scrollBarRef,
      fillerInnerRef,
      delayHideScrollBar
    };
  },
  render() {
    const _a2 = _extends$1(_extends$1({}, this.$props), this.$attrs), {
      prefixCls = "rc-virtual-list",
      height,
      itemHeight,
      // eslint-disable-next-line no-unused-vars
      fullHeight,
      data,
      itemKey: itemKey2,
      virtual,
      component: Component = "div",
      onScroll,
      children = this.$slots.default,
      style,
      class: className
    } = _a2, restProps = __rest$$(_a2, ["prefixCls", "height", "itemHeight", "fullHeight", "data", "itemKey", "virtual", "component", "onScroll", "children", "style", "class"]);
    const mergedClassName = classNames(prefixCls, className);
    const {
      scrollTop
    } = this.state;
    const {
      scrollHeight,
      offset: offset3,
      start,
      end
    } = this.calRes;
    const {
      componentStyle,
      onFallbackScroll,
      onScrollBar,
      useVirtual,
      collectHeight,
      sharedConfig,
      setInstance,
      mergedData,
      delayHideScrollBar
    } = this;
    return createVNode("div", _objectSpread2$1({
      "style": _extends$1(_extends$1({}, style), {
        position: "relative"
      }),
      "class": mergedClassName
    }, restProps), [createVNode(Component, {
      "class": `${prefixCls}-holder`,
      "style": componentStyle,
      "ref": "componentRef",
      "onScroll": onFallbackScroll,
      "onMouseenter": delayHideScrollBar
    }, {
      default: () => [createVNode(Filter, {
        "prefixCls": prefixCls,
        "height": scrollHeight,
        "offset": offset3,
        "onInnerResize": collectHeight,
        "ref": "fillerInnerRef"
      }, {
        default: () => renderChildren(mergedData, start, end, setInstance, children, sharedConfig)
      })]
    }), useVirtual && createVNode(ScrollBar, {
      "ref": "scrollBarRef",
      "prefixCls": prefixCls,
      "scrollTop": scrollTop,
      "height": height,
      "scrollHeight": scrollHeight,
      "count": mergedData.length,
      "onScroll": onScrollBar,
      "onStartMove": () => {
        this.state.scrollMoving = true;
      },
      "onStopMove": () => {
        this.state.scrollMoving = false;
      }
    }, null)]);
  }
});
function useMemo(getValue2, condition, shouldUpdate) {
  const cacheRef = ref(getValue2());
  watch(condition, (next2, pre) => {
    if (shouldUpdate) {
      if (shouldUpdate(next2, pre)) {
        cacheRef.value = getValue2();
      }
    } else {
      cacheRef.value = getValue2();
    }
  });
  return cacheRef;
}
function isPlatformMac() {
  return /(mac\sos|macintosh)/i.test(navigator.appVersion);
}
const SelectContextKey = Symbol("SelectContextKey");
function useProvideSelectProps(props2) {
  return provide(SelectContextKey, props2);
}
function useSelectProps() {
  return inject(SelectContextKey, {});
}
var __rest$_ = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
function isTitleType(content) {
  return typeof content === "string" || typeof content === "number";
}
const OptionList$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "OptionList",
  inheritAttrs: false,
  setup(_2, _ref) {
    let {
      expose,
      slots
    } = _ref;
    const baseProps2 = useBaseProps();
    const props2 = useSelectProps();
    const itemPrefixCls = computed(() => `${baseProps2.prefixCls}-item`);
    const memoFlattenOptions = useMemo(() => props2.flattenOptions, [() => baseProps2.open, () => props2.flattenOptions], (next2) => next2[0]);
    const listRef = createRef();
    const onListMouseDown = (event) => {
      event.preventDefault();
    };
    const scrollIntoView2 = (args) => {
      if (listRef.current) {
        listRef.current.scrollTo(typeof args === "number" ? {
          index: args
        } : args);
      }
    };
    const getEnabledActiveIndex = function(index2) {
      let offset3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      const len = memoFlattenOptions.value.length;
      for (let i2 = 0; i2 < len; i2 += 1) {
        const current = (index2 + i2 * offset3 + len) % len;
        const {
          group,
          data
        } = memoFlattenOptions.value[current];
        if (!group && !data.disabled) {
          return current;
        }
      }
      return -1;
    };
    const state = reactive({
      activeIndex: getEnabledActiveIndex(0)
    });
    const setActive = function(index2) {
      let fromKeyboard = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      state.activeIndex = index2;
      const info = {
        source: fromKeyboard ? "keyboard" : "mouse"
      };
      const flattenItem = memoFlattenOptions.value[index2];
      if (!flattenItem) {
        props2.onActiveValue(null, -1, info);
        return;
      }
      props2.onActiveValue(flattenItem.value, index2, info);
    };
    watch([() => memoFlattenOptions.value.length, () => baseProps2.searchValue], () => {
      setActive(props2.defaultActiveFirstOption !== false ? getEnabledActiveIndex(0) : -1);
    }, {
      immediate: true
    });
    const isSelected = (value) => props2.rawValues.has(value) && baseProps2.mode !== "combobox";
    watch([() => baseProps2.open, () => baseProps2.searchValue], () => {
      if (!baseProps2.multiple && baseProps2.open && props2.rawValues.size === 1) {
        const value = Array.from(props2.rawValues)[0];
        const index2 = toRaw(memoFlattenOptions.value).findIndex((_ref2) => {
          let {
            data
          } = _ref2;
          return data[props2.fieldNames.value] === value;
        });
        if (index2 !== -1) {
          setActive(index2);
          nextTick(() => {
            scrollIntoView2(index2);
          });
        }
      }
      if (baseProps2.open) {
        nextTick(() => {
          var _a2;
          (_a2 = listRef.current) === null || _a2 === void 0 ? void 0 : _a2.scrollTo(void 0);
        });
      }
    }, {
      immediate: true,
      flush: "post"
    });
    const onSelectValue = (value) => {
      if (value !== void 0) {
        props2.onSelect(value, {
          selected: !props2.rawValues.has(value)
        });
      }
      if (!baseProps2.multiple) {
        baseProps2.toggleOpen(false);
      }
    };
    const getLabel = (item) => typeof item.label === "function" ? item.label() : item.label;
    function renderItem(index2) {
      const item = memoFlattenOptions.value[index2];
      if (!item) return null;
      const itemData = item.data || {};
      const {
        value
      } = itemData;
      const {
        group
      } = item;
      const attrs = pickAttrs(itemData, true);
      const mergedLabel = getLabel(item);
      return item ? createVNode("div", _objectSpread2$1(_objectSpread2$1({
        "aria-label": typeof mergedLabel === "string" && !group ? mergedLabel : null
      }, attrs), {}, {
        "key": index2,
        "role": group ? "presentation" : "option",
        "id": `${baseProps2.id}_list_${index2}`,
        "aria-selected": isSelected(value)
      }), [value]) : null;
    }
    const onKeydown = (event) => {
      const {
        which,
        ctrlKey
      } = event;
      switch (which) {
        // >>> Arrow keys & ctrl + n/p on Mac
        case KeyCode.N:
        case KeyCode.P:
        case KeyCode.UP:
        case KeyCode.DOWN: {
          let offset3 = 0;
          if (which === KeyCode.UP) {
            offset3 = -1;
          } else if (which === KeyCode.DOWN) {
            offset3 = 1;
          } else if (isPlatformMac() && ctrlKey) {
            if (which === KeyCode.N) {
              offset3 = 1;
            } else if (which === KeyCode.P) {
              offset3 = -1;
            }
          }
          if (offset3 !== 0) {
            const nextActiveIndex = getEnabledActiveIndex(state.activeIndex + offset3, offset3);
            scrollIntoView2(nextActiveIndex);
            setActive(nextActiveIndex, true);
          }
          break;
        }
        // >>> Select
        case KeyCode.ENTER: {
          const item = memoFlattenOptions.value[state.activeIndex];
          if (item && !item.data.disabled) {
            onSelectValue(item.value);
          } else {
            onSelectValue(void 0);
          }
          if (baseProps2.open) {
            event.preventDefault();
          }
          break;
        }
        // >>> Close
        case KeyCode.ESC: {
          baseProps2.toggleOpen(false);
          if (baseProps2.open) {
            event.stopPropagation();
          }
        }
      }
    };
    const onKeyup = () => {
    };
    const scrollTo2 = (index2) => {
      scrollIntoView2(index2);
    };
    expose({
      onKeydown,
      onKeyup,
      scrollTo: scrollTo2
    });
    return () => {
      const {
        id,
        notFoundContent,
        onPopupScroll
      } = baseProps2;
      const {
        menuItemSelectedIcon,
        fieldNames,
        virtual,
        listHeight,
        listItemHeight
      } = props2;
      const renderOption = slots.option;
      const {
        activeIndex
      } = state;
      const omitFieldNameList = Object.keys(fieldNames).map((key2) => fieldNames[key2]);
      if (memoFlattenOptions.value.length === 0) {
        return createVNode("div", {
          "role": "listbox",
          "id": `${id}_list`,
          "class": `${itemPrefixCls.value}-empty`,
          "onMousedown": onListMouseDown
        }, [notFoundContent]);
      }
      return createVNode(Fragment, null, [createVNode("div", {
        "role": "listbox",
        "id": `${id}_list`,
        "style": {
          height: 0,
          width: 0,
          overflow: "hidden"
        }
      }, [renderItem(activeIndex - 1), renderItem(activeIndex), renderItem(activeIndex + 1)]), createVNode(List$1, {
        "itemKey": "key",
        "ref": listRef,
        "data": memoFlattenOptions.value,
        "height": listHeight,
        "itemHeight": listItemHeight,
        "fullHeight": false,
        "onMousedown": onListMouseDown,
        "onScroll": onPopupScroll,
        "virtual": virtual
      }, {
        default: (item, itemIndex) => {
          var _a2;
          const {
            group,
            groupOption,
            data,
            value
          } = item;
          const {
            key: key2
          } = data;
          const label = typeof item.label === "function" ? item.label() : item.label;
          if (group) {
            const groupTitle = (_a2 = data.title) !== null && _a2 !== void 0 ? _a2 : isTitleType(label) && label;
            return createVNode("div", {
              "class": classNames(itemPrefixCls.value, `${itemPrefixCls.value}-group`),
              "title": groupTitle
            }, [renderOption ? renderOption(data) : label !== void 0 ? label : key2]);
          }
          const {
            disabled,
            title,
            children,
            style,
            class: cls,
            className
          } = data, otherProps = __rest$_(data, ["disabled", "title", "children", "style", "class", "className"]);
          const passedProps = omit$1(otherProps, omitFieldNameList);
          const selected = isSelected(value);
          const optionPrefixCls = `${itemPrefixCls.value}-option`;
          const optionClassName = classNames(itemPrefixCls.value, optionPrefixCls, cls, className, {
            [`${optionPrefixCls}-grouped`]: groupOption,
            [`${optionPrefixCls}-active`]: activeIndex === itemIndex && !disabled,
            [`${optionPrefixCls}-disabled`]: disabled,
            [`${optionPrefixCls}-selected`]: selected
          });
          const mergedLabel = getLabel(item);
          const iconVisible = !menuItemSelectedIcon || typeof menuItemSelectedIcon === "function" || selected;
          const content = typeof mergedLabel === "number" ? mergedLabel : mergedLabel || value;
          let optionTitle = isTitleType(content) ? content.toString() : void 0;
          if (title !== void 0) {
            optionTitle = title;
          }
          return createVNode("div", _objectSpread2$1(_objectSpread2$1({}, passedProps), {}, {
            "aria-selected": selected,
            "class": optionClassName,
            "title": optionTitle,
            "onMousemove": (e2) => {
              if (otherProps.onMousemove) {
                otherProps.onMousemove(e2);
              }
              if (activeIndex === itemIndex || disabled) {
                return;
              }
              setActive(itemIndex);
            },
            "onClick": (e2) => {
              if (!disabled) {
                onSelectValue(value);
              }
              if (otherProps.onClick) {
                otherProps.onClick(e2);
              }
            },
            "style": style
          }), [createVNode("div", {
            "class": `${optionPrefixCls}-content`
          }, [renderOption ? renderOption(data) : content]), isValidElement(menuItemSelectedIcon) || selected, iconVisible && createVNode(TransBtn, {
            "class": `${itemPrefixCls.value}-option-state`,
            "customizeIcon": menuItemSelectedIcon,
            "customizeIconProps": {
              isSelected: selected
            }
          }, {
            default: () => [selected ? "✓" : null]
          })]);
        }
      })]);
    };
  }
});
var __rest$Z = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
function convertNodeToOption(node2) {
  const _a2 = node2, {
    key: key2,
    children
  } = _a2, _b = _a2.props, {
    value,
    disabled
  } = _b, restProps = __rest$Z(_b, ["value", "disabled"]);
  const child = children === null || children === void 0 ? void 0 : children.default;
  return _extends$1({
    key: key2,
    value: value !== void 0 ? value : key2,
    children: child,
    disabled: disabled || disabled === ""
  }, restProps);
}
function convertChildrenToData(nodes) {
  let optionOnly = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  const dd = flattenChildren(nodes).map((node2, index2) => {
    var _a2;
    if (!isValidElement(node2) || !node2.type) {
      return null;
    }
    const {
      type: {
        isSelectOptGroup
      },
      key: key2,
      children,
      props: props2
    } = node2;
    if (optionOnly || !isSelectOptGroup) {
      return convertNodeToOption(node2);
    }
    const child = children && children.default ? children.default() : void 0;
    const label = (props2 === null || props2 === void 0 ? void 0 : props2.label) || ((_a2 = children.label) === null || _a2 === void 0 ? void 0 : _a2.call(children)) || key2;
    return _extends$1(_extends$1({
      key: `__RC_SELECT_GRP__${key2 === null ? index2 : String(key2)}__`
    }, props2), {
      label,
      options: convertChildrenToData(child || [])
    });
  }).filter((data) => data);
  return dd;
}
function useOptions(options, children, fieldNames) {
  const mergedOptions = shallowRef();
  const valueOptions = shallowRef();
  const labelOptions = shallowRef();
  const tempMergedOptions = shallowRef([]);
  watch([options, children], () => {
    if (options.value) {
      tempMergedOptions.value = toRaw(options.value).slice();
    } else {
      tempMergedOptions.value = convertChildrenToData(children.value);
    }
  }, {
    immediate: true,
    deep: true
  });
  watchEffect(() => {
    const newOptions = tempMergedOptions.value;
    const newValueOptions = /* @__PURE__ */ new Map();
    const newLabelOptions = /* @__PURE__ */ new Map();
    const fieldNamesValue = fieldNames.value;
    function dig(optionList) {
      let isChildren = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      for (let i2 = 0; i2 < optionList.length; i2 += 1) {
        const option = optionList[i2];
        if (!option[fieldNamesValue.options] || isChildren) {
          newValueOptions.set(option[fieldNamesValue.value], option);
          newLabelOptions.set(option[fieldNamesValue.label], option);
        } else {
          dig(option[fieldNamesValue.options], true);
        }
      }
    }
    dig(newOptions);
    mergedOptions.value = newOptions;
    valueOptions.value = newValueOptions;
    labelOptions.value = newLabelOptions;
  });
  return {
    options: mergedOptions,
    valueOptions,
    labelOptions
  };
}
let uuid$4 = 0;
const isBrowserClient = canUseDom();
function getUUID$1() {
  let retId;
  if (isBrowserClient) {
    retId = uuid$4;
    uuid$4 += 1;
  } else {
    retId = "TEST_OR_SSR";
  }
  return retId;
}
function useId() {
  let id = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ref("");
  const innerId = `rc_select_${getUUID$1()}`;
  return id.value || innerId;
}
function toArray$6(value) {
  if (Array.isArray(value)) {
    return value;
  }
  return value !== void 0 ? [value] : [];
}
function includes(test, search) {
  return toArray$6(test).join("").toUpperCase().includes(search);
}
const useFilterOptions = (options, fieldNames, searchValue, filterOption, optionFilterProp) => computed(() => {
  const searchValueVal = searchValue.value;
  const optionFilterPropValue = optionFilterProp === null || optionFilterProp === void 0 ? void 0 : optionFilterProp.value;
  const filterOptionValue = filterOption === null || filterOption === void 0 ? void 0 : filterOption.value;
  if (!searchValueVal || filterOptionValue === false) {
    return options.value;
  }
  const {
    options: fieldOptions,
    label: fieldLabel,
    value: fieldValue
  } = fieldNames.value;
  const filteredOptions = [];
  const customizeFilter = typeof filterOptionValue === "function";
  const upperSearch = searchValueVal.toUpperCase();
  const filterFunc = customizeFilter ? filterOptionValue : (_2, option) => {
    if (optionFilterPropValue) {
      return includes(option[optionFilterPropValue], upperSearch);
    }
    if (option[fieldOptions]) {
      return includes(option[fieldLabel !== "children" ? fieldLabel : "label"], upperSearch);
    }
    return includes(option[fieldValue], upperSearch);
  };
  const wrapOption = customizeFilter ? (opt) => injectPropsWithOption(opt) : (opt) => opt;
  options.value.forEach((item) => {
    if (item[fieldOptions]) {
      const matchGroup = filterFunc(searchValueVal, wrapOption(item));
      if (matchGroup) {
        filteredOptions.push(item);
      } else {
        const subOptions = item[fieldOptions].filter((subItem) => filterFunc(searchValueVal, wrapOption(subItem)));
        if (subOptions.length) {
          filteredOptions.push(_extends$1(_extends$1({}, item), {
            [fieldOptions]: subOptions
          }));
        }
      }
      return;
    }
    if (filterFunc(searchValueVal, wrapOption(item))) {
      filteredOptions.push(item);
    }
  });
  return filteredOptions;
});
const useCache = (labeledValues, valueOptions) => {
  const cacheRef = shallowRef({
    values: /* @__PURE__ */ new Map(),
    options: /* @__PURE__ */ new Map()
  });
  const filledLabeledValues = computed(() => {
    const {
      values: prevValueCache,
      options: prevOptionCache
    } = cacheRef.value;
    const patchedValues = labeledValues.value.map((item) => {
      var _a2;
      if (item.label === void 0) {
        return _extends$1(_extends$1({}, item), {
          label: (_a2 = prevValueCache.get(item.value)) === null || _a2 === void 0 ? void 0 : _a2.label
        });
      }
      return item;
    });
    const valueCache = /* @__PURE__ */ new Map();
    const optionCache = /* @__PURE__ */ new Map();
    patchedValues.forEach((item) => {
      valueCache.set(item.value, item);
      optionCache.set(item.value, valueOptions.value.get(item.value) || prevOptionCache.get(item.value));
    });
    cacheRef.value.values = valueCache;
    cacheRef.value.options = optionCache;
    return patchedValues;
  });
  const getOption = (val) => valueOptions.value.get(val) || cacheRef.value.options.get(val);
  return [filledLabeledValues, getOption];
};
function useMergedState(defaultStateValue, option) {
  const {
    defaultValue,
    value = ref()
  } = option || {};
  let initValue = typeof defaultStateValue === "function" ? defaultStateValue() : defaultStateValue;
  if (value.value !== void 0) {
    initValue = unref(value);
  }
  if (defaultValue !== void 0) {
    initValue = typeof defaultValue === "function" ? defaultValue() : defaultValue;
  }
  const innerValue = ref(initValue);
  const mergedValue = ref(initValue);
  watchEffect(() => {
    let val = value.value !== void 0 ? value.value : innerValue.value;
    if (option.postState) {
      val = option.postState(val);
    }
    mergedValue.value = val;
  });
  function triggerChange(newValue) {
    const preVal = mergedValue.value;
    innerValue.value = newValue;
    if (toRaw(mergedValue.value) !== newValue && option.onChange) {
      option.onChange(newValue, preVal);
    }
  }
  watch(value, () => {
    innerValue.value = value.value;
  });
  return [mergedValue, triggerChange];
}
function useState(defaultStateValue) {
  const initValue = typeof defaultStateValue === "function" ? defaultStateValue() : defaultStateValue;
  const innerValue = ref(initValue);
  function triggerChange(newValue) {
    innerValue.value = newValue;
  }
  return [innerValue, triggerChange];
}
const OMIT_DOM_PROPS = ["inputValue"];
function selectProps$1() {
  return _extends$1(_extends$1({}, baseSelectPropsWithoutPrivate()), {
    prefixCls: String,
    id: String,
    backfill: {
      type: Boolean,
      default: void 0
    },
    // >>> Field Names
    fieldNames: Object,
    // >>> Search
    /** @deprecated Use `searchValue` instead */
    inputValue: String,
    searchValue: String,
    onSearch: Function,
    autoClearSearchValue: {
      type: Boolean,
      default: void 0
    },
    // >>> Select
    onSelect: Function,
    onDeselect: Function,
    // >>> Options
    /**
     * In Select, `false` means do nothing.
     * In TreeSelect, `false` will highlight match item.
     * It's by design.
     */
    filterOption: {
      type: [Boolean, Function],
      default: void 0
    },
    filterSort: Function,
    optionFilterProp: String,
    optionLabelProp: String,
    options: Array,
    defaultActiveFirstOption: {
      type: Boolean,
      default: void 0
    },
    virtual: {
      type: Boolean,
      default: void 0
    },
    listHeight: Number,
    listItemHeight: Number,
    // >>> Icon
    menuItemSelectedIcon: PropTypes.any,
    mode: String,
    labelInValue: {
      type: Boolean,
      default: void 0
    },
    value: PropTypes.any,
    defaultValue: PropTypes.any,
    onChange: Function,
    children: Array
  });
}
function isRawValue(value) {
  return !value || typeof value !== "object";
}
const Select$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "VcSelect",
  inheritAttrs: false,
  props: initDefaultProps(selectProps$1(), {
    prefixCls: "vc-select",
    autoClearSearchValue: true,
    listHeight: 200,
    listItemHeight: 20,
    dropdownMatchSelectWidth: true
  }),
  setup(props2, _ref) {
    let {
      expose,
      attrs,
      slots
    } = _ref;
    const mergedId = useId(toRef(props2, "id"));
    const multiple = computed(() => isMultiple(props2.mode));
    const childrenAsData = computed(() => !!(!props2.options && props2.children));
    const mergedFilterOption = computed(() => {
      if (props2.filterOption === void 0 && props2.mode === "combobox") {
        return false;
      }
      return props2.filterOption;
    });
    const mergedFieldNames = computed(() => fillFieldNames$2(props2.fieldNames, childrenAsData.value));
    const [mergedSearchValue, setSearchValue] = useMergedState("", {
      value: computed(() => props2.searchValue !== void 0 ? props2.searchValue : props2.inputValue),
      postState: (search) => search || ""
    });
    const parsedOptions = useOptions(toRef(props2, "options"), toRef(props2, "children"), mergedFieldNames);
    const {
      valueOptions,
      labelOptions,
      options: mergedOptions
    } = parsedOptions;
    const convert2LabelValues = (draftValues) => {
      const valueList = toArray$6(draftValues);
      return valueList.map((val) => {
        var _a2, _b;
        let rawValue;
        let rawLabel;
        let rawKey;
        let rawDisabled;
        if (isRawValue(val)) {
          rawValue = val;
        } else {
          rawKey = val.key;
          rawLabel = val.label;
          rawValue = (_a2 = val.value) !== null && _a2 !== void 0 ? _a2 : rawKey;
        }
        const option = valueOptions.value.get(rawValue);
        if (option) {
          if (rawLabel === void 0) rawLabel = option === null || option === void 0 ? void 0 : option[props2.optionLabelProp || mergedFieldNames.value.label];
          if (rawKey === void 0) rawKey = (_b = option === null || option === void 0 ? void 0 : option.key) !== null && _b !== void 0 ? _b : rawValue;
          rawDisabled = option === null || option === void 0 ? void 0 : option.disabled;
        }
        return {
          label: rawLabel,
          value: rawValue,
          key: rawKey,
          disabled: rawDisabled,
          option
        };
      });
    };
    const [internalValue, setInternalValue] = useMergedState(props2.defaultValue, {
      value: toRef(props2, "value")
    });
    const rawLabeledValues = computed(() => {
      var _a2;
      const values = convert2LabelValues(internalValue.value);
      if (props2.mode === "combobox" && !((_a2 = values[0]) === null || _a2 === void 0 ? void 0 : _a2.value)) {
        return [];
      }
      return values;
    });
    const [mergedValues, getMixedOption] = useCache(rawLabeledValues, valueOptions);
    const displayValues = computed(() => {
      if (!props2.mode && mergedValues.value.length === 1) {
        const firstValue = mergedValues.value[0];
        if (firstValue.value === null && (firstValue.label === null || firstValue.label === void 0)) {
          return [];
        }
      }
      return mergedValues.value.map((item) => {
        var _a2;
        return _extends$1(_extends$1({}, item), {
          label: (_a2 = typeof item.label === "function" ? item.label() : item.label) !== null && _a2 !== void 0 ? _a2 : item.value
        });
      });
    });
    const rawValues = computed(() => new Set(mergedValues.value.map((val) => val.value)));
    watchEffect(() => {
      var _a2;
      if (props2.mode === "combobox") {
        const strValue = (_a2 = mergedValues.value[0]) === null || _a2 === void 0 ? void 0 : _a2.value;
        if (strValue !== void 0 && strValue !== null) {
          setSearchValue(String(strValue));
        }
      }
    }, {
      flush: "post"
    });
    const createTagOption = (val, label) => {
      const mergedLabel = label !== null && label !== void 0 ? label : val;
      return {
        [mergedFieldNames.value.value]: val,
        [mergedFieldNames.value.label]: mergedLabel
      };
    };
    const filledTagOptions = shallowRef();
    watchEffect(() => {
      if (props2.mode !== "tags") {
        filledTagOptions.value = mergedOptions.value;
        return;
      }
      const cloneOptions = mergedOptions.value.slice();
      const existOptions = (val) => valueOptions.value.has(val);
      [...mergedValues.value].sort((a2, b2) => a2.value < b2.value ? -1 : 1).forEach((item) => {
        const val = item.value;
        if (!existOptions(val)) {
          cloneOptions.push(createTagOption(val, item.label));
        }
      });
      filledTagOptions.value = cloneOptions;
    });
    const filteredOptions = useFilterOptions(filledTagOptions, mergedFieldNames, mergedSearchValue, mergedFilterOption, toRef(props2, "optionFilterProp"));
    const filledSearchOptions = computed(() => {
      if (props2.mode !== "tags" || !mergedSearchValue.value || filteredOptions.value.some((item) => item[props2.optionFilterProp || "value"] === mergedSearchValue.value)) {
        return filteredOptions.value;
      }
      return [createTagOption(mergedSearchValue.value), ...filteredOptions.value];
    });
    const orderedFilteredOptions = computed(() => {
      if (!props2.filterSort) {
        return filledSearchOptions.value;
      }
      return [...filledSearchOptions.value].sort((a2, b2) => props2.filterSort(a2, b2));
    });
    const displayOptions = computed(() => flattenOptions(orderedFilteredOptions.value, {
      fieldNames: mergedFieldNames.value,
      childrenAsData: childrenAsData.value
    }));
    const triggerChange = (values) => {
      const labeledValues = convert2LabelValues(values);
      setInternalValue(labeledValues);
      if (props2.onChange && // Trigger event only when value changed
      (labeledValues.length !== mergedValues.value.length || labeledValues.some((newVal, index2) => {
        var _a2;
        return ((_a2 = mergedValues.value[index2]) === null || _a2 === void 0 ? void 0 : _a2.value) !== (newVal === null || newVal === void 0 ? void 0 : newVal.value);
      }))) {
        const returnValues = props2.labelInValue ? labeledValues.map((v2) => {
          return _extends$1(_extends$1({}, v2), {
            originLabel: v2.label,
            label: typeof v2.label === "function" ? v2.label() : v2.label
          });
        }) : labeledValues.map((v2) => v2.value);
        const returnOptions = labeledValues.map((v2) => injectPropsWithOption(getMixedOption(v2.value)));
        props2.onChange(
          // Value
          multiple.value ? returnValues : returnValues[0],
          // Option
          multiple.value ? returnOptions : returnOptions[0]
        );
      }
    };
    const [activeValue, setActiveValue] = useState(null);
    const [accessibilityIndex, setAccessibilityIndex] = useState(0);
    const mergedDefaultActiveFirstOption = computed(() => props2.defaultActiveFirstOption !== void 0 ? props2.defaultActiveFirstOption : props2.mode !== "combobox");
    const onActiveValue = function(active, index2) {
      let {
        source = "keyboard"
      } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      setAccessibilityIndex(index2);
      if (props2.backfill && props2.mode === "combobox" && active !== null && source === "keyboard") {
        setActiveValue(String(active));
      }
    };
    const triggerSelect = (val, selected) => {
      const getSelectEnt = () => {
        var _a2;
        const option = getMixedOption(val);
        const originLabel = option === null || option === void 0 ? void 0 : option[mergedFieldNames.value.label];
        return [props2.labelInValue ? {
          label: typeof originLabel === "function" ? originLabel() : originLabel,
          originLabel,
          value: val,
          key: (_a2 = option === null || option === void 0 ? void 0 : option.key) !== null && _a2 !== void 0 ? _a2 : val
        } : val, injectPropsWithOption(option)];
      };
      if (selected && props2.onSelect) {
        const [wrappedValue, option] = getSelectEnt();
        props2.onSelect(wrappedValue, option);
      } else if (!selected && props2.onDeselect) {
        const [wrappedValue, option] = getSelectEnt();
        props2.onDeselect(wrappedValue, option);
      }
    };
    const onInternalSelect = (val, info) => {
      let cloneValues;
      const mergedSelect = multiple.value ? info.selected : true;
      if (mergedSelect) {
        cloneValues = multiple.value ? [...mergedValues.value, val] : [val];
      } else {
        cloneValues = mergedValues.value.filter((v2) => v2.value !== val);
      }
      triggerChange(cloneValues);
      triggerSelect(val, mergedSelect);
      if (props2.mode === "combobox") {
        setActiveValue("");
      } else if (!multiple.value || props2.autoClearSearchValue) {
        setSearchValue("");
        setActiveValue("");
      }
    };
    const onDisplayValuesChange = (nextValues, info) => {
      triggerChange(nextValues);
      if (info.type === "remove" || info.type === "clear") {
        info.values.forEach((item) => {
          triggerSelect(item.value, false);
        });
      }
    };
    const onInternalSearch = (searchText, info) => {
      var _a2;
      setSearchValue(searchText);
      setActiveValue(null);
      if (info.source === "submit") {
        const formatted = (searchText || "").trim();
        if (formatted) {
          const newRawValues = Array.from(/* @__PURE__ */ new Set([...rawValues.value, formatted]));
          triggerChange(newRawValues);
          triggerSelect(formatted, true);
          setSearchValue("");
        }
        return;
      }
      if (info.source !== "blur") {
        if (props2.mode === "combobox") {
          triggerChange(searchText);
        }
        (_a2 = props2.onSearch) === null || _a2 === void 0 ? void 0 : _a2.call(props2, searchText);
      }
    };
    const onInternalSearchSplit = (words) => {
      let patchValues = words;
      if (props2.mode !== "tags") {
        patchValues = words.map((word) => {
          const opt = labelOptions.value.get(word);
          return opt === null || opt === void 0 ? void 0 : opt.value;
        }).filter((val) => val !== void 0);
      }
      const newRawValues = Array.from(/* @__PURE__ */ new Set([...rawValues.value, ...patchValues]));
      triggerChange(newRawValues);
      newRawValues.forEach((newRawValue) => {
        triggerSelect(newRawValue, true);
      });
    };
    const realVirtual = computed(() => props2.virtual !== false && props2.dropdownMatchSelectWidth !== false);
    useProvideSelectProps(toReactive(_extends$1(_extends$1({}, parsedOptions), {
      flattenOptions: displayOptions,
      onActiveValue,
      defaultActiveFirstOption: mergedDefaultActiveFirstOption,
      onSelect: onInternalSelect,
      menuItemSelectedIcon: toRef(props2, "menuItemSelectedIcon"),
      rawValues,
      fieldNames: mergedFieldNames,
      virtual: realVirtual,
      listHeight: toRef(props2, "listHeight"),
      listItemHeight: toRef(props2, "listItemHeight"),
      childrenAsData
    })));
    const selectRef = ref();
    expose({
      focus() {
        var _a2;
        (_a2 = selectRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
      },
      blur() {
        var _a2;
        (_a2 = selectRef.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
      },
      scrollTo(arg) {
        var _a2;
        (_a2 = selectRef.value) === null || _a2 === void 0 ? void 0 : _a2.scrollTo(arg);
      }
    });
    const pickProps = computed(() => {
      return omit$1(props2, [
        "id",
        "mode",
        "prefixCls",
        "backfill",
        "fieldNames",
        // Search
        "inputValue",
        "searchValue",
        "onSearch",
        "autoClearSearchValue",
        // Select
        "onSelect",
        "onDeselect",
        "dropdownMatchSelectWidth",
        // Options
        "filterOption",
        "filterSort",
        "optionFilterProp",
        "optionLabelProp",
        "options",
        "children",
        "defaultActiveFirstOption",
        "menuItemSelectedIcon",
        "virtual",
        "listHeight",
        "listItemHeight",
        // Value
        "value",
        "defaultValue",
        "labelInValue",
        "onChange"
      ]);
    });
    return () => {
      return createVNode(BaseSelect, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, pickProps.value), attrs), {}, {
        "id": mergedId,
        "prefixCls": props2.prefixCls,
        "ref": selectRef,
        "omitDomProps": OMIT_DOM_PROPS,
        "mode": props2.mode,
        "displayValues": displayValues.value,
        "onDisplayValuesChange": onDisplayValuesChange,
        "searchValue": mergedSearchValue.value,
        "onSearch": onInternalSearch,
        "onSearchSplit": onInternalSearchSplit,
        "dropdownMatchSelectWidth": props2.dropdownMatchSelectWidth,
        "OptionList": OptionList$1,
        "emptyOptions": !displayOptions.value.length,
        "activeValue": activeValue.value,
        "activeDescendantId": `${mergedId}_list_${accessibilityIndex.value}`
      }), slots);
    };
  }
});
const Option = () => null;
Option.isSelectOption = true;
Option.displayName = "ASelectOption";
const OptGroup = () => null;
OptGroup.isSelectOptGroup = true;
OptGroup.displayName = "ASelectOptGroup";
function getIcons(props2) {
  let slots = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    loading,
    multiple,
    prefixCls,
    hasFeedback,
    feedbackIcon,
    showArrow
  } = props2;
  const suffixIcon = props2.suffixIcon || slots.suffixIcon && slots.suffixIcon();
  const clearIcon = props2.clearIcon || slots.clearIcon && slots.clearIcon();
  const menuItemSelectedIcon = props2.menuItemSelectedIcon || slots.menuItemSelectedIcon && slots.menuItemSelectedIcon();
  const removeIcon = props2.removeIcon || slots.removeIcon && slots.removeIcon();
  const mergedClearIcon = clearIcon !== null && clearIcon !== void 0 ? clearIcon : createVNode(CloseCircleFilled, null, null);
  const getSuffixIconNode = (arrowIcon) => createVNode(Fragment, null, [showArrow !== false && arrowIcon, hasFeedback && feedbackIcon]);
  let mergedSuffixIcon = null;
  if (suffixIcon !== void 0) {
    mergedSuffixIcon = getSuffixIconNode(suffixIcon);
  } else if (loading) {
    mergedSuffixIcon = getSuffixIconNode(createVNode(LoadingOutlined, {
      "spin": true
    }, null));
  } else {
    const iconCls = `${prefixCls}-suffix`;
    mergedSuffixIcon = (_ref) => {
      let {
        open: open2,
        showSearch
      } = _ref;
      if (open2 && showSearch) {
        return getSuffixIconNode(createVNode(SearchOutlined, {
          "class": iconCls
        }, null));
      }
      return getSuffixIconNode(createVNode(DownOutlined, {
        "class": iconCls
      }, null));
    };
  }
  let mergedItemIcon = null;
  if (menuItemSelectedIcon !== void 0) {
    mergedItemIcon = menuItemSelectedIcon;
  } else if (multiple) {
    mergedItemIcon = createVNode(CheckOutlined, null, null);
  } else {
    mergedItemIcon = null;
  }
  let mergedRemoveIcon = null;
  if (removeIcon !== void 0) {
    mergedRemoveIcon = removeIcon;
  } else {
    mergedRemoveIcon = createVNode(CloseOutlined, null, null);
  }
  return {
    clearIcon: mergedClearIcon,
    suffixIcon: mergedSuffixIcon,
    itemIcon: mergedItemIcon,
    removeIcon: mergedRemoveIcon
  };
}
function createContext(defaultValue) {
  const contextKey2 = Symbol("contextKey");
  const useProvide = (props2, newProps) => {
    const mergedProps = reactive({});
    provide(contextKey2, mergedProps);
    watchEffect(() => {
      _extends$1(mergedProps, props2, newProps || {});
    });
    return mergedProps;
  };
  const useInject = () => {
    return inject(contextKey2, defaultValue) || {};
  };
  return {
    useProvide,
    useInject
  };
}
const ContextKey$1 = Symbol("ContextProps");
const InternalContextKey = Symbol("InternalContextProps");
const useProvideFormItemContext = function(props2) {
  let useValidation = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : computed(() => true);
  const formItemFields = ref(/* @__PURE__ */ new Map());
  const addFormItemField = (key2, type4) => {
    formItemFields.value.set(key2, type4);
    formItemFields.value = new Map(formItemFields.value);
  };
  const removeFormItemField = (key2) => {
    formItemFields.value.delete(key2);
    formItemFields.value = new Map(formItemFields.value);
  };
  watch([useValidation, formItemFields], () => {
  });
  provide(ContextKey$1, props2);
  provide(InternalContextKey, {
    addFormItemField,
    removeFormItemField
  });
};
const defaultContext = {
  id: computed(() => void 0),
  onFieldBlur: () => {
  },
  onFieldChange: () => {
  },
  clearValidate: () => {
  }
};
const defaultInternalContext = {
  addFormItemField: () => {
  },
  removeFormItemField: () => {
  }
};
const useInjectFormItemContext = () => {
  const internalContext = inject(InternalContextKey, defaultInternalContext);
  const formItemFieldKey = Symbol("FormItemFieldKey");
  const instance = getCurrentInstance();
  internalContext.addFormItemField(formItemFieldKey, instance.type);
  onBeforeUnmount(() => {
    internalContext.removeFormItemField(formItemFieldKey);
  });
  provide(InternalContextKey, defaultInternalContext);
  provide(ContextKey$1, defaultContext);
  return inject(ContextKey$1, defaultContext);
};
const FormItemRest = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AFormItemRest",
  setup(_2, _ref) {
    let {
      slots
    } = _ref;
    provide(InternalContextKey, defaultInternalContext);
    provide(ContextKey$1, defaultContext);
    return () => {
      var _a2;
      return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
    };
  }
});
const FormItemInputContext = createContext({});
const NoFormStatus = defineComponent({
  name: "NoFormStatus",
  setup(_2, _ref2) {
    let {
      slots
    } = _ref2;
    FormItemInputContext.useProvide({});
    return () => {
      var _a2;
      return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
    };
  }
});
function getStatusClassNames(prefixCls, status, hasFeedback) {
  return classNames({
    [`${prefixCls}-status-success`]: status === "success",
    [`${prefixCls}-status-warning`]: status === "warning",
    [`${prefixCls}-status-error`]: status === "error",
    [`${prefixCls}-status-validating`]: status === "validating",
    [`${prefixCls}-has-feedback`]: hasFeedback
  });
}
const getMergedStatus = (contextStatus, customStatus) => customStatus || contextStatus;
const genSpaceCompactStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [componentCls]: {
      display: "inline-flex",
      "&-block": {
        display: "flex",
        width: "100%"
      },
      "&-vertical": {
        flexDirection: "column"
      }
    }
  };
};
const genSpaceStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [componentCls]: {
      display: "inline-flex",
      "&-rtl": {
        direction: "rtl"
      },
      "&-vertical": {
        flexDirection: "column"
      },
      "&-align": {
        flexDirection: "column",
        "&-center": {
          alignItems: "center"
        },
        "&-start": {
          alignItems: "flex-start"
        },
        "&-end": {
          alignItems: "flex-end"
        },
        "&-baseline": {
          alignItems: "baseline"
        }
      },
      [`${componentCls}-item`]: {
        "&:empty": {
          display: "none"
        }
      }
    }
  };
};
const useStyle$H = genComponentStyleHook("Space", (token2) => [genSpaceStyle(token2), genSpaceCompactStyle(token2)]);
var symbolTag$2 = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$2;
}
function arrayMap(array4, iteratee) {
  var index2 = -1, length2 = array4 == null ? 0 : array4.length, result = Array(length2);
  while (++index2 < length2) {
    result[index2] = iteratee(array4[index2], index2, array4);
  }
  return result;
}
var INFINITY$3 = 1 / 0;
var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto$1 ? symbolProto$1.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray(value)) {
    return arrayMap(value, baseToString) + "";
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$3 ? "-0" : result;
}
var reWhitespace = /\s/;
function trimmedEndIndex(string3) {
  var index2 = string3.length;
  while (index2-- && reWhitespace.test(string3.charAt(index2))) {
  }
  return index2;
}
var reTrimStart = /^\s+/;
function baseTrim(string3) {
  return string3 ? string3.slice(0, trimmedEndIndex(string3) + 1).replace(reTrimStart, "") : string3;
}
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject$1(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject$1(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var INFINITY$2 = 1 / 0, MAX_INTEGER = 17976931348623157e292;
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY$2 || value === -INFINITY$2) {
    var sign = value < 0 ? -1 : 1;
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}
function toInteger(value) {
  var result = toFinite(value), remainder = result % 1;
  return result === result ? remainder ? result - remainder : result : 0;
}
function identity(value) {
  return value;
}
var objectCreate = Object.create;
var baseCreate = /* @__PURE__ */ function() {
  function object4() {
  }
  return function(proto) {
    if (!isObject$1(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object4.prototype = proto;
    var result = new object4();
    object4.prototype = void 0;
    return result;
  };
}();
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
function noop$3() {
}
function copyArray(source, array4) {
  var index2 = -1, length2 = source.length;
  array4 || (array4 = Array(length2));
  while (++index2 < length2) {
    array4[index2] = source[index2];
  }
  return array4;
}
var HOT_COUNT = 800, HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
function constant(value) {
  return function() {
    return value;
  };
}
var defineProperty = function() {
  try {
    var func = getNative(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e2) {
  }
}();
var baseSetToString = !defineProperty ? identity : function(func, string3) {
  return defineProperty(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant(string3),
    "writable": true
  });
};
var setToString = shortOut(baseSetToString);
function arrayEach(array4, iteratee) {
  var index2 = -1, length2 = array4 == null ? 0 : array4.length;
  while (++index2 < length2) {
    if (iteratee(array4[index2], index2, array4) === false) {
      break;
    }
  }
  return array4;
}
function baseFindIndex(array4, predicate, fromIndex, fromRight) {
  var length2 = array4.length, index2 = fromIndex + -1;
  while (++index2 < length2) {
    if (predicate(array4[index2], index2, array4)) {
      return index2;
    }
  }
  return -1;
}
function baseIsNaN(value) {
  return value !== value;
}
function strictIndexOf(array4, value, fromIndex) {
  var index2 = fromIndex - 1, length2 = array4.length;
  while (++index2 < length2) {
    if (array4[index2] === value) {
      return index2;
    }
  }
  return -1;
}
function baseIndexOf(array4, value, fromIndex) {
  return value === value ? strictIndexOf(array4, value, fromIndex) : baseFindIndex(array4, baseIsNaN, fromIndex);
}
function arrayIncludes(array4, value) {
  var length2 = array4 == null ? 0 : array4.length;
  return !!length2 && baseIndexOf(array4, value, 0) > -1;
}
function baseAssignValue(object4, key2, value) {
  if (key2 == "__proto__" && defineProperty) {
    defineProperty(object4, key2, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object4[key2] = value;
  }
}
var objectProto$3 = Object.prototype;
var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
function assignValue(object4, key2, value) {
  var objValue = object4[key2];
  if (!(hasOwnProperty$3.call(object4, key2) && eq(objValue, value)) || value === void 0 && !(key2 in object4)) {
    baseAssignValue(object4, key2, value);
  }
}
function copyObject(source, props2, object4, customizer) {
  var isNew = !object4;
  object4 || (object4 = {});
  var index2 = -1, length2 = props2.length;
  while (++index2 < length2) {
    var key2 = props2[index2];
    var newValue = void 0;
    if (newValue === void 0) {
      newValue = source[key2];
    }
    if (isNew) {
      baseAssignValue(object4, key2, newValue);
    } else {
      assignValue(object4, key2, newValue);
    }
  }
  return object4;
}
var nativeMax$2 = Math.max;
function overRest(func, start, transform) {
  start = nativeMax$2(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args = arguments, index2 = -1, length2 = nativeMax$2(args.length - start, 0), array4 = Array(length2);
    while (++index2 < length2) {
      array4[index2] = args[start + index2];
    }
    index2 = -1;
    var otherArgs = Array(start + 1);
    while (++index2 < start) {
      otherArgs[index2] = args[index2];
    }
    otherArgs[start] = transform(array4);
    return apply(func, this, otherArgs);
  };
}
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + "");
}
function nativeKeysIn(object4) {
  var result = [];
  if (object4 != null) {
    for (var key2 in Object(object4)) {
      result.push(key2);
    }
  }
  return result;
}
var objectProto$2 = Object.prototype;
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
function baseKeysIn(object4) {
  if (!isObject$1(object4)) {
    return nativeKeysIn(object4);
  }
  var isProto = isPrototype(object4), result = [];
  for (var key2 in object4) {
    if (!(key2 == "constructor" && (isProto || !hasOwnProperty$2.call(object4, key2)))) {
      result.push(key2);
    }
  }
  return result;
}
function keysIn(object4) {
  return isArrayLike(object4) ? arrayLikeKeys(object4, true) : baseKeysIn(object4);
}
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey(value, object4) {
  if (isArray(value)) {
    return false;
  }
  var type4 = typeof value;
  if (type4 == "number" || type4 == "symbol" || type4 == "boolean" || value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object4 != null && value in Object(object4);
}
var FUNC_ERROR_TEXT$1 = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  var memoized = function() {
    var args = arguments, key2 = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key2)) {
      return cache.get(key2);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key2, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
}
memoize.Cache = MapCache;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize(func, function(key2) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key2;
  });
  var cache = result.cache;
  return result;
}
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped(function(string3) {
  var result = [];
  if (string3.charCodeAt(0) === 46) {
    result.push("");
  }
  string3.replace(rePropName, function(match2, number4, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number4 || match2);
  });
  return result;
});
function toString(value) {
  return value == null ? "" : baseToString(value);
}
function castPath(value, object4) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object4) ? [value] : stringToPath(toString(value));
}
var INFINITY$1 = 1 / 0;
function toKey(value) {
  if (typeof value == "string" || isSymbol(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
}
function baseGet(object4, path2) {
  path2 = castPath(path2, object4);
  var index2 = 0, length2 = path2.length;
  while (object4 != null && index2 < length2) {
    object4 = object4[toKey(path2[index2++])];
  }
  return index2 && index2 == length2 ? object4 : void 0;
}
function get$1(object4, path2, defaultValue) {
  var result = object4 == null ? void 0 : baseGet(object4, path2);
  return result === void 0 ? defaultValue : result;
}
var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
function isFlattenable(value) {
  return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
function baseFlatten(array4, depth, predicate, isStrict, result) {
  var index2 = -1, length2 = array4.length;
  predicate || (predicate = isFlattenable);
  result || (result = []);
  while (++index2 < length2) {
    var value = array4[index2];
    if (predicate(value)) {
      {
        arrayPush(result, value);
      }
    } else {
      result[result.length] = value;
    }
  }
  return result;
}
function flatten(array4) {
  var length2 = array4 == null ? 0 : array4.length;
  return length2 ? baseFlatten(array4) : [];
}
function flatRest(func) {
  return setToString(overRest(func, void 0, flatten), func + "");
}
var getPrototype = overArg(Object.getPrototypeOf, Object);
var objectTag$1 = "[object Object]";
var funcProto = Function.prototype, objectProto$1 = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
var objectCtorString = funcToString.call(Object);
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag$1) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$1.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
function baseSlice(array4, start, end) {
  var index2 = -1, length2 = array4.length;
  if (start < 0) {
    start = -start > length2 ? 0 : length2 + start;
  }
  end = end > length2 ? length2 : end;
  if (end < 0) {
    end += length2;
  }
  length2 = start > end ? 0 : end - start >>> 0;
  start >>>= 0;
  var result = Array(length2);
  while (++index2 < length2) {
    result[index2] = array4[index2 + start];
  }
  return result;
}
function baseAssign(object4, source) {
  return object4 && copyObject(source, keys(source), object4);
}
function baseAssignIn(object4, source) {
  return object4 && copyObject(source, keysIn(source), object4);
}
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer = moduleExports ? root.Buffer : void 0, allocUnsafe = Buffer ? Buffer.allocUnsafe : void 0;
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length2 = buffer.length, result = allocUnsafe ? allocUnsafe(length2) : new buffer.constructor(length2);
  buffer.copy(result);
  return result;
}
function copySymbols(source, object4) {
  return copyObject(source, getSymbols(source), object4);
}
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object4) {
  var result = [];
  while (object4) {
    arrayPush(result, getSymbols(object4));
    object4 = getPrototype(object4);
  }
  return result;
};
function copySymbolsIn(source, object4) {
  return copyObject(source, getSymbolsIn(source), object4);
}
function getAllKeysIn(object4) {
  return baseGetAllKeys(object4, keysIn, getSymbolsIn);
}
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function initCloneArray(array4) {
  var length2 = array4.length, result = new array4.constructor(length2);
  if (length2 && typeof array4[0] == "string" && hasOwnProperty.call(array4, "index")) {
    result.index = array4.index;
    result.input = array4.input;
  }
  return result;
}
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var reFlags = /\w*$/;
function cloneRegExp(regexp4) {
  var result = new regexp4.constructor(regexp4.source, reFlags.exec(regexp4));
  result.lastIndex = regexp4.lastIndex;
  return result;
}
var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", mapTag$2 = "[object Map]", numberTag$2 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag(object4, tag, isDeep) {
  var Ctor = object4.constructor;
  switch (tag) {
    case arrayBufferTag$1:
      return cloneArrayBuffer(object4);
    case boolTag$1:
    case dateTag$1:
      return new Ctor(+object4);
    case dataViewTag$1:
      return cloneDataView(object4, isDeep);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray(object4, isDeep);
    case mapTag$2:
      return new Ctor();
    case numberTag$2:
    case stringTag$1:
      return new Ctor(object4);
    case regexpTag$1:
      return cloneRegExp(object4);
    case setTag$2:
      return new Ctor();
    case symbolTag$1:
      return cloneSymbol(object4);
  }
}
function initCloneObject(object4) {
  return typeof object4.constructor == "function" && !isPrototype(object4) ? baseCreate(getPrototype(object4)) : {};
}
var mapTag$1 = "[object Map]";
function baseIsMap(value) {
  return isObjectLike(value) && getTag(value) == mapTag$1;
}
var nodeIsMap = nodeUtil && nodeUtil.isMap;
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
var setTag$1 = "[object Set]";
function baseIsSet(value) {
  return isObjectLike(value) && getTag(value) == setTag$1;
}
var nodeIsSet = nodeUtil && nodeUtil.isSet;
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
var CLONE_DEEP_FLAG$2 = 1, CLONE_FLAT_FLAG$1 = 2, CLONE_SYMBOLS_FLAG$2 = 4;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag$1 = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag$1] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
function baseClone(value, bitmask, customizer, key2, object4, stack) {
  var result, isDeep = bitmask & CLONE_DEEP_FLAG$2, isFlat = bitmask & CLONE_FLAT_FLAG$1, isFull = bitmask & CLONE_SYMBOLS_FLAG$2;
  if (customizer) {
    result = object4 ? customizer(value, key2, object4, stack) : customizer(value);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject$1(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || isFunc && !object4) {
      result = isFlat || isFunc ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object4 ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  stack || (stack = new Stack());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);
  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key3) {
      result.set(key3, baseClone(subValue, bitmask, customizer, key3, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
  var props2 = isArr ? void 0 : keysFunc(value);
  arrayEach(props2 || value, function(subValue, key3) {
    if (props2) {
      key3 = subValue;
      subValue = value[key3];
    }
    assignValue(result, key3, baseClone(subValue, bitmask, customizer, key3, value, stack));
  });
  return result;
}
var CLONE_DEEP_FLAG$1 = 1, CLONE_SYMBOLS_FLAG$1 = 4;
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG$1 | CLONE_SYMBOLS_FLAG$1);
}
var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function baseIsMatch(object4, source, matchData, customizer) {
  var index2 = matchData.length, length2 = index2;
  if (object4 == null) {
    return !length2;
  }
  object4 = Object(object4);
  while (index2--) {
    var data = matchData[index2];
    if (data[2] ? data[1] !== object4[data[0]] : !(data[0] in object4)) {
      return false;
    }
  }
  while (++index2 < length2) {
    data = matchData[index2];
    var key2 = data[0], objValue = object4[key2], srcValue = data[1];
    if (data[2]) {
      if (objValue === void 0 && !(key2 in object4)) {
        return false;
      }
    } else {
      var stack = new Stack();
      var result;
      if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}
function isStrictComparable(value) {
  return value === value && !isObject$1(value);
}
function getMatchData(object4) {
  var result = keys(object4), length2 = result.length;
  while (length2--) {
    var key2 = result[length2], value = object4[key2];
    result[length2] = [key2, value, isStrictComparable(value)];
  }
  return result;
}
function matchesStrictComparable(key2, srcValue) {
  return function(object4) {
    if (object4 == null) {
      return false;
    }
    return object4[key2] === srcValue && (srcValue !== void 0 || key2 in Object(object4));
  };
}
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object4) {
    return object4 === source || baseIsMatch(object4, source, matchData);
  };
}
function baseHasIn(object4, key2) {
  return object4 != null && key2 in Object(object4);
}
function hasPath(object4, path2, hasFunc) {
  path2 = castPath(path2, object4);
  var index2 = -1, length2 = path2.length, result = false;
  while (++index2 < length2) {
    var key2 = toKey(path2[index2]);
    if (!(result = object4 != null && hasFunc(object4, key2))) {
      break;
    }
    object4 = object4[key2];
  }
  if (result || ++index2 != length2) {
    return result;
  }
  length2 = object4 == null ? 0 : object4.length;
  return !!length2 && isLength(length2) && isIndex(key2, length2) && (isArray(object4) || isArguments(object4));
}
function hasIn(object4, path2) {
  return object4 != null && hasPath(object4, path2, baseHasIn);
}
var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
function baseMatchesProperty(path2, srcValue) {
  if (isKey(path2) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path2), srcValue);
  }
  return function(object4) {
    var objValue = get$1(object4, path2);
    return objValue === void 0 && objValue === srcValue ? hasIn(object4, path2) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}
function baseProperty(key2) {
  return function(object4) {
    return object4 == null ? void 0 : object4[key2];
  };
}
function basePropertyDeep(path2) {
  return function(object4) {
    return baseGet(object4, path2);
  };
}
function property(path2) {
  return isKey(path2) ? baseProperty(toKey(path2)) : basePropertyDeep(path2);
}
function baseIteratee(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == "object") {
    return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }
  return property(value);
}
function arrayAggregator(array4, setter, iteratee, accumulator) {
  var index2 = -1, length2 = array4 == null ? 0 : array4.length;
  while (++index2 < length2) {
    var value = array4[index2];
    setter(accumulator, value, iteratee(value), array4);
  }
  return accumulator;
}
function createBaseFor(fromRight) {
  return function(object4, iteratee, keysFunc) {
    var index2 = -1, iterable = Object(object4), props2 = keysFunc(object4), length2 = props2.length;
    while (length2--) {
      var key2 = props2[++index2];
      if (iteratee(iterable[key2], key2, iterable) === false) {
        break;
      }
    }
    return object4;
  };
}
var baseFor = createBaseFor();
function baseForOwn(object4, iteratee) {
  return object4 && baseFor(object4, iteratee, keys);
}
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length2 = collection.length, index2 = -1, iterable = Object(collection);
    while (++index2 < length2) {
      if (iteratee(iterable[index2], index2, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var baseEach = createBaseEach(baseForOwn);
function baseAggregator(collection, setter, iteratee, accumulator) {
  baseEach(collection, function(value, key2, collection2) {
    setter(accumulator, value, iteratee(value), collection2);
  });
  return accumulator;
}
function createAggregator(setter, initializer) {
  return function(collection, iteratee) {
    var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer();
    return func(collection, setter, baseIteratee(iteratee), accumulator);
  };
}
var now$3 = function() {
  return root.Date.now();
};
var FUNC_ERROR_TEXT = "Expected a function";
var nativeMax$1 = Math.max, nativeMin$1 = Math.min;
function debounce$1(func, wait, options) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject$1(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax$1(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin$1(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now$3();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now$3());
  }
  function debounced() {
    var time = now$3(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}
function last(array4) {
  var length2 = array4 == null ? 0 : array4.length;
  return length2 ? array4[length2 - 1] : void 0;
}
function createFind(findIndexFunc) {
  return function(collection, predicate, fromIndex) {
    var iterable = Object(collection);
    if (!isArrayLike(collection)) {
      var iteratee = baseIteratee(predicate);
      collection = keys(collection);
      predicate = function(key2) {
        return iteratee(iterable[key2], key2, iterable);
      };
    }
    var index2 = findIndexFunc(collection, predicate, fromIndex);
    return index2 > -1 ? iterable[iteratee ? collection[index2] : index2] : void 0;
  };
}
var nativeMax = Math.max;
function findIndex(array4, predicate, fromIndex) {
  var length2 = array4 == null ? 0 : array4.length;
  if (!length2) {
    return -1;
  }
  var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
  if (index2 < 0) {
    index2 = nativeMax(length2 + index2, 0);
  }
  return baseFindIndex(array4, baseIteratee(predicate), index2);
}
var find = createFind(findIndex);
function fromPairs(pairs) {
  var index2 = -1, length2 = pairs == null ? 0 : pairs.length, result = {};
  while (++index2 < length2) {
    var pair = pairs[index2];
    result[pair[0]] = pair[1];
  }
  return result;
}
var nativeMin = Math.min;
function baseIntersection(arrays, iteratee, comparator) {
  var includes2 = arrayIncludes, length2 = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = Infinity, result = [];
  while (othIndex--) {
    var array4 = arrays[othIndex];
    maxLength = nativeMin(array4.length, maxLength);
    caches[othIndex] = length2 >= 120 && array4.length >= 120 ? new SetCache(othIndex && array4) : void 0;
  }
  array4 = arrays[0];
  var index2 = -1, seen = caches[0];
  outer:
    while (++index2 < length2 && result.length < maxLength) {
      var value = array4[index2], computed2 = value;
      value = value !== 0 ? value : 0;
      if (!(seen ? cacheHas(seen, computed2) : includes2(result, computed2))) {
        othIndex = othLength;
        while (--othIndex) {
          var cache = caches[othIndex];
          if (!(cache ? cacheHas(cache, computed2) : includes2(arrays[othIndex], computed2))) {
            continue outer;
          }
        }
        if (seen) {
          seen.push(computed2);
        }
        result.push(value);
      }
    }
  return result;
}
function castArrayLikeObject(value) {
  return isArrayLikeObject(value) ? value : [];
}
var intersection = baseRest(function(arrays) {
  var mapped = arrayMap(arrays, castArrayLikeObject);
  return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
});
function parent(object4, path2) {
  return path2.length < 2 ? object4 : baseGet(object4, baseSlice(path2, 0, -1));
}
var numberTag = "[object Number]";
function isNumber(value) {
  return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
}
function baseUnset(object4, path2) {
  path2 = castPath(path2, object4);
  object4 = parent(object4, path2);
  return object4 == null || delete object4[toKey(last(path2))];
}
function customOmitClone(value) {
  return isPlainObject(value) ? void 0 : value;
}
var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
var omit = flatRest(function(object4, paths) {
  var result = {};
  if (object4 == null) {
    return result;
  }
  var isDeep = false;
  paths = arrayMap(paths, function(path2) {
    path2 = castPath(path2, object4);
    isDeep || (isDeep = path2.length > 1);
    return path2;
  });
  copyObject(object4, getAllKeysIn(object4), result);
  if (isDeep) {
    result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
  }
  var length2 = paths.length;
  while (length2--) {
    baseUnset(result, paths[length2]);
  }
  return result;
});
function baseSet(object4, path2, value, customizer) {
  if (!isObject$1(object4)) {
    return object4;
  }
  path2 = castPath(path2, object4);
  var index2 = -1, length2 = path2.length, lastIndex = length2 - 1, nested = object4;
  while (nested != null && ++index2 < length2) {
    var key2 = toKey(path2[index2]), newValue = value;
    if (key2 === "__proto__" || key2 === "constructor" || key2 === "prototype") {
      return object4;
    }
    if (index2 != lastIndex) {
      var objValue = nested[key2];
      newValue = void 0;
      if (newValue === void 0) {
        newValue = isObject$1(objValue) ? objValue : isIndex(path2[index2 + 1]) ? [] : {};
      }
    }
    assignValue(nested, key2, newValue);
    nested = nested[key2];
  }
  return object4;
}
function basePickBy(object4, paths, predicate) {
  var index2 = -1, length2 = paths.length, result = {};
  while (++index2 < length2) {
    var path2 = paths[index2], value = baseGet(object4, path2);
    if (predicate(value, path2)) {
      baseSet(result, castPath(path2, object4), value);
    }
  }
  return result;
}
var partition = createAggregator(function(result, value, key2) {
  result[key2 ? 0 : 1].push(value);
}, function() {
  return [[], []];
});
function basePick(object4, paths) {
  return basePickBy(object4, paths, function(value, path2) {
    return hasIn(object4, path2);
  });
}
var pick = flatRest(function(object4, paths) {
  return object4 == null ? {} : basePick(object4, paths);
});
var INFINITY = 1 / 0;
var createSet = !(Set$1 && 1 / setToArray(new Set$1([, -0]))[1] == INFINITY) ? noop$3 : function(values) {
  return new Set$1(values);
};
var LARGE_ARRAY_SIZE = 200;
function baseUniq(array4, iteratee, comparator) {
  var index2 = -1, includes2 = arrayIncludes, length2 = array4.length, isCommon = true, result = [], seen = result;
  if (length2 >= LARGE_ARRAY_SIZE) {
    var set2 = createSet(array4);
    if (set2) {
      return setToArray(set2);
    }
    isCommon = false;
    includes2 = cacheHas;
    seen = new SetCache();
  } else {
    seen = result;
  }
  outer:
    while (++index2 < length2) {
      var value = array4[index2], computed2 = value;
      value = value !== 0 ? value : 0;
      if (isCommon && computed2 === computed2) {
        var seenIndex = seen.length;
        while (seenIndex--) {
          if (seen[seenIndex] === computed2) {
            continue outer;
          }
        }
        result.push(value);
      } else if (!includes2(seen, computed2, comparator)) {
        if (seen !== result) {
          seen.push(computed2);
        }
        result.push(value);
      }
    }
  return result;
}
function uniq(array4) {
  return array4 && array4.length ? baseUniq(array4) : [];
}
const spaceCompactItemProps = () => ({
  compactSize: String,
  compactDirection: PropTypes.oneOf(tuple$1("horizontal", "vertical")).def("horizontal"),
  isFirstItem: booleanType(),
  isLastItem: booleanType()
});
const SpaceCompactItemContext = createContext(null);
const useCompactItemContext = (prefixCls, direction) => {
  const compactItemContext = SpaceCompactItemContext.useInject();
  const compactItemClassnames = computed(() => {
    if (!compactItemContext || isEmpty$1(compactItemContext)) return "";
    const {
      compactDirection,
      isFirstItem,
      isLastItem
    } = compactItemContext;
    const separator = compactDirection === "vertical" ? "-vertical-" : "-";
    return classNames({
      [`${prefixCls.value}-compact${separator}item`]: true,
      [`${prefixCls.value}-compact${separator}first-item`]: isFirstItem,
      [`${prefixCls.value}-compact${separator}last-item`]: isLastItem,
      [`${prefixCls.value}-compact${separator}item-rtl`]: direction.value === "rtl"
    });
  });
  return {
    compactSize: computed(() => compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.compactSize),
    compactDirection: computed(() => compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.compactDirection),
    compactItemClassnames
  };
};
const NoCompactStyle = defineComponent({
  name: "NoCompactStyle",
  setup(_2, _ref) {
    let {
      slots
    } = _ref;
    SpaceCompactItemContext.useProvide(null);
    return () => {
      var _a2;
      return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
    };
  }
});
const spaceCompactProps = () => ({
  prefixCls: String,
  size: {
    type: String
  },
  direction: PropTypes.oneOf(tuple$1("horizontal", "vertical")).def("horizontal"),
  align: PropTypes.oneOf(tuple$1("start", "end", "center", "baseline")),
  block: {
    type: Boolean,
    default: void 0
  }
});
const CompactItem = defineComponent({
  name: "CompactItem",
  props: spaceCompactItemProps(),
  setup(props2, _ref2) {
    let {
      slots
    } = _ref2;
    SpaceCompactItemContext.useProvide(props2);
    return () => {
      var _a2;
      return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
    };
  }
});
const Compact = defineComponent({
  name: "ASpaceCompact",
  inheritAttrs: false,
  props: spaceCompactProps(),
  setup(props2, _ref3) {
    let {
      attrs,
      slots
    } = _ref3;
    const {
      prefixCls,
      direction: directionConfig
    } = useConfigInject("space-compact", props2);
    const compactItemContext = SpaceCompactItemContext.useInject();
    const [wrapSSR, hashId] = useStyle$H(prefixCls);
    const clx = computed(() => {
      return classNames(prefixCls.value, hashId.value, {
        [`${prefixCls.value}-rtl`]: directionConfig.value === "rtl",
        [`${prefixCls.value}-block`]: props2.block,
        [`${prefixCls.value}-vertical`]: props2.direction === "vertical"
      });
    });
    return () => {
      var _a2;
      const childNodes = flattenChildren(((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)) || []);
      if (childNodes.length === 0) {
        return null;
      }
      return wrapSSR(createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "class": [clx.value, attrs.class]
      }), [childNodes.map((child, i2) => {
        var _a3;
        const key2 = child && child.key || `${prefixCls.value}-item-${i2}`;
        const noCompactItemContext = !compactItemContext || isEmpty$1(compactItemContext);
        return createVNode(CompactItem, {
          "key": key2,
          "compactSize": (_a3 = props2.size) !== null && _a3 !== void 0 ? _a3 : "middle",
          "compactDirection": props2.direction,
          "isFirstItem": i2 === 0 && (noCompactItemContext || (compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.isFirstItem)),
          "isLastItem": i2 === childNodes.length - 1 && (noCompactItemContext || (compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.isLastItem))
        }, {
          default: () => [child]
        });
      })]));
    };
  }
});
const initMotionCommon = (duration) => ({
  animationDuration: duration,
  animationFillMode: "both"
});
const initMotionCommonLeave = (duration) => ({
  animationDuration: duration,
  animationFillMode: "both"
});
const initMotion = function(motionCls, inKeyframes, outKeyframes, duration) {
  let sameLevel = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
  const sameLevelPrefix = sameLevel ? "&" : "";
  return {
    [`
      ${sameLevelPrefix}${motionCls}-enter,
      ${sameLevelPrefix}${motionCls}-appear
    `]: _extends$1(_extends$1({}, initMotionCommon(duration)), {
      animationPlayState: "paused"
    }),
    [`${sameLevelPrefix}${motionCls}-leave`]: _extends$1(_extends$1({}, initMotionCommonLeave(duration)), {
      animationPlayState: "paused"
    }),
    [`
      ${sameLevelPrefix}${motionCls}-enter${motionCls}-enter-active,
      ${sameLevelPrefix}${motionCls}-appear${motionCls}-appear-active
    `]: {
      animationName: inKeyframes,
      animationPlayState: "running"
    },
    [`${sameLevelPrefix}${motionCls}-leave${motionCls}-leave-active`]: {
      animationName: outKeyframes,
      animationPlayState: "running",
      pointerEvents: "none"
    }
  };
};
const fadeIn = new Keyframe("antFadeIn", {
  "0%": {
    opacity: 0
  },
  "100%": {
    opacity: 1
  }
});
const fadeOut = new Keyframe("antFadeOut", {
  "0%": {
    opacity: 1
  },
  "100%": {
    opacity: 0
  }
});
const initFadeMotion = function(token2) {
  let sameLevel = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  const {
    antCls
  } = token2;
  const motionCls = `${antCls}-fade`;
  const sameLevelPrefix = sameLevel ? "&" : "";
  return [initMotion(motionCls, fadeIn, fadeOut, token2.motionDurationMid, sameLevel), {
    [`
        ${sameLevelPrefix}${motionCls}-enter,
        ${sameLevelPrefix}${motionCls}-appear
      `]: {
      opacity: 0,
      animationTimingFunction: "linear"
    },
    [`${sameLevelPrefix}${motionCls}-leave`]: {
      animationTimingFunction: "linear"
    }
  }];
};
const moveDownIn = new Keyframe("antMoveDownIn", {
  "0%": {
    transform: "translate3d(0, 100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
});
const moveDownOut = new Keyframe("antMoveDownOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(0, 100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
});
const moveLeftIn = new Keyframe("antMoveLeftIn", {
  "0%": {
    transform: "translate3d(-100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
});
const moveLeftOut = new Keyframe("antMoveLeftOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(-100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
});
const moveRightIn = new Keyframe("antMoveRightIn", {
  "0%": {
    transform: "translate3d(100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
});
const moveRightOut = new Keyframe("antMoveRightOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
});
const moveUpIn = new Keyframe("antMoveUpIn", {
  "0%": {
    transform: "translate3d(0, -100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
});
const moveUpOut = new Keyframe("antMoveUpOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(0, -100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
});
const moveMotion = {
  "move-up": {
    inKeyframes: moveUpIn,
    outKeyframes: moveUpOut
  },
  "move-down": {
    inKeyframes: moveDownIn,
    outKeyframes: moveDownOut
  },
  "move-left": {
    inKeyframes: moveLeftIn,
    outKeyframes: moveLeftOut
  },
  "move-right": {
    inKeyframes: moveRightIn,
    outKeyframes: moveRightOut
  }
};
const initMoveMotion = (token2, motionName) => {
  const {
    antCls
  } = token2;
  const motionCls = `${antCls}-${motionName}`;
  const {
    inKeyframes,
    outKeyframes
  } = moveMotion[motionName];
  return [initMotion(motionCls, inKeyframes, outKeyframes, token2.motionDurationMid), {
    [`
        ${motionCls}-enter,
        ${motionCls}-appear
      `]: {
      opacity: 0,
      animationTimingFunction: token2.motionEaseOutCirc
    },
    [`${motionCls}-leave`]: {
      animationTimingFunction: token2.motionEaseInOutCirc
    }
  }];
};
const slideUpIn = new Keyframe("antSlideUpIn", {
  "0%": {
    transform: "scaleY(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scaleY(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  }
});
const slideUpOut = new Keyframe("antSlideUpOut", {
  "0%": {
    transform: "scaleY(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  },
  "100%": {
    transform: "scaleY(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  }
});
const slideDownIn = new Keyframe("antSlideDownIn", {
  "0%": {
    transform: "scaleY(0.8)",
    transformOrigin: "100% 100%",
    opacity: 0
  },
  "100%": {
    transform: "scaleY(1)",
    transformOrigin: "100% 100%",
    opacity: 1
  }
});
const slideDownOut = new Keyframe("antSlideDownOut", {
  "0%": {
    transform: "scaleY(1)",
    transformOrigin: "100% 100%",
    opacity: 1
  },
  "100%": {
    transform: "scaleY(0.8)",
    transformOrigin: "100% 100%",
    opacity: 0
  }
});
const slideLeftIn = new Keyframe("antSlideLeftIn", {
  "0%": {
    transform: "scaleX(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scaleX(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  }
});
const slideLeftOut = new Keyframe("antSlideLeftOut", {
  "0%": {
    transform: "scaleX(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  },
  "100%": {
    transform: "scaleX(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  }
});
const slideRightIn = new Keyframe("antSlideRightIn", {
  "0%": {
    transform: "scaleX(0.8)",
    transformOrigin: "100% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scaleX(1)",
    transformOrigin: "100% 0%",
    opacity: 1
  }
});
const slideRightOut = new Keyframe("antSlideRightOut", {
  "0%": {
    transform: "scaleX(1)",
    transformOrigin: "100% 0%",
    opacity: 1
  },
  "100%": {
    transform: "scaleX(0.8)",
    transformOrigin: "100% 0%",
    opacity: 0
  }
});
const slideMotion = {
  "slide-up": {
    inKeyframes: slideUpIn,
    outKeyframes: slideUpOut
  },
  "slide-down": {
    inKeyframes: slideDownIn,
    outKeyframes: slideDownOut
  },
  "slide-left": {
    inKeyframes: slideLeftIn,
    outKeyframes: slideLeftOut
  },
  "slide-right": {
    inKeyframes: slideRightIn,
    outKeyframes: slideRightOut
  }
};
const initSlideMotion = (token2, motionName) => {
  const {
    antCls
  } = token2;
  const motionCls = `${antCls}-${motionName}`;
  const {
    inKeyframes,
    outKeyframes
  } = slideMotion[motionName];
  return [initMotion(motionCls, inKeyframes, outKeyframes, token2.motionDurationMid), {
    [`
      ${motionCls}-enter,
      ${motionCls}-appear
    `]: {
      transform: "scale(0)",
      transformOrigin: "0% 0%",
      opacity: 0,
      animationTimingFunction: token2.motionEaseOutQuint
    },
    [`${motionCls}-leave`]: {
      animationTimingFunction: token2.motionEaseInQuint
    }
  }];
};
const zoomIn = new Keyframe("antZoomIn", {
  "0%": {
    transform: "scale(0.2)",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    opacity: 1
  }
});
const zoomOut = new Keyframe("antZoomOut", {
  "0%": {
    transform: "scale(1)"
  },
  "100%": {
    transform: "scale(0.2)",
    opacity: 0
  }
});
const zoomBigIn = new Keyframe("antZoomBigIn", {
  "0%": {
    transform: "scale(0.8)",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    opacity: 1
  }
});
const zoomBigOut = new Keyframe("antZoomBigOut", {
  "0%": {
    transform: "scale(1)"
  },
  "100%": {
    transform: "scale(0.8)",
    opacity: 0
  }
});
const zoomUpIn = new Keyframe("antZoomUpIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "50% 0%"
  }
});
const zoomUpOut = new Keyframe("antZoomUpOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "50% 0%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 0%",
    opacity: 0
  }
});
const zoomLeftIn = new Keyframe("antZoomLeftIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "0% 50%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "0% 50%"
  }
});
const zoomLeftOut = new Keyframe("antZoomLeftOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "0% 50%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "0% 50%",
    opacity: 0
  }
});
const zoomRightIn = new Keyframe("antZoomRightIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "100% 50%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "100% 50%"
  }
});
const zoomRightOut = new Keyframe("antZoomRightOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "100% 50%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "100% 50%",
    opacity: 0
  }
});
const zoomDownIn = new Keyframe("antZoomDownIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 100%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "50% 100%"
  }
});
const zoomDownOut = new Keyframe("antZoomDownOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "50% 100%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 100%",
    opacity: 0
  }
});
const zoomMotion = {
  zoom: {
    inKeyframes: zoomIn,
    outKeyframes: zoomOut
  },
  "zoom-big": {
    inKeyframes: zoomBigIn,
    outKeyframes: zoomBigOut
  },
  "zoom-big-fast": {
    inKeyframes: zoomBigIn,
    outKeyframes: zoomBigOut
  },
  "zoom-left": {
    inKeyframes: zoomLeftIn,
    outKeyframes: zoomLeftOut
  },
  "zoom-right": {
    inKeyframes: zoomRightIn,
    outKeyframes: zoomRightOut
  },
  "zoom-up": {
    inKeyframes: zoomUpIn,
    outKeyframes: zoomUpOut
  },
  "zoom-down": {
    inKeyframes: zoomDownIn,
    outKeyframes: zoomDownOut
  }
};
const initZoomMotion = (token2, motionName) => {
  const {
    antCls
  } = token2;
  const motionCls = `${antCls}-${motionName}`;
  const {
    inKeyframes,
    outKeyframes
  } = zoomMotion[motionName];
  return [initMotion(motionCls, inKeyframes, outKeyframes, motionName === "zoom-big-fast" ? token2.motionDurationFast : token2.motionDurationMid), {
    [`
        ${motionCls}-enter,
        ${motionCls}-appear
      `]: {
      transform: "scale(0)",
      opacity: 0,
      animationTimingFunction: token2.motionEaseOutCirc,
      "&-prepare": {
        transform: "none"
      }
    },
    [`${motionCls}-leave`]: {
      animationTimingFunction: token2.motionEaseInOutCirc
    }
  }];
};
const genCollapseMotion = (token2) => ({
  [token2.componentCls]: {
    // For common/openAnimation
    [`${token2.antCls}-motion-collapse-legacy`]: {
      overflow: "hidden",
      "&-active": {
        transition: `height ${token2.motionDurationMid} ${token2.motionEaseInOut},
        opacity ${token2.motionDurationMid} ${token2.motionEaseInOut} !important`
      }
    },
    [`${token2.antCls}-motion-collapse`]: {
      overflow: "hidden",
      transition: `height ${token2.motionDurationMid} ${token2.motionEaseInOut},
        opacity ${token2.motionDurationMid} ${token2.motionEaseInOut} !important`
    }
  }
});
const genItemStyle = (token2) => {
  const {
    controlPaddingHorizontal
  } = token2;
  return {
    position: "relative",
    display: "block",
    minHeight: token2.controlHeight,
    padding: `${(token2.controlHeight - token2.fontSize * token2.lineHeight) / 2}px ${controlPaddingHorizontal}px`,
    color: token2.colorText,
    fontWeight: "normal",
    fontSize: token2.fontSize,
    lineHeight: token2.lineHeight,
    boxSizing: "border-box"
  };
};
const genSingleStyle$1 = (token2) => {
  const {
    antCls,
    componentCls
  } = token2;
  const selectItemCls = `${componentCls}-item`;
  return [
    {
      [`${componentCls}-dropdown`]: _extends$1(_extends$1({}, resetComponent(token2)), {
        position: "absolute",
        top: -9999,
        zIndex: token2.zIndexPopup,
        boxSizing: "border-box",
        padding: token2.paddingXXS,
        overflow: "hidden",
        fontSize: token2.fontSize,
        // Fix select render lag of long text in chrome
        // https://github.com/ant-design/ant-design/issues/11456
        // https://github.com/ant-design/ant-design/issues/11843
        fontVariant: "initial",
        backgroundColor: token2.colorBgElevated,
        borderRadius: token2.borderRadiusLG,
        outline: "none",
        boxShadow: token2.boxShadowSecondary,
        [`
            &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-bottomLeft,
            &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-bottomLeft
          `]: {
          animationName: slideUpIn
        },
        [`
            &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-topLeft,
            &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-topLeft
          `]: {
          animationName: slideDownIn
        },
        [`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-bottomLeft`]: {
          animationName: slideUpOut
        },
        [`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-topLeft`]: {
          animationName: slideDownOut
        },
        "&-hidden": {
          display: "none"
        },
        "&-empty": {
          color: token2.colorTextDisabled
        },
        // ========================= Options =========================
        [`${selectItemCls}-empty`]: _extends$1(_extends$1({}, genItemStyle(token2)), {
          color: token2.colorTextDisabled
        }),
        [`${selectItemCls}`]: _extends$1(_extends$1({}, genItemStyle(token2)), {
          cursor: "pointer",
          transition: `background ${token2.motionDurationSlow} ease`,
          borderRadius: token2.borderRadiusSM,
          // =========== Group ============
          "&-group": {
            color: token2.colorTextDescription,
            fontSize: token2.fontSizeSM,
            cursor: "default"
          },
          // =========== Option ===========
          "&-option": {
            display: "flex",
            "&-content": _extends$1({
              flex: "auto"
            }, textEllipsis),
            "&-state": {
              flex: "none"
            },
            [`&-active:not(${selectItemCls}-option-disabled)`]: {
              backgroundColor: token2.controlItemBgHover
            },
            [`&-selected:not(${selectItemCls}-option-disabled)`]: {
              color: token2.colorText,
              fontWeight: token2.fontWeightStrong,
              backgroundColor: token2.controlItemBgActive,
              [`${selectItemCls}-option-state`]: {
                color: token2.colorPrimary
              }
            },
            "&-disabled": {
              [`&${selectItemCls}-option-selected`]: {
                backgroundColor: token2.colorBgContainerDisabled
              },
              color: token2.colorTextDisabled,
              cursor: "not-allowed"
            },
            "&-grouped": {
              paddingInlineStart: token2.controlPaddingHorizontal * 2
            }
          }
        }),
        // =========================== RTL ===========================
        "&-rtl": {
          direction: "rtl"
        }
      })
    },
    // Follow code may reuse in other components
    initSlideMotion(token2, "slide-up"),
    initSlideMotion(token2, "slide-down"),
    initMoveMotion(token2, "move-up"),
    initMoveMotion(token2, "move-down")
  ];
};
const FIXED_ITEM_MARGIN = 2;
function getSelectItemStyle(_ref) {
  let {
    controlHeightSM,
    controlHeight,
    lineWidth: borderWidth
  } = _ref;
  const selectItemDist = (controlHeight - controlHeightSM) / 2 - borderWidth;
  const selectItemMargin = Math.ceil(selectItemDist / 2);
  return [selectItemDist, selectItemMargin];
}
function genSizeStyle$3(token2, suffix) {
  const {
    componentCls,
    iconCls
  } = token2;
  const selectOverflowPrefixCls = `${componentCls}-selection-overflow`;
  const selectItemHeight = token2.controlHeightSM;
  const [selectItemDist] = getSelectItemStyle(token2);
  const suffixCls = suffix ? `${componentCls}-${suffix}` : "";
  return {
    [`${componentCls}-multiple${suffixCls}`]: {
      fontSize: token2.fontSize,
      /**
       * Do not merge `height` & `line-height` under style with `selection` & `search`, since chrome
       * may update to redesign with its align logic.
       */
      // =========================== Overflow ===========================
      [selectOverflowPrefixCls]: {
        position: "relative",
        display: "flex",
        flex: "auto",
        flexWrap: "wrap",
        maxWidth: "100%",
        "&-item": {
          flex: "none",
          alignSelf: "center",
          maxWidth: "100%",
          display: "inline-flex"
        }
      },
      // ========================= Selector =========================
      [`${componentCls}-selector`]: {
        display: "flex",
        flexWrap: "wrap",
        alignItems: "center",
        // Multiple is little different that horizontal is follow the vertical
        padding: `${selectItemDist - FIXED_ITEM_MARGIN}px ${FIXED_ITEM_MARGIN * 2}px`,
        borderRadius: token2.borderRadius,
        [`${componentCls}-show-search&`]: {
          cursor: "text"
        },
        [`${componentCls}-disabled&`]: {
          background: token2.colorBgContainerDisabled,
          cursor: "not-allowed"
        },
        "&:after": {
          display: "inline-block",
          width: 0,
          margin: `${FIXED_ITEM_MARGIN}px 0`,
          lineHeight: `${selectItemHeight}px`,
          content: '"\\a0"'
        }
      },
      [`
        &${componentCls}-show-arrow ${componentCls}-selector,
        &${componentCls}-allow-clear ${componentCls}-selector
      `]: {
        paddingInlineEnd: token2.fontSizeIcon + token2.controlPaddingHorizontal
      },
      // ======================== Selections ========================
      [`${componentCls}-selection-item`]: {
        position: "relative",
        display: "flex",
        flex: "none",
        boxSizing: "border-box",
        maxWidth: "100%",
        height: selectItemHeight,
        marginTop: FIXED_ITEM_MARGIN,
        marginBottom: FIXED_ITEM_MARGIN,
        lineHeight: `${selectItemHeight - token2.lineWidth * 2}px`,
        background: token2.colorFillSecondary,
        border: `${token2.lineWidth}px solid ${token2.colorSplit}`,
        borderRadius: token2.borderRadiusSM,
        cursor: "default",
        transition: `font-size ${token2.motionDurationSlow}, line-height ${token2.motionDurationSlow}, height ${token2.motionDurationSlow}`,
        userSelect: "none",
        marginInlineEnd: FIXED_ITEM_MARGIN * 2,
        paddingInlineStart: token2.paddingXS,
        paddingInlineEnd: token2.paddingXS / 2,
        [`${componentCls}-disabled&`]: {
          color: token2.colorTextDisabled,
          borderColor: token2.colorBorder,
          cursor: "not-allowed"
        },
        // It's ok not to do this, but 24px makes bottom narrow in view should adjust
        "&-content": {
          display: "inline-block",
          marginInlineEnd: token2.paddingXS / 2,
          overflow: "hidden",
          whiteSpace: "pre",
          textOverflow: "ellipsis"
        },
        "&-remove": _extends$1(_extends$1({}, resetIcon()), {
          display: "inline-block",
          color: token2.colorIcon,
          fontWeight: "bold",
          fontSize: 10,
          lineHeight: "inherit",
          cursor: "pointer",
          [`> ${iconCls}`]: {
            verticalAlign: "-0.2em"
          },
          "&:hover": {
            color: token2.colorIconHover
          }
        })
      },
      // ========================== Input ==========================
      [`${selectOverflowPrefixCls}-item + ${selectOverflowPrefixCls}-item`]: {
        [`${componentCls}-selection-search`]: {
          marginInlineStart: 0
        }
      },
      [`${componentCls}-selection-search`]: {
        display: "inline-flex",
        position: "relative",
        maxWidth: "100%",
        marginInlineStart: token2.inputPaddingHorizontalBase - selectItemDist,
        [`
          &-input,
          &-mirror
        `]: {
          height: selectItemHeight,
          fontFamily: token2.fontFamily,
          lineHeight: `${selectItemHeight}px`,
          transition: `all ${token2.motionDurationSlow}`
        },
        "&-input": {
          width: "100%",
          minWidth: 4.1
          // fix search cursor missing
        },
        "&-mirror": {
          position: "absolute",
          top: 0,
          insetInlineStart: 0,
          insetInlineEnd: "auto",
          zIndex: 999,
          whiteSpace: "pre",
          visibility: "hidden"
        }
      },
      // ======================= Placeholder =======================
      [`${componentCls}-selection-placeholder `]: {
        position: "absolute",
        top: "50%",
        insetInlineStart: token2.inputPaddingHorizontalBase,
        insetInlineEnd: token2.inputPaddingHorizontalBase,
        transform: "translateY(-50%)",
        transition: `all ${token2.motionDurationSlow}`
      }
    }
  };
}
function genMultipleStyle(token2) {
  const {
    componentCls
  } = token2;
  const smallToken = merge(token2, {
    controlHeight: token2.controlHeightSM,
    controlHeightSM: token2.controlHeightXS,
    borderRadius: token2.borderRadiusSM,
    borderRadiusSM: token2.borderRadiusXS
  });
  const [, smSelectItemMargin] = getSelectItemStyle(token2);
  return [
    genSizeStyle$3(token2),
    // ======================== Small ========================
    // Shared
    genSizeStyle$3(smallToken, "sm"),
    // Padding
    {
      [`${componentCls}-multiple${componentCls}-sm`]: {
        [`${componentCls}-selection-placeholder`]: {
          insetInlineStart: token2.controlPaddingHorizontalSM - token2.lineWidth,
          insetInlineEnd: "auto"
        },
        // https://github.com/ant-design/ant-design/issues/29559
        [`${componentCls}-selection-search`]: {
          marginInlineStart: smSelectItemMargin
        }
      }
    },
    // ======================== Large ========================
    // Shared
    genSizeStyle$3(merge(token2, {
      fontSize: token2.fontSizeLG,
      controlHeight: token2.controlHeightLG,
      controlHeightSM: token2.controlHeight,
      borderRadius: token2.borderRadiusLG,
      borderRadiusSM: token2.borderRadius
    }), "lg")
  ];
}
function genSizeStyle$2(token2, suffix) {
  const {
    componentCls,
    inputPaddingHorizontalBase,
    borderRadius
  } = token2;
  const selectHeightWithoutBorder = token2.controlHeight - token2.lineWidth * 2;
  const selectionItemPadding = Math.ceil(token2.fontSize * 1.25);
  const suffixCls = suffix ? `${componentCls}-${suffix}` : "";
  return {
    [`${componentCls}-single${suffixCls}`]: {
      fontSize: token2.fontSize,
      // ========================= Selector =========================
      [`${componentCls}-selector`]: _extends$1(_extends$1({}, resetComponent(token2)), {
        display: "flex",
        borderRadius,
        [`${componentCls}-selection-search`]: {
          position: "absolute",
          top: 0,
          insetInlineStart: inputPaddingHorizontalBase,
          insetInlineEnd: inputPaddingHorizontalBase,
          bottom: 0,
          "&-input": {
            width: "100%"
          }
        },
        [`
          ${componentCls}-selection-item,
          ${componentCls}-selection-placeholder
        `]: {
          padding: 0,
          lineHeight: `${selectHeightWithoutBorder}px`,
          transition: `all ${token2.motionDurationSlow}`,
          // Firefox inline-block position calculation is not same as Chrome & Safari. Patch this:
          "@supports (-moz-appearance: meterbar)": {
            lineHeight: `${selectHeightWithoutBorder}px`
          }
        },
        [`${componentCls}-selection-item`]: {
          position: "relative",
          userSelect: "none"
        },
        [`${componentCls}-selection-placeholder`]: {
          transition: "none",
          pointerEvents: "none"
        },
        // For common baseline align
        [[
          "&:after",
          /* For '' value baseline align */
          `${componentCls}-selection-item:after`,
          /* For undefined value baseline align */
          `${componentCls}-selection-placeholder:after`
        ].join(",")]: {
          display: "inline-block",
          width: 0,
          visibility: "hidden",
          content: '"\\a0"'
        }
      }),
      [`
        &${componentCls}-show-arrow ${componentCls}-selection-item,
        &${componentCls}-show-arrow ${componentCls}-selection-placeholder
      `]: {
        paddingInlineEnd: selectionItemPadding
      },
      // Opacity selection if open
      [`&${componentCls}-open ${componentCls}-selection-item`]: {
        color: token2.colorTextPlaceholder
      },
      // ========================== Input ==========================
      // We only change the style of non-customize input which is only support by `combobox` mode.
      // Not customize
      [`&:not(${componentCls}-customize-input)`]: {
        [`${componentCls}-selector`]: {
          width: "100%",
          height: token2.controlHeight,
          padding: `0 ${inputPaddingHorizontalBase}px`,
          [`${componentCls}-selection-search-input`]: {
            height: selectHeightWithoutBorder
          },
          "&:after": {
            lineHeight: `${selectHeightWithoutBorder}px`
          }
        }
      },
      [`&${componentCls}-customize-input`]: {
        [`${componentCls}-selector`]: {
          "&:after": {
            display: "none"
          },
          [`${componentCls}-selection-search`]: {
            position: "static",
            width: "100%"
          },
          [`${componentCls}-selection-placeholder`]: {
            position: "absolute",
            insetInlineStart: 0,
            insetInlineEnd: 0,
            padding: `0 ${inputPaddingHorizontalBase}px`,
            "&:after": {
              display: "none"
            }
          }
        }
      }
    }
  };
}
function genSingleStyle(token2) {
  const {
    componentCls
  } = token2;
  const inputPaddingHorizontalSM = token2.controlPaddingHorizontalSM - token2.lineWidth;
  return [
    genSizeStyle$2(token2),
    // ======================== Small ========================
    // Shared
    genSizeStyle$2(merge(token2, {
      controlHeight: token2.controlHeightSM,
      borderRadius: token2.borderRadiusSM
    }), "sm"),
    // padding
    {
      [`${componentCls}-single${componentCls}-sm`]: {
        [`&:not(${componentCls}-customize-input)`]: {
          [`${componentCls}-selection-search`]: {
            insetInlineStart: inputPaddingHorizontalSM,
            insetInlineEnd: inputPaddingHorizontalSM
          },
          [`${componentCls}-selector`]: {
            padding: `0 ${inputPaddingHorizontalSM}px`
          },
          // With arrow should provides `padding-right` to show the arrow
          [`&${componentCls}-show-arrow ${componentCls}-selection-search`]: {
            insetInlineEnd: inputPaddingHorizontalSM + token2.fontSize * 1.5
          },
          [`
            &${componentCls}-show-arrow ${componentCls}-selection-item,
            &${componentCls}-show-arrow ${componentCls}-selection-placeholder
          `]: {
            paddingInlineEnd: token2.fontSize * 1.5
          }
        }
      }
    },
    // ======================== Large ========================
    // Shared
    genSizeStyle$2(merge(token2, {
      controlHeight: token2.controlHeightLG,
      fontSize: token2.fontSizeLG,
      borderRadius: token2.borderRadiusLG
    }), "lg")
  ];
}
function compactItemBorder(token2, parentCls, options) {
  const {
    focusElCls,
    focus,
    borderElCls
  } = options;
  const childCombinator = borderElCls ? "> *" : "";
  const hoverEffects = ["hover", focus ? "focus" : null, "active"].filter(Boolean).map((n2) => `&:${n2} ${childCombinator}`).join(",");
  return {
    [`&-item:not(${parentCls}-last-item)`]: {
      marginInlineEnd: -token2.lineWidth
    },
    "&-item": _extends$1(_extends$1({
      [hoverEffects]: {
        zIndex: 2
      }
    }, focusElCls ? {
      [`&${focusElCls}`]: {
        zIndex: 2
      }
    } : {}), {
      [`&[disabled] ${childCombinator}`]: {
        zIndex: 0
      }
    })
  };
}
function compactItemBorderRadius(prefixCls, parentCls, options) {
  const {
    borderElCls
  } = options;
  const childCombinator = borderElCls ? `> ${borderElCls}` : "";
  return {
    [`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item) ${childCombinator}`]: {
      borderRadius: 0
    },
    [`&-item:not(${parentCls}-last-item)${parentCls}-first-item`]: {
      [`& ${childCombinator}, &${prefixCls}-sm ${childCombinator}, &${prefixCls}-lg ${childCombinator}`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`&-item:not(${parentCls}-first-item)${parentCls}-last-item`]: {
      [`& ${childCombinator}, &${prefixCls}-sm ${childCombinator}, &${prefixCls}-lg ${childCombinator}`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    }
  };
}
function genCompactItemStyle(token2) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    focus: true
  };
  const {
    componentCls
  } = token2;
  const compactCls = `${componentCls}-compact`;
  return {
    [compactCls]: _extends$1(_extends$1({}, compactItemBorder(token2, compactCls, options)), compactItemBorderRadius(componentCls, compactCls, options))
  };
}
const genSelectorStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    position: "relative",
    backgroundColor: token2.colorBgContainer,
    border: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`,
    transition: `all ${token2.motionDurationMid} ${token2.motionEaseInOut}`,
    input: {
      cursor: "pointer"
    },
    [`${componentCls}-show-search&`]: {
      cursor: "text",
      input: {
        cursor: "auto",
        color: "inherit"
      }
    },
    [`${componentCls}-disabled&`]: {
      color: token2.colorTextDisabled,
      background: token2.colorBgContainerDisabled,
      cursor: "not-allowed",
      [`${componentCls}-multiple&`]: {
        background: token2.colorBgContainerDisabled
      },
      input: {
        cursor: "not-allowed"
      }
    }
  };
};
const genStatusStyle$2 = function(rootSelectCls, token2) {
  let overwriteDefaultBorder = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  const {
    componentCls,
    borderHoverColor,
    outlineColor,
    antCls
  } = token2;
  const overwriteStyle = overwriteDefaultBorder ? {
    [`${componentCls}-selector`]: {
      borderColor: borderHoverColor
    }
  } : {};
  return {
    [rootSelectCls]: {
      [`&:not(${componentCls}-disabled):not(${componentCls}-customize-input):not(${antCls}-pagination-size-changer)`]: _extends$1(_extends$1({}, overwriteStyle), {
        [`${componentCls}-focused& ${componentCls}-selector`]: {
          borderColor: borderHoverColor,
          boxShadow: `0 0 0 ${token2.controlOutlineWidth}px ${outlineColor}`,
          borderInlineEndWidth: `${token2.controlLineWidth}px !important`,
          outline: 0
        },
        [`&:hover ${componentCls}-selector`]: {
          borderColor: borderHoverColor,
          borderInlineEndWidth: `${token2.controlLineWidth}px !important`
        }
      })
    }
  };
};
const getSearchInputWithoutBorderStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-selection-search-input`]: {
      margin: 0,
      padding: 0,
      background: "transparent",
      border: "none",
      outline: "none",
      appearance: "none",
      "&::-webkit-search-cancel-button": {
        display: "none",
        "-webkit-appearance": "none"
      }
    }
  };
};
const genBaseStyle$e = (token2) => {
  const {
    componentCls,
    inputPaddingHorizontalBase,
    iconCls
  } = token2;
  return {
    [componentCls]: _extends$1(_extends$1({}, resetComponent(token2)), {
      position: "relative",
      display: "inline-block",
      cursor: "pointer",
      [`&:not(${componentCls}-customize-input) ${componentCls}-selector`]: _extends$1(_extends$1({}, genSelectorStyle(token2)), getSearchInputWithoutBorderStyle(token2)),
      // [`&:not(&-disabled):hover ${selectCls}-selector`]: {
      //   ...genHoverStyle(token),
      // },
      // ======================== Selection ========================
      [`${componentCls}-selection-item`]: _extends$1({
        flex: 1,
        fontWeight: "normal"
      }, textEllipsis),
      // ======================= Placeholder =======================
      [`${componentCls}-selection-placeholder`]: _extends$1(_extends$1({}, textEllipsis), {
        flex: 1,
        color: token2.colorTextPlaceholder,
        pointerEvents: "none"
      }),
      // ========================== Arrow ==========================
      [`${componentCls}-arrow`]: _extends$1(_extends$1({}, resetIcon()), {
        position: "absolute",
        top: "50%",
        insetInlineStart: "auto",
        insetInlineEnd: inputPaddingHorizontalBase,
        height: token2.fontSizeIcon,
        marginTop: -token2.fontSizeIcon / 2,
        color: token2.colorTextQuaternary,
        fontSize: token2.fontSizeIcon,
        lineHeight: 1,
        textAlign: "center",
        pointerEvents: "none",
        display: "flex",
        alignItems: "center",
        [iconCls]: {
          verticalAlign: "top",
          transition: `transform ${token2.motionDurationSlow}`,
          "> svg": {
            verticalAlign: "top"
          },
          [`&:not(${componentCls}-suffix)`]: {
            pointerEvents: "auto"
          }
        },
        [`${componentCls}-disabled &`]: {
          cursor: "not-allowed"
        },
        "> *:not(:last-child)": {
          marginInlineEnd: 8
          // FIXME: magic
        }
      }),
      // ========================== Clear ==========================
      [`${componentCls}-clear`]: {
        position: "absolute",
        top: "50%",
        insetInlineStart: "auto",
        insetInlineEnd: inputPaddingHorizontalBase,
        zIndex: 1,
        display: "inline-block",
        width: token2.fontSizeIcon,
        height: token2.fontSizeIcon,
        marginTop: -token2.fontSizeIcon / 2,
        color: token2.colorTextQuaternary,
        fontSize: token2.fontSizeIcon,
        fontStyle: "normal",
        lineHeight: 1,
        textAlign: "center",
        textTransform: "none",
        background: token2.colorBgContainer,
        cursor: "pointer",
        opacity: 0,
        transition: `color ${token2.motionDurationMid} ease, opacity ${token2.motionDurationSlow} ease`,
        textRendering: "auto",
        "&:before": {
          display: "block"
        },
        "&:hover": {
          color: token2.colorTextTertiary
        }
      },
      "&:hover": {
        [`${componentCls}-clear`]: {
          opacity: 1
        }
      }
    }),
    // ========================= Feedback ==========================
    [`${componentCls}-has-feedback`]: {
      [`${componentCls}-clear`]: {
        insetInlineEnd: inputPaddingHorizontalBase + token2.fontSize + token2.paddingXXS
      }
    }
  };
};
const genSelectStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return [
    {
      [componentCls]: {
        // ==================== BorderLess ====================
        [`&-borderless ${componentCls}-selector`]: {
          backgroundColor: `transparent !important`,
          borderColor: `transparent !important`,
          boxShadow: `none !important`
        },
        // ==================== In Form ====================
        [`&${componentCls}-in-form-item`]: {
          width: "100%"
        }
      }
    },
    // =====================================================
    // ==                       LTR                       ==
    // =====================================================
    // Base
    genBaseStyle$e(token2),
    // Single
    genSingleStyle(token2),
    // Multiple
    genMultipleStyle(token2),
    // Dropdown
    genSingleStyle$1(token2),
    // =====================================================
    // ==                       RTL                       ==
    // =====================================================
    {
      [`${componentCls}-rtl`]: {
        direction: "rtl"
      }
    },
    // =====================================================
    // ==                     Status                      ==
    // =====================================================
    genStatusStyle$2(componentCls, merge(token2, {
      borderHoverColor: token2.colorPrimaryHover,
      outlineColor: token2.controlOutline
    })),
    genStatusStyle$2(`${componentCls}-status-error`, merge(token2, {
      borderHoverColor: token2.colorErrorHover,
      outlineColor: token2.colorErrorOutline
    }), true),
    genStatusStyle$2(`${componentCls}-status-warning`, merge(token2, {
      borderHoverColor: token2.colorWarningHover,
      outlineColor: token2.colorWarningOutline
    }), true),
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    genCompactItemStyle(token2, {
      borderElCls: `${componentCls}-selector`,
      focusElCls: `${componentCls}-focused`
    })
  ];
};
const useSelectStyle = genComponentStyleHook("Select", (token2, _ref) => {
  let {
    rootPrefixCls
  } = _ref;
  const selectToken = merge(token2, {
    rootPrefixCls,
    inputPaddingHorizontalBase: token2.paddingSM - 1
  });
  return [genSelectStyle(selectToken)];
}, (token2) => ({
  zIndexPopup: token2.zIndexPopupBase + 50
}));
const selectProps = () => _extends$1(_extends$1({}, omit$1(selectProps$1(), ["inputIcon", "mode", "getInputElement", "getRawInputElement", "backfill"])), {
  value: someType([Array, Object, String, Number]),
  defaultValue: someType([Array, Object, String, Number]),
  notFoundContent: PropTypes.any,
  suffixIcon: PropTypes.any,
  itemIcon: PropTypes.any,
  size: stringType(),
  mode: stringType(),
  bordered: booleanType(true),
  transitionName: String,
  choiceTransitionName: stringType(""),
  popupClassName: String,
  /** @deprecated Please use `popupClassName` instead */
  dropdownClassName: String,
  placement: stringType(),
  status: stringType(),
  "onUpdate:value": functionType()
});
const SECRET_COMBOBOX_MODE_DO_NOT_USE = "SECRET_COMBOBOX_MODE_DO_NOT_USE";
const Select = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ASelect",
  Option,
  OptGroup,
  inheritAttrs: false,
  props: initDefaultProps(selectProps(), {
    listHeight: 256,
    listItemHeight: 24
  }),
  SECRET_COMBOBOX_MODE_DO_NOT_USE,
  slots: Object,
  setup(props2, _ref) {
    let {
      attrs,
      emit,
      slots,
      expose
    } = _ref;
    const selectRef = ref();
    const formItemContext = useInjectFormItemContext();
    const formItemInputContext = FormItemInputContext.useInject();
    const mergedStatus = computed(() => getMergedStatus(formItemInputContext.status, props2.status));
    const focus = () => {
      var _a2;
      (_a2 = selectRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
    };
    const blur = () => {
      var _a2;
      (_a2 = selectRef.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
    };
    const scrollTo2 = (arg) => {
      var _a2;
      (_a2 = selectRef.value) === null || _a2 === void 0 ? void 0 : _a2.scrollTo(arg);
    };
    const mode = computed(() => {
      const {
        mode: mode2
      } = props2;
      if (mode2 === "combobox") {
        return void 0;
      }
      if (mode2 === SECRET_COMBOBOX_MODE_DO_NOT_USE) {
        return "combobox";
      }
      return mode2;
    });
    const {
      prefixCls,
      direction,
      configProvider,
      renderEmpty: renderEmpty2,
      size: contextSize,
      getPrefixCls,
      getPopupContainer,
      disabled,
      select
    } = useConfigInject("select", props2);
    const {
      compactSize,
      compactItemClassnames
    } = useCompactItemContext(prefixCls, direction);
    const mergedSize = computed(() => compactSize.value || contextSize.value);
    const contextDisabled = useInjectDisabled();
    const mergedDisabled = computed(() => {
      var _a2;
      return (_a2 = disabled.value) !== null && _a2 !== void 0 ? _a2 : contextDisabled.value;
    });
    const [wrapSSR, hashId] = useSelectStyle(prefixCls);
    const rootPrefixCls = computed(() => getPrefixCls());
    const placement = computed(() => {
      if (props2.placement !== void 0) {
        return props2.placement;
      }
      return direction.value === "rtl" ? "bottomRight" : "bottomLeft";
    });
    const transitionName2 = computed(() => getTransitionName(rootPrefixCls.value, getTransitionDirection(placement.value), props2.transitionName));
    const mergedClassName = computed(() => classNames({
      [`${prefixCls.value}-lg`]: mergedSize.value === "large",
      [`${prefixCls.value}-sm`]: mergedSize.value === "small",
      [`${prefixCls.value}-rtl`]: direction.value === "rtl",
      [`${prefixCls.value}-borderless`]: !props2.bordered,
      [`${prefixCls.value}-in-form-item`]: formItemInputContext.isFormItemInput
    }, getStatusClassNames(prefixCls.value, mergedStatus.value, formItemInputContext.hasFeedback), compactItemClassnames.value, hashId.value));
    const triggerChange = function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      emit("update:value", args[0]);
      emit("change", ...args);
      formItemContext.onFieldChange();
    };
    const handleBlur = (e2) => {
      emit("blur", e2);
      formItemContext.onFieldBlur();
    };
    expose({
      blur,
      focus,
      scrollTo: scrollTo2
    });
    const isMultiple2 = computed(() => mode.value === "multiple" || mode.value === "tags");
    const mergedShowArrow = computed(() => props2.showArrow !== void 0 ? props2.showArrow : props2.loading || !(isMultiple2.value || mode.value === "combobox"));
    return () => {
      var _a2, _b, _c, _d;
      const {
        notFoundContent,
        listHeight = 256,
        listItemHeight = 24,
        popupClassName,
        dropdownClassName,
        virtual,
        dropdownMatchSelectWidth,
        id = formItemContext.id.value,
        placeholder = (_a2 = slots.placeholder) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
        showArrow
      } = props2;
      const {
        hasFeedback,
        feedbackIcon
      } = formItemInputContext;
      let mergedNotFound;
      if (notFoundContent !== void 0) {
        mergedNotFound = notFoundContent;
      } else if (slots.notFoundContent) {
        mergedNotFound = slots.notFoundContent();
      } else if (mode.value === "combobox") {
        mergedNotFound = null;
      } else {
        mergedNotFound = (renderEmpty2 === null || renderEmpty2 === void 0 ? void 0 : renderEmpty2("Select")) || createVNode(DefaultRenderEmpty, {
          "componentName": "Select"
        }, null);
      }
      const {
        suffixIcon,
        itemIcon,
        removeIcon,
        clearIcon
      } = getIcons(_extends$1(_extends$1({}, props2), {
        multiple: isMultiple2.value,
        prefixCls: prefixCls.value,
        hasFeedback,
        feedbackIcon,
        showArrow: mergedShowArrow.value
      }), slots);
      const selectProps2 = omit$1(props2, ["prefixCls", "suffixIcon", "itemIcon", "removeIcon", "clearIcon", "size", "bordered", "status"]);
      const rcSelectRtlDropdownClassName = classNames(popupClassName || dropdownClassName, {
        [`${prefixCls.value}-dropdown-${direction.value}`]: direction.value === "rtl"
      }, hashId.value);
      return wrapSSR(createVNode(Select$1, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
        "ref": selectRef,
        "virtual": virtual,
        "dropdownMatchSelectWidth": dropdownMatchSelectWidth
      }, selectProps2), attrs), {}, {
        "showSearch": (_b = props2.showSearch) !== null && _b !== void 0 ? _b : (_c = select === null || select === void 0 ? void 0 : select.value) === null || _c === void 0 ? void 0 : _c.showSearch,
        "placeholder": placeholder,
        "listHeight": listHeight,
        "listItemHeight": listItemHeight,
        "mode": mode.value,
        "prefixCls": prefixCls.value,
        "direction": direction.value,
        "inputIcon": suffixIcon,
        "menuItemSelectedIcon": itemIcon,
        "removeIcon": removeIcon,
        "clearIcon": clearIcon,
        "notFoundContent": mergedNotFound,
        "class": [mergedClassName.value, attrs.class],
        "getPopupContainer": getPopupContainer === null || getPopupContainer === void 0 ? void 0 : getPopupContainer.value,
        "dropdownClassName": rcSelectRtlDropdownClassName,
        "onChange": triggerChange,
        "onBlur": handleBlur,
        "id": id,
        "dropdownRender": selectProps2.dropdownRender || slots.dropdownRender,
        "transitionName": transitionName2.value,
        "children": (_d = slots.default) === null || _d === void 0 ? void 0 : _d.call(slots),
        "tagRender": props2.tagRender || slots.tagRender,
        "optionLabelRender": slots.optionLabel,
        "maxTagPlaceholder": props2.maxTagPlaceholder || slots.maxTagPlaceholder,
        "showArrow": hasFeedback || showArrow,
        "disabled": mergedDisabled.value
      }), {
        option: slots.option
      }));
    };
  }
});
Select.install = function(app) {
  app.component(Select.name, Select);
  app.component(Select.Option.displayName, Select.Option);
  app.component(Select.OptGroup.displayName, Select.OptGroup);
  return app;
};
Select.Option;
Select.OptGroup;
const responsiveArray = ["xxxl", "xxl", "xl", "lg", "md", "sm", "xs"];
const getResponsiveMap = (token2) => ({
  xs: `(max-width: ${token2.screenXSMax}px)`,
  sm: `(min-width: ${token2.screenSM}px)`,
  md: `(min-width: ${token2.screenMD}px)`,
  lg: `(min-width: ${token2.screenLG}px)`,
  xl: `(min-width: ${token2.screenXL}px)`,
  xxl: `(min-width: ${token2.screenXXL}px)`,
  xxxl: `{min-width: ${token2.screenXXXL}px}`
});
function useResponsiveObserver() {
  const [, token2] = useToken$1();
  return computed(() => {
    const responsiveMap = getResponsiveMap(token2.value);
    const subscribers = /* @__PURE__ */ new Map();
    let subUid = -1;
    let screens = {};
    return {
      matchHandlers: {},
      dispatch(pointMap) {
        screens = pointMap;
        subscribers.forEach((func) => func(screens));
        return subscribers.size >= 1;
      },
      subscribe(func) {
        if (!subscribers.size) this.register();
        subUid += 1;
        subscribers.set(subUid, func);
        func(screens);
        return subUid;
      },
      unsubscribe(paramToken) {
        subscribers.delete(paramToken);
        if (!subscribers.size) this.unregister();
      },
      unregister() {
        Object.keys(responsiveMap).forEach((screen) => {
          const matchMediaQuery = responsiveMap[screen];
          const handler = this.matchHandlers[matchMediaQuery];
          handler === null || handler === void 0 ? void 0 : handler.mql.removeListener(handler === null || handler === void 0 ? void 0 : handler.listener);
        });
        subscribers.clear();
      },
      register() {
        Object.keys(responsiveMap).forEach((screen) => {
          const matchMediaQuery = responsiveMap[screen];
          const listener = (_ref) => {
            let {
              matches
            } = _ref;
            this.dispatch(_extends$1(_extends$1({}, screens), {
              [screen]: matches
            }));
          };
          const mql = window.matchMedia(matchMediaQuery);
          mql.addListener(listener);
          this.matchHandlers[matchMediaQuery] = {
            mql,
            listener
          };
          listener(mql);
        });
      },
      responsiveMap
    };
  });
}
function useBreakpoint() {
  const screens = shallowRef({});
  let token2 = null;
  const responsiveObserve = useResponsiveObserver();
  onMounted(() => {
    token2 = responsiveObserve.value.subscribe((supportScreens) => {
      screens.value = supportScreens;
    });
  });
  onUnmounted(() => {
    responsiveObserve.value.unsubscribe(token2);
  });
  return screens;
}
function eagerComputed(fn) {
  const result = shallowRef();
  watchEffect(() => {
    result.value = fn();
  }, {
    flush: "sync"
    // needed so updates are immediate.
  });
  return result;
}
const genBaseStyle$d = (token2) => {
  const {
    antCls,
    componentCls,
    iconCls,
    avatarBg,
    avatarColor,
    containerSize,
    containerSizeLG,
    containerSizeSM,
    textFontSize,
    textFontSizeLG,
    textFontSizeSM,
    borderRadius,
    borderRadiusLG,
    borderRadiusSM,
    lineWidth,
    lineType
  } = token2;
  const avatarSizeStyle = (size, fontSize, radius) => ({
    width: size,
    height: size,
    lineHeight: `${size - lineWidth * 2}px`,
    borderRadius: "50%",
    [`&${componentCls}-square`]: {
      borderRadius: radius
    },
    [`${componentCls}-string`]: {
      position: "absolute",
      left: {
        _skip_check_: true,
        value: "50%"
      },
      transformOrigin: "0 center"
    },
    [`&${componentCls}-icon`]: {
      fontSize,
      [`> ${iconCls}`]: {
        margin: 0
      }
    }
  });
  return {
    [componentCls]: _extends$1(_extends$1(_extends$1(_extends$1({}, resetComponent(token2)), {
      position: "relative",
      display: "inline-block",
      overflow: "hidden",
      color: avatarColor,
      whiteSpace: "nowrap",
      textAlign: "center",
      verticalAlign: "middle",
      background: avatarBg,
      border: `${lineWidth}px ${lineType} transparent`,
      [`&-image`]: {
        background: "transparent"
      },
      [`${antCls}-image-img`]: {
        display: "block"
      }
    }), avatarSizeStyle(containerSize, textFontSize, borderRadius)), {
      [`&-lg`]: _extends$1({}, avatarSizeStyle(containerSizeLG, textFontSizeLG, borderRadiusLG)),
      [`&-sm`]: _extends$1({}, avatarSizeStyle(containerSizeSM, textFontSizeSM, borderRadiusSM)),
      "> img": {
        display: "block",
        width: "100%",
        height: "100%",
        objectFit: "cover"
      }
    })
  };
};
const genGroupStyle$2 = (token2) => {
  const {
    componentCls,
    groupBorderColor,
    groupOverlapping,
    groupSpace
  } = token2;
  return {
    [`${componentCls}-group`]: {
      display: "inline-flex",
      [`${componentCls}`]: {
        borderColor: groupBorderColor
      },
      [`> *:not(:first-child)`]: {
        marginInlineStart: groupOverlapping
      }
    },
    [`${componentCls}-group-popover`]: {
      [`${componentCls} + ${componentCls}`]: {
        marginInlineStart: groupSpace
      }
    }
  };
};
const useStyle$G = genComponentStyleHook("Avatar", (token2) => {
  const {
    colorTextLightSolid,
    colorTextPlaceholder
  } = token2;
  const avatarToken = merge(token2, {
    avatarBg: colorTextPlaceholder,
    avatarColor: colorTextLightSolid
  });
  return [genBaseStyle$d(avatarToken), genGroupStyle$2(avatarToken)];
}, (token2) => {
  const {
    controlHeight,
    controlHeightLG,
    controlHeightSM,
    fontSize,
    fontSizeLG,
    fontSizeXL,
    fontSizeHeading3,
    marginXS,
    marginXXS,
    colorBorderBg
  } = token2;
  return {
    containerSize: controlHeight,
    containerSizeLG: controlHeightLG,
    containerSizeSM: controlHeightSM,
    textFontSize: Math.round((fontSizeLG + fontSizeXL) / 2),
    textFontSizeLG: fontSizeHeading3,
    textFontSizeSM: fontSize,
    groupSpace: marginXXS,
    groupOverlapping: -marginXS,
    groupBorderColor: colorBorderBg
  };
});
const AvatarContextKey = Symbol("AvatarContextKey");
const useAvatarInjectContext = () => {
  return inject(AvatarContextKey, {});
};
const useAvatarProviderContext = (context2) => {
  return provide(AvatarContextKey, context2);
};
const avatarProps$1 = () => ({
  prefixCls: String,
  shape: {
    type: String,
    default: "circle"
  },
  size: {
    type: [Number, String, Object],
    default: () => "default"
  },
  src: String,
  /** Srcset of image avatar */
  srcset: String,
  icon: PropTypes.any,
  alt: String,
  gap: Number,
  draggable: {
    type: Boolean,
    default: void 0
  },
  crossOrigin: String,
  loadError: {
    type: Function
  }
});
const Avatar = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AAvatar",
  inheritAttrs: false,
  props: avatarProps$1(),
  slots: Object,
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const isImgExist = shallowRef(true);
    const isMounted = shallowRef(false);
    const scale = shallowRef(1);
    const avatarChildrenRef = shallowRef(null);
    const avatarNodeRef = shallowRef(null);
    const {
      prefixCls
    } = useConfigInject("avatar", props2);
    const [wrapSSR, hashId] = useStyle$G(prefixCls);
    const avatarCtx = useAvatarInjectContext();
    const size = computed(() => {
      return props2.size === "default" ? avatarCtx.size : props2.size;
    });
    const screens = useBreakpoint();
    const responsiveSize = eagerComputed(() => {
      if (typeof props2.size !== "object") {
        return void 0;
      }
      const currentBreakpoint = responsiveArray.find((screen) => screens.value[screen]);
      const currentSize = props2.size[currentBreakpoint];
      return currentSize;
    });
    const responsiveSizeStyle = (hasIcon) => {
      if (responsiveSize.value) {
        return {
          width: `${responsiveSize.value}px`,
          height: `${responsiveSize.value}px`,
          lineHeight: `${responsiveSize.value}px`,
          fontSize: `${hasIcon ? responsiveSize.value / 2 : 18}px`
        };
      }
      return {};
    };
    const setScaleParam = () => {
      if (!avatarChildrenRef.value || !avatarNodeRef.value) {
        return;
      }
      const childrenWidth = avatarChildrenRef.value.offsetWidth;
      const nodeWidth = avatarNodeRef.value.offsetWidth;
      if (childrenWidth !== 0 && nodeWidth !== 0) {
        const {
          gap = 4
        } = props2;
        if (gap * 2 < nodeWidth) {
          scale.value = nodeWidth - gap * 2 < childrenWidth ? (nodeWidth - gap * 2) / childrenWidth : 1;
        }
      }
    };
    const handleImgLoadError = () => {
      const {
        loadError
      } = props2;
      const errorFlag = loadError === null || loadError === void 0 ? void 0 : loadError();
      if (errorFlag !== false) {
        isImgExist.value = false;
      }
    };
    watch(() => props2.src, () => {
      nextTick(() => {
        isImgExist.value = true;
        scale.value = 1;
      });
    });
    watch(() => props2.gap, () => {
      nextTick(() => {
        setScaleParam();
      });
    });
    onMounted(() => {
      nextTick(() => {
        setScaleParam();
        isMounted.value = true;
      });
    });
    return () => {
      var _a2, _b;
      const {
        shape,
        src,
        alt,
        srcset,
        draggable,
        crossOrigin
      } = props2;
      const mergeShape = (_a2 = avatarCtx.shape) !== null && _a2 !== void 0 ? _a2 : shape;
      const icon = getPropsSlot(slots, props2, "icon");
      const pre = prefixCls.value;
      const classString = {
        [`${attrs.class}`]: !!attrs.class,
        [pre]: true,
        [`${pre}-lg`]: size.value === "large",
        [`${pre}-sm`]: size.value === "small",
        [`${pre}-${mergeShape}`]: true,
        [`${pre}-image`]: src && isImgExist.value,
        [`${pre}-icon`]: icon,
        [hashId.value]: true
      };
      const sizeStyle = typeof size.value === "number" ? {
        width: `${size.value}px`,
        height: `${size.value}px`,
        lineHeight: `${size.value}px`,
        fontSize: icon ? `${size.value / 2}px` : "18px"
      } : {};
      const children = (_b = slots.default) === null || _b === void 0 ? void 0 : _b.call(slots);
      let childrenToRender;
      if (src && isImgExist.value) {
        childrenToRender = createVNode("img", {
          "draggable": draggable,
          "src": src,
          "srcset": srcset,
          "onError": handleImgLoadError,
          "alt": alt,
          "crossorigin": crossOrigin
        }, null);
      } else if (icon) {
        childrenToRender = icon;
      } else if (isMounted.value || scale.value !== 1) {
        const transformString = `scale(${scale.value}) translateX(-50%)`;
        const childrenStyle = {
          msTransform: transformString,
          WebkitTransform: transformString,
          transform: transformString
        };
        const sizeChildrenStyle = typeof size.value === "number" ? {
          lineHeight: `${size.value}px`
        } : {};
        childrenToRender = createVNode(ResizeObserver$1, {
          "onResize": setScaleParam
        }, {
          default: () => [createVNode("span", {
            "class": `${pre}-string`,
            "ref": avatarChildrenRef,
            "style": _extends$1(_extends$1({}, sizeChildrenStyle), childrenStyle)
          }, [children])]
        });
      } else {
        childrenToRender = createVNode("span", {
          "class": `${pre}-string`,
          "ref": avatarChildrenRef,
          "style": {
            opacity: 0
          }
        }, [children]);
      }
      return wrapSSR(createVNode("span", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "ref": avatarNodeRef,
        "class": classString,
        "style": [sizeStyle, responsiveSizeStyle(!!icon), attrs.style]
      }), [childrenToRender]));
    };
  }
});
const autoAdjustOverflow$2 = {
  adjustX: 1,
  adjustY: 1
};
const targetOffset$2 = [0, 0];
const placements$2 = {
  left: {
    points: ["cr", "cl"],
    overflow: autoAdjustOverflow$2,
    offset: [-4, 0],
    targetOffset: targetOffset$2
  },
  right: {
    points: ["cl", "cr"],
    overflow: autoAdjustOverflow$2,
    offset: [4, 0],
    targetOffset: targetOffset$2
  },
  top: {
    points: ["bc", "tc"],
    overflow: autoAdjustOverflow$2,
    offset: [0, -4],
    targetOffset: targetOffset$2
  },
  bottom: {
    points: ["tc", "bc"],
    overflow: autoAdjustOverflow$2,
    offset: [0, 4],
    targetOffset: targetOffset$2
  },
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflow$2,
    offset: [0, -4],
    targetOffset: targetOffset$2
  },
  leftTop: {
    points: ["tr", "tl"],
    overflow: autoAdjustOverflow$2,
    offset: [-4, 0],
    targetOffset: targetOffset$2
  },
  topRight: {
    points: ["br", "tr"],
    overflow: autoAdjustOverflow$2,
    offset: [0, -4],
    targetOffset: targetOffset$2
  },
  rightTop: {
    points: ["tl", "tr"],
    overflow: autoAdjustOverflow$2,
    offset: [4, 0],
    targetOffset: targetOffset$2
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: autoAdjustOverflow$2,
    offset: [0, 4],
    targetOffset: targetOffset$2
  },
  rightBottom: {
    points: ["bl", "br"],
    overflow: autoAdjustOverflow$2,
    offset: [4, 0],
    targetOffset: targetOffset$2
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflow$2,
    offset: [0, 4],
    targetOffset: targetOffset$2
  },
  leftBottom: {
    points: ["br", "bl"],
    overflow: autoAdjustOverflow$2,
    offset: [-4, 0],
    targetOffset: targetOffset$2
  }
};
const tooltipContentProps = {
  prefixCls: String,
  id: String,
  overlayInnerStyle: PropTypes.any
};
const Content$2 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "TooltipContent",
  props: tooltipContentProps,
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    return () => {
      var _a2;
      return createVNode("div", {
        "class": `${props2.prefixCls}-inner`,
        "id": props2.id,
        "role": "tooltip",
        "style": props2.overlayInnerStyle
      }, [(_a2 = slots.overlay) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]);
    };
  }
});
var __rest$Y = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
function noop$2() {
}
const Tooltip$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Tooltip",
  inheritAttrs: false,
  props: {
    trigger: PropTypes.any.def(["hover"]),
    defaultVisible: {
      type: Boolean,
      default: void 0
    },
    visible: {
      type: Boolean,
      default: void 0
    },
    placement: PropTypes.string.def("right"),
    transitionName: String,
    animation: PropTypes.any,
    afterVisibleChange: PropTypes.func.def(() => {
    }),
    overlayStyle: {
      type: Object,
      default: void 0
    },
    overlayClassName: String,
    prefixCls: PropTypes.string.def("rc-tooltip"),
    mouseEnterDelay: PropTypes.number.def(0.1),
    mouseLeaveDelay: PropTypes.number.def(0.1),
    getPopupContainer: Function,
    destroyTooltipOnHide: {
      type: Boolean,
      default: false
    },
    align: PropTypes.object.def(() => ({})),
    arrowContent: PropTypes.any.def(null),
    tipId: String,
    builtinPlacements: PropTypes.object,
    overlayInnerStyle: {
      type: Object,
      default: void 0
    },
    popupVisible: {
      type: Boolean,
      default: void 0
    },
    onVisibleChange: Function,
    onPopupAlign: Function,
    arrow: {
      type: Boolean,
      default: true
    }
  },
  setup(props2, _ref) {
    let {
      slots,
      attrs,
      expose
    } = _ref;
    const triggerDOM = shallowRef();
    const getPopupElement = () => {
      const {
        prefixCls,
        tipId,
        overlayInnerStyle
      } = props2;
      return [!!props2.arrow ? createVNode("div", {
        "class": `${prefixCls}-arrow`,
        "key": "arrow"
      }, [getPropsSlot(slots, props2, "arrowContent")]) : null, createVNode(Content$2, {
        "key": "content",
        "prefixCls": prefixCls,
        "id": tipId,
        "overlayInnerStyle": overlayInnerStyle
      }, {
        overlay: slots.overlay
      })];
    };
    const getPopupDomNode = () => {
      return triggerDOM.value.getPopupDomNode();
    };
    expose({
      getPopupDomNode,
      triggerDOM,
      forcePopupAlign: () => {
        var _a2;
        return (_a2 = triggerDOM.value) === null || _a2 === void 0 ? void 0 : _a2.forcePopupAlign();
      }
    });
    const destroyTooltip = shallowRef(false);
    const autoDestroy = shallowRef(false);
    watchEffect(() => {
      const {
        destroyTooltipOnHide
      } = props2;
      if (typeof destroyTooltipOnHide === "boolean") {
        destroyTooltip.value = destroyTooltipOnHide;
      } else if (destroyTooltipOnHide && typeof destroyTooltipOnHide === "object") {
        const {
          keepParent
        } = destroyTooltipOnHide;
        destroyTooltip.value = keepParent === true;
        autoDestroy.value = keepParent === false;
      }
    });
    return () => {
      const {
        overlayClassName,
        trigger,
        mouseEnterDelay,
        mouseLeaveDelay,
        overlayStyle,
        prefixCls,
        afterVisibleChange,
        transitionName: transitionName2,
        animation,
        placement,
        align,
        destroyTooltipOnHide,
        defaultVisible
      } = props2, restProps = __rest$Y(props2, ["overlayClassName", "trigger", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "prefixCls", "afterVisibleChange", "transitionName", "animation", "placement", "align", "destroyTooltipOnHide", "defaultVisible"]);
      const extraProps = _extends$1({}, restProps);
      if (props2.visible !== void 0) {
        extraProps.popupVisible = props2.visible;
      }
      const triggerProps2 = _extends$1(_extends$1(_extends$1({
        popupClassName: overlayClassName,
        prefixCls,
        action: trigger,
        builtinPlacements: placements$2,
        popupPlacement: placement,
        popupAlign: align,
        afterPopupVisibleChange: afterVisibleChange,
        popupTransitionName: transitionName2,
        popupAnimation: animation,
        defaultPopupVisible: defaultVisible,
        destroyPopupOnHide: destroyTooltip.value,
        autoDestroy: autoDestroy.value,
        mouseLeaveDelay,
        popupStyle: overlayStyle,
        mouseEnterDelay
      }, extraProps), attrs), {
        onPopupVisibleChange: props2.onVisibleChange || noop$2,
        onPopupAlign: props2.onPopupAlign || noop$2,
        ref: triggerDOM,
        arrow: !!props2.arrow,
        popup: getPopupElement()
      });
      return createVNode(Trigger, triggerProps2, {
        default: slots.default
      });
    };
  }
});
const abstractTooltipProps = () => ({
  trigger: [String, Array],
  open: {
    type: Boolean,
    default: void 0
  },
  /** @deprecated Please use `open` instead. */
  visible: {
    type: Boolean,
    default: void 0
  },
  placement: String,
  color: String,
  transitionName: String,
  overlayStyle: objectType(),
  overlayInnerStyle: objectType(),
  overlayClassName: String,
  openClassName: String,
  prefixCls: String,
  mouseEnterDelay: Number,
  mouseLeaveDelay: Number,
  getPopupContainer: Function,
  /**@deprecated Please use `arrow={{ pointAtCenter: true }}` instead. */
  arrowPointAtCenter: {
    type: Boolean,
    default: void 0
  },
  arrow: {
    type: [Boolean, Object],
    default: true
  },
  autoAdjustOverflow: {
    type: [Boolean, Object],
    default: void 0
  },
  destroyTooltipOnHide: {
    type: Boolean,
    default: void 0
  },
  align: objectType(),
  builtinPlacements: objectType(),
  children: Array,
  /** @deprecated Please use `onOpenChange` instead. */
  onVisibleChange: Function,
  /** @deprecated Please use `onUpdate:open` instead. */
  "onUpdate:visible": Function,
  onOpenChange: Function,
  "onUpdate:open": Function
});
const autoAdjustOverflowEnabled = {
  adjustX: 1,
  adjustY: 1
};
const autoAdjustOverflowDisabled = {
  adjustX: 0,
  adjustY: 0
};
const targetOffset$1 = [0, 0];
function getOverflowOptions(autoAdjustOverflow2) {
  if (typeof autoAdjustOverflow2 === "boolean") {
    return autoAdjustOverflow2 ? autoAdjustOverflowEnabled : autoAdjustOverflowDisabled;
  }
  return _extends$1(_extends$1({}, autoAdjustOverflowDisabled), autoAdjustOverflow2);
}
function getPlacements(config) {
  const {
    arrowWidth = 4,
    horizontalArrowShift = 16,
    verticalArrowShift = 8,
    autoAdjustOverflow: autoAdjustOverflow2,
    arrowPointAtCenter
  } = config;
  const placementMap = {
    left: {
      points: ["cr", "cl"],
      offset: [-4, 0]
    },
    right: {
      points: ["cl", "cr"],
      offset: [4, 0]
    },
    top: {
      points: ["bc", "tc"],
      offset: [0, -4]
    },
    bottom: {
      points: ["tc", "bc"],
      offset: [0, 4]
    },
    topLeft: {
      points: ["bl", "tc"],
      offset: [-(horizontalArrowShift + arrowWidth), -4]
    },
    leftTop: {
      points: ["tr", "cl"],
      offset: [-4, -(verticalArrowShift + arrowWidth)]
    },
    topRight: {
      points: ["br", "tc"],
      offset: [horizontalArrowShift + arrowWidth, -4]
    },
    rightTop: {
      points: ["tl", "cr"],
      offset: [4, -(verticalArrowShift + arrowWidth)]
    },
    bottomRight: {
      points: ["tr", "bc"],
      offset: [horizontalArrowShift + arrowWidth, 4]
    },
    rightBottom: {
      points: ["bl", "cr"],
      offset: [4, verticalArrowShift + arrowWidth]
    },
    bottomLeft: {
      points: ["tl", "bc"],
      offset: [-(horizontalArrowShift + arrowWidth), 4]
    },
    leftBottom: {
      points: ["br", "cl"],
      offset: [-4, verticalArrowShift + arrowWidth]
    }
  };
  Object.keys(placementMap).forEach((key2) => {
    placementMap[key2] = arrowPointAtCenter ? _extends$1(_extends$1({}, placementMap[key2]), {
      overflow: getOverflowOptions(autoAdjustOverflow2),
      targetOffset: targetOffset$1
    }) : _extends$1(_extends$1({}, placements$2[key2]), {
      overflow: getOverflowOptions(autoAdjustOverflow2)
    });
    placementMap[key2].ignoreShake = true;
  });
  return placementMap;
}
function firstNotUndefined() {
  let arr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  for (let i2 = 0, len = arr.length; i2 < len; i2++) {
    if (arr[i2] !== void 0) {
      return arr[i2];
    }
  }
  return void 0;
}
const inverseColors = PresetColors.map((color) => `${color}-inverse`);
const PresetStatusColorTypes = ["success", "processing", "error", "default", "warning"];
function isPresetColor(color) {
  let includeInverse = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  if (includeInverse) {
    return [...inverseColors, ...PresetColors].includes(color);
  }
  return PresetColors.includes(color);
}
function isPresetStatusColor(color) {
  return PresetStatusColorTypes.includes(color);
}
function parseColor(prefixCls, color) {
  const isInternalColor = isPresetColor(color);
  const className = classNames({
    [`${prefixCls}-${color}`]: color && isInternalColor
  });
  const overlayStyle = {};
  const arrowStyle = {};
  if (color && !isInternalColor) {
    overlayStyle.background = color;
    arrowStyle["--antd-arrow-background-color"] = color;
  }
  return {
    className,
    overlayStyle,
    arrowStyle
  };
}
function connectArrowCls(classList) {
  let showArrowCls = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  return classList.map((cls) => `${showArrowCls}${cls}`).join(",");
}
const MAX_VERTICAL_CONTENT_RADIUS = 8;
function getArrowOffset(options) {
  const maxVerticalContentRadius = MAX_VERTICAL_CONTENT_RADIUS;
  const {
    sizePopupArrow,
    contentRadius,
    borderRadiusOuter,
    limitVerticalRadius
  } = options;
  const arrowInnerOffset = sizePopupArrow / 2 - Math.ceil(borderRadiusOuter * (Math.sqrt(2) - 1));
  const dropdownArrowOffset = (contentRadius > 12 ? contentRadius + 2 : 12) - arrowInnerOffset;
  const dropdownArrowOffsetVertical = limitVerticalRadius ? maxVerticalContentRadius - arrowInnerOffset : dropdownArrowOffset;
  return {
    dropdownArrowOffset,
    dropdownArrowOffsetVertical
  };
}
function getArrowStyle(token2, options) {
  const {
    componentCls,
    sizePopupArrow,
    marginXXS,
    borderRadiusXS,
    borderRadiusOuter,
    boxShadowPopoverArrow
  } = token2;
  const {
    colorBg,
    showArrowCls,
    contentRadius = token2.borderRadiusLG,
    limitVerticalRadius
  } = options;
  const {
    dropdownArrowOffsetVertical,
    dropdownArrowOffset
  } = getArrowOffset({
    sizePopupArrow,
    contentRadius,
    borderRadiusOuter,
    limitVerticalRadius
  });
  const dropdownArrowDistance = sizePopupArrow / 2 + marginXXS;
  return {
    [componentCls]: {
      // ============================ Basic ============================
      [`${componentCls}-arrow`]: [_extends$1(_extends$1({
        position: "absolute",
        zIndex: 1,
        display: "block"
      }, roundedArrow(sizePopupArrow, borderRadiusXS, borderRadiusOuter, colorBg, boxShadowPopoverArrow)), {
        "&:before": {
          background: colorBg
        }
      })],
      // ========================== Placement ==========================
      // Here handle the arrow position and rotate stuff
      // >>>>> Top
      [[`&-placement-top ${componentCls}-arrow`, `&-placement-topLeft ${componentCls}-arrow`, `&-placement-topRight ${componentCls}-arrow`].join(",")]: {
        bottom: 0,
        transform: "translateY(100%) rotate(180deg)"
      },
      [`&-placement-top ${componentCls}-arrow`]: {
        left: {
          _skip_check_: true,
          value: "50%"
        },
        transform: "translateX(-50%) translateY(100%) rotate(180deg)"
      },
      [`&-placement-topLeft ${componentCls}-arrow`]: {
        left: {
          _skip_check_: true,
          value: dropdownArrowOffset
        }
      },
      [`&-placement-topRight ${componentCls}-arrow`]: {
        right: {
          _skip_check_: true,
          value: dropdownArrowOffset
        }
      },
      // >>>>> Bottom
      [[`&-placement-bottom ${componentCls}-arrow`, `&-placement-bottomLeft ${componentCls}-arrow`, `&-placement-bottomRight ${componentCls}-arrow`].join(",")]: {
        top: 0,
        transform: `translateY(-100%)`
      },
      [`&-placement-bottom ${componentCls}-arrow`]: {
        left: {
          _skip_check_: true,
          value: "50%"
        },
        transform: `translateX(-50%) translateY(-100%)`
      },
      [`&-placement-bottomLeft ${componentCls}-arrow`]: {
        left: {
          _skip_check_: true,
          value: dropdownArrowOffset
        }
      },
      [`&-placement-bottomRight ${componentCls}-arrow`]: {
        right: {
          _skip_check_: true,
          value: dropdownArrowOffset
        }
      },
      // >>>>> Left
      [[`&-placement-left ${componentCls}-arrow`, `&-placement-leftTop ${componentCls}-arrow`, `&-placement-leftBottom ${componentCls}-arrow`].join(",")]: {
        right: {
          _skip_check_: true,
          value: 0
        },
        transform: "translateX(100%) rotate(90deg)"
      },
      [`&-placement-left ${componentCls}-arrow`]: {
        top: {
          _skip_check_: true,
          value: "50%"
        },
        transform: "translateY(-50%) translateX(100%) rotate(90deg)"
      },
      [`&-placement-leftTop ${componentCls}-arrow`]: {
        top: dropdownArrowOffsetVertical
      },
      [`&-placement-leftBottom ${componentCls}-arrow`]: {
        bottom: dropdownArrowOffsetVertical
      },
      // >>>>> Right
      [[`&-placement-right ${componentCls}-arrow`, `&-placement-rightTop ${componentCls}-arrow`, `&-placement-rightBottom ${componentCls}-arrow`].join(",")]: {
        left: {
          _skip_check_: true,
          value: 0
        },
        transform: "translateX(-100%) rotate(-90deg)"
      },
      [`&-placement-right ${componentCls}-arrow`]: {
        top: {
          _skip_check_: true,
          value: "50%"
        },
        transform: "translateY(-50%) translateX(-100%) rotate(-90deg)"
      },
      [`&-placement-rightTop ${componentCls}-arrow`]: {
        top: dropdownArrowOffsetVertical
      },
      [`&-placement-rightBottom ${componentCls}-arrow`]: {
        bottom: dropdownArrowOffsetVertical
      },
      // =========================== Offset ============================
      // Offset the popover to account for the dropdown arrow
      // >>>>> Top
      [connectArrowCls([`&-placement-topLeft`, `&-placement-top`, `&-placement-topRight`].map((cls) => cls += ":not(&-arrow-hidden)"), showArrowCls)]: {
        paddingBottom: dropdownArrowDistance
      },
      // >>>>> Bottom
      [connectArrowCls([`&-placement-bottomLeft`, `&-placement-bottom`, `&-placement-bottomRight`].map((cls) => cls += ":not(&-arrow-hidden)"), showArrowCls)]: {
        paddingTop: dropdownArrowDistance
      },
      // >>>>> Left
      [connectArrowCls([`&-placement-leftTop`, `&-placement-left`, `&-placement-leftBottom`].map((cls) => cls += ":not(&-arrow-hidden)"), showArrowCls)]: {
        paddingRight: {
          _skip_check_: true,
          value: dropdownArrowDistance
        }
      },
      // >>>>> Right
      [connectArrowCls([`&-placement-rightTop`, `&-placement-right`, `&-placement-rightBottom`].map((cls) => cls += ":not(&-arrow-hidden)"), showArrowCls)]: {
        paddingLeft: {
          _skip_check_: true,
          value: dropdownArrowDistance
        }
      }
    }
  };
}
const genTooltipStyle = (token2) => {
  const {
    componentCls,
    // ant-tooltip
    tooltipMaxWidth,
    tooltipColor,
    tooltipBg,
    tooltipBorderRadius,
    zIndexPopup,
    controlHeight,
    boxShadowSecondary,
    paddingSM,
    paddingXS,
    tooltipRadiusOuter
  } = token2;
  return [
    {
      [componentCls]: _extends$1(_extends$1(_extends$1(_extends$1({}, resetComponent(token2)), {
        position: "absolute",
        zIndex: zIndexPopup,
        display: "block",
        "&": [{
          width: "max-content"
        }, {
          width: "intrinsic"
        }],
        maxWidth: tooltipMaxWidth,
        visibility: "visible",
        "&-hidden": {
          display: "none"
        },
        "--antd-arrow-background-color": tooltipBg,
        // Wrapper for the tooltip content
        [`${componentCls}-inner`]: {
          minWidth: controlHeight,
          minHeight: controlHeight,
          padding: `${paddingSM / 2}px ${paddingXS}px`,
          color: tooltipColor,
          textAlign: "start",
          textDecoration: "none",
          wordWrap: "break-word",
          backgroundColor: tooltipBg,
          borderRadius: tooltipBorderRadius,
          boxShadow: boxShadowSecondary
        },
        // Limit left and right placement radius
        [[`&-placement-left`, `&-placement-leftTop`, `&-placement-leftBottom`, `&-placement-right`, `&-placement-rightTop`, `&-placement-rightBottom`].join(",")]: {
          [`${componentCls}-inner`]: {
            borderRadius: Math.min(tooltipBorderRadius, MAX_VERTICAL_CONTENT_RADIUS)
          }
        },
        [`${componentCls}-content`]: {
          position: "relative"
        }
      }), genPresetColor(token2, (colorKey, _ref) => {
        let {
          darkColor
        } = _ref;
        return {
          [`&${componentCls}-${colorKey}`]: {
            [`${componentCls}-inner`]: {
              backgroundColor: darkColor
            },
            [`${componentCls}-arrow`]: {
              "--antd-arrow-background-color": darkColor
            }
          }
        };
      })), {
        // RTL
        "&-rtl": {
          direction: "rtl"
        }
      })
    },
    // Arrow Style
    getArrowStyle(merge(token2, {
      borderRadiusOuter: tooltipRadiusOuter
    }), {
      colorBg: "var(--antd-arrow-background-color)",
      showArrowCls: "",
      contentRadius: tooltipBorderRadius,
      limitVerticalRadius: true
    }),
    // Pure Render
    {
      [`${componentCls}-pure`]: {
        position: "relative",
        maxWidth: "none"
      }
    }
  ];
};
const useStyle$F = (prefixCls, injectStyle) => {
  const useOriginHook = genComponentStyleHook("Tooltip", (token2) => {
    if ((injectStyle === null || injectStyle === void 0 ? void 0 : injectStyle.value) === false) {
      return [];
    }
    const {
      borderRadius,
      colorTextLightSolid,
      colorBgDefault,
      borderRadiusOuter
    } = token2;
    const TooltipToken = merge(token2, {
      // default variables
      tooltipMaxWidth: 250,
      tooltipColor: colorTextLightSolid,
      tooltipBorderRadius: borderRadius,
      tooltipBg: colorBgDefault,
      tooltipRadiusOuter: borderRadiusOuter > 4 ? 4 : borderRadiusOuter
    });
    return [genTooltipStyle(TooltipToken), initZoomMotion(token2, "zoom-big-fast")];
  }, (_ref2) => {
    let {
      zIndexPopupBase,
      colorBgSpotlight
    } = _ref2;
    return {
      zIndexPopup: zIndexPopupBase + 70,
      colorBgDefault: colorBgSpotlight
    };
  });
  return useOriginHook(prefixCls);
};
const splitObject = (obj, keys2) => {
  const picked = {};
  const omitted = _extends$1({}, obj);
  keys2.forEach((key2) => {
    if (obj && key2 in obj) {
      picked[key2] = obj[key2];
      delete omitted[key2];
    }
  });
  return {
    picked,
    omitted
  };
};
const tooltipProps = () => _extends$1(_extends$1({}, abstractTooltipProps()), {
  title: PropTypes.any
});
const tooltipDefaultProps = () => ({
  trigger: "hover",
  align: {},
  placement: "top",
  mouseEnterDelay: 0.1,
  mouseLeaveDelay: 0.1,
  arrowPointAtCenter: false,
  autoAdjustOverflow: true
});
const ToolTip = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ATooltip",
  inheritAttrs: false,
  props: initDefaultProps(tooltipProps(), {
    trigger: "hover",
    align: {},
    placement: "top",
    mouseEnterDelay: 0.1,
    mouseLeaveDelay: 0.1,
    arrowPointAtCenter: false,
    autoAdjustOverflow: true
  }),
  slots: Object,
  // emits: ['update:visible', 'visibleChange'],
  setup(props2, _ref) {
    let {
      slots,
      emit,
      attrs,
      expose
    } = _ref;
    const {
      prefixCls,
      getPopupContainer,
      direction,
      rootPrefixCls
    } = useConfigInject("tooltip", props2);
    const mergedOpen = computed(() => {
      var _a2;
      return (_a2 = props2.open) !== null && _a2 !== void 0 ? _a2 : props2.visible;
    });
    const innerOpen = ref(firstNotUndefined([props2.open, props2.visible]));
    const tooltip = ref();
    let rafId;
    watch(mergedOpen, (val) => {
      wrapperRaf.cancel(rafId);
      rafId = wrapperRaf(() => {
        innerOpen.value = !!val;
      });
    });
    const isNoTitle = () => {
      var _a2;
      const title = (_a2 = props2.title) !== null && _a2 !== void 0 ? _a2 : slots.title;
      return !title && title !== 0;
    };
    const handleVisibleChange = (val) => {
      const noTitle = isNoTitle();
      if (mergedOpen.value === void 0) {
        innerOpen.value = noTitle ? false : val;
      }
      if (!noTitle) {
        emit("update:visible", val);
        emit("visibleChange", val);
        emit("update:open", val);
        emit("openChange", val);
      }
    };
    const getPopupDomNode = () => {
      return tooltip.value.getPopupDomNode();
    };
    expose({
      getPopupDomNode,
      open: innerOpen,
      forcePopupAlign: () => {
        var _a2;
        return (_a2 = tooltip.value) === null || _a2 === void 0 ? void 0 : _a2.forcePopupAlign();
      }
    });
    const tooltipPlacements = computed(() => {
      var _a2;
      const {
        builtinPlacements,
        autoAdjustOverflow: autoAdjustOverflow2,
        arrow,
        arrowPointAtCenter
      } = props2;
      let mergedArrowPointAtCenter = arrowPointAtCenter;
      if (typeof arrow === "object") {
        mergedArrowPointAtCenter = (_a2 = arrow.pointAtCenter) !== null && _a2 !== void 0 ? _a2 : arrowPointAtCenter;
      }
      return builtinPlacements || getPlacements({
        arrowPointAtCenter: mergedArrowPointAtCenter,
        autoAdjustOverflow: autoAdjustOverflow2
      });
    });
    const isTrueProps = (val) => {
      return val || val === "";
    };
    const getDisabledCompatibleChildren = (ele) => {
      const elementType = ele.type;
      if (typeof elementType === "object" && ele.props) {
        if ((elementType.__ANT_BUTTON === true || elementType === "button") && isTrueProps(ele.props.disabled) || elementType.__ANT_SWITCH === true && (isTrueProps(ele.props.disabled) || isTrueProps(ele.props.loading)) || elementType.__ANT_RADIO === true && isTrueProps(ele.props.disabled)) {
          const {
            picked,
            omitted
          } = splitObject(getStyle$3(ele), ["position", "left", "right", "top", "bottom", "float", "display", "zIndex"]);
          const spanStyle = _extends$1(_extends$1({
            display: "inline-block"
          }, picked), {
            cursor: "not-allowed",
            lineHeight: 1,
            width: ele.props && ele.props.block ? "100%" : void 0
          });
          const buttonStyle = _extends$1(_extends$1({}, omitted), {
            pointerEvents: "none"
          });
          const child = cloneElement(ele, {
            style: buttonStyle
          }, true);
          return createVNode("span", {
            "style": spanStyle,
            "class": `${prefixCls.value}-disabled-compatible-wrapper`
          }, [child]);
        }
      }
      return ele;
    };
    const getOverlay = () => {
      var _a2, _b;
      return (_a2 = props2.title) !== null && _a2 !== void 0 ? _a2 : (_b = slots.title) === null || _b === void 0 ? void 0 : _b.call(slots);
    };
    const onPopupAlign = (domNode, align) => {
      const placements2 = tooltipPlacements.value;
      const placement = Object.keys(placements2).find((key2) => {
        var _a2, _b;
        return placements2[key2].points[0] === ((_a2 = align.points) === null || _a2 === void 0 ? void 0 : _a2[0]) && placements2[key2].points[1] === ((_b = align.points) === null || _b === void 0 ? void 0 : _b[1]);
      });
      if (placement) {
        const rect = domNode.getBoundingClientRect();
        const transformOrigin = {
          top: "50%",
          left: "50%"
        };
        if (placement.indexOf("top") >= 0 || placement.indexOf("Bottom") >= 0) {
          transformOrigin.top = `${rect.height - align.offset[1]}px`;
        } else if (placement.indexOf("Top") >= 0 || placement.indexOf("bottom") >= 0) {
          transformOrigin.top = `${-align.offset[1]}px`;
        }
        if (placement.indexOf("left") >= 0 || placement.indexOf("Right") >= 0) {
          transformOrigin.left = `${rect.width - align.offset[0]}px`;
        } else if (placement.indexOf("right") >= 0 || placement.indexOf("Left") >= 0) {
          transformOrigin.left = `${-align.offset[0]}px`;
        }
        domNode.style.transformOrigin = `${transformOrigin.left} ${transformOrigin.top}`;
      }
    };
    const colorInfo = computed(() => parseColor(prefixCls.value, props2.color));
    const injectFromPopover = computed(() => attrs["data-popover-inject"]);
    const [wrapSSR, hashId] = useStyle$F(prefixCls, computed(() => !injectFromPopover.value));
    return () => {
      var _a2, _b;
      const {
        openClassName,
        overlayClassName,
        overlayStyle,
        overlayInnerStyle
      } = props2;
      let children = (_b = filterEmpty((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots))) !== null && _b !== void 0 ? _b : null;
      children = children.length === 1 ? children[0] : children;
      let tempVisible = innerOpen.value;
      if (mergedOpen.value === void 0 && isNoTitle()) {
        tempVisible = false;
      }
      if (!children) {
        return null;
      }
      const child = getDisabledCompatibleChildren(isValidElement(children) && !isFragment(children) ? children : createVNode("span", null, [children]));
      const childCls = classNames({
        [openClassName || `${prefixCls.value}-open`]: true,
        [child.props && child.props.class]: child.props && child.props.class
      });
      const customOverlayClassName = classNames(overlayClassName, {
        [`${prefixCls.value}-rtl`]: direction.value === "rtl"
      }, colorInfo.value.className, hashId.value);
      const formattedOverlayInnerStyle = _extends$1(_extends$1({}, colorInfo.value.overlayStyle), overlayInnerStyle);
      const arrowContentStyle = colorInfo.value.arrowStyle;
      const vcTooltipProps = _extends$1(_extends$1(_extends$1({}, attrs), props2), {
        prefixCls: prefixCls.value,
        arrow: !!props2.arrow,
        getPopupContainer: getPopupContainer === null || getPopupContainer === void 0 ? void 0 : getPopupContainer.value,
        builtinPlacements: tooltipPlacements.value,
        visible: tempVisible,
        ref: tooltip,
        overlayClassName: customOverlayClassName,
        overlayStyle: _extends$1(_extends$1({}, arrowContentStyle), overlayStyle),
        overlayInnerStyle: formattedOverlayInnerStyle,
        onVisibleChange: handleVisibleChange,
        onPopupAlign,
        transitionName: getTransitionName(rootPrefixCls.value, "zoom-big-fast", props2.transitionName)
      });
      return wrapSSR(createVNode(Tooltip$1, vcTooltipProps, {
        default: () => [innerOpen.value ? cloneElement(child, {
          class: childCls
        }) : child],
        arrowContent: () => createVNode("span", {
          "class": `${prefixCls.value}-arrow-content`
        }, null),
        overlay: getOverlay
      }));
    };
  }
});
const Tooltip = withInstall(ToolTip);
const genBaseStyle$c = (token2) => {
  const {
    componentCls,
    popoverBg,
    popoverColor,
    width,
    fontWeightStrong,
    popoverPadding,
    boxShadowSecondary,
    colorTextHeading,
    borderRadiusLG: borderRadius,
    zIndexPopup,
    marginXS,
    colorBgElevated
  } = token2;
  return [
    {
      [componentCls]: _extends$1(_extends$1({}, resetComponent(token2)), {
        position: "absolute",
        top: 0,
        // use `left` to fix https://github.com/ant-design/ant-design/issues/39195
        left: {
          _skip_check_: true,
          value: 0
        },
        zIndex: zIndexPopup,
        fontWeight: "normal",
        whiteSpace: "normal",
        textAlign: "start",
        cursor: "auto",
        userSelect: "text",
        "--antd-arrow-background-color": colorBgElevated,
        "&-rtl": {
          direction: "rtl"
        },
        "&-hidden": {
          display: "none"
        },
        [`${componentCls}-content`]: {
          position: "relative"
        },
        [`${componentCls}-inner`]: {
          backgroundColor: popoverBg,
          backgroundClip: "padding-box",
          borderRadius,
          boxShadow: boxShadowSecondary,
          padding: popoverPadding
        },
        [`${componentCls}-title`]: {
          minWidth: width,
          marginBottom: marginXS,
          color: colorTextHeading,
          fontWeight: fontWeightStrong
        },
        [`${componentCls}-inner-content`]: {
          color: popoverColor
        }
      })
    },
    // Arrow Style
    getArrowStyle(token2, {
      colorBg: "var(--antd-arrow-background-color)"
    }),
    // Pure Render
    {
      [`${componentCls}-pure`]: {
        position: "relative",
        maxWidth: "none",
        [`${componentCls}-content`]: {
          display: "inline-block"
        }
      }
    }
  ];
};
const genColorStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [componentCls]: PresetColors.map((colorKey) => {
      const lightColor = token2[`${colorKey}-6`];
      return {
        [`&${componentCls}-${colorKey}`]: {
          "--antd-arrow-background-color": lightColor,
          [`${componentCls}-inner`]: {
            backgroundColor: lightColor
          },
          [`${componentCls}-arrow`]: {
            background: "transparent"
          }
        }
      };
    })
  };
};
const genWireframeStyle$1 = (token2) => {
  const {
    componentCls,
    lineWidth,
    lineType,
    colorSplit,
    paddingSM,
    controlHeight,
    fontSize,
    lineHeight,
    padding
  } = token2;
  const titlePaddingBlockDist = controlHeight - Math.round(fontSize * lineHeight);
  const popoverTitlePaddingBlockTop = titlePaddingBlockDist / 2;
  const popoverTitlePaddingBlockBottom = titlePaddingBlockDist / 2 - lineWidth;
  const popoverPaddingHorizontal = padding;
  return {
    [componentCls]: {
      [`${componentCls}-inner`]: {
        padding: 0
      },
      [`${componentCls}-title`]: {
        margin: 0,
        padding: `${popoverTitlePaddingBlockTop}px ${popoverPaddingHorizontal}px ${popoverTitlePaddingBlockBottom}px`,
        borderBottom: `${lineWidth}px ${lineType} ${colorSplit}`
      },
      [`${componentCls}-inner-content`]: {
        padding: `${paddingSM}px ${popoverPaddingHorizontal}px`
      }
    }
  };
};
const useStyle$E = genComponentStyleHook("Popover", (token2) => {
  const {
    colorBgElevated,
    colorText,
    wireframe
  } = token2;
  const popoverToken = merge(token2, {
    popoverBg: colorBgElevated,
    popoverColor: colorText,
    popoverPadding: 12
    // Fixed Value
  });
  return [genBaseStyle$c(popoverToken), genColorStyle(popoverToken), wireframe && genWireframeStyle$1(popoverToken), initZoomMotion(popoverToken, "zoom-big")];
}, (_ref) => {
  let {
    zIndexPopupBase
  } = _ref;
  return {
    zIndexPopup: zIndexPopupBase + 30,
    width: 177
  };
});
const popoverProps = () => _extends$1(_extends$1({}, abstractTooltipProps()), {
  content: anyType(),
  title: anyType()
});
const Popover = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "APopover",
  inheritAttrs: false,
  props: initDefaultProps(popoverProps(), _extends$1(_extends$1({}, tooltipDefaultProps()), {
    trigger: "hover",
    placement: "top",
    mouseEnterDelay: 0.1,
    mouseLeaveDelay: 0.1
  })),
  setup(props2, _ref) {
    let {
      expose,
      slots,
      attrs
    } = _ref;
    const tooltipRef = ref();
    warning$1(props2.visible === void 0);
    expose({
      getPopupDomNode: () => {
        var _a2, _b;
        return (_b = (_a2 = tooltipRef.value) === null || _a2 === void 0 ? void 0 : _a2.getPopupDomNode) === null || _b === void 0 ? void 0 : _b.call(_a2);
      }
    });
    const {
      prefixCls,
      configProvider
    } = useConfigInject("popover", props2);
    const [wrapSSR, hashId] = useStyle$E(prefixCls);
    const rootPrefixCls = computed(() => configProvider.getPrefixCls());
    const getOverlay = () => {
      var _a2, _b;
      const {
        title = filterEmpty((_a2 = slots.title) === null || _a2 === void 0 ? void 0 : _a2.call(slots)),
        content = filterEmpty((_b = slots.content) === null || _b === void 0 ? void 0 : _b.call(slots))
      } = props2;
      const hasTitle = !!(Array.isArray(title) ? title.length : title);
      const hasContent = !!(Array.isArray(content) ? content.length : title);
      if (!hasTitle && !hasContent) return null;
      return createVNode(Fragment, null, [hasTitle && createVNode("div", {
        "class": `${prefixCls.value}-title`
      }, [title]), createVNode("div", {
        "class": `${prefixCls.value}-inner-content`
      }, [content])]);
    };
    return () => {
      const overlayCls = classNames(props2.overlayClassName, hashId.value);
      return wrapSSR(createVNode(Tooltip, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, omit$1(props2, ["title", "content"])), attrs), {}, {
        "prefixCls": prefixCls.value,
        "ref": tooltipRef,
        "overlayClassName": overlayCls,
        "transitionName": getTransitionName(rootPrefixCls.value, "zoom-big", props2.transitionName),
        "data-popover-inject": true
      }), {
        title: getOverlay,
        default: slots.default
      }));
    };
  }
});
const Popover$1 = withInstall(Popover);
const groupProps = () => ({
  prefixCls: String,
  maxCount: Number,
  maxStyle: {
    type: Object,
    default: void 0
  },
  maxPopoverPlacement: {
    type: String,
    default: "top"
  },
  maxPopoverTrigger: String,
  /*
   * Size of avatar, options: `large`, `small`, `default`
   * or a custom number size
   * */
  size: {
    type: [Number, String, Object],
    default: "default"
  },
  shape: {
    type: String,
    default: "circle"
  }
});
const Group$3 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AAvatarGroup",
  inheritAttrs: false,
  props: groupProps(),
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const {
      prefixCls,
      direction
    } = useConfigInject("avatar", props2);
    const groupPrefixCls = computed(() => `${prefixCls.value}-group`);
    const [wrapSSR, hashId] = useStyle$G(prefixCls);
    watchEffect(() => {
      const context2 = {
        size: props2.size,
        shape: props2.shape
      };
      useAvatarProviderContext(context2);
    });
    return () => {
      const {
        maxPopoverPlacement = "top",
        maxCount: maxCount2,
        maxStyle,
        maxPopoverTrigger = "hover",
        shape
      } = props2;
      const cls = {
        [groupPrefixCls.value]: true,
        [`${groupPrefixCls.value}-rtl`]: direction.value === "rtl",
        [`${attrs.class}`]: !!attrs.class,
        [hashId.value]: true
      };
      const children = getPropsSlot(slots, props2);
      const childrenWithProps = flattenChildren(children).map((child, index2) => cloneElement(child, {
        key: `avatar-key-${index2}`
      }));
      const numOfChildren = childrenWithProps.length;
      if (maxCount2 && maxCount2 < numOfChildren) {
        const childrenShow = childrenWithProps.slice(0, maxCount2);
        const childrenHidden = childrenWithProps.slice(maxCount2, numOfChildren);
        childrenShow.push(createVNode(Popover$1, {
          "key": "avatar-popover-key",
          "content": childrenHidden,
          "trigger": maxPopoverTrigger,
          "placement": maxPopoverPlacement,
          "overlayClassName": `${groupPrefixCls.value}-popover`
        }, {
          default: () => [createVNode(Avatar, {
            "style": maxStyle,
            "shape": shape
          }, {
            default: () => [`+${numOfChildren - maxCount2}`]
          })]
        }));
        return wrapSSR(createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
          "class": cls,
          "style": attrs.style
        }), [childrenShow]));
      }
      return wrapSSR(createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "class": cls,
        "style": attrs.style
      }), [childrenWithProps]));
    };
  }
});
Avatar.Group = Group$3;
Avatar.install = function(app) {
  app.component(Avatar.name, Avatar);
  app.component(Group$3.name, Group$3);
  return app;
};
function UnitNumber(_ref) {
  let {
    prefixCls,
    value,
    current,
    offset: offset3 = 0
  } = _ref;
  let style;
  if (offset3) {
    style = {
      position: "absolute",
      top: `${offset3}00%`,
      left: 0
    };
  }
  return createVNode("p", {
    "style": style,
    "class": classNames(`${prefixCls}-only-unit`, {
      current
    })
  }, [value]);
}
function getOffset(start, end, unit) {
  let index2 = start;
  let offset3 = 0;
  while ((index2 + 10) % 10 !== end) {
    index2 += unit;
    offset3 += unit;
  }
  return offset3;
}
const SingleNumber = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "SingleNumber",
  props: {
    prefixCls: String,
    value: String,
    count: Number
  },
  setup(props2) {
    const originValue = computed(() => Number(props2.value));
    const originCount = computed(() => Math.abs(props2.count));
    const state = reactive({
      prevValue: originValue.value,
      prevCount: originCount.value
    });
    const onTransitionEnd = () => {
      state.prevValue = originValue.value;
      state.prevCount = originCount.value;
    };
    const timeout = ref();
    watch(originValue, () => {
      clearTimeout(timeout.value);
      timeout.value = setTimeout(() => {
        onTransitionEnd();
      }, 1e3);
    }, {
      flush: "post"
    });
    onUnmounted(() => {
      clearTimeout(timeout.value);
    });
    return () => {
      let unitNodes;
      let offsetStyle = {};
      const value = originValue.value;
      if (state.prevValue === value || Number.isNaN(value) || Number.isNaN(state.prevValue)) {
        unitNodes = [UnitNumber(_extends$1(_extends$1({}, props2), {
          current: true
        }))];
        offsetStyle = {
          transition: "none"
        };
      } else {
        unitNodes = [];
        const end = value + 10;
        const unitNumberList = [];
        for (let index2 = value; index2 <= end; index2 += 1) {
          unitNumberList.push(index2);
        }
        const prevIndex = unitNumberList.findIndex((n2) => n2 % 10 === state.prevValue);
        unitNodes = unitNumberList.map((n2, index2) => {
          const singleUnit = n2 % 10;
          return UnitNumber(_extends$1(_extends$1({}, props2), {
            value: singleUnit,
            offset: index2 - prevIndex,
            current: index2 === prevIndex
          }));
        });
        const unit = state.prevCount < originCount.value ? 1 : -1;
        offsetStyle = {
          transform: `translateY(${-getOffset(state.prevValue, value, unit)}00%)`
        };
      }
      return createVNode("span", {
        "class": `${props2.prefixCls}-only`,
        "style": offsetStyle,
        "onTransitionend": () => onTransitionEnd()
      }, [unitNodes]);
    };
  }
});
var __rest$X = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const scrollNumberProps = {
  prefixCls: String,
  count: PropTypes.any,
  component: String,
  title: PropTypes.any,
  show: Boolean
};
const ScrollNumber = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ScrollNumber",
  inheritAttrs: false,
  props: scrollNumberProps,
  setup(props2, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const {
      prefixCls
    } = useConfigInject("scroll-number", props2);
    return () => {
      var _a2;
      const _b = _extends$1(_extends$1({}, props2), attrs), {
        prefixCls: customizePrefixCls,
        count,
        title,
        show,
        component: Tag2 = "sup",
        class: className,
        style
      } = _b, restProps = __rest$X(_b, ["prefixCls", "count", "title", "show", "component", "class", "style"]);
      const newProps = _extends$1(_extends$1({}, restProps), {
        style,
        "data-show": props2.show,
        class: classNames(prefixCls.value, className),
        title
      });
      let numberNodes = count;
      if (count && Number(count) % 1 === 0) {
        const numberList = String(count).split("");
        numberNodes = numberList.map((num, i2) => createVNode(SingleNumber, {
          "prefixCls": prefixCls.value,
          "count": Number(count),
          "value": num,
          "key": numberList.length - i2
        }, null));
      }
      if (style && style.borderColor) {
        newProps.style = _extends$1(_extends$1({}, style), {
          boxShadow: `0 0 0 1px ${style.borderColor} inset`
        });
      }
      const children = filterEmpty((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots));
      if (children.length) {
        return cloneElement(children, {
          class: classNames(`${prefixCls.value}-custom-component`)
        }, false);
      }
      return createVNode(Tag2, newProps, {
        default: () => [numberNodes]
      });
    };
  }
});
const antStatusProcessing = new Keyframe("antStatusProcessing", {
  "0%": {
    transform: "scale(0.8)",
    opacity: 0.5
  },
  "100%": {
    transform: "scale(2.4)",
    opacity: 0
  }
});
const antZoomBadgeIn = new Keyframe("antZoomBadgeIn", {
  "0%": {
    transform: "scale(0) translate(50%, -50%)",
    opacity: 0
  },
  "100%": {
    transform: "scale(1) translate(50%, -50%)"
  }
});
const antZoomBadgeOut = new Keyframe("antZoomBadgeOut", {
  "0%": {
    transform: "scale(1) translate(50%, -50%)"
  },
  "100%": {
    transform: "scale(0) translate(50%, -50%)",
    opacity: 0
  }
});
const antNoWrapperZoomBadgeIn = new Keyframe("antNoWrapperZoomBadgeIn", {
  "0%": {
    transform: "scale(0)",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)"
  }
});
const antNoWrapperZoomBadgeOut = new Keyframe("antNoWrapperZoomBadgeOut", {
  "0%": {
    transform: "scale(1)"
  },
  "100%": {
    transform: "scale(0)",
    opacity: 0
  }
});
const antBadgeLoadingCircle = new Keyframe("antBadgeLoadingCircle", {
  "0%": {
    transformOrigin: "50%"
  },
  "100%": {
    transform: "translate(50%, -50%) rotate(360deg)",
    transformOrigin: "50%"
  }
});
const genSharedBadgeStyle = (token2) => {
  const {
    componentCls,
    iconCls,
    antCls,
    badgeFontHeight,
    badgeShadowSize,
    badgeHeightSm,
    motionDurationSlow,
    badgeStatusSize,
    marginXS,
    badgeRibbonOffset
  } = token2;
  const numberPrefixCls = `${antCls}-scroll-number`;
  const ribbonPrefixCls = `${antCls}-ribbon`;
  const ribbonWrapperPrefixCls = `${antCls}-ribbon-wrapper`;
  const colorPreset = genPresetColor(token2, (colorKey, _ref) => {
    let {
      darkColor
    } = _ref;
    return {
      [`&${componentCls} ${componentCls}-color-${colorKey}`]: {
        background: darkColor,
        [`&:not(${componentCls}-count)`]: {
          color: darkColor
        }
      }
    };
  });
  const statusRibbonPreset = genPresetColor(token2, (colorKey, _ref2) => {
    let {
      darkColor
    } = _ref2;
    return {
      [`&${ribbonPrefixCls}-color-${colorKey}`]: {
        background: darkColor,
        color: darkColor
      }
    };
  });
  return {
    [componentCls]: _extends$1(_extends$1(_extends$1(_extends$1({}, resetComponent(token2)), {
      position: "relative",
      display: "inline-block",
      width: "fit-content",
      lineHeight: 1,
      [`${componentCls}-count`]: {
        zIndex: token2.badgeZIndex,
        minWidth: token2.badgeHeight,
        height: token2.badgeHeight,
        color: token2.badgeTextColor,
        fontWeight: token2.badgeFontWeight,
        fontSize: token2.badgeFontSize,
        lineHeight: `${token2.badgeHeight}px`,
        whiteSpace: "nowrap",
        textAlign: "center",
        background: token2.badgeColor,
        borderRadius: token2.badgeHeight / 2,
        boxShadow: `0 0 0 ${badgeShadowSize}px ${token2.badgeShadowColor}`,
        transition: `background ${token2.motionDurationMid}`,
        a: {
          color: token2.badgeTextColor
        },
        "a:hover": {
          color: token2.badgeTextColor
        },
        "a:hover &": {
          background: token2.badgeColorHover
        }
      },
      [`${componentCls}-count-sm`]: {
        minWidth: badgeHeightSm,
        height: badgeHeightSm,
        fontSize: token2.badgeFontSizeSm,
        lineHeight: `${badgeHeightSm}px`,
        borderRadius: badgeHeightSm / 2
      },
      [`${componentCls}-multiple-words`]: {
        padding: `0 ${token2.paddingXS}px`
      },
      [`${componentCls}-dot`]: {
        zIndex: token2.badgeZIndex,
        width: token2.badgeDotSize,
        minWidth: token2.badgeDotSize,
        height: token2.badgeDotSize,
        background: token2.badgeColor,
        borderRadius: "100%",
        boxShadow: `0 0 0 ${badgeShadowSize}px ${token2.badgeShadowColor}`
      },
      [`${componentCls}-dot${numberPrefixCls}`]: {
        transition: `background ${motionDurationSlow}`
      },
      [`${componentCls}-count, ${componentCls}-dot, ${numberPrefixCls}-custom-component`]: {
        position: "absolute",
        top: 0,
        insetInlineEnd: 0,
        transform: "translate(50%, -50%)",
        transformOrigin: "100% 0%",
        [`&${iconCls}-spin`]: {
          animationName: antBadgeLoadingCircle,
          animationDuration: "1s",
          animationIterationCount: "infinite",
          animationTimingFunction: "linear"
        }
      },
      [`&${componentCls}-status`]: {
        lineHeight: "inherit",
        verticalAlign: "baseline",
        [`${componentCls}-status-dot`]: {
          position: "relative",
          top: -1,
          display: "inline-block",
          width: badgeStatusSize,
          height: badgeStatusSize,
          verticalAlign: "middle",
          borderRadius: "50%"
        },
        [`${componentCls}-status-success`]: {
          backgroundColor: token2.colorSuccess
        },
        [`${componentCls}-status-processing`]: {
          overflow: "visible",
          color: token2.colorPrimary,
          backgroundColor: token2.colorPrimary,
          "&::after": {
            position: "absolute",
            top: 0,
            insetInlineStart: 0,
            width: "100%",
            height: "100%",
            borderWidth: badgeShadowSize,
            borderStyle: "solid",
            borderColor: "inherit",
            borderRadius: "50%",
            animationName: antStatusProcessing,
            animationDuration: token2.badgeProcessingDuration,
            animationIterationCount: "infinite",
            animationTimingFunction: "ease-in-out",
            content: '""'
          }
        },
        [`${componentCls}-status-default`]: {
          backgroundColor: token2.colorTextPlaceholder
        },
        [`${componentCls}-status-error`]: {
          backgroundColor: token2.colorError
        },
        [`${componentCls}-status-warning`]: {
          backgroundColor: token2.colorWarning
        },
        [`${componentCls}-status-text`]: {
          marginInlineStart: marginXS,
          color: token2.colorText,
          fontSize: token2.fontSize
        }
      }
    }), colorPreset), {
      [`${componentCls}-zoom-appear, ${componentCls}-zoom-enter`]: {
        animationName: antZoomBadgeIn,
        animationDuration: token2.motionDurationSlow,
        animationTimingFunction: token2.motionEaseOutBack,
        animationFillMode: "both"
      },
      [`${componentCls}-zoom-leave`]: {
        animationName: antZoomBadgeOut,
        animationDuration: token2.motionDurationSlow,
        animationTimingFunction: token2.motionEaseOutBack,
        animationFillMode: "both"
      },
      [`&${componentCls}-not-a-wrapper`]: {
        [`${componentCls}-zoom-appear, ${componentCls}-zoom-enter`]: {
          animationName: antNoWrapperZoomBadgeIn,
          animationDuration: token2.motionDurationSlow,
          animationTimingFunction: token2.motionEaseOutBack
        },
        [`${componentCls}-zoom-leave`]: {
          animationName: antNoWrapperZoomBadgeOut,
          animationDuration: token2.motionDurationSlow,
          animationTimingFunction: token2.motionEaseOutBack
        },
        [`&:not(${componentCls}-status)`]: {
          verticalAlign: "middle"
        },
        [`${numberPrefixCls}-custom-component, ${componentCls}-count`]: {
          transform: "none"
        },
        [`${numberPrefixCls}-custom-component, ${numberPrefixCls}`]: {
          position: "relative",
          top: "auto",
          display: "block",
          transformOrigin: "50% 50%"
        }
      },
      [`${numberPrefixCls}`]: {
        overflow: "hidden",
        [`${numberPrefixCls}-only`]: {
          position: "relative",
          display: "inline-block",
          height: token2.badgeHeight,
          transition: `all ${token2.motionDurationSlow} ${token2.motionEaseOutBack}`,
          WebkitTransformStyle: "preserve-3d",
          WebkitBackfaceVisibility: "hidden",
          [`> p${numberPrefixCls}-only-unit`]: {
            height: token2.badgeHeight,
            margin: 0,
            WebkitTransformStyle: "preserve-3d",
            WebkitBackfaceVisibility: "hidden"
          }
        },
        [`${numberPrefixCls}-symbol`]: {
          verticalAlign: "top"
        }
      },
      // ====================== RTL =======================
      "&-rtl": {
        direction: "rtl",
        [`${componentCls}-count, ${componentCls}-dot, ${numberPrefixCls}-custom-component`]: {
          transform: "translate(-50%, -50%)"
        }
      }
    }),
    [`${ribbonWrapperPrefixCls}`]: {
      position: "relative"
    },
    [`${ribbonPrefixCls}`]: _extends$1(_extends$1(_extends$1(_extends$1({}, resetComponent(token2)), {
      position: "absolute",
      top: marginXS,
      padding: `0 ${token2.paddingXS}px`,
      color: token2.colorPrimary,
      lineHeight: `${badgeFontHeight}px`,
      whiteSpace: "nowrap",
      backgroundColor: token2.colorPrimary,
      borderRadius: token2.borderRadiusSM,
      [`${ribbonPrefixCls}-text`]: {
        color: token2.colorTextLightSolid
      },
      [`${ribbonPrefixCls}-corner`]: {
        position: "absolute",
        top: "100%",
        width: badgeRibbonOffset,
        height: badgeRibbonOffset,
        color: "currentcolor",
        border: `${badgeRibbonOffset / 2}px solid`,
        transform: token2.badgeRibbonCornerTransform,
        transformOrigin: "top",
        filter: token2.badgeRibbonCornerFilter
      }
    }), statusRibbonPreset), {
      [`&${ribbonPrefixCls}-placement-end`]: {
        insetInlineEnd: -badgeRibbonOffset,
        borderEndEndRadius: 0,
        [`${ribbonPrefixCls}-corner`]: {
          insetInlineEnd: 0,
          borderInlineEndColor: "transparent",
          borderBlockEndColor: "transparent"
        }
      },
      [`&${ribbonPrefixCls}-placement-start`]: {
        insetInlineStart: -badgeRibbonOffset,
        borderEndStartRadius: 0,
        [`${ribbonPrefixCls}-corner`]: {
          insetInlineStart: 0,
          borderBlockEndColor: "transparent",
          borderInlineStartColor: "transparent"
        }
      },
      // ====================== RTL =======================
      "&-rtl": {
        direction: "rtl"
      }
    })
  };
};
const useStyle$D = genComponentStyleHook("Badge", (token2) => {
  const {
    fontSize,
    lineHeight,
    fontSizeSM,
    lineWidth,
    marginXS,
    colorBorderBg
  } = token2;
  const badgeFontHeight = Math.round(fontSize * lineHeight);
  const badgeShadowSize = lineWidth;
  const badgeZIndex = "auto";
  const badgeHeight = badgeFontHeight - 2 * badgeShadowSize;
  const badgeTextColor = token2.colorBgContainer;
  const badgeFontWeight = "normal";
  const badgeFontSize = fontSizeSM;
  const badgeColor = token2.colorError;
  const badgeColorHover = token2.colorErrorHover;
  const badgeHeightSm = fontSize;
  const badgeDotSize = fontSizeSM / 2;
  const badgeFontSizeSm = fontSizeSM;
  const badgeStatusSize = fontSizeSM / 2;
  const badgeToken = merge(token2, {
    badgeFontHeight,
    badgeShadowSize,
    badgeZIndex,
    badgeHeight,
    badgeTextColor,
    badgeFontWeight,
    badgeFontSize,
    badgeColor,
    badgeColorHover,
    badgeShadowColor: colorBorderBg,
    badgeHeightSm,
    badgeDotSize,
    badgeFontSizeSm,
    badgeStatusSize,
    badgeProcessingDuration: "1.2s",
    badgeRibbonOffset: marginXS,
    // Follow token just by Design. Not related with token
    badgeRibbonCornerTransform: "scaleY(0.75)",
    badgeRibbonCornerFilter: `brightness(75%)`
  });
  return [genSharedBadgeStyle(badgeToken)];
});
var __rest$W = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const ribbonProps = () => ({
  prefix: String,
  color: {
    type: String
  },
  text: PropTypes.any,
  placement: {
    type: String,
    default: "end"
  }
});
const Ribbon = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ABadgeRibbon",
  inheritAttrs: false,
  props: ribbonProps(),
  slots: Object,
  setup(props2, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const {
      prefixCls,
      direction
    } = useConfigInject("ribbon", props2);
    const [wrapSSR, hashId] = useStyle$D(prefixCls);
    const colorInPreset = computed(() => isPresetColor(props2.color, false));
    const ribbonCls = computed(() => [prefixCls.value, `${prefixCls.value}-placement-${props2.placement}`, {
      [`${prefixCls.value}-rtl`]: direction.value === "rtl",
      [`${prefixCls.value}-color-${props2.color}`]: colorInPreset.value
    }]);
    return () => {
      var _a2, _b;
      const {
        class: className,
        style
      } = attrs, restAttrs = __rest$W(attrs, ["class", "style"]);
      const colorStyle = {};
      const cornerColorStyle = {};
      if (props2.color && !colorInPreset.value) {
        colorStyle.background = props2.color;
        cornerColorStyle.color = props2.color;
      }
      return wrapSSR(createVNode("div", _objectSpread2$1({
        "class": `${prefixCls.value}-wrapper ${hashId.value}`
      }, restAttrs), [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots), createVNode("div", {
        "class": [ribbonCls.value, className, hashId.value],
        "style": _extends$1(_extends$1({}, colorStyle), style)
      }, [createVNode("span", {
        "class": `${prefixCls.value}-text`
      }, [props2.text || ((_b = slots.text) === null || _b === void 0 ? void 0 : _b.call(slots))]), createVNode("div", {
        "class": `${prefixCls.value}-corner`,
        "style": cornerColorStyle
      }, null)])]));
    };
  }
});
const isNumeric = (value) => {
  return !isNaN(parseFloat(value)) && isFinite(value);
};
const badgeProps = () => ({
  /** Number to show in badge */
  count: PropTypes.any.def(null),
  showZero: {
    type: Boolean,
    default: void 0
  },
  /** Max count to show */
  overflowCount: {
    type: Number,
    default: 99
  },
  /** whether to show red dot without number */
  dot: {
    type: Boolean,
    default: void 0
  },
  prefixCls: String,
  scrollNumberPrefixCls: String,
  status: {
    type: String
  },
  size: {
    type: String,
    default: "default"
  },
  color: String,
  text: PropTypes.any,
  offset: Array,
  numberStyle: {
    type: Object,
    default: void 0
  },
  title: String
});
const Badge = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ABadge",
  Ribbon,
  inheritAttrs: false,
  props: badgeProps(),
  slots: Object,
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const {
      prefixCls,
      direction
    } = useConfigInject("badge", props2);
    const [wrapSSR, hashId] = useStyle$D(prefixCls);
    const numberedDisplayCount = computed(() => {
      return props2.count > props2.overflowCount ? `${props2.overflowCount}+` : props2.count;
    });
    const isZero = computed(() => numberedDisplayCount.value === "0" || numberedDisplayCount.value === 0);
    const ignoreCount = computed(() => props2.count === null || isZero.value && !props2.showZero);
    const hasStatus = computed(() => (props2.status !== null && props2.status !== void 0 || props2.color !== null && props2.color !== void 0) && ignoreCount.value);
    const showAsDot = computed(() => props2.dot && !isZero.value);
    const mergedCount = computed(() => showAsDot.value ? "" : numberedDisplayCount.value);
    const isHidden = computed(() => {
      const isEmpty2 = mergedCount.value === null || mergedCount.value === void 0 || mergedCount.value === "";
      return (isEmpty2 || isZero.value && !props2.showZero) && !showAsDot.value;
    });
    const livingCount = ref(props2.count);
    const displayCount = ref(mergedCount.value);
    const isDotRef = ref(showAsDot.value);
    watch([() => props2.count, mergedCount, showAsDot], () => {
      if (!isHidden.value) {
        livingCount.value = props2.count;
        displayCount.value = mergedCount.value;
        isDotRef.value = showAsDot.value;
      }
    }, {
      immediate: true
    });
    const isInternalColor = computed(() => isPresetColor(props2.color, false));
    const statusCls = computed(() => ({
      [`${prefixCls.value}-status-dot`]: hasStatus.value,
      [`${prefixCls.value}-status-${props2.status}`]: !!props2.status,
      [`${prefixCls.value}-color-${props2.color}`]: isInternalColor.value
    }));
    const statusStyle = computed(() => {
      if (props2.color && !isInternalColor.value) {
        return {
          background: props2.color,
          color: props2.color
        };
      } else {
        return {};
      }
    });
    const scrollNumberCls = computed(() => ({
      [`${prefixCls.value}-dot`]: isDotRef.value,
      [`${prefixCls.value}-count`]: !isDotRef.value,
      [`${prefixCls.value}-count-sm`]: props2.size === "small",
      [`${prefixCls.value}-multiple-words`]: !isDotRef.value && displayCount.value && displayCount.value.toString().length > 1,
      [`${prefixCls.value}-status-${props2.status}`]: !!props2.status,
      [`${prefixCls.value}-color-${props2.color}`]: isInternalColor.value
    }));
    return () => {
      var _a2, _b;
      const {
        offset: offset3,
        title,
        color
      } = props2;
      const style = attrs.style;
      const text = getPropsSlot(slots, props2, "text");
      const pre = prefixCls.value;
      const count = livingCount.value;
      let children = flattenChildren((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots));
      children = children.length ? children : null;
      const visible = !!(!isHidden.value || slots.count);
      const mergedStyle = (() => {
        if (!offset3) {
          return _extends$1({}, style);
        }
        const offsetStyle = {
          marginTop: isNumeric(offset3[1]) ? `${offset3[1]}px` : offset3[1]
        };
        if (direction.value === "rtl") {
          offsetStyle.left = `${parseInt(offset3[0], 10)}px`;
        } else {
          offsetStyle.right = `${-parseInt(offset3[0], 10)}px`;
        }
        return _extends$1(_extends$1({}, offsetStyle), style);
      })();
      const titleNode = title !== null && title !== void 0 ? title : typeof count === "string" || typeof count === "number" ? count : void 0;
      const statusTextNode = visible || !text ? null : createVNode("span", {
        "class": `${pre}-status-text`
      }, [text]);
      const displayNode = typeof count === "object" || count === void 0 && slots.count ? cloneElement(count !== null && count !== void 0 ? count : (_b = slots.count) === null || _b === void 0 ? void 0 : _b.call(slots), {
        style: mergedStyle
      }, false) : null;
      const badgeClassName = classNames(pre, {
        [`${pre}-status`]: hasStatus.value,
        [`${pre}-not-a-wrapper`]: !children,
        [`${pre}-rtl`]: direction.value === "rtl"
      }, attrs.class, hashId.value);
      if (!children && hasStatus.value) {
        const statusTextColor = mergedStyle.color;
        return wrapSSR(createVNode("span", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
          "class": badgeClassName,
          "style": mergedStyle
        }), [createVNode("span", {
          "class": statusCls.value,
          "style": statusStyle.value
        }, null), createVNode("span", {
          "style": {
            color: statusTextColor
          },
          "class": `${pre}-status-text`
        }, [text])]));
      }
      const transitionProps = getTransitionProps(children ? `${pre}-zoom` : "", {
        appear: false
      });
      let scrollNumberStyle = _extends$1(_extends$1({}, mergedStyle), props2.numberStyle);
      if (color && !isInternalColor.value) {
        scrollNumberStyle = scrollNumberStyle || {};
        scrollNumberStyle.background = color;
      }
      return wrapSSR(createVNode("span", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "class": badgeClassName
      }), [children, createVNode(Transition, transitionProps, {
        default: () => [withDirectives(createVNode(ScrollNumber, {
          "prefixCls": props2.scrollNumberPrefixCls,
          "show": visible,
          "class": scrollNumberCls.value,
          "count": displayCount.value,
          "title": titleNode,
          "style": scrollNumberStyle,
          "key": "scrollNumber"
        }, {
          default: () => [displayNode]
        }), [[vShow, visible]])]
      }), statusTextNode]));
    };
  }
});
Badge.install = function(app) {
  app.component(Badge.name, Badge);
  app.component(Ribbon.name, Ribbon);
  return app;
};
const autoAdjustOverflow$1 = {
  adjustX: 1,
  adjustY: 1
};
const targetOffset = [0, 0];
const placements$1 = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflow$1,
    offset: [0, -4],
    targetOffset
  },
  topCenter: {
    points: ["bc", "tc"],
    overflow: autoAdjustOverflow$1,
    offset: [0, -4],
    targetOffset
  },
  topRight: {
    points: ["br", "tr"],
    overflow: autoAdjustOverflow$1,
    offset: [0, -4],
    targetOffset
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflow$1,
    offset: [0, 4],
    targetOffset
  },
  bottomCenter: {
    points: ["tc", "bc"],
    overflow: autoAdjustOverflow$1,
    offset: [0, 4],
    targetOffset
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: autoAdjustOverflow$1,
    offset: [0, 4],
    targetOffset
  }
};
var __rest$V = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const Dropdown$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  props: {
    minOverlayWidthMatchTrigger: {
      type: Boolean,
      default: void 0
    },
    arrow: {
      type: Boolean,
      default: false
    },
    prefixCls: PropTypes.string.def("rc-dropdown"),
    transitionName: String,
    overlayClassName: PropTypes.string.def(""),
    openClassName: String,
    animation: PropTypes.any,
    align: PropTypes.object,
    overlayStyle: {
      type: Object,
      default: void 0
    },
    placement: PropTypes.string.def("bottomLeft"),
    overlay: PropTypes.any,
    trigger: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]).def("hover"),
    alignPoint: {
      type: Boolean,
      default: void 0
    },
    showAction: PropTypes.array,
    hideAction: PropTypes.array,
    getPopupContainer: Function,
    visible: {
      type: Boolean,
      default: void 0
    },
    defaultVisible: {
      type: Boolean,
      default: false
    },
    mouseEnterDelay: PropTypes.number.def(0.15),
    mouseLeaveDelay: PropTypes.number.def(0.1)
  },
  emits: ["visibleChange", "overlayClick"],
  setup(props2, _ref) {
    let {
      slots,
      emit,
      expose
    } = _ref;
    const triggerVisible = ref(!!props2.visible);
    watch(() => props2.visible, (val) => {
      if (val !== void 0) {
        triggerVisible.value = val;
      }
    });
    const triggerRef2 = ref();
    expose({
      triggerRef: triggerRef2
    });
    const onClick = (e2) => {
      if (props2.visible === void 0) {
        triggerVisible.value = false;
      }
      emit("overlayClick", e2);
    };
    const onVisibleChange = (visible) => {
      if (props2.visible === void 0) {
        triggerVisible.value = visible;
      }
      emit("visibleChange", visible);
    };
    const getMenuElement = () => {
      var _a2;
      const overlayElement = (_a2 = slots.overlay) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
      const extraOverlayProps = {
        prefixCls: `${props2.prefixCls}-menu`,
        onClick
      };
      return createVNode(Fragment, {
        "key": skipFlattenKey
      }, [props2.arrow && createVNode("div", {
        "class": `${props2.prefixCls}-arrow`
      }, null), cloneElement(overlayElement, extraOverlayProps, false)]);
    };
    const minOverlayWidthMatchTrigger = computed(() => {
      const {
        minOverlayWidthMatchTrigger: matchTrigger = !props2.alignPoint
      } = props2;
      return matchTrigger;
    });
    const renderChildren2 = () => {
      var _a2;
      const children = (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
      return triggerVisible.value && children ? cloneElement(children[0], {
        class: props2.openClassName || `${props2.prefixCls}-open`
      }, false) : children;
    };
    const triggerHideAction = computed(() => {
      if (!props2.hideAction && props2.trigger.indexOf("contextmenu") !== -1) {
        return ["click"];
      }
      return props2.hideAction;
    });
    return () => {
      const {
        prefixCls,
        arrow,
        showAction,
        overlayStyle,
        trigger,
        placement,
        align,
        getPopupContainer,
        transitionName: transitionName2,
        animation,
        overlayClassName
      } = props2, otherProps = __rest$V(props2, ["prefixCls", "arrow", "showAction", "overlayStyle", "trigger", "placement", "align", "getPopupContainer", "transitionName", "animation", "overlayClassName"]);
      return createVNode(Trigger, _objectSpread2$1(_objectSpread2$1({}, otherProps), {}, {
        "prefixCls": prefixCls,
        "ref": triggerRef2,
        "popupClassName": classNames(overlayClassName, {
          [`${prefixCls}-show-arrow`]: arrow
        }),
        "popupStyle": overlayStyle,
        "builtinPlacements": placements$1,
        "action": trigger,
        "showAction": showAction,
        "hideAction": triggerHideAction.value || [],
        "popupPlacement": placement,
        "popupAlign": align,
        "popupTransitionName": transitionName2,
        "popupAnimation": animation,
        "popupVisible": triggerVisible.value,
        "stretch": minOverlayWidthMatchTrigger.value ? "minWidth" : "",
        "onPopupVisibleChange": onVisibleChange,
        "getPopupContainer": getPopupContainer
      }), {
        popup: getMenuElement,
        default: renderChildren2
      });
    };
  }
});
const genWaveStyle = (token2) => {
  const {
    componentCls,
    colorPrimary
  } = token2;
  return {
    [componentCls]: {
      position: "absolute",
      background: "transparent",
      pointerEvents: "none",
      boxSizing: "border-box",
      color: `var(--wave-color, ${colorPrimary})`,
      boxShadow: `0 0 0 0 currentcolor`,
      opacity: 0.2,
      // =================== Motion ===================
      "&.wave-motion-appear": {
        transition: [`box-shadow 0.4s ${token2.motionEaseOutCirc}`, `opacity 2s ${token2.motionEaseOutCirc}`].join(","),
        "&-active": {
          boxShadow: `0 0 0 6px currentcolor`,
          opacity: 0
        }
      }
    }
  };
};
const useStyle$C = genComponentStyleHook("Wave", (token2) => [genWaveStyle(token2)]);
function isNotGrey(color) {
  const match2 = (color || "").match(/rgba?\((\d*), (\d*), (\d*)(, [\d.]*)?\)/);
  if (match2 && match2[1] && match2[2] && match2[3]) {
    return !(match2[1] === match2[2] && match2[2] === match2[3]);
  }
  return true;
}
function isValidWaveColor(color) {
  return color && color !== "#fff" && color !== "#ffffff" && color !== "rgb(255, 255, 255)" && color !== "rgba(255, 255, 255, 1)" && isNotGrey(color) && !/rgba\((?:\d*, ){3}0\)/.test(color) && // any transparent rgba color
  color !== "transparent";
}
function getTargetWaveColor(node2) {
  const {
    borderTopColor,
    borderColor,
    backgroundColor
  } = getComputedStyle(node2);
  if (isValidWaveColor(borderTopColor)) {
    return borderTopColor;
  }
  if (isValidWaveColor(borderColor)) {
    return borderColor;
  }
  if (isValidWaveColor(backgroundColor)) {
    return backgroundColor;
  }
  return null;
}
function validateNum(value) {
  return Number.isNaN(value) ? 0 : value;
}
const WaveEffect = defineComponent({
  props: {
    target: objectType(),
    className: String
  },
  setup(props2) {
    const divRef = shallowRef(null);
    const [color, setWaveColor] = useState(null);
    const [borderRadius, setBorderRadius] = useState([]);
    const [left, setLeft] = useState(0);
    const [top, setTop] = useState(0);
    const [width, setWidth] = useState(0);
    const [height, setHeight] = useState(0);
    const [enabled, setEnabled] = useState(false);
    function syncPos() {
      const {
        target
      } = props2;
      const nodeStyle = getComputedStyle(target);
      setWaveColor(getTargetWaveColor(target));
      const isStatic = nodeStyle.position === "static";
      const {
        borderLeftWidth,
        borderTopWidth
      } = nodeStyle;
      setLeft(isStatic ? target.offsetLeft : validateNum(-parseFloat(borderLeftWidth)));
      setTop(isStatic ? target.offsetTop : validateNum(-parseFloat(borderTopWidth)));
      setWidth(target.offsetWidth);
      setHeight(target.offsetHeight);
      const {
        borderTopLeftRadius,
        borderTopRightRadius,
        borderBottomLeftRadius,
        borderBottomRightRadius
      } = nodeStyle;
      setBorderRadius([borderTopLeftRadius, borderTopRightRadius, borderBottomRightRadius, borderBottomLeftRadius].map((radius) => validateNum(parseFloat(radius))));
    }
    let resizeObserver;
    let rafId;
    let timeoutId;
    const clear = () => {
      clearTimeout(timeoutId);
      wrapperRaf.cancel(rafId);
      resizeObserver === null || resizeObserver === void 0 ? void 0 : resizeObserver.disconnect();
    };
    const removeDom = () => {
      var _a2;
      const holder = (_a2 = divRef.value) === null || _a2 === void 0 ? void 0 : _a2.parentElement;
      if (holder) {
        render(null, holder);
        if (holder.parentElement) {
          holder.parentElement.removeChild(holder);
        }
      }
    };
    onMounted(() => {
      clear();
      timeoutId = setTimeout(() => {
        removeDom();
      }, 5e3);
      const {
        target
      } = props2;
      if (target) {
        rafId = wrapperRaf(() => {
          syncPos();
          setEnabled(true);
        });
        if (typeof ResizeObserver !== "undefined") {
          resizeObserver = new ResizeObserver(syncPos);
          resizeObserver.observe(target);
        }
      }
    });
    onBeforeUnmount(() => {
      clear();
    });
    const onTransitionend = (e2) => {
      if (e2.propertyName === "opacity") {
        removeDom();
      }
    };
    return () => {
      if (!enabled.value) {
        return null;
      }
      const waveStyle = {
        left: `${left.value}px`,
        top: `${top.value}px`,
        width: `${width.value}px`,
        height: `${height.value}px`,
        borderRadius: borderRadius.value.map((radius) => `${radius}px`).join(" ")
      };
      if (color) {
        waveStyle["--wave-color"] = color.value;
      }
      return createVNode(Transition, {
        "appear": true,
        "name": "wave-motion",
        "appearFromClass": "wave-motion-appear",
        "appearActiveClass": "wave-motion-appear",
        "appearToClass": "wave-motion-appear wave-motion-appear-active"
      }, {
        default: () => [createVNode("div", {
          "ref": divRef,
          "class": props2.className,
          "style": waveStyle,
          "onTransitionend": onTransitionend
        }, null)]
      });
    };
  }
});
function showWaveEffect(node2, className) {
  const holder = document.createElement("div");
  holder.style.position = "absolute";
  holder.style.left = `0px`;
  holder.style.top = `0px`;
  node2 === null || node2 === void 0 ? void 0 : node2.insertBefore(holder, node2 === null || node2 === void 0 ? void 0 : node2.firstChild);
  render(createVNode(WaveEffect, {
    "target": node2,
    "className": className
  }, null), holder);
  return () => {
    render(null, holder);
    if (holder.parentElement) {
      holder.parentElement.removeChild(holder);
    }
  };
}
function useWave(className, wave) {
  const instance = getCurrentInstance();
  let stopWave;
  function showWave() {
    var _a2;
    const node2 = findDOMNode(instance);
    stopWave === null || stopWave === void 0 ? void 0 : stopWave();
    if (((_a2 = wave === null || wave === void 0 ? void 0 : wave.value) === null || _a2 === void 0 ? void 0 : _a2.disabled) || !node2) {
      return;
    }
    stopWave = showWaveEffect(node2, className.value);
  }
  onBeforeUnmount(() => {
    stopWave === null || stopWave === void 0 ? void 0 : stopWave();
  });
  return showWave;
}
const Wave = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Wave",
  props: {
    disabled: Boolean
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const instance = getCurrentInstance();
    const {
      prefixCls,
      wave
    } = useConfigInject("wave", props2);
    const [, hashId] = useStyle$C(prefixCls);
    const showWave = useWave(computed(() => classNames(prefixCls.value, hashId.value)), wave);
    let onClick;
    const clear = () => {
      const node2 = findDOMNode(instance);
      node2.removeEventListener("click", onClick, true);
    };
    onMounted(() => {
      watch(() => props2.disabled, () => {
        clear();
        nextTick(() => {
          const node2 = findDOMNode(instance);
          node2 === null || node2 === void 0 ? void 0 : node2.removeEventListener("click", onClick, true);
          if (!node2 || node2.nodeType !== 1 || props2.disabled) {
            return;
          }
          onClick = (e2) => {
            if (e2.target.tagName === "INPUT" || !isVisible(e2.target) || // No need wave
            !node2.getAttribute || node2.getAttribute("disabled") || node2.disabled || node2.className.includes("disabled") || node2.className.includes("-leave")) {
              return;
            }
            showWave();
          };
          node2.addEventListener("click", onClick, true);
        });
      }, {
        immediate: true,
        flush: "post"
      });
    });
    onBeforeUnmount(() => {
      clear();
    });
    return () => {
      var _a2;
      const children = (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)[0];
      return children;
    };
  }
});
function convertLegacyProps(type4) {
  if (type4 === "danger") {
    return {
      danger: true
    };
  }
  return {
    type: type4
  };
}
const buttonProps = () => ({
  prefixCls: String,
  type: String,
  htmlType: {
    type: String,
    default: "button"
  },
  shape: {
    type: String
  },
  size: {
    type: String
  },
  loading: {
    type: [Boolean, Object],
    default: () => false
  },
  disabled: {
    type: Boolean,
    default: void 0
  },
  ghost: {
    type: Boolean,
    default: void 0
  },
  block: {
    type: Boolean,
    default: void 0
  },
  danger: {
    type: Boolean,
    default: void 0
  },
  icon: PropTypes.any,
  href: String,
  target: String,
  title: String,
  onClick: eventType(),
  onMousedown: eventType()
});
const getCollapsedWidth = (node2) => {
  if (node2) {
    node2.style.width = "0px";
    node2.style.opacity = "0";
    node2.style.transform = "scale(0)";
  }
};
const getRealWidth = (node2) => {
  nextTick(() => {
    if (node2) {
      node2.style.width = `${node2.scrollWidth}px`;
      node2.style.opacity = "1";
      node2.style.transform = "scale(1)";
    }
  });
};
const resetStyle = (node2) => {
  if (node2 && node2.style) {
    node2.style.width = null;
    node2.style.opacity = null;
    node2.style.transform = null;
  }
};
const LoadingIcon = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "LoadingIcon",
  props: {
    prefixCls: String,
    loading: [Boolean, Object],
    existIcon: Boolean
  },
  setup(props2) {
    return () => {
      const {
        existIcon,
        prefixCls,
        loading
      } = props2;
      if (existIcon) {
        return createVNode("span", {
          "class": `${prefixCls}-loading-icon`
        }, [createVNode(LoadingOutlined, null, null)]);
      }
      const visible = !!loading;
      return createVNode(Transition, {
        "name": `${prefixCls}-loading-icon-motion`,
        "onBeforeEnter": getCollapsedWidth,
        "onEnter": getRealWidth,
        "onAfterEnter": resetStyle,
        "onBeforeLeave": getRealWidth,
        "onLeave": (node2) => {
          setTimeout(() => {
            getCollapsedWidth(node2);
          });
        },
        "onAfterLeave": resetStyle
      }, {
        default: () => [visible ? createVNode("span", {
          "class": `${prefixCls}-loading-icon`
        }, [createVNode(LoadingOutlined, null, null)]) : null]
      });
    };
  }
});
const genButtonBorderStyle = (buttonTypeCls, borderColor) => ({
  // Border
  [`> span, > ${buttonTypeCls}`]: {
    "&:not(:last-child)": {
      [`&, & > ${buttonTypeCls}`]: {
        "&:not(:disabled)": {
          borderInlineEndColor: borderColor
        }
      }
    },
    "&:not(:first-child)": {
      [`&, & > ${buttonTypeCls}`]: {
        "&:not(:disabled)": {
          borderInlineStartColor: borderColor
        }
      }
    }
  }
});
const genGroupStyle$1 = (token2) => {
  const {
    componentCls,
    fontSize,
    lineWidth,
    colorPrimaryHover,
    colorErrorHover
  } = token2;
  return {
    [`${componentCls}-group`]: [
      {
        position: "relative",
        display: "inline-flex",
        // Border
        [`> span, > ${componentCls}`]: {
          "&:not(:last-child)": {
            [`&, & > ${componentCls}`]: {
              borderStartEndRadius: 0,
              borderEndEndRadius: 0
            }
          },
          "&:not(:first-child)": {
            marginInlineStart: -lineWidth,
            [`&, & > ${componentCls}`]: {
              borderStartStartRadius: 0,
              borderEndStartRadius: 0
            }
          }
        },
        [componentCls]: {
          position: "relative",
          zIndex: 1,
          [`&:hover,
          &:focus,
          &:active`]: {
            zIndex: 2
          },
          "&[disabled]": {
            zIndex: 0
          }
        },
        [`${componentCls}-icon-only`]: {
          fontSize
        }
      },
      // Border Color
      genButtonBorderStyle(`${componentCls}-primary`, colorPrimaryHover),
      genButtonBorderStyle(`${componentCls}-danger`, colorErrorHover)
    ]
  };
};
function compactItemVerticalBorder(token2, parentCls) {
  return {
    // border collapse
    [`&-item:not(${parentCls}-last-item)`]: {
      marginBottom: -token2.lineWidth
    },
    "&-item": {
      "&:hover,&:focus,&:active": {
        zIndex: 2
      },
      "&[disabled]": {
        zIndex: 0
      }
    }
  };
}
function compactItemBorderVerticalRadius(prefixCls, parentCls) {
  return {
    [`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item)`]: {
      borderRadius: 0
    },
    [`&-item${parentCls}-first-item:not(${parentCls}-last-item)`]: {
      [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
        borderEndEndRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`&-item${parentCls}-last-item:not(${parentCls}-first-item)`]: {
      [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
        borderStartStartRadius: 0,
        borderStartEndRadius: 0
      }
    }
  };
}
function genCompactItemVerticalStyle(token2) {
  const compactCls = `${token2.componentCls}-compact-vertical`;
  return {
    [compactCls]: _extends$1(_extends$1({}, compactItemVerticalBorder(token2, compactCls)), compactItemBorderVerticalRadius(token2.componentCls, compactCls))
  };
}
const genSharedButtonStyle = (token2) => {
  const {
    componentCls,
    iconCls
  } = token2;
  return {
    [componentCls]: {
      outline: "none",
      position: "relative",
      display: "inline-block",
      fontWeight: 400,
      whiteSpace: "nowrap",
      textAlign: "center",
      backgroundImage: "none",
      backgroundColor: "transparent",
      border: `${token2.lineWidth}px ${token2.lineType} transparent`,
      cursor: "pointer",
      transition: `all ${token2.motionDurationMid} ${token2.motionEaseInOut}`,
      userSelect: "none",
      touchAction: "manipulation",
      lineHeight: token2.lineHeight,
      color: token2.colorText,
      "> span": {
        display: "inline-block"
      },
      // Leave a space between icon and text.
      [`> ${iconCls} + span, > span + ${iconCls}`]: {
        marginInlineStart: token2.marginXS
      },
      "> a": {
        color: "currentColor"
      },
      "&:not(:disabled)": _extends$1({}, genFocusStyle(token2)),
      // make `btn-icon-only` not too narrow
      [`&-icon-only${componentCls}-compact-item`]: {
        flex: "none"
      },
      // Special styles for Primary Button
      [`&-compact-item${componentCls}-primary`]: {
        [`&:not([disabled]) + ${componentCls}-compact-item${componentCls}-primary:not([disabled])`]: {
          position: "relative",
          "&:before": {
            position: "absolute",
            top: -token2.lineWidth,
            insetInlineStart: -token2.lineWidth,
            display: "inline-block",
            width: token2.lineWidth,
            height: `calc(100% + ${token2.lineWidth * 2}px)`,
            backgroundColor: token2.colorPrimaryHover,
            content: '""'
          }
        }
      },
      // Special styles for Primary Button
      "&-compact-vertical-item": {
        [`&${componentCls}-primary`]: {
          [`&:not([disabled]) + ${componentCls}-compact-vertical-item${componentCls}-primary:not([disabled])`]: {
            position: "relative",
            "&:before": {
              position: "absolute",
              top: -token2.lineWidth,
              insetInlineStart: -token2.lineWidth,
              display: "inline-block",
              width: `calc(100% + ${token2.lineWidth * 2}px)`,
              height: token2.lineWidth,
              backgroundColor: token2.colorPrimaryHover,
              content: '""'
            }
          }
        }
      }
    }
  };
};
const genHoverActiveButtonStyle = (hoverStyle, activeStyle) => ({
  "&:not(:disabled)": {
    "&:hover": hoverStyle,
    "&:active": activeStyle
  }
});
const genCircleButtonStyle = (token2) => ({
  minWidth: token2.controlHeight,
  paddingInlineStart: 0,
  paddingInlineEnd: 0,
  borderRadius: "50%"
});
const genRoundButtonStyle = (token2) => ({
  borderRadius: token2.controlHeight,
  paddingInlineStart: token2.controlHeight / 2,
  paddingInlineEnd: token2.controlHeight / 2
});
const genDisabledStyle$1 = (token2) => ({
  cursor: "not-allowed",
  borderColor: token2.colorBorder,
  color: token2.colorTextDisabled,
  backgroundColor: token2.colorBgContainerDisabled,
  boxShadow: "none"
});
const genGhostButtonStyle = (btnCls, textColor, borderColor, textColorDisabled, borderColorDisabled, hoverStyle, activeStyle) => ({
  [`&${btnCls}-background-ghost`]: _extends$1(_extends$1({
    color: textColor || void 0,
    backgroundColor: "transparent",
    borderColor: borderColor || void 0,
    boxShadow: "none"
  }, genHoverActiveButtonStyle(_extends$1({
    backgroundColor: "transparent"
  }, hoverStyle), _extends$1({
    backgroundColor: "transparent"
  }, activeStyle))), {
    "&:disabled": {
      cursor: "not-allowed",
      color: textColorDisabled || void 0,
      borderColor: borderColorDisabled || void 0
    }
  })
});
const genSolidDisabledButtonStyle = (token2) => ({
  "&:disabled": _extends$1({}, genDisabledStyle$1(token2))
});
const genSolidButtonStyle = (token2) => _extends$1({}, genSolidDisabledButtonStyle(token2));
const genPureDisabledButtonStyle = (token2) => ({
  "&:disabled": {
    cursor: "not-allowed",
    color: token2.colorTextDisabled
  }
});
const genDefaultButtonStyle = (token2) => _extends$1(_extends$1(_extends$1(_extends$1(_extends$1({}, genSolidButtonStyle(token2)), {
  backgroundColor: token2.colorBgContainer,
  borderColor: token2.colorBorder,
  boxShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.controlTmpOutline}`
}), genHoverActiveButtonStyle({
  color: token2.colorPrimaryHover,
  borderColor: token2.colorPrimaryHover
}, {
  color: token2.colorPrimaryActive,
  borderColor: token2.colorPrimaryActive
})), genGhostButtonStyle(token2.componentCls, token2.colorBgContainer, token2.colorBgContainer, token2.colorTextDisabled, token2.colorBorder)), {
  [`&${token2.componentCls}-dangerous`]: _extends$1(_extends$1(_extends$1({
    color: token2.colorError,
    borderColor: token2.colorError
  }, genHoverActiveButtonStyle({
    color: token2.colorErrorHover,
    borderColor: token2.colorErrorBorderHover
  }, {
    color: token2.colorErrorActive,
    borderColor: token2.colorErrorActive
  })), genGhostButtonStyle(token2.componentCls, token2.colorError, token2.colorError, token2.colorTextDisabled, token2.colorBorder)), genSolidDisabledButtonStyle(token2))
});
const genPrimaryButtonStyle = (token2) => _extends$1(_extends$1(_extends$1(_extends$1(_extends$1({}, genSolidButtonStyle(token2)), {
  color: token2.colorTextLightSolid,
  backgroundColor: token2.colorPrimary,
  boxShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.controlOutline}`
}), genHoverActiveButtonStyle({
  color: token2.colorTextLightSolid,
  backgroundColor: token2.colorPrimaryHover
}, {
  color: token2.colorTextLightSolid,
  backgroundColor: token2.colorPrimaryActive
})), genGhostButtonStyle(token2.componentCls, token2.colorPrimary, token2.colorPrimary, token2.colorTextDisabled, token2.colorBorder, {
  color: token2.colorPrimaryHover,
  borderColor: token2.colorPrimaryHover
}, {
  color: token2.colorPrimaryActive,
  borderColor: token2.colorPrimaryActive
})), {
  [`&${token2.componentCls}-dangerous`]: _extends$1(_extends$1(_extends$1({
    backgroundColor: token2.colorError,
    boxShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.colorErrorOutline}`
  }, genHoverActiveButtonStyle({
    backgroundColor: token2.colorErrorHover
  }, {
    backgroundColor: token2.colorErrorActive
  })), genGhostButtonStyle(token2.componentCls, token2.colorError, token2.colorError, token2.colorTextDisabled, token2.colorBorder, {
    color: token2.colorErrorHover,
    borderColor: token2.colorErrorHover
  }, {
    color: token2.colorErrorActive,
    borderColor: token2.colorErrorActive
  })), genSolidDisabledButtonStyle(token2))
});
const genDashedButtonStyle = (token2) => _extends$1(_extends$1({}, genDefaultButtonStyle(token2)), {
  borderStyle: "dashed"
});
const genLinkButtonStyle = (token2) => _extends$1(_extends$1(_extends$1({
  color: token2.colorLink
}, genHoverActiveButtonStyle({
  color: token2.colorLinkHover
}, {
  color: token2.colorLinkActive
})), genPureDisabledButtonStyle(token2)), {
  [`&${token2.componentCls}-dangerous`]: _extends$1(_extends$1({
    color: token2.colorError
  }, genHoverActiveButtonStyle({
    color: token2.colorErrorHover
  }, {
    color: token2.colorErrorActive
  })), genPureDisabledButtonStyle(token2))
});
const genTextButtonStyle = (token2) => _extends$1(_extends$1(_extends$1({}, genHoverActiveButtonStyle({
  color: token2.colorText,
  backgroundColor: token2.colorBgTextHover
}, {
  color: token2.colorText,
  backgroundColor: token2.colorBgTextActive
})), genPureDisabledButtonStyle(token2)), {
  [`&${token2.componentCls}-dangerous`]: _extends$1(_extends$1({
    color: token2.colorError
  }, genPureDisabledButtonStyle(token2)), genHoverActiveButtonStyle({
    color: token2.colorErrorHover,
    backgroundColor: token2.colorErrorBg
  }, {
    color: token2.colorErrorHover,
    backgroundColor: token2.colorErrorBg
  }))
});
const genDisabledButtonStyle = (token2) => _extends$1(_extends$1({}, genDisabledStyle$1(token2)), {
  [`&${token2.componentCls}:hover`]: _extends$1({}, genDisabledStyle$1(token2))
});
const genTypeButtonStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-default`]: genDefaultButtonStyle(token2),
    [`${componentCls}-primary`]: genPrimaryButtonStyle(token2),
    [`${componentCls}-dashed`]: genDashedButtonStyle(token2),
    [`${componentCls}-link`]: genLinkButtonStyle(token2),
    [`${componentCls}-text`]: genTextButtonStyle(token2),
    [`${componentCls}-disabled`]: genDisabledButtonStyle(token2)
  };
};
const genSizeButtonStyle = function(token2) {
  let sizePrefixCls = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  const {
    componentCls,
    iconCls,
    controlHeight,
    fontSize,
    lineHeight,
    lineWidth,
    borderRadius,
    buttonPaddingHorizontal
  } = token2;
  const paddingVertical = Math.max(0, (controlHeight - fontSize * lineHeight) / 2 - lineWidth);
  const paddingHorizontal = buttonPaddingHorizontal - lineWidth;
  const iconOnlyCls = `${componentCls}-icon-only`;
  return [
    // Size
    {
      [`${componentCls}${sizePrefixCls}`]: {
        fontSize,
        height: controlHeight,
        padding: `${paddingVertical}px ${paddingHorizontal}px`,
        borderRadius,
        [`&${iconOnlyCls}`]: {
          width: controlHeight,
          paddingInlineStart: 0,
          paddingInlineEnd: 0,
          [`&${componentCls}-round`]: {
            width: "auto"
          },
          "> span": {
            transform: "scale(1.143)"
            // 14px -> 16px
          }
        },
        // Loading
        [`&${componentCls}-loading`]: {
          opacity: token2.opacityLoading,
          cursor: "default"
        },
        [`${componentCls}-loading-icon`]: {
          transition: `width ${token2.motionDurationSlow} ${token2.motionEaseInOut}, opacity ${token2.motionDurationSlow} ${token2.motionEaseInOut}`
        },
        [`&:not(${iconOnlyCls}) ${componentCls}-loading-icon > ${iconCls}`]: {
          marginInlineEnd: token2.marginXS
        }
      }
    },
    // Shape - patch prefixCls again to override solid border radius style
    {
      [`${componentCls}${componentCls}-circle${sizePrefixCls}`]: genCircleButtonStyle(token2)
    },
    {
      [`${componentCls}${componentCls}-round${sizePrefixCls}`]: genRoundButtonStyle(token2)
    }
  ];
};
const genSizeBaseButtonStyle = (token2) => genSizeButtonStyle(token2);
const genSizeSmallButtonStyle = (token2) => {
  const smallToken = merge(token2, {
    controlHeight: token2.controlHeightSM,
    padding: token2.paddingXS,
    buttonPaddingHorizontal: 8,
    borderRadius: token2.borderRadiusSM
  });
  return genSizeButtonStyle(smallToken, `${token2.componentCls}-sm`);
};
const genSizeLargeButtonStyle = (token2) => {
  const largeToken = merge(token2, {
    controlHeight: token2.controlHeightLG,
    fontSize: token2.fontSizeLG,
    borderRadius: token2.borderRadiusLG
  });
  return genSizeButtonStyle(largeToken, `${token2.componentCls}-lg`);
};
const genBlockButtonStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [componentCls]: {
      [`&${componentCls}-block`]: {
        width: "100%"
      }
    }
  };
};
const useStyle$B = genComponentStyleHook("Button", (token2) => {
  const {
    controlTmpOutline,
    paddingContentHorizontal
  } = token2;
  const buttonToken = merge(token2, {
    colorOutlineDefault: controlTmpOutline,
    buttonPaddingHorizontal: paddingContentHorizontal
  });
  return [
    // Shared
    genSharedButtonStyle(buttonToken),
    // Size
    genSizeSmallButtonStyle(buttonToken),
    genSizeBaseButtonStyle(buttonToken),
    genSizeLargeButtonStyle(buttonToken),
    // Block
    genBlockButtonStyle(buttonToken),
    // Group (type, ghost, danger, disabled, loading)
    genTypeButtonStyle(buttonToken),
    // Button Group
    genGroupStyle$1(buttonToken),
    // Space Compact
    genCompactItemStyle(token2, {
      focus: false
    }),
    genCompactItemVerticalStyle(token2)
  ];
});
const buttonGroupProps = () => ({
  prefixCls: String,
  size: {
    type: String
  }
});
const GroupSizeContext = createContext();
const ButtonGroup$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AButtonGroup",
  props: buttonGroupProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      prefixCls,
      direction
    } = useConfigInject("btn-group", props2);
    const [, , hashId] = useToken$1();
    GroupSizeContext.useProvide(reactive({
      size: computed(() => props2.size)
    }));
    const classes = computed(() => {
      const {
        size
      } = props2;
      let sizeCls = "";
      switch (size) {
        case "large":
          sizeCls = "lg";
          break;
        case "small":
          sizeCls = "sm";
          break;
        case "middle":
        case void 0:
          break;
        default:
          devWarning(!size, "Button.Group", "Invalid prop `size`.");
      }
      return {
        [`${prefixCls.value}`]: true,
        [`${prefixCls.value}-${sizeCls}`]: sizeCls,
        [`${prefixCls.value}-rtl`]: direction.value === "rtl",
        [hashId.value]: true
      };
    });
    return () => {
      var _a2;
      return createVNode("div", {
        "class": classes.value
      }, [flattenChildren((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots))]);
    };
  }
});
const rxTwoCNChar = /^[\u4e00-\u9fa5]{2}$/;
const isTwoCNChar = rxTwoCNChar.test.bind(rxTwoCNChar);
function isUnBorderedButtonType(type4) {
  return type4 === "text" || type4 === "link";
}
const Button$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AButton",
  inheritAttrs: false,
  __ANT_BUTTON: true,
  props: initDefaultProps(buttonProps(), {
    type: "default"
  }),
  slots: Object,
  // emits: ['click', 'mousedown'],
  setup(props2, _ref) {
    let {
      slots,
      attrs,
      emit,
      expose
    } = _ref;
    const {
      prefixCls,
      autoInsertSpaceInButton,
      direction,
      size
    } = useConfigInject("btn", props2);
    const [wrapSSR, hashId] = useStyle$B(prefixCls);
    const groupSizeContext = GroupSizeContext.useInject();
    const disabledContext = useInjectDisabled();
    const mergedDisabled = computed(() => {
      var _a2;
      return (_a2 = props2.disabled) !== null && _a2 !== void 0 ? _a2 : disabledContext.value;
    });
    const buttonNodeRef = shallowRef(null);
    const delayTimeoutRef = shallowRef(void 0);
    let isNeedInserted = false;
    const innerLoading = shallowRef(false);
    const hasTwoCNChar = shallowRef(false);
    const autoInsertSpace = computed(() => autoInsertSpaceInButton.value !== false);
    const {
      compactSize,
      compactItemClassnames
    } = useCompactItemContext(prefixCls, direction);
    const loadingOrDelay = computed(() => typeof props2.loading === "object" && props2.loading.delay ? props2.loading.delay || true : !!props2.loading);
    watch(loadingOrDelay, (val) => {
      clearTimeout(delayTimeoutRef.value);
      if (typeof loadingOrDelay.value === "number") {
        delayTimeoutRef.value = setTimeout(() => {
          innerLoading.value = val;
        }, loadingOrDelay.value);
      } else {
        innerLoading.value = val;
      }
    }, {
      immediate: true
    });
    const classes = computed(() => {
      const {
        type: type4,
        shape = "default",
        ghost,
        block,
        danger
      } = props2;
      const pre = prefixCls.value;
      const sizeClassNameMap = {
        large: "lg",
        small: "sm",
        middle: void 0
      };
      const sizeFullname = compactSize.value || (groupSizeContext === null || groupSizeContext === void 0 ? void 0 : groupSizeContext.size) || size.value;
      const sizeCls = sizeFullname ? sizeClassNameMap[sizeFullname] || "" : "";
      return [compactItemClassnames.value, {
        [hashId.value]: true,
        [`${pre}`]: true,
        [`${pre}-${shape}`]: shape !== "default" && shape,
        [`${pre}-${type4}`]: type4,
        [`${pre}-${sizeCls}`]: sizeCls,
        [`${pre}-loading`]: innerLoading.value,
        [`${pre}-background-ghost`]: ghost && !isUnBorderedButtonType(type4),
        [`${pre}-two-chinese-chars`]: hasTwoCNChar.value && autoInsertSpace.value,
        [`${pre}-block`]: block,
        [`${pre}-dangerous`]: !!danger,
        [`${pre}-rtl`]: direction.value === "rtl"
      }];
    });
    const fixTwoCNChar = () => {
      const node2 = buttonNodeRef.value;
      if (!node2 || autoInsertSpaceInButton.value === false) {
        return;
      }
      const buttonText = node2.textContent;
      if (isNeedInserted && isTwoCNChar(buttonText)) {
        if (!hasTwoCNChar.value) {
          hasTwoCNChar.value = true;
        }
      } else if (hasTwoCNChar.value) {
        hasTwoCNChar.value = false;
      }
    };
    const handleClick = (event) => {
      if (innerLoading.value || mergedDisabled.value) {
        event.preventDefault();
        return;
      }
      emit("click", event);
    };
    const handleMousedown = (event) => {
      emit("mousedown", event);
    };
    const insertSpace = (child, needInserted) => {
      const SPACE = needInserted ? " " : "";
      if (child.type === Text$1) {
        let text = child.children.trim();
        if (isTwoCNChar(text)) {
          text = text.split("").join(SPACE);
        }
        return createVNode("span", null, [text]);
      }
      return child;
    };
    watchEffect(() => {
      devWarning(!(props2.ghost && isUnBorderedButtonType(props2.type)), "Button", "`link` or `text` button can't be a `ghost` button.");
    });
    onMounted(fixTwoCNChar);
    onUpdated(fixTwoCNChar);
    onBeforeUnmount(() => {
      delayTimeoutRef.value && clearTimeout(delayTimeoutRef.value);
    });
    const focus = () => {
      var _a2;
      (_a2 = buttonNodeRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
    };
    const blur = () => {
      var _a2;
      (_a2 = buttonNodeRef.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
    };
    expose({
      focus,
      blur
    });
    return () => {
      var _a2, _b;
      const {
        icon = (_a2 = slots.icon) === null || _a2 === void 0 ? void 0 : _a2.call(slots)
      } = props2;
      const children = flattenChildren((_b = slots.default) === null || _b === void 0 ? void 0 : _b.call(slots));
      isNeedInserted = children.length === 1 && !icon && !isUnBorderedButtonType(props2.type);
      const {
        type: type4,
        htmlType,
        href,
        title,
        target
      } = props2;
      const iconType = innerLoading.value ? "loading" : icon;
      const buttonProps2 = _extends$1(_extends$1({}, attrs), {
        title,
        disabled: mergedDisabled.value,
        class: [classes.value, attrs.class, {
          [`${prefixCls.value}-icon-only`]: children.length === 0 && !!iconType
        }],
        onClick: handleClick,
        onMousedown: handleMousedown
      });
      if (!mergedDisabled.value) {
        delete buttonProps2.disabled;
      }
      const iconNode = icon && !innerLoading.value ? icon : createVNode(LoadingIcon, {
        "existIcon": !!icon,
        "prefixCls": prefixCls.value,
        "loading": !!innerLoading.value
      }, null);
      const kids = children.map((child) => insertSpace(child, isNeedInserted && autoInsertSpace.value));
      if (href !== void 0) {
        return wrapSSR(createVNode("a", _objectSpread2$1(_objectSpread2$1({}, buttonProps2), {}, {
          "href": href,
          "target": target,
          "ref": buttonNodeRef
        }), [iconNode, kids]));
      }
      let buttonNode = createVNode("button", _objectSpread2$1(_objectSpread2$1({}, buttonProps2), {}, {
        "ref": buttonNodeRef,
        "type": htmlType
      }), [iconNode, kids]);
      if (!isUnBorderedButtonType(type4)) {
        const _buttonNode = /* @__PURE__ */ function() {
          return buttonNode;
        }();
        buttonNode = createVNode(Wave, {
          "ref": "wave",
          "disabled": !!innerLoading.value
        }, {
          default: () => [_buttonNode]
        });
      }
      return wrapSSR(buttonNode);
    };
  }
});
Button$1.Group = ButtonGroup$1;
Button$1.install = function(app) {
  app.component(Button$1.name, Button$1);
  app.component(ButtonGroup$1.name, ButtonGroup$1);
  return app;
};
const dropdownProps = () => ({
  arrow: someType([Boolean, Object]),
  trigger: {
    type: [Array, String]
  },
  menu: objectType(),
  overlay: PropTypes.any,
  /** @deprecated Please use `open` instead */
  visible: booleanType(),
  open: booleanType(),
  disabled: booleanType(),
  danger: booleanType(),
  autofocus: booleanType(),
  align: objectType(),
  getPopupContainer: Function,
  prefixCls: String,
  transitionName: String,
  placement: String,
  overlayClassName: String,
  overlayStyle: objectType(),
  forceRender: booleanType(),
  mouseEnterDelay: Number,
  mouseLeaveDelay: Number,
  openClassName: String,
  minOverlayWidthMatchTrigger: booleanType(),
  destroyPopupOnHide: booleanType(),
  /** @deprecated Please use `onOpenChange` instead */
  onVisibleChange: {
    type: Function
  },
  /** @deprecated Please use `onUpdate:open` instead */
  "onUpdate:visible": {
    type: Function
  },
  onOpenChange: {
    type: Function
  },
  "onUpdate:open": {
    type: Function
  }
});
const buttonTypesProps = buttonProps();
const dropdownButtonProps = () => _extends$1(_extends$1({}, dropdownProps()), {
  type: buttonTypesProps.type,
  size: String,
  htmlType: buttonTypesProps.htmlType,
  href: String,
  disabled: booleanType(),
  prefixCls: String,
  icon: PropTypes.any,
  title: String,
  loading: buttonTypesProps.loading,
  onClick: eventType()
});
const genButtonStyle = (token2) => {
  const {
    componentCls,
    antCls,
    paddingXS,
    opacityLoading
  } = token2;
  return {
    [`${componentCls}-button`]: {
      whiteSpace: "nowrap",
      [`&${antCls}-btn-group > ${antCls}-btn`]: {
        [`&-loading, &-loading + ${antCls}-btn`]: {
          cursor: "default",
          pointerEvents: "none",
          opacity: opacityLoading
        },
        [`&:last-child:not(:first-child):not(${antCls}-btn-icon-only)`]: {
          paddingInline: paddingXS
        }
      }
    }
  };
};
const genStatusStyle$1 = (token2) => {
  const {
    componentCls,
    menuCls,
    colorError,
    colorTextLightSolid
  } = token2;
  const itemCls = `${menuCls}-item`;
  return {
    [`${componentCls}, ${componentCls}-menu-submenu`]: {
      [`${menuCls} ${itemCls}`]: {
        [`&${itemCls}-danger:not(${itemCls}-disabled)`]: {
          color: colorError,
          "&:hover": {
            color: colorTextLightSolid,
            backgroundColor: colorError
          }
        }
      }
    }
  };
};
const genBaseStyle$b = (token2) => {
  const {
    componentCls,
    menuCls,
    zIndexPopup,
    dropdownArrowDistance,
    dropdownArrowOffset,
    sizePopupArrow,
    antCls,
    iconCls,
    motionDurationMid,
    dropdownPaddingVertical,
    fontSize,
    dropdownEdgeChildPadding,
    colorTextDisabled,
    fontSizeIcon,
    controlPaddingHorizontal,
    colorBgElevated,
    boxShadowPopoverArrow
  } = token2;
  return [
    {
      [componentCls]: _extends$1(_extends$1({}, resetComponent(token2)), {
        position: "absolute",
        top: -9999,
        left: {
          _skip_check_: true,
          value: -9999
        },
        zIndex: zIndexPopup,
        display: "block",
        // A placeholder out of dropdown visible range to avoid close when user moving
        "&::before": {
          position: "absolute",
          insetBlock: -dropdownArrowDistance + sizePopupArrow / 2,
          // insetInlineStart: -7, // FIXME: Seems not work for hidden element
          zIndex: -9999,
          opacity: 1e-4,
          content: '""'
        },
        [`${componentCls}-wrap`]: {
          position: "relative",
          [`${antCls}-btn > ${iconCls}-down`]: {
            fontSize: fontSizeIcon
          },
          [`${iconCls}-down::before`]: {
            transition: `transform ${motionDurationMid}`
          }
        },
        [`${componentCls}-wrap-open`]: {
          [`${iconCls}-down::before`]: {
            transform: `rotate(180deg)`
          }
        },
        [`
        &-hidden,
        &-menu-hidden,
        &-menu-submenu-hidden
      `]: {
          display: "none"
        },
        // =============================================================
        // ==                          Arrow                          ==
        // =============================================================
        // Offset the popover to account for the dropdown arrow
        [`
        &-show-arrow${componentCls}-placement-topLeft,
        &-show-arrow${componentCls}-placement-top,
        &-show-arrow${componentCls}-placement-topRight
      `]: {
          paddingBottom: dropdownArrowDistance
        },
        [`
        &-show-arrow${componentCls}-placement-bottomLeft,
        &-show-arrow${componentCls}-placement-bottom,
        &-show-arrow${componentCls}-placement-bottomRight
      `]: {
          paddingTop: dropdownArrowDistance
        },
        // Note: .popover-arrow is outer, .popover-arrow:after is inner
        [`${componentCls}-arrow`]: _extends$1({
          position: "absolute",
          zIndex: 1,
          display: "block"
        }, roundedArrow(sizePopupArrow, token2.borderRadiusXS, token2.borderRadiusOuter, colorBgElevated, boxShadowPopoverArrow)),
        [`
        &-placement-top > ${componentCls}-arrow,
        &-placement-topLeft > ${componentCls}-arrow,
        &-placement-topRight > ${componentCls}-arrow
      `]: {
          bottom: dropdownArrowDistance,
          transform: "translateY(100%) rotate(180deg)"
        },
        [`&-placement-top > ${componentCls}-arrow`]: {
          left: {
            _skip_check_: true,
            value: "50%"
          },
          transform: "translateX(-50%) translateY(100%) rotate(180deg)"
        },
        [`&-placement-topLeft > ${componentCls}-arrow`]: {
          left: {
            _skip_check_: true,
            value: dropdownArrowOffset
          }
        },
        [`&-placement-topRight > ${componentCls}-arrow`]: {
          right: {
            _skip_check_: true,
            value: dropdownArrowOffset
          }
        },
        [`
          &-placement-bottom > ${componentCls}-arrow,
          &-placement-bottomLeft > ${componentCls}-arrow,
          &-placement-bottomRight > ${componentCls}-arrow
        `]: {
          top: dropdownArrowDistance,
          transform: `translateY(-100%)`
        },
        [`&-placement-bottom > ${componentCls}-arrow`]: {
          left: {
            _skip_check_: true,
            value: "50%"
          },
          transform: `translateY(-100%) translateX(-50%)`
        },
        [`&-placement-bottomLeft > ${componentCls}-arrow`]: {
          left: {
            _skip_check_: true,
            value: dropdownArrowOffset
          }
        },
        [`&-placement-bottomRight > ${componentCls}-arrow`]: {
          right: {
            _skip_check_: true,
            value: dropdownArrowOffset
          }
        },
        // =============================================================
        // ==                         Motion                          ==
        // =============================================================
        // When position is not enough for dropdown, the placement will revert.
        // We will handle this with revert motion name.
        [`&${antCls}-slide-down-enter${antCls}-slide-down-enter-active${componentCls}-placement-bottomLeft,
          &${antCls}-slide-down-appear${antCls}-slide-down-appear-active${componentCls}-placement-bottomLeft,
          &${antCls}-slide-down-enter${antCls}-slide-down-enter-active${componentCls}-placement-bottom,
          &${antCls}-slide-down-appear${antCls}-slide-down-appear-active${componentCls}-placement-bottom,
          &${antCls}-slide-down-enter${antCls}-slide-down-enter-active${componentCls}-placement-bottomRight,
          &${antCls}-slide-down-appear${antCls}-slide-down-appear-active${componentCls}-placement-bottomRight`]: {
          animationName: slideUpIn
        },
        [`&${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-placement-topLeft,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-placement-topLeft,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-placement-top,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-placement-top,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-placement-topRight,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-placement-topRight`]: {
          animationName: slideDownIn
        },
        [`&${antCls}-slide-down-leave${antCls}-slide-down-leave-active${componentCls}-placement-bottomLeft,
          &${antCls}-slide-down-leave${antCls}-slide-down-leave-active${componentCls}-placement-bottom,
          &${antCls}-slide-down-leave${antCls}-slide-down-leave-active${componentCls}-placement-bottomRight`]: {
          animationName: slideUpOut
        },
        [`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-placement-topLeft,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-placement-top,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-placement-topRight`]: {
          animationName: slideDownOut
        }
      })
    },
    {
      // =============================================================
      // ==                          Menu                           ==
      // =============================================================
      [`${componentCls} ${menuCls}`]: {
        position: "relative",
        margin: 0
      },
      [`${menuCls}-submenu-popup`]: {
        position: "absolute",
        zIndex: zIndexPopup,
        background: "transparent",
        boxShadow: "none",
        transformOrigin: "0 0",
        "ul,li": {
          listStyle: "none"
        },
        ul: {
          marginInline: "0.3em"
        }
      },
      [`${componentCls}, ${componentCls}-menu-submenu`]: {
        [menuCls]: _extends$1(_extends$1({
          padding: dropdownEdgeChildPadding,
          listStyleType: "none",
          backgroundColor: colorBgElevated,
          backgroundClip: "padding-box",
          borderRadius: token2.borderRadiusLG,
          outline: "none",
          boxShadow: token2.boxShadowSecondary
        }, genFocusStyle(token2)), {
          [`${menuCls}-item-group-title`]: {
            padding: `${dropdownPaddingVertical}px ${controlPaddingHorizontal}px`,
            color: token2.colorTextDescription,
            transition: `all ${motionDurationMid}`
          },
          // ======================= Item Content =======================
          [`${menuCls}-item`]: {
            position: "relative",
            display: "flex",
            alignItems: "center",
            borderRadius: token2.borderRadiusSM
          },
          [`${menuCls}-item-icon`]: {
            minWidth: fontSize,
            marginInlineEnd: token2.marginXS,
            fontSize: token2.fontSizeSM
          },
          [`${menuCls}-title-content`]: {
            flex: "auto",
            "> a": {
              color: "inherit",
              transition: `all ${motionDurationMid}`,
              "&:hover": {
                color: "inherit"
              },
              "&::after": {
                position: "absolute",
                inset: 0,
                content: '""'
              }
            }
          },
          // =========================== Item ===========================
          [`${menuCls}-item, ${menuCls}-submenu-title`]: _extends$1(_extends$1({
            clear: "both",
            margin: 0,
            padding: `${dropdownPaddingVertical}px ${controlPaddingHorizontal}px`,
            color: token2.colorText,
            fontWeight: "normal",
            fontSize,
            lineHeight: token2.lineHeight,
            cursor: "pointer",
            transition: `all ${motionDurationMid}`,
            [`&:hover, &-active`]: {
              backgroundColor: token2.controlItemBgHover
            }
          }, genFocusStyle(token2)), {
            "&-selected": {
              color: token2.colorPrimary,
              backgroundColor: token2.controlItemBgActive,
              "&:hover, &-active": {
                backgroundColor: token2.controlItemBgActiveHover
              }
            },
            "&-disabled": {
              color: colorTextDisabled,
              cursor: "not-allowed",
              "&:hover": {
                color: colorTextDisabled,
                backgroundColor: colorBgElevated,
                cursor: "not-allowed"
              },
              a: {
                pointerEvents: "none"
              }
            },
            "&-divider": {
              height: 1,
              margin: `${token2.marginXXS}px 0`,
              overflow: "hidden",
              lineHeight: 0,
              backgroundColor: token2.colorSplit
            },
            [`${componentCls}-menu-submenu-expand-icon`]: {
              position: "absolute",
              insetInlineEnd: token2.paddingXS,
              [`${componentCls}-menu-submenu-arrow-icon`]: {
                marginInlineEnd: "0 !important",
                color: token2.colorTextDescription,
                fontSize: fontSizeIcon,
                fontStyle: "normal"
              }
            }
          }),
          [`${menuCls}-item-group-list`]: {
            margin: `0 ${token2.marginXS}px`,
            padding: 0,
            listStyle: "none"
          },
          [`${menuCls}-submenu-title`]: {
            paddingInlineEnd: controlPaddingHorizontal + token2.fontSizeSM
          },
          [`${menuCls}-submenu-vertical`]: {
            position: "relative"
          },
          [`${menuCls}-submenu${menuCls}-submenu-disabled ${componentCls}-menu-submenu-title`]: {
            [`&, ${componentCls}-menu-submenu-arrow-icon`]: {
              color: colorTextDisabled,
              backgroundColor: colorBgElevated,
              cursor: "not-allowed"
            }
          },
          // https://github.com/ant-design/ant-design/issues/19264
          [`${menuCls}-submenu-selected ${componentCls}-menu-submenu-title`]: {
            color: token2.colorPrimary
          }
        })
      }
    },
    // Follow code may reuse in other components
    [initSlideMotion(token2, "slide-up"), initSlideMotion(token2, "slide-down"), initMoveMotion(token2, "move-up"), initMoveMotion(token2, "move-down"), initZoomMotion(token2, "zoom-big")]
  ];
};
const useStyle$A = genComponentStyleHook("Dropdown", (token2, _ref) => {
  let {
    rootPrefixCls
  } = _ref;
  const {
    marginXXS,
    sizePopupArrow,
    controlHeight,
    fontSize,
    lineHeight,
    paddingXXS,
    componentCls,
    borderRadiusOuter,
    borderRadiusLG
  } = token2;
  const dropdownPaddingVertical = (controlHeight - fontSize * lineHeight) / 2;
  const {
    dropdownArrowOffset
  } = getArrowOffset({
    sizePopupArrow,
    contentRadius: borderRadiusLG,
    borderRadiusOuter
  });
  const dropdownToken = merge(token2, {
    menuCls: `${componentCls}-menu`,
    rootPrefixCls,
    dropdownArrowDistance: sizePopupArrow / 2 + marginXXS,
    dropdownArrowOffset,
    dropdownPaddingVertical,
    dropdownEdgeChildPadding: paddingXXS
  });
  return [genBaseStyle$b(dropdownToken), genButtonStyle(dropdownToken), genStatusStyle$1(dropdownToken)];
}, (token2) => ({
  zIndexPopup: token2.zIndexPopupBase + 50
}));
var __rest$U = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const ButtonGroup = Button$1.Group;
const DropdownButton = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ADropdownButton",
  inheritAttrs: false,
  __ANT_BUTTON: true,
  props: initDefaultProps(dropdownButtonProps(), {
    trigger: "hover",
    placement: "bottomRight",
    type: "default"
  }),
  // emits: ['click', 'visibleChange', 'update:visible'],s
  slots: Object,
  setup(props2, _ref) {
    let {
      slots,
      attrs,
      emit
    } = _ref;
    const handleVisibleChange = (val) => {
      emit("update:visible", val);
      emit("visibleChange", val);
      emit("update:open", val);
      emit("openChange", val);
    };
    const {
      prefixCls,
      direction,
      getPopupContainer
    } = useConfigInject("dropdown", props2);
    const buttonPrefixCls = computed(() => `${prefixCls.value}-button`);
    const [wrapSSR, hashId] = useStyle$A(prefixCls);
    return () => {
      var _a2, _b;
      const _c = _extends$1(_extends$1({}, props2), attrs), {
        type: type4 = "default",
        disabled,
        danger,
        loading,
        htmlType,
        class: className = "",
        overlay = (_a2 = slots.overlay) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
        trigger,
        align,
        open: open2,
        visible,
        onVisibleChange: _onVisibleChange,
        placement = direction.value === "rtl" ? "bottomLeft" : "bottomRight",
        href,
        title,
        icon = ((_b = slots.icon) === null || _b === void 0 ? void 0 : _b.call(slots)) || createVNode(EllipsisOutlined, null, null),
        mouseEnterDelay,
        mouseLeaveDelay,
        overlayClassName,
        overlayStyle,
        destroyPopupOnHide,
        onClick,
        "onUpdate:open": _updateVisible
      } = _c, restProps = __rest$U(_c, ["type", "disabled", "danger", "loading", "htmlType", "class", "overlay", "trigger", "align", "open", "visible", "onVisibleChange", "placement", "href", "title", "icon", "mouseEnterDelay", "mouseLeaveDelay", "overlayClassName", "overlayStyle", "destroyPopupOnHide", "onClick", "onUpdate:open"]);
      const dropdownProps2 = {
        align,
        disabled,
        trigger: disabled ? [] : trigger,
        placement,
        getPopupContainer: getPopupContainer === null || getPopupContainer === void 0 ? void 0 : getPopupContainer.value,
        onOpenChange: handleVisibleChange,
        mouseEnterDelay,
        mouseLeaveDelay,
        open: open2 !== null && open2 !== void 0 ? open2 : visible,
        overlayClassName,
        overlayStyle,
        destroyPopupOnHide
      };
      const leftButton = createVNode(Button$1, {
        "danger": danger,
        "type": type4,
        "disabled": disabled,
        "loading": loading,
        "onClick": onClick,
        "htmlType": htmlType,
        "href": href,
        "title": title
      }, {
        default: slots.default
      });
      const rightButton = createVNode(Button$1, {
        "danger": danger,
        "type": type4,
        "icon": icon
      }, null);
      return wrapSSR(createVNode(ButtonGroup, _objectSpread2$1(_objectSpread2$1({}, restProps), {}, {
        "class": classNames(buttonPrefixCls.value, className, hashId.value)
      }), {
        default: () => [slots.leftButton ? slots.leftButton({
          button: leftButton
        }) : leftButton, createVNode(Dropdown, dropdownProps2, {
          default: () => [slots.rightButton ? slots.rightButton({
            button: rightButton
          }) : rightButton],
          overlay: () => overlay
        })]
      }));
    };
  }
});
const OverrideContextKey = Symbol("OverrideContextKey");
const useInjectOverride = () => {
  return inject(OverrideContextKey, void 0);
};
const useProvideOverride = (props2) => {
  var _a2, _b, _c;
  const {
    prefixCls,
    mode,
    selectable,
    validator,
    onClick,
    expandIcon
  } = useInjectOverride() || {};
  provide(OverrideContextKey, {
    prefixCls: computed(() => {
      var _a3, _b2;
      return (_b2 = (_a3 = props2.prefixCls) === null || _a3 === void 0 ? void 0 : _a3.value) !== null && _b2 !== void 0 ? _b2 : prefixCls === null || prefixCls === void 0 ? void 0 : prefixCls.value;
    }),
    mode: computed(() => {
      var _a3, _b2;
      return (_b2 = (_a3 = props2.mode) === null || _a3 === void 0 ? void 0 : _a3.value) !== null && _b2 !== void 0 ? _b2 : mode === null || mode === void 0 ? void 0 : mode.value;
    }),
    selectable: computed(() => {
      var _a3, _b2;
      return (_b2 = (_a3 = props2.selectable) === null || _a3 === void 0 ? void 0 : _a3.value) !== null && _b2 !== void 0 ? _b2 : selectable === null || selectable === void 0 ? void 0 : selectable.value;
    }),
    validator: (_a2 = props2.validator) !== null && _a2 !== void 0 ? _a2 : validator,
    onClick: (_b = props2.onClick) !== null && _b !== void 0 ? _b : onClick,
    expandIcon: (_c = props2.expandIcon) !== null && _c !== void 0 ? _c : expandIcon === null || expandIcon === void 0 ? void 0 : expandIcon.value
  });
};
const Dropdown = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ADropdown",
  inheritAttrs: false,
  props: initDefaultProps(dropdownProps(), {
    mouseEnterDelay: 0.15,
    mouseLeaveDelay: 0.1,
    placement: "bottomLeft",
    trigger: "hover"
  }),
  // emits: ['visibleChange', 'update:visible'],
  slots: Object,
  setup(props2, _ref) {
    let {
      slots,
      attrs,
      emit
    } = _ref;
    const {
      prefixCls,
      rootPrefixCls,
      direction,
      getPopupContainer
    } = useConfigInject("dropdown", props2);
    const [wrapSSR, hashId] = useStyle$A(prefixCls);
    const transitionName2 = computed(() => {
      const {
        placement: placement2 = "",
        transitionName: transitionName22
      } = props2;
      if (transitionName22 !== void 0) {
        return transitionName22;
      }
      if (placement2.includes("top")) {
        return `${rootPrefixCls.value}-slide-down`;
      }
      return `${rootPrefixCls.value}-slide-up`;
    });
    useProvideOverride({
      prefixCls: computed(() => `${prefixCls.value}-menu`),
      expandIcon: computed(() => {
        return createVNode("span", {
          "class": `${prefixCls.value}-menu-submenu-arrow`
        }, [createVNode(RightOutlined, {
          "class": `${prefixCls.value}-menu-submenu-arrow-icon`
        }, null)]);
      }),
      mode: computed(() => "vertical"),
      selectable: computed(() => false),
      onClick: () => {
      },
      validator: (_ref3) => {
      }
    });
    const renderOverlay = () => {
      var _a2, _b, _c;
      const overlay = props2.overlay || ((_a2 = slots.overlay) === null || _a2 === void 0 ? void 0 : _a2.call(slots));
      const overlayNode = Array.isArray(overlay) ? overlay[0] : overlay;
      if (!overlayNode) return null;
      const overlayProps = overlayNode.props || {};
      devWarning(!overlayProps.mode || overlayProps.mode === "vertical", "Dropdown", `mode="${overlayProps.mode}" is not supported for Dropdown's Menu.`);
      const {
        selectable = false,
        expandIcon = (_c = (_b = overlayNode.children) === null || _b === void 0 ? void 0 : _b.expandIcon) === null || _c === void 0 ? void 0 : _c.call(_b)
      } = overlayProps;
      const overlayNodeExpandIcon = typeof expandIcon !== "undefined" && isValidElement(expandIcon) ? expandIcon : createVNode("span", {
        "class": `${prefixCls.value}-menu-submenu-arrow`
      }, [createVNode(RightOutlined, {
        "class": `${prefixCls.value}-menu-submenu-arrow-icon`
      }, null)]);
      const fixedModeOverlay = isValidElement(overlayNode) ? cloneElement(overlayNode, {
        mode: "vertical",
        selectable,
        expandIcon: () => overlayNodeExpandIcon
      }) : overlayNode;
      return fixedModeOverlay;
    };
    const placement = computed(() => {
      const placement2 = props2.placement;
      if (!placement2) {
        return direction.value === "rtl" ? "bottomRight" : "bottomLeft";
      }
      if (placement2.includes("Center")) {
        const newPlacement = placement2.slice(0, placement2.indexOf("Center"));
        devWarning(!placement2.includes("Center"), "Dropdown", `You are using '${placement2}' placement in Dropdown, which is deprecated. Try to use '${newPlacement}' instead.`);
        return newPlacement;
      }
      return placement2;
    });
    const mergedVisible = computed(() => {
      return typeof props2.visible === "boolean" ? props2.visible : props2.open;
    });
    const handleVisibleChange = (val) => {
      emit("update:visible", val);
      emit("visibleChange", val);
      emit("update:open", val);
      emit("openChange", val);
    };
    return () => {
      var _a2, _b;
      const {
        arrow,
        trigger,
        disabled,
        overlayClassName
      } = props2;
      const child = (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)[0];
      const dropdownTrigger = cloneElement(child, _extends$1({
        class: classNames((_b = child === null || child === void 0 ? void 0 : child.props) === null || _b === void 0 ? void 0 : _b.class, {
          [`${prefixCls.value}-rtl`]: direction.value === "rtl"
        }, `${prefixCls.value}-trigger`)
      }, disabled ? {
        disabled
      } : {}));
      const overlayClassNameCustomized = classNames(overlayClassName, hashId.value, {
        [`${prefixCls.value}-rtl`]: direction.value === "rtl"
      });
      const triggerActions = disabled ? [] : trigger;
      let alignPoint2;
      if (triggerActions && triggerActions.includes("contextmenu")) {
        alignPoint2 = true;
      }
      const builtinPlacements = getPlacements({
        arrowPointAtCenter: typeof arrow === "object" && arrow.pointAtCenter,
        autoAdjustOverflow: true
      });
      const dropdownProps2 = omit$1(_extends$1(_extends$1(_extends$1({}, props2), attrs), {
        visible: mergedVisible.value,
        builtinPlacements,
        overlayClassName: overlayClassNameCustomized,
        arrow: !!arrow,
        alignPoint: alignPoint2,
        prefixCls: prefixCls.value,
        getPopupContainer: getPopupContainer === null || getPopupContainer === void 0 ? void 0 : getPopupContainer.value,
        transitionName: transitionName2.value,
        trigger: triggerActions,
        onVisibleChange: handleVisibleChange,
        placement: placement.value
      }), ["overlay", "onUpdate:visible"]);
      return wrapSSR(createVNode(Dropdown$1, dropdownProps2, {
        default: () => [dropdownTrigger],
        overlay: renderOverlay
      }));
    };
  }
});
Dropdown.Button = DropdownButton;
var __rest$T = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const breadcrumbItemProps = () => ({
  prefixCls: String,
  href: String,
  separator: PropTypes.any,
  dropdownProps: objectType(),
  overlay: PropTypes.any,
  onClick: eventType()
});
const BreadcrumbItem = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ABreadcrumbItem",
  inheritAttrs: false,
  __ANT_BREADCRUMB_ITEM: true,
  props: breadcrumbItemProps(),
  // emits: ['click'],
  slots: Object,
  setup(props2, _ref) {
    let {
      slots,
      attrs,
      emit
    } = _ref;
    const {
      prefixCls
    } = useConfigInject("breadcrumb", props2);
    const renderBreadcrumbNode = (breadcrumbItem, prefixCls2) => {
      const overlay = getPropsSlot(slots, props2, "overlay");
      if (overlay) {
        return createVNode(Dropdown, _objectSpread2$1(_objectSpread2$1({}, props2.dropdownProps), {}, {
          "overlay": overlay,
          "placement": "bottom"
        }), {
          default: () => [createVNode("span", {
            "class": `${prefixCls2}-overlay-link`
          }, [breadcrumbItem, createVNode(DownOutlined, null, null)])]
        });
      }
      return breadcrumbItem;
    };
    const handleClick = (e2) => {
      emit("click", e2);
    };
    return () => {
      var _a2;
      const separator = (_a2 = getPropsSlot(slots, props2, "separator")) !== null && _a2 !== void 0 ? _a2 : "/";
      const children = getPropsSlot(slots, props2);
      const {
        class: cls,
        style
      } = attrs, restAttrs = __rest$T(attrs, ["class", "style"]);
      let link;
      if (props2.href !== void 0) {
        link = createVNode("a", _objectSpread2$1({
          "class": `${prefixCls.value}-link`,
          "onClick": handleClick
        }, restAttrs), [children]);
      } else {
        link = createVNode("span", _objectSpread2$1({
          "class": `${prefixCls.value}-link`,
          "onClick": handleClick
        }, restAttrs), [children]);
      }
      link = renderBreadcrumbNode(link, prefixCls.value);
      if (children !== void 0 && children !== null) {
        return createVNode("li", {
          "class": cls,
          "style": style
        }, [link, separator && createVNode("span", {
          "class": `${prefixCls.value}-separator`
        }, [separator])]);
      }
      return null;
    };
  }
});
function shallowEqual(objA, objB, compare, compareContext) {
  let ret = void 0;
  if (ret !== void 0) {
    return !!ret;
  }
  if (objA === objB) {
    return true;
  }
  if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
    return false;
  }
  const keysA = Object.keys(objA);
  const keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) {
    return false;
  }
  const bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
  for (let idx = 0; idx < keysA.length; idx++) {
    const key2 = keysA[idx];
    if (!bHasOwnProperty(key2)) {
      return false;
    }
    const valueA = objA[key2];
    const valueB = objB[key2];
    ret = void 0;
    if (ret === false || ret === void 0 && valueA !== valueB) {
      return false;
    }
  }
  return true;
}
function shallowequal(value, other) {
  return shallowEqual(toRaw(value), toRaw(other));
}
const MenuContextKey = Symbol("menuContextKey");
const useProvideMenu = (props2) => {
  provide(MenuContextKey, props2);
};
const useInjectMenu = () => {
  return inject(MenuContextKey);
};
const ForceRenderKey = Symbol("ForceRenderKey");
const useProvideForceRender = (forceRender) => {
  provide(ForceRenderKey, forceRender);
};
const useInjectForceRender = () => {
  return inject(ForceRenderKey, false);
};
const MenuFirstLevelContextKey = Symbol("menuFirstLevelContextKey");
const useProvideFirstLevel = (firstLevel) => {
  provide(MenuFirstLevelContextKey, firstLevel);
};
const useInjectFirstLevel = () => {
  return inject(MenuFirstLevelContextKey, true);
};
const MenuContextProvider = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "MenuContextProvider",
  inheritAttrs: false,
  props: {
    mode: {
      type: String,
      default: void 0
    },
    overflowDisabled: {
      type: Boolean,
      default: void 0
    }
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const menuContext = useInjectMenu();
    const newContext = _extends$1({}, menuContext);
    if (props2.mode !== void 0) {
      newContext.mode = toRef(props2, "mode");
    }
    if (props2.overflowDisabled !== void 0) {
      newContext.overflowDisabled = toRef(props2, "overflowDisabled");
    }
    useProvideMenu(newContext);
    return () => {
      var _a2;
      return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
    };
  }
});
const SiderCollapsedKey = Symbol("siderCollapsed");
const SiderHookProviderKey = Symbol("siderHookProvider");
const OVERFLOW_KEY = "$$__vc-menu-more__key";
const KeyPathContext = Symbol("KeyPathContext");
const useInjectKeyPath = () => {
  return inject(KeyPathContext, {
    parentEventKeys: computed(() => []),
    parentKeys: computed(() => []),
    parentInfo: {}
  });
};
const useProvideKeyPath = (eventKey, key2, menuInfo) => {
  const {
    parentEventKeys,
    parentKeys
  } = useInjectKeyPath();
  const eventKeys = computed(() => [...parentEventKeys.value, eventKey]);
  const keys2 = computed(() => [...parentKeys.value, key2]);
  provide(KeyPathContext, {
    parentEventKeys: eventKeys,
    parentKeys: keys2,
    parentInfo: menuInfo
  });
  return keys2;
};
const measure$1 = Symbol("measure");
const PathContext = defineComponent({
  compatConfig: {
    MODE: 3
  },
  setup(_props, _ref) {
    let {
      slots
    } = _ref;
    provide(measure$1, true);
    return () => {
      var _a2;
      return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
    };
  }
});
const useMeasure = () => {
  return inject(measure$1, false);
};
function useDirectionStyle(level) {
  const {
    mode,
    rtl: rtl2,
    inlineIndent
  } = useInjectMenu();
  return computed(() => mode.value !== "inline" ? null : rtl2.value ? {
    paddingRight: `${level.value * inlineIndent.value}px`
  } : {
    paddingLeft: `${level.value * inlineIndent.value}px`
  });
}
let indexGuid$3 = 0;
const menuItemProps = () => ({
  id: String,
  role: String,
  disabled: Boolean,
  danger: Boolean,
  title: {
    type: [String, Boolean],
    default: void 0
  },
  icon: PropTypes.any,
  onMouseenter: Function,
  onMouseleave: Function,
  onClick: Function,
  onKeydown: Function,
  onFocus: Function,
  // Internal user prop
  originItemValue: objectType()
});
const MenuItem$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AMenuItem",
  inheritAttrs: false,
  props: menuItemProps(),
  slots: Object,
  setup(props2, _ref) {
    let {
      slots,
      emit,
      attrs
    } = _ref;
    const instance = getCurrentInstance();
    const isMeasure = useMeasure();
    const key2 = typeof instance.vnode.key === "symbol" ? String(instance.vnode.key) : instance.vnode.key;
    devWarning(typeof instance.vnode.key !== "symbol", "MenuItem", `MenuItem \`:key="${String(key2)}"\` not support Symbol type`);
    const eventKey = `menu_item_${++indexGuid$3}_$$_${key2}`;
    const {
      parentEventKeys,
      parentKeys
    } = useInjectKeyPath();
    const {
      prefixCls,
      activeKeys,
      disabled,
      changeActiveKeys,
      rtl: rtl2,
      inlineCollapsed,
      siderCollapsed,
      onItemClick,
      selectedKeys,
      registerMenuInfo,
      unRegisterMenuInfo
    } = useInjectMenu();
    const firstLevel = useInjectFirstLevel();
    const isActive = shallowRef(false);
    const keysPath = computed(() => {
      return [...parentKeys.value, key2];
    });
    const menuInfo = {
      eventKey,
      key: key2,
      parentEventKeys,
      parentKeys,
      isLeaf: true
    };
    registerMenuInfo(eventKey, menuInfo);
    onBeforeUnmount(() => {
      unRegisterMenuInfo(eventKey);
    });
    watch(activeKeys, () => {
      isActive.value = !!activeKeys.value.find((val) => val === key2);
    }, {
      immediate: true
    });
    const mergedDisabled = computed(() => disabled.value || props2.disabled);
    const selected = computed(() => selectedKeys.value.includes(key2));
    const classNames2 = computed(() => {
      const itemCls = `${prefixCls.value}-item`;
      return {
        [`${itemCls}`]: true,
        [`${itemCls}-danger`]: props2.danger,
        [`${itemCls}-active`]: isActive.value,
        [`${itemCls}-selected`]: selected.value,
        [`${itemCls}-disabled`]: mergedDisabled.value
      };
    });
    const getEventInfo = (e2) => {
      return {
        key: key2,
        eventKey,
        keyPath: keysPath.value,
        eventKeyPath: [...parentEventKeys.value, eventKey],
        domEvent: e2,
        item: _extends$1(_extends$1({}, props2), attrs)
      };
    };
    const onInternalClick = (e2) => {
      if (mergedDisabled.value) {
        return;
      }
      const info = getEventInfo(e2);
      emit("click", e2);
      onItemClick(info);
    };
    const onMouseEnter = (event) => {
      if (!mergedDisabled.value) {
        changeActiveKeys(keysPath.value);
        emit("mouseenter", event);
      }
    };
    const onMouseLeave = (event) => {
      if (!mergedDisabled.value) {
        changeActiveKeys([]);
        emit("mouseleave", event);
      }
    };
    const onInternalKeyDown = (e2) => {
      emit("keydown", e2);
      if (e2.which === KeyCode.ENTER) {
        const info = getEventInfo(e2);
        emit("click", e2);
        onItemClick(info);
      }
    };
    const onInternalFocus = (e2) => {
      changeActiveKeys(keysPath.value);
      emit("focus", e2);
    };
    const renderItemChildren = (icon, children) => {
      const wrapNode = createVNode("span", {
        "class": `${prefixCls.value}-title-content`
      }, [children]);
      if (!icon || isValidElement(children) && children.type === "span") {
        if (inlineCollapsed.value && firstLevel && typeof children === "string") {
          return createVNode("div", {
            "class": `${prefixCls.value}-inline-collapsed-noicon`
          }, [children.charAt(0)]);
        }
      }
      return wrapNode;
    };
    const directionStyle = useDirectionStyle(computed(() => keysPath.value.length));
    return () => {
      var _a2, _b, _c, _d, _e;
      if (isMeasure) return null;
      const title = (_a2 = props2.title) !== null && _a2 !== void 0 ? _a2 : (_b = slots.title) === null || _b === void 0 ? void 0 : _b.call(slots);
      const children = flattenChildren((_c = slots.default) === null || _c === void 0 ? void 0 : _c.call(slots));
      const childrenLength = children.length;
      let tooltipTitle = title;
      if (typeof title === "undefined") {
        tooltipTitle = firstLevel && childrenLength ? children : "";
      } else if (title === false) {
        tooltipTitle = "";
      }
      const tooltipProps2 = {
        title: tooltipTitle
      };
      if (!siderCollapsed.value && !inlineCollapsed.value) {
        tooltipProps2.title = null;
        tooltipProps2.open = false;
      }
      const optionRoleProps = {};
      if (props2.role === "option") {
        optionRoleProps["aria-selected"] = selected.value;
      }
      const icon = (_d = props2.icon) !== null && _d !== void 0 ? _d : (_e = slots.icon) === null || _e === void 0 ? void 0 : _e.call(slots, props2);
      return createVNode(Tooltip, _objectSpread2$1(_objectSpread2$1({}, tooltipProps2), {}, {
        "placement": rtl2.value ? "left" : "right",
        "overlayClassName": `${prefixCls.value}-inline-collapsed-tooltip`
      }), {
        default: () => [createVNode(Overflow.Item, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
          "component": "li"
        }, attrs), {}, {
          "id": props2.id,
          "style": _extends$1(_extends$1({}, attrs.style || {}), directionStyle.value),
          "class": [classNames2.value, {
            [`${attrs.class}`]: !!attrs.class,
            [`${prefixCls.value}-item-only-child`]: (icon ? childrenLength + 1 : childrenLength) === 1
          }],
          "role": props2.role || "menuitem",
          "tabindex": props2.disabled ? null : -1,
          "data-menu-id": key2,
          "aria-disabled": props2.disabled
        }, optionRoleProps), {}, {
          "onMouseenter": onMouseEnter,
          "onMouseleave": onMouseLeave,
          "onClick": onInternalClick,
          "onKeydown": onInternalKeyDown,
          "onFocus": onInternalFocus,
          "title": typeof title === "string" ? title : void 0
        }), {
          default: () => [cloneElement(typeof icon === "function" ? icon(props2.originItemValue) : icon, {
            class: `${prefixCls.value}-item-icon`
          }, false), renderItemChildren(icon, children)]
        })]
      });
    };
  }
});
const autoAdjustOverflow = {
  adjustX: 1,
  adjustY: 1
};
const placements = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflow,
    offset: [0, -7]
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflow,
    offset: [0, 7]
  },
  leftTop: {
    points: ["tr", "tl"],
    overflow: autoAdjustOverflow,
    offset: [-4, 0]
  },
  rightTop: {
    points: ["tl", "tr"],
    overflow: autoAdjustOverflow,
    offset: [4, 0]
  }
};
const placementsRtl = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflow,
    offset: [0, -7]
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflow,
    offset: [0, 7]
  },
  rightTop: {
    points: ["tr", "tl"],
    overflow: autoAdjustOverflow,
    offset: [-4, 0]
  },
  leftTop: {
    points: ["tl", "tr"],
    overflow: autoAdjustOverflow,
    offset: [4, 0]
  }
};
const popupPlacementMap = {
  horizontal: "bottomLeft",
  vertical: "rightTop",
  "vertical-left": "rightTop",
  "vertical-right": "leftTop"
};
const PopupTrigger = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "PopupTrigger",
  inheritAttrs: false,
  props: {
    prefixCls: String,
    mode: String,
    visible: Boolean,
    // popup: React.ReactNode;
    popupClassName: String,
    popupOffset: Array,
    disabled: Boolean,
    onVisibleChange: Function
  },
  slots: Object,
  emits: ["visibleChange"],
  setup(props2, _ref) {
    let {
      slots,
      emit
    } = _ref;
    const innerVisible = shallowRef(false);
    const {
      getPopupContainer,
      rtl: rtl2,
      subMenuOpenDelay,
      subMenuCloseDelay,
      builtinPlacements,
      triggerSubMenuAction,
      forceSubMenuRender,
      motion,
      defaultMotions,
      rootClassName
    } = useInjectMenu();
    const forceRender = useInjectForceRender();
    const placement = computed(() => rtl2.value ? _extends$1(_extends$1({}, placementsRtl), builtinPlacements.value) : _extends$1(_extends$1({}, placements), builtinPlacements.value));
    const popupPlacement = computed(() => popupPlacementMap[props2.mode]);
    const visibleRef = shallowRef();
    watch(() => props2.visible, (visible) => {
      wrapperRaf.cancel(visibleRef.value);
      visibleRef.value = wrapperRaf(() => {
        innerVisible.value = visible;
      });
    }, {
      immediate: true
    });
    onBeforeUnmount(() => {
      wrapperRaf.cancel(visibleRef.value);
    });
    const onVisibleChange = (visible) => {
      emit("visibleChange", visible);
    };
    const mergedMotion = computed(() => {
      var _a2, _b;
      const m2 = motion.value || ((_a2 = defaultMotions.value) === null || _a2 === void 0 ? void 0 : _a2[props2.mode]) || ((_b = defaultMotions.value) === null || _b === void 0 ? void 0 : _b.other);
      const res = typeof m2 === "function" ? m2() : m2;
      return res ? getTransitionProps(res.name, {
        css: true
      }) : void 0;
    });
    return () => {
      const {
        prefixCls,
        popupClassName,
        mode,
        popupOffset,
        disabled
      } = props2;
      return createVNode(Trigger, {
        "prefixCls": prefixCls,
        "popupClassName": classNames(`${prefixCls}-popup`, {
          [`${prefixCls}-rtl`]: rtl2.value
        }, popupClassName, rootClassName.value),
        "stretch": mode === "horizontal" ? "minWidth" : null,
        "getPopupContainer": getPopupContainer.value,
        "builtinPlacements": placement.value,
        "popupPlacement": popupPlacement.value,
        "popupVisible": innerVisible.value,
        "popupAlign": popupOffset && {
          offset: popupOffset
        },
        "action": disabled ? [] : [triggerSubMenuAction.value],
        "mouseEnterDelay": subMenuOpenDelay.value,
        "mouseLeaveDelay": subMenuCloseDelay.value,
        "onPopupVisibleChange": onVisibleChange,
        "forceRender": forceRender || forceSubMenuRender.value,
        "popupAnimation": mergedMotion.value
      }, {
        popup: slots.popup,
        default: slots.default
      });
    };
  }
});
const InternalSubMenuList = (_props, _ref) => {
  let {
    slots,
    attrs
  } = _ref;
  var _a2;
  const {
    prefixCls,
    mode
  } = useInjectMenu();
  return createVNode("ul", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
    "class": classNames(prefixCls.value, `${prefixCls.value}-sub`, `${prefixCls.value}-${mode.value === "inline" ? "inline" : "vertical"}`),
    "data-menu-list": true
  }), [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]);
};
InternalSubMenuList.displayName = "SubMenuList";
const InlineSubMenuList = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "InlineSubMenuList",
  inheritAttrs: false,
  props: {
    id: String,
    open: Boolean,
    keyPath: Array
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const fixedMode = computed(() => "inline");
    const {
      motion,
      mode,
      defaultMotions
    } = useInjectMenu();
    const sameModeRef = computed(() => mode.value === fixedMode.value);
    const destroy = ref(!sameModeRef.value);
    const mergedOpen = computed(() => sameModeRef.value ? props2.open : false);
    watch(mode, () => {
      if (sameModeRef.value) {
        destroy.value = false;
      }
    }, {
      flush: "post"
    });
    const mergedMotion = computed(() => {
      var _a2, _b;
      const m2 = motion.value || ((_a2 = defaultMotions.value) === null || _a2 === void 0 ? void 0 : _a2[fixedMode.value]) || ((_b = defaultMotions.value) === null || _b === void 0 ? void 0 : _b.other);
      const res = typeof m2 === "function" ? m2() : m2;
      return _extends$1(_extends$1({}, res), {
        appear: props2.keyPath.length <= 1
      });
    });
    return () => {
      var _a2;
      if (destroy.value) {
        return null;
      }
      return createVNode(MenuContextProvider, {
        "mode": fixedMode.value
      }, {
        default: () => [createVNode(Transition, mergedMotion.value, {
          default: () => [withDirectives(createVNode(InternalSubMenuList, {
            "id": props2.id
          }, {
            default: () => [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]
          }), [[vShow, mergedOpen.value]])]
        })]
      });
    };
  }
});
let indexGuid$2 = 0;
const subMenuProps = () => ({
  icon: PropTypes.any,
  title: PropTypes.any,
  disabled: Boolean,
  level: Number,
  popupClassName: String,
  popupOffset: Array,
  internalPopupClose: Boolean,
  eventKey: String,
  expandIcon: Function,
  theme: String,
  onMouseenter: Function,
  onMouseleave: Function,
  onTitleClick: Function,
  // Internal user prop
  originItemValue: objectType()
});
const SubMenu$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ASubMenu",
  inheritAttrs: false,
  props: subMenuProps(),
  slots: Object,
  setup(props2, _ref) {
    let {
      slots,
      attrs,
      emit
    } = _ref;
    var _a2, _b;
    useProvideFirstLevel(false);
    const isMeasure = useMeasure();
    const instance = getCurrentInstance();
    const vnodeKey = typeof instance.vnode.key === "symbol" ? String(instance.vnode.key) : instance.vnode.key;
    devWarning(typeof instance.vnode.key !== "symbol", "SubMenu", `SubMenu \`:key="${String(vnodeKey)}"\` not support Symbol type`);
    const key2 = isValid$2(vnodeKey) ? vnodeKey : `sub_menu_${++indexGuid$2}_$$_not_set_key`;
    const eventKey = (_a2 = props2.eventKey) !== null && _a2 !== void 0 ? _a2 : isValid$2(vnodeKey) ? `sub_menu_${++indexGuid$2}_$$_${vnodeKey}` : key2;
    const {
      parentEventKeys,
      parentInfo,
      parentKeys
    } = useInjectKeyPath();
    const keysPath = computed(() => [...parentKeys.value, key2]);
    const childrenEventKeys = shallowRef([]);
    const menuInfo = {
      eventKey,
      key: key2,
      parentEventKeys,
      childrenEventKeys,
      parentKeys
    };
    (_b = parentInfo.childrenEventKeys) === null || _b === void 0 ? void 0 : _b.value.push(eventKey);
    onBeforeUnmount(() => {
      var _a3;
      if (parentInfo.childrenEventKeys) {
        parentInfo.childrenEventKeys.value = (_a3 = parentInfo.childrenEventKeys) === null || _a3 === void 0 ? void 0 : _a3.value.filter((k2) => k2 != eventKey);
      }
    });
    useProvideKeyPath(eventKey, key2, menuInfo);
    const {
      prefixCls,
      activeKeys,
      disabled: contextDisabled,
      changeActiveKeys,
      mode,
      inlineCollapsed,
      openKeys,
      overflowDisabled,
      onOpenChange,
      registerMenuInfo,
      unRegisterMenuInfo,
      selectedSubMenuKeys,
      expandIcon: menuExpandIcon,
      theme: theme2
    } = useInjectMenu();
    const hasKey = vnodeKey !== void 0 && vnodeKey !== null;
    const forceRender = !isMeasure && (useInjectForceRender() || !hasKey);
    useProvideForceRender(forceRender);
    if (isMeasure && hasKey || !isMeasure && !hasKey || forceRender) {
      registerMenuInfo(eventKey, menuInfo);
      onBeforeUnmount(() => {
        unRegisterMenuInfo(eventKey);
      });
    }
    const subMenuPrefixCls = computed(() => `${prefixCls.value}-submenu`);
    const mergedDisabled = computed(() => contextDisabled.value || props2.disabled);
    const elementRef = shallowRef();
    const popupRef = shallowRef();
    const originOpen = computed(() => openKeys.value.includes(key2));
    const open2 = computed(() => !overflowDisabled.value && originOpen.value);
    const childrenSelected = computed(() => {
      return selectedSubMenuKeys.value.includes(key2);
    });
    const isActive = shallowRef(false);
    watch(activeKeys, () => {
      isActive.value = !!activeKeys.value.find((val) => val === key2);
    }, {
      immediate: true
    });
    const onInternalTitleClick = (e2) => {
      if (mergedDisabled.value) {
        return;
      }
      emit("titleClick", e2, key2);
      if (mode.value === "inline") {
        onOpenChange(key2, !originOpen.value);
      }
    };
    const onMouseEnter = (event) => {
      if (!mergedDisabled.value) {
        changeActiveKeys(keysPath.value);
        emit("mouseenter", event);
      }
    };
    const onMouseLeave = (event) => {
      if (!mergedDisabled.value) {
        changeActiveKeys([]);
        emit("mouseleave", event);
      }
    };
    const directionStyle = useDirectionStyle(computed(() => keysPath.value.length));
    const onPopupVisibleChange = (newVisible) => {
      if (mode.value !== "inline") {
        onOpenChange(key2, newVisible);
      }
    };
    const onInternalFocus = () => {
      changeActiveKeys(keysPath.value);
    };
    const popupId = eventKey && `${eventKey}-popup`;
    const popupClassName = computed(() => classNames(prefixCls.value, `${prefixCls.value}-${props2.theme || theme2.value}`, props2.popupClassName));
    const renderTitle = (title, icon) => {
      if (!icon) {
        return inlineCollapsed.value && !parentKeys.value.length && title && typeof title === "string" ? createVNode("div", {
          "class": `${prefixCls.value}-inline-collapsed-noicon`
        }, [title.charAt(0)]) : createVNode("span", {
          "class": `${prefixCls.value}-title-content`
        }, [title]);
      }
      const titleIsSpan = isValidElement(title) && title.type === "span";
      return createVNode(Fragment, null, [cloneElement(typeof icon === "function" ? icon(props2.originItemValue) : icon, {
        class: `${prefixCls.value}-item-icon`
      }, false), titleIsSpan ? title : createVNode("span", {
        "class": `${prefixCls.value}-title-content`
      }, [title])]);
    };
    const triggerModeRef = computed(() => {
      return mode.value !== "inline" && keysPath.value.length > 1 ? "vertical" : mode.value;
    });
    const renderMode = computed(() => mode.value === "horizontal" ? "vertical" : mode.value);
    const subMenuTriggerModeRef = computed(() => triggerModeRef.value === "horizontal" ? "vertical" : triggerModeRef.value);
    const baseTitleNode = () => {
      var _a3, _b2;
      const subMenuPrefixClsValue = subMenuPrefixCls.value;
      const icon = (_a3 = props2.icon) !== null && _a3 !== void 0 ? _a3 : (_b2 = slots.icon) === null || _b2 === void 0 ? void 0 : _b2.call(slots, props2);
      const expandIcon = props2.expandIcon || slots.expandIcon || menuExpandIcon.value;
      const title = renderTitle(getPropsSlot(slots, props2, "title"), icon);
      return createVNode("div", {
        "style": directionStyle.value,
        "class": `${subMenuPrefixClsValue}-title`,
        "tabindex": mergedDisabled.value ? null : -1,
        "ref": elementRef,
        "title": typeof title === "string" ? title : null,
        "data-menu-id": key2,
        "aria-expanded": open2.value,
        "aria-haspopup": true,
        "aria-controls": popupId,
        "aria-disabled": mergedDisabled.value,
        "onClick": onInternalTitleClick,
        "onFocus": onInternalFocus
      }, [title, mode.value !== "horizontal" && expandIcon ? expandIcon(_extends$1(_extends$1({}, props2), {
        isOpen: open2.value
      })) : createVNode("i", {
        "class": `${subMenuPrefixClsValue}-arrow`
      }, null)]);
    };
    return () => {
      var _a3;
      if (isMeasure) {
        if (!hasKey) {
          return null;
        }
        return (_a3 = slots.default) === null || _a3 === void 0 ? void 0 : _a3.call(slots);
      }
      const subMenuPrefixClsValue = subMenuPrefixCls.value;
      let titleNode = () => null;
      if (!overflowDisabled.value && mode.value !== "inline") {
        const popupOffset = mode.value === "horizontal" ? [0, 8] : [10, 0];
        titleNode = () => createVNode(PopupTrigger, {
          "mode": triggerModeRef.value,
          "prefixCls": subMenuPrefixClsValue,
          "visible": !props2.internalPopupClose && open2.value,
          "popupClassName": popupClassName.value,
          "popupOffset": props2.popupOffset || popupOffset,
          "disabled": mergedDisabled.value,
          "onVisibleChange": onPopupVisibleChange
        }, {
          default: () => [baseTitleNode()],
          popup: () => createVNode(MenuContextProvider, {
            "mode": subMenuTriggerModeRef.value
          }, {
            default: () => [createVNode(InternalSubMenuList, {
              "id": popupId,
              "ref": popupRef
            }, {
              default: slots.default
            })]
          })
        });
      } else {
        titleNode = () => createVNode(PopupTrigger, null, {
          default: baseTitleNode
        });
      }
      return createVNode(MenuContextProvider, {
        "mode": renderMode.value
      }, {
        default: () => [createVNode(Overflow.Item, _objectSpread2$1(_objectSpread2$1({
          "component": "li"
        }, attrs), {}, {
          "role": "none",
          "class": classNames(subMenuPrefixClsValue, `${subMenuPrefixClsValue}-${mode.value}`, attrs.class, {
            [`${subMenuPrefixClsValue}-open`]: open2.value,
            [`${subMenuPrefixClsValue}-active`]: isActive.value,
            [`${subMenuPrefixClsValue}-selected`]: childrenSelected.value,
            [`${subMenuPrefixClsValue}-disabled`]: mergedDisabled.value
          }),
          "onMouseenter": onMouseEnter,
          "onMouseleave": onMouseLeave,
          "data-submenu-id": key2
        }), {
          default: () => {
            return createVNode(Fragment, null, [titleNode(), !overflowDisabled.value && createVNode(InlineSubMenuList, {
              "id": popupId,
              "open": open2.value,
              "keyPath": keysPath.value
            }, {
              default: slots.default
            })]);
          }
        })]
      });
    };
  }
});
function hasClass(node2, className) {
  if (node2.classList) {
    return node2.classList.contains(className);
  }
  const originClass = node2.className;
  return ` ${originClass} `.indexOf(` ${className} `) > -1;
}
function addClass(node2, className) {
  if (node2.classList) {
    node2.classList.add(className);
  } else {
    if (!hasClass(node2, className)) {
      node2.className = `${node2.className} ${className}`;
    }
  }
}
function removeClass(node2, className) {
  if (node2.classList) {
    node2.classList.remove(className);
  } else {
    if (hasClass(node2, className)) {
      const originClass = node2.className;
      node2.className = ` ${originClass} `.replace(` ${className} `, " ");
    }
  }
}
const collapseMotion = function() {
  let name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "ant-motion-collapse";
  let appear = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  return {
    name,
    appear,
    css: true,
    onBeforeEnter: (node2) => {
      node2.style.height = "0px";
      node2.style.opacity = "0";
      addClass(node2, name);
    },
    onEnter: (node2) => {
      nextTick(() => {
        node2.style.height = `${node2.scrollHeight}px`;
        node2.style.opacity = "1";
      });
    },
    onAfterEnter: (node2) => {
      if (node2) {
        removeClass(node2, name);
        node2.style.height = null;
        node2.style.opacity = null;
      }
    },
    onBeforeLeave: (node2) => {
      addClass(node2, name);
      node2.style.height = `${node2.offsetHeight}px`;
      node2.style.opacity = null;
    },
    onLeave: (node2) => {
      setTimeout(() => {
        node2.style.height = "0px";
        node2.style.opacity = "0";
      });
    },
    onAfterLeave: (node2) => {
      if (node2) {
        removeClass(node2, name);
        if (node2.style) {
          node2.style.height = null;
          node2.style.opacity = null;
        }
      }
    }
  };
};
const menuItemGroupProps = () => ({
  title: PropTypes.any,
  // Internal user prop
  originItemValue: objectType()
});
const ItemGroup = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AMenuItemGroup",
  inheritAttrs: false,
  props: menuItemGroupProps(),
  slots: Object,
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const {
      prefixCls
    } = useInjectMenu();
    const groupPrefixCls = computed(() => `${prefixCls.value}-item-group`);
    const isMeasure = useMeasure();
    return () => {
      var _a2, _b;
      if (isMeasure) return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
      return createVNode("li", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "onClick": (e2) => e2.stopPropagation(),
        "class": groupPrefixCls.value
      }), [createVNode("div", {
        "title": typeof props2.title === "string" ? props2.title : void 0,
        "class": `${groupPrefixCls.value}-title`
      }, [getPropsSlot(slots, props2, "title")]), createVNode("ul", {
        "class": `${groupPrefixCls.value}-list`
      }, [(_b = slots.default) === null || _b === void 0 ? void 0 : _b.call(slots)])]);
    };
  }
});
const menuDividerProps = () => ({
  prefixCls: String,
  dashed: Boolean
});
const Divider$2 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AMenuDivider",
  props: menuDividerProps(),
  setup(props2) {
    const {
      prefixCls
    } = useInjectMenu();
    const cls = computed(() => {
      return {
        [`${prefixCls.value}-item-divider`]: true,
        [`${prefixCls.value}-item-divider-dashed`]: !!props2.dashed
      };
    });
    return () => {
      return createVNode("li", {
        "class": cls.value
      }, null);
    };
  }
});
var __rest$S = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
function convertItemsToNodes(list, store, parentMenuInfo) {
  return (list || []).map((opt, index2) => {
    if (opt && typeof opt === "object") {
      const _a2 = opt, {
        label,
        children,
        key: key2,
        type: type4
      } = _a2, restProps = __rest$S(_a2, ["label", "children", "key", "type"]);
      const mergedKey = key2 !== null && key2 !== void 0 ? key2 : `tmp-${index2}`;
      const parentKeys = parentMenuInfo ? parentMenuInfo.parentKeys.slice() : [];
      const childrenEventKeys = [];
      const menuInfo = {
        eventKey: mergedKey,
        key: mergedKey,
        parentEventKeys: ref(parentKeys),
        parentKeys: ref(parentKeys),
        childrenEventKeys: ref(childrenEventKeys),
        isLeaf: false
      };
      if (children || type4 === "group") {
        if (type4 === "group") {
          const childrenNodes2 = convertItemsToNodes(children, store, parentMenuInfo);
          return createVNode(ItemGroup, _objectSpread2$1(_objectSpread2$1({
            "key": mergedKey
          }, restProps), {}, {
            "title": label,
            "originItemValue": opt
          }), {
            default: () => [childrenNodes2]
          });
        }
        store.set(mergedKey, menuInfo);
        if (parentMenuInfo) {
          parentMenuInfo.childrenEventKeys.push(mergedKey);
        }
        const childrenNodes = convertItemsToNodes(children, store, {
          childrenEventKeys,
          parentKeys: [].concat(parentKeys, mergedKey)
        });
        return createVNode(SubMenu$1, _objectSpread2$1(_objectSpread2$1({
          "key": mergedKey
        }, restProps), {}, {
          "title": label,
          "originItemValue": opt
        }), {
          default: () => [childrenNodes]
        });
      }
      if (type4 === "divider") {
        return createVNode(Divider$2, _objectSpread2$1({
          "key": mergedKey
        }, restProps), null);
      }
      menuInfo.isLeaf = true;
      store.set(mergedKey, menuInfo);
      return createVNode(MenuItem$1, _objectSpread2$1(_objectSpread2$1({
        "key": mergedKey
      }, restProps), {}, {
        "originItemValue": opt
      }), {
        default: () => [label]
      });
    }
    return null;
  }).filter((opt) => opt);
}
function useItems(props2) {
  const itemsNodes = shallowRef([]);
  const hasItmes = shallowRef(false);
  const store = shallowRef(/* @__PURE__ */ new Map());
  watch(() => props2.items, () => {
    const newStore = /* @__PURE__ */ new Map();
    hasItmes.value = false;
    if (props2.items) {
      hasItmes.value = true;
      itemsNodes.value = convertItemsToNodes(props2.items, newStore);
    } else {
      itemsNodes.value = void 0;
    }
    store.value = newStore;
  }, {
    immediate: true,
    deep: true
  });
  return {
    itemsNodes,
    store,
    hasItmes
  };
}
const getHorizontalStyle = (token2) => {
  const {
    componentCls,
    motionDurationSlow,
    menuHorizontalHeight,
    colorSplit,
    lineWidth,
    lineType,
    menuItemPaddingInline
  } = token2;
  return {
    [`${componentCls}-horizontal`]: {
      lineHeight: `${menuHorizontalHeight}px`,
      border: 0,
      borderBottom: `${lineWidth}px ${lineType} ${colorSplit}`,
      boxShadow: "none",
      "&::after": {
        display: "block",
        clear: "both",
        height: 0,
        content: '"\\20"'
      },
      // ======================= Item =======================
      [`${componentCls}-item, ${componentCls}-submenu`]: {
        position: "relative",
        display: "inline-block",
        verticalAlign: "bottom",
        paddingInline: menuItemPaddingInline
      },
      [`> ${componentCls}-item:hover,
        > ${componentCls}-item-active,
        > ${componentCls}-submenu ${componentCls}-submenu-title:hover`]: {
        backgroundColor: "transparent"
      },
      [`${componentCls}-item, ${componentCls}-submenu-title`]: {
        transition: [`border-color ${motionDurationSlow}`, `background ${motionDurationSlow}`].join(",")
      },
      // ===================== Sub Menu =====================
      [`${componentCls}-submenu-arrow`]: {
        display: "none"
      }
    }
  };
};
const getRTLStyle = (_ref) => {
  let {
    componentCls,
    menuArrowOffset
  } = _ref;
  return {
    [`${componentCls}-rtl`]: {
      direction: "rtl"
    },
    [`${componentCls}-submenu-rtl`]: {
      transformOrigin: "100% 0"
    },
    // Vertical Arrow
    [`${componentCls}-rtl${componentCls}-vertical,
    ${componentCls}-submenu-rtl ${componentCls}-vertical`]: {
      [`${componentCls}-submenu-arrow`]: {
        "&::before": {
          transform: `rotate(-45deg) translateY(-${menuArrowOffset})`
        },
        "&::after": {
          transform: `rotate(45deg) translateY(${menuArrowOffset})`
        }
      }
    }
  };
};
const accessibilityFocus = (token2) => _extends$1({}, genFocusOutline(token2));
const getThemeStyle = (token2, themeSuffix) => {
  const {
    componentCls,
    colorItemText,
    colorItemTextSelected,
    colorGroupTitle,
    colorItemBg,
    colorSubItemBg,
    colorItemBgSelected,
    colorActiveBarHeight,
    colorActiveBarWidth,
    colorActiveBarBorderSize,
    motionDurationSlow,
    motionEaseInOut,
    motionEaseOut,
    menuItemPaddingInline,
    motionDurationMid,
    colorItemTextHover,
    lineType,
    colorSplit,
    // Disabled
    colorItemTextDisabled,
    // Danger
    colorDangerItemText,
    colorDangerItemTextHover,
    colorDangerItemTextSelected,
    colorDangerItemBgActive,
    colorDangerItemBgSelected,
    colorItemBgHover,
    menuSubMenuBg,
    // Horizontal
    colorItemTextSelectedHorizontal,
    colorItemBgSelectedHorizontal
  } = token2;
  return {
    [`${componentCls}-${themeSuffix}`]: {
      color: colorItemText,
      background: colorItemBg,
      [`&${componentCls}-root:focus-visible`]: _extends$1({}, accessibilityFocus(token2)),
      // ======================== Item ========================
      [`${componentCls}-item-group-title`]: {
        color: colorGroupTitle
      },
      [`${componentCls}-submenu-selected`]: {
        [`> ${componentCls}-submenu-title`]: {
          color: colorItemTextSelected
        }
      },
      // Disabled
      [`${componentCls}-item-disabled, ${componentCls}-submenu-disabled`]: {
        color: `${colorItemTextDisabled} !important`
      },
      // Hover
      [`${componentCls}-item:hover, ${componentCls}-submenu-title:hover`]: {
        [`&:not(${componentCls}-item-selected):not(${componentCls}-submenu-selected)`]: {
          color: colorItemTextHover
        }
      },
      [`&:not(${componentCls}-horizontal)`]: {
        [`${componentCls}-item:not(${componentCls}-item-selected)`]: {
          "&:hover": {
            backgroundColor: colorItemBgHover
          },
          "&:active": {
            backgroundColor: colorItemBgSelected
          }
        },
        [`${componentCls}-submenu-title`]: {
          "&:hover": {
            backgroundColor: colorItemBgHover
          },
          "&:active": {
            backgroundColor: colorItemBgSelected
          }
        }
      },
      // Danger - only Item has
      [`${componentCls}-item-danger`]: {
        color: colorDangerItemText,
        [`&${componentCls}-item:hover`]: {
          [`&:not(${componentCls}-item-selected):not(${componentCls}-submenu-selected)`]: {
            color: colorDangerItemTextHover
          }
        },
        [`&${componentCls}-item:active`]: {
          background: colorDangerItemBgActive
        }
      },
      [`${componentCls}-item a`]: {
        "&, &:hover": {
          color: "inherit"
        }
      },
      [`${componentCls}-item-selected`]: {
        color: colorItemTextSelected,
        // Danger
        [`&${componentCls}-item-danger`]: {
          color: colorDangerItemTextSelected
        },
        [`a, a:hover`]: {
          color: "inherit"
        }
      },
      [`& ${componentCls}-item-selected`]: {
        backgroundColor: colorItemBgSelected,
        // Danger
        [`&${componentCls}-item-danger`]: {
          backgroundColor: colorDangerItemBgSelected
        }
      },
      [`${componentCls}-item, ${componentCls}-submenu-title`]: {
        [`&:not(${componentCls}-item-disabled):focus-visible`]: _extends$1({}, accessibilityFocus(token2))
      },
      [`&${componentCls}-submenu > ${componentCls}`]: {
        backgroundColor: menuSubMenuBg
      },
      [`&${componentCls}-popup > ${componentCls}`]: {
        backgroundColor: colorItemBg
      },
      // ====================== Horizontal ======================
      [`&${componentCls}-horizontal`]: _extends$1(_extends$1({}, themeSuffix === "dark" ? {
        borderBottom: 0
      } : {}), {
        [`> ${componentCls}-item, > ${componentCls}-submenu`]: {
          top: colorActiveBarBorderSize,
          marginTop: -colorActiveBarBorderSize,
          marginBottom: 0,
          borderRadius: 0,
          "&::after": {
            position: "absolute",
            insetInline: menuItemPaddingInline,
            bottom: 0,
            borderBottom: `${colorActiveBarHeight}px solid transparent`,
            transition: `border-color ${motionDurationSlow} ${motionEaseInOut}`,
            content: '""'
          },
          [`&:hover, &-active, &-open`]: {
            "&::after": {
              borderBottomWidth: colorActiveBarHeight,
              borderBottomColor: colorItemTextSelectedHorizontal
            }
          },
          [`&-selected`]: {
            color: colorItemTextSelectedHorizontal,
            backgroundColor: colorItemBgSelectedHorizontal,
            "&::after": {
              borderBottomWidth: colorActiveBarHeight,
              borderBottomColor: colorItemTextSelectedHorizontal
            }
          }
        }
      }),
      // ================== Inline & Vertical ===================
      //
      [`&${componentCls}-root`]: {
        [`&${componentCls}-inline, &${componentCls}-vertical`]: {
          borderInlineEnd: `${colorActiveBarBorderSize}px ${lineType} ${colorSplit}`
        }
      },
      // ======================== Inline ========================
      [`&${componentCls}-inline`]: {
        // Sub
        [`${componentCls}-sub${componentCls}-inline`]: {
          background: colorSubItemBg
        },
        // Item
        [`${componentCls}-item, ${componentCls}-submenu-title`]: colorActiveBarBorderSize && colorActiveBarWidth ? {
          width: `calc(100% + ${colorActiveBarBorderSize}px)`
        } : {},
        [`${componentCls}-item`]: {
          position: "relative",
          "&::after": {
            position: "absolute",
            insetBlock: 0,
            insetInlineEnd: 0,
            borderInlineEnd: `${colorActiveBarWidth}px solid ${colorItemTextSelected}`,
            transform: "scaleY(0.0001)",
            opacity: 0,
            transition: [`transform ${motionDurationMid} ${motionEaseOut}`, `opacity ${motionDurationMid} ${motionEaseOut}`].join(","),
            content: '""'
          },
          // Danger
          [`&${componentCls}-item-danger`]: {
            "&::after": {
              borderInlineEndColor: colorDangerItemTextSelected
            }
          }
        },
        [`${componentCls}-selected, ${componentCls}-item-selected`]: {
          "&::after": {
            transform: "scaleY(1)",
            opacity: 1,
            transition: [`transform ${motionDurationMid} ${motionEaseInOut}`, `opacity ${motionDurationMid} ${motionEaseInOut}`].join(",")
          }
        }
      }
    }
  };
};
const getVerticalInlineStyle = (token2) => {
  const {
    componentCls,
    menuItemHeight,
    itemMarginInline,
    padding,
    menuArrowSize,
    marginXS,
    marginXXS
  } = token2;
  const paddingWithArrow = padding + menuArrowSize + marginXS;
  return {
    [`${componentCls}-item`]: {
      position: "relative"
    },
    [`${componentCls}-item, ${componentCls}-submenu-title`]: {
      height: menuItemHeight,
      lineHeight: `${menuItemHeight}px`,
      paddingInline: padding,
      overflow: "hidden",
      textOverflow: "ellipsis",
      marginInline: itemMarginInline,
      marginBlock: marginXXS,
      width: `calc(100% - ${itemMarginInline * 2}px)`
    },
    // disable margin collapsed
    [`${componentCls}-submenu`]: {
      paddingBottom: 0.02
    },
    [`> ${componentCls}-item,
            > ${componentCls}-submenu > ${componentCls}-submenu-title`]: {
      height: menuItemHeight,
      lineHeight: `${menuItemHeight}px`
    },
    [`${componentCls}-item-group-list ${componentCls}-submenu-title,
            ${componentCls}-submenu-title`]: {
      paddingInlineEnd: paddingWithArrow
    }
  };
};
const getVerticalStyle = (token2) => {
  const {
    componentCls,
    iconCls,
    menuItemHeight,
    colorTextLightSolid,
    dropdownWidth,
    controlHeightLG,
    motionDurationMid,
    motionEaseOut,
    paddingXL,
    fontSizeSM,
    fontSizeLG,
    motionDurationSlow,
    paddingXS,
    boxShadowSecondary
  } = token2;
  const inlineItemStyle = {
    height: menuItemHeight,
    lineHeight: `${menuItemHeight}px`,
    listStylePosition: "inside",
    listStyleType: "disc"
  };
  return [
    {
      [componentCls]: {
        [`&-inline, &-vertical`]: _extends$1({
          [`&${componentCls}-root`]: {
            boxShadow: "none"
          }
        }, getVerticalInlineStyle(token2))
      },
      [`${componentCls}-submenu-popup`]: {
        [`${componentCls}-vertical`]: _extends$1(_extends$1({}, getVerticalInlineStyle(token2)), {
          boxShadow: boxShadowSecondary
        })
      }
    },
    // Vertical only
    {
      [`${componentCls}-submenu-popup ${componentCls}-vertical${componentCls}-sub`]: {
        minWidth: dropdownWidth,
        maxHeight: `calc(100vh - ${controlHeightLG * 2.5}px)`,
        padding: "0",
        overflow: "hidden",
        borderInlineEnd: 0,
        // https://github.com/ant-design/ant-design/issues/22244
        // https://github.com/ant-design/ant-design/issues/26812
        "&:not([class*='-active'])": {
          overflowX: "hidden",
          overflowY: "auto"
        }
      }
    },
    // Inline Only
    {
      [`${componentCls}-inline`]: {
        width: "100%",
        // Motion enhance for first level
        [`&${componentCls}-root`]: {
          [`${componentCls}-item, ${componentCls}-submenu-title`]: {
            display: "flex",
            alignItems: "center",
            transition: [`border-color ${motionDurationSlow}`, `background ${motionDurationSlow}`, `padding ${motionDurationMid} ${motionEaseOut}`].join(","),
            [`> ${componentCls}-title-content`]: {
              flex: "auto",
              minWidth: 0,
              overflow: "hidden",
              textOverflow: "ellipsis"
            },
            "> *": {
              flex: "none"
            }
          }
        },
        // >>>>> Sub
        [`${componentCls}-sub${componentCls}-inline`]: {
          padding: 0,
          border: 0,
          borderRadius: 0,
          boxShadow: "none",
          [`& > ${componentCls}-submenu > ${componentCls}-submenu-title`]: inlineItemStyle,
          [`& ${componentCls}-item-group-title`]: {
            paddingInlineStart: paddingXL
          }
        },
        // >>>>> Item
        [`${componentCls}-item`]: inlineItemStyle
      }
    },
    // Inline Collapse Only
    {
      [`${componentCls}-inline-collapsed`]: {
        width: menuItemHeight * 2,
        [`&${componentCls}-root`]: {
          [`${componentCls}-item, ${componentCls}-submenu ${componentCls}-submenu-title`]: {
            [`> ${componentCls}-inline-collapsed-noicon`]: {
              fontSize: fontSizeLG,
              textAlign: "center"
            }
          }
        },
        [`> ${componentCls}-item,
          > ${componentCls}-item-group > ${componentCls}-item-group-list > ${componentCls}-item,
          > ${componentCls}-item-group > ${componentCls}-item-group-list > ${componentCls}-submenu > ${componentCls}-submenu-title,
          > ${componentCls}-submenu > ${componentCls}-submenu-title`]: {
          insetInlineStart: 0,
          paddingInline: `calc(50% - ${fontSizeSM}px)`,
          textOverflow: "clip",
          [`
            ${componentCls}-submenu-arrow,
            ${componentCls}-submenu-expand-icon
          `]: {
            opacity: 0
          },
          [`${componentCls}-item-icon, ${iconCls}`]: {
            margin: 0,
            fontSize: fontSizeLG,
            lineHeight: `${menuItemHeight}px`,
            "+ span": {
              display: "inline-block",
              opacity: 0
            }
          }
        },
        [`${componentCls}-item-icon, ${iconCls}`]: {
          display: "inline-block"
        },
        "&-tooltip": {
          pointerEvents: "none",
          [`${componentCls}-item-icon, ${iconCls}`]: {
            display: "none"
          },
          "a, a:hover": {
            color: colorTextLightSolid
          }
        },
        [`${componentCls}-item-group-title`]: _extends$1(_extends$1({}, textEllipsis), {
          paddingInline: paddingXS
        })
      }
    }
  ];
};
const genMenuItemStyle = (token2) => {
  const {
    componentCls,
    fontSize,
    motionDurationSlow,
    motionDurationMid,
    motionEaseInOut,
    motionEaseOut,
    iconCls,
    controlHeightSM
  } = token2;
  return {
    // >>>>> Item
    [`${componentCls}-item, ${componentCls}-submenu-title`]: {
      position: "relative",
      display: "block",
      margin: 0,
      whiteSpace: "nowrap",
      cursor: "pointer",
      transition: [`border-color ${motionDurationSlow}`, `background ${motionDurationSlow}`, `padding ${motionDurationSlow} ${motionEaseInOut}`].join(","),
      [`${componentCls}-item-icon, ${iconCls}`]: {
        minWidth: fontSize,
        fontSize,
        transition: [`font-size ${motionDurationMid} ${motionEaseOut}`, `margin ${motionDurationSlow} ${motionEaseInOut}`, `color ${motionDurationSlow}`].join(","),
        "+ span": {
          marginInlineStart: controlHeightSM - fontSize,
          opacity: 1,
          transition: [`opacity ${motionDurationSlow} ${motionEaseInOut}`, `margin ${motionDurationSlow}`, `color ${motionDurationSlow}`].join(",")
        }
      },
      [`${componentCls}-item-icon`]: _extends$1({}, resetIcon()),
      [`&${componentCls}-item-only-child`]: {
        [`> ${iconCls}, > ${componentCls}-item-icon`]: {
          marginInlineEnd: 0
        }
      }
    },
    // Disabled state sets text to gray and nukes hover/tab effects
    [`${componentCls}-item-disabled, ${componentCls}-submenu-disabled`]: {
      background: "none !important",
      cursor: "not-allowed",
      "&::after": {
        borderColor: "transparent !important"
      },
      a: {
        color: "inherit !important"
      },
      [`> ${componentCls}-submenu-title`]: {
        color: "inherit !important",
        cursor: "not-allowed"
      }
    }
  };
};
const genSubMenuArrowStyle = (token2) => {
  const {
    componentCls,
    motionDurationSlow,
    motionEaseInOut,
    borderRadius,
    menuArrowSize,
    menuArrowOffset
  } = token2;
  return {
    [`${componentCls}-submenu`]: {
      [`&-expand-icon, &-arrow`]: {
        position: "absolute",
        top: "50%",
        insetInlineEnd: token2.margin,
        width: menuArrowSize,
        color: "currentcolor",
        transform: "translateY(-50%)",
        transition: `transform ${motionDurationSlow} ${motionEaseInOut}, opacity ${motionDurationSlow}`
      },
      "&-arrow": {
        // →
        "&::before, &::after": {
          position: "absolute",
          width: menuArrowSize * 0.6,
          height: menuArrowSize * 0.15,
          backgroundColor: "currentcolor",
          borderRadius,
          transition: [`background ${motionDurationSlow} ${motionEaseInOut}`, `transform ${motionDurationSlow} ${motionEaseInOut}`, `top ${motionDurationSlow} ${motionEaseInOut}`, `color ${motionDurationSlow} ${motionEaseInOut}`].join(","),
          content: '""'
        },
        "&::before": {
          transform: `rotate(45deg) translateY(-${menuArrowOffset})`
        },
        "&::after": {
          transform: `rotate(-45deg) translateY(${menuArrowOffset})`
        }
      }
    }
  };
};
const getBaseStyle = (token2) => {
  const {
    antCls,
    componentCls,
    fontSize,
    motionDurationSlow,
    motionDurationMid,
    motionEaseInOut,
    lineHeight,
    paddingXS,
    padding,
    colorSplit,
    lineWidth,
    zIndexPopup,
    borderRadiusLG,
    radiusSubMenuItem,
    menuArrowSize,
    menuArrowOffset,
    lineType,
    menuPanelMaskInset
  } = token2;
  return [
    // Misc
    {
      "": {
        [`${componentCls}`]: _extends$1(_extends$1({}, clearFix()), {
          // Hidden
          [`&-hidden`]: {
            display: "none"
          }
        })
      },
      [`${componentCls}-submenu-hidden`]: {
        display: "none"
      }
    },
    {
      [componentCls]: _extends$1(_extends$1(_extends$1(_extends$1(_extends$1(_extends$1(_extends$1({}, resetComponent(token2)), clearFix()), {
        marginBottom: 0,
        paddingInlineStart: 0,
        // Override default ul/ol
        fontSize,
        lineHeight: 0,
        listStyle: "none",
        outline: "none",
        transition: `width ${motionDurationSlow} cubic-bezier(0.2, 0, 0, 1) 0s`,
        [`ul, ol`]: {
          margin: 0,
          padding: 0,
          listStyle: "none"
        },
        // Overflow ellipsis
        [`&-overflow`]: {
          display: "flex",
          [`${componentCls}-item`]: {
            flex: "none"
          }
        },
        [`${componentCls}-item, ${componentCls}-submenu, ${componentCls}-submenu-title`]: {
          borderRadius: token2.radiusItem
        },
        [`${componentCls}-item-group-title`]: {
          padding: `${paddingXS}px ${padding}px`,
          fontSize,
          lineHeight,
          transition: `all ${motionDurationSlow}`
        },
        [`&-horizontal ${componentCls}-submenu`]: {
          transition: [`border-color ${motionDurationSlow} ${motionEaseInOut}`, `background ${motionDurationSlow} ${motionEaseInOut}`].join(",")
        },
        [`${componentCls}-submenu, ${componentCls}-submenu-inline`]: {
          transition: [`border-color ${motionDurationSlow} ${motionEaseInOut}`, `background ${motionDurationSlow} ${motionEaseInOut}`, `padding ${motionDurationMid} ${motionEaseInOut}`].join(",")
        },
        [`${componentCls}-submenu ${componentCls}-sub`]: {
          cursor: "initial",
          transition: [`background ${motionDurationSlow} ${motionEaseInOut}`, `padding ${motionDurationSlow} ${motionEaseInOut}`].join(",")
        },
        [`${componentCls}-title-content`]: {
          transition: `color ${motionDurationSlow}`
        },
        [`${componentCls}-item a`]: {
          "&::before": {
            position: "absolute",
            inset: 0,
            backgroundColor: "transparent",
            content: '""'
          }
        },
        // Removed a Badge related style seems it's safe
        // https://github.com/ant-design/ant-design/issues/19809
        // >>>>> Divider
        [`${componentCls}-item-divider`]: {
          overflow: "hidden",
          lineHeight: 0,
          borderColor: colorSplit,
          borderStyle: lineType,
          borderWidth: 0,
          borderTopWidth: lineWidth,
          marginBlock: lineWidth,
          padding: 0,
          "&-dashed": {
            borderStyle: "dashed"
          }
        }
      }), genMenuItemStyle(token2)), {
        [`${componentCls}-item-group`]: {
          [`${componentCls}-item-group-list`]: {
            margin: 0,
            padding: 0,
            [`${componentCls}-item, ${componentCls}-submenu-title`]: {
              paddingInline: `${fontSize * 2}px ${padding}px`
            }
          }
        },
        // ======================= Sub Menu =======================
        "&-submenu": {
          "&-popup": {
            position: "absolute",
            zIndex: zIndexPopup,
            background: "transparent",
            borderRadius: borderRadiusLG,
            boxShadow: "none",
            transformOrigin: "0 0",
            // https://github.com/ant-design/ant-design/issues/13955
            "&::before": {
              position: "absolute",
              inset: `${menuPanelMaskInset}px 0 0`,
              zIndex: -1,
              width: "100%",
              height: "100%",
              opacity: 0,
              content: '""'
            }
          },
          // https://github.com/ant-design/ant-design/issues/13955
          "&-placement-rightTop::before": {
            top: 0,
            insetInlineStart: menuPanelMaskInset
          },
          [`> ${componentCls}`]: _extends$1(_extends$1(_extends$1({
            borderRadius: borderRadiusLG
          }, genMenuItemStyle(token2)), genSubMenuArrowStyle(token2)), {
            [`${componentCls}-item, ${componentCls}-submenu > ${componentCls}-submenu-title`]: {
              borderRadius: radiusSubMenuItem
            },
            [`${componentCls}-submenu-title::after`]: {
              transition: `transform ${motionDurationSlow} ${motionEaseInOut}`
            }
          })
        }
      }), genSubMenuArrowStyle(token2)), {
        [`&-inline-collapsed ${componentCls}-submenu-arrow,
        &-inline ${componentCls}-submenu-arrow`]: {
          // ↓
          "&::before": {
            transform: `rotate(-45deg) translateX(${menuArrowOffset})`
          },
          "&::after": {
            transform: `rotate(45deg) translateX(-${menuArrowOffset})`
          }
        },
        [`${componentCls}-submenu-open${componentCls}-submenu-inline > ${componentCls}-submenu-title > ${componentCls}-submenu-arrow`]: {
          // ↑
          transform: `translateY(-${menuArrowSize * 0.2}px)`,
          "&::after": {
            transform: `rotate(-45deg) translateX(-${menuArrowOffset})`
          },
          "&::before": {
            transform: `rotate(45deg) translateX(${menuArrowOffset})`
          }
        }
      })
    },
    // Integration with header element so menu items have the same height
    {
      [`${antCls}-layout-header`]: {
        [componentCls]: {
          lineHeight: "inherit"
        }
      }
    }
  ];
};
const useStyle$z = (prefixCls, injectStyle) => {
  const useOriginHook = genComponentStyleHook("Menu", (token2, _ref) => {
    let {
      overrideComponentToken
    } = _ref;
    if ((injectStyle === null || injectStyle === void 0 ? void 0 : injectStyle.value) === false) {
      return [];
    }
    const {
      colorBgElevated,
      colorPrimary,
      colorError,
      colorErrorHover,
      colorTextLightSolid
    } = token2;
    const {
      controlHeightLG,
      fontSize
    } = token2;
    const menuArrowSize = fontSize / 7 * 5;
    const menuToken = merge(token2, {
      menuItemHeight: controlHeightLG,
      menuItemPaddingInline: token2.margin,
      menuArrowSize,
      menuHorizontalHeight: controlHeightLG * 1.15,
      menuArrowOffset: `${menuArrowSize * 0.25}px`,
      menuPanelMaskInset: -7,
      menuSubMenuBg: colorBgElevated
    });
    const colorTextDark = new TinyColor(colorTextLightSolid).setAlpha(0.65).toRgbString();
    const menuDarkToken = merge(menuToken, {
      colorItemText: colorTextDark,
      colorItemTextHover: colorTextLightSolid,
      colorGroupTitle: colorTextDark,
      colorItemTextSelected: colorTextLightSolid,
      colorItemBg: "#001529",
      colorSubItemBg: "#000c17",
      colorItemBgActive: "transparent",
      colorItemBgSelected: colorPrimary,
      colorActiveBarWidth: 0,
      colorActiveBarHeight: 0,
      colorActiveBarBorderSize: 0,
      // Disabled
      colorItemTextDisabled: new TinyColor(colorTextLightSolid).setAlpha(0.25).toRgbString(),
      // Danger
      colorDangerItemText: colorError,
      colorDangerItemTextHover: colorErrorHover,
      colorDangerItemTextSelected: colorTextLightSolid,
      colorDangerItemBgActive: colorError,
      colorDangerItemBgSelected: colorError,
      menuSubMenuBg: "#001529",
      // Horizontal
      colorItemTextSelectedHorizontal: colorTextLightSolid,
      colorItemBgSelectedHorizontal: colorPrimary
    }, _extends$1({}, overrideComponentToken));
    return [
      // Basic
      getBaseStyle(menuToken),
      // Horizontal
      getHorizontalStyle(menuToken),
      // Vertical
      getVerticalStyle(menuToken),
      // Theme
      getThemeStyle(menuToken, "light"),
      getThemeStyle(menuDarkToken, "dark"),
      // RTL
      getRTLStyle(menuToken),
      // Motion
      genCollapseMotion(menuToken),
      initSlideMotion(menuToken, "slide-up"),
      initSlideMotion(menuToken, "slide-down"),
      initZoomMotion(menuToken, "zoom-big")
    ];
  }, (token2) => {
    const {
      colorPrimary,
      colorError,
      colorTextDisabled,
      colorErrorBg,
      colorText,
      colorTextDescription,
      colorBgContainer,
      colorFillAlter,
      colorFillContent,
      lineWidth,
      lineWidthBold,
      controlItemBgActive,
      colorBgTextHover
    } = token2;
    return {
      dropdownWidth: 160,
      zIndexPopup: token2.zIndexPopupBase + 50,
      radiusItem: token2.borderRadiusLG,
      radiusSubMenuItem: token2.borderRadiusSM,
      colorItemText: colorText,
      colorItemTextHover: colorText,
      colorItemTextHoverHorizontal: colorPrimary,
      colorGroupTitle: colorTextDescription,
      colorItemTextSelected: colorPrimary,
      colorItemTextSelectedHorizontal: colorPrimary,
      colorItemBg: colorBgContainer,
      colorItemBgHover: colorBgTextHover,
      colorItemBgActive: colorFillContent,
      colorSubItemBg: colorFillAlter,
      colorItemBgSelected: controlItemBgActive,
      colorItemBgSelectedHorizontal: "transparent",
      colorActiveBarWidth: 0,
      colorActiveBarHeight: lineWidthBold,
      colorActiveBarBorderSize: lineWidth,
      // Disabled
      colorItemTextDisabled: colorTextDisabled,
      // Danger
      colorDangerItemText: colorError,
      colorDangerItemTextHover: colorError,
      colorDangerItemTextSelected: colorError,
      colorDangerItemBgActive: colorErrorBg,
      colorDangerItemBgSelected: colorErrorBg,
      itemMarginInline: token2.marginXXS
    };
  });
  return useOriginHook(prefixCls);
};
const menuProps = () => ({
  id: String,
  prefixCls: String,
  // donot use items, now only support inner use
  items: Array,
  disabled: Boolean,
  inlineCollapsed: Boolean,
  disabledOverflow: Boolean,
  forceSubMenuRender: Boolean,
  openKeys: Array,
  selectedKeys: Array,
  activeKey: String,
  selectable: {
    type: Boolean,
    default: true
  },
  multiple: {
    type: Boolean,
    default: false
  },
  tabindex: {
    type: [Number, String]
  },
  motion: Object,
  role: String,
  theme: {
    type: String,
    default: "light"
  },
  mode: {
    type: String,
    default: "vertical"
  },
  inlineIndent: {
    type: Number,
    default: 24
  },
  subMenuOpenDelay: {
    type: Number,
    default: 0
  },
  subMenuCloseDelay: {
    type: Number,
    default: 0.1
  },
  builtinPlacements: {
    type: Object
  },
  triggerSubMenuAction: {
    type: String,
    default: "hover"
  },
  getPopupContainer: Function,
  expandIcon: Function,
  onOpenChange: Function,
  onSelect: Function,
  onDeselect: Function,
  onClick: [Function, Array],
  onFocus: Function,
  onBlur: Function,
  onMousedown: Function,
  "onUpdate:openKeys": Function,
  "onUpdate:selectedKeys": Function,
  "onUpdate:activeKey": Function
});
const EMPTY_LIST$2 = [];
const Menu = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AMenu",
  inheritAttrs: false,
  props: menuProps(),
  slots: Object,
  setup(props2, _ref) {
    let {
      slots,
      emit,
      attrs
    } = _ref;
    const {
      direction,
      getPrefixCls
    } = useConfigInject("menu", props2);
    const override = useInjectOverride();
    const prefixCls = computed(() => {
      var _a2;
      return getPrefixCls("menu", props2.prefixCls || ((_a2 = override === null || override === void 0 ? void 0 : override.prefixCls) === null || _a2 === void 0 ? void 0 : _a2.value));
    });
    const [wrapSSR, hashId] = useStyle$z(prefixCls, computed(() => {
      return !override;
    }));
    const store = shallowRef(/* @__PURE__ */ new Map());
    const siderCollapsed = inject(SiderCollapsedKey, ref(void 0));
    const inlineCollapsed = computed(() => {
      if (siderCollapsed.value !== void 0) {
        return siderCollapsed.value;
      }
      return props2.inlineCollapsed;
    });
    const {
      itemsNodes
    } = useItems(props2);
    const isMounted = shallowRef(false);
    onMounted(() => {
      isMounted.value = true;
    });
    watchEffect(() => {
      devWarning(!(props2.inlineCollapsed === true && props2.mode !== "inline"), "Menu", "`inlineCollapsed` should only be used when `mode` is inline.");
      devWarning(!(siderCollapsed.value !== void 0 && props2.inlineCollapsed === true), "Menu", "`inlineCollapsed` not control Menu under Sider. Should set `collapsed` on Sider instead.");
    });
    const activeKeys = ref([]);
    const mergedSelectedKeys = ref([]);
    const keyMapStore = ref({});
    watch(store, () => {
      const newKeyMapStore = {};
      for (const menuInfo of store.value.values()) {
        newKeyMapStore[menuInfo.key] = menuInfo;
      }
      keyMapStore.value = newKeyMapStore;
    }, {
      flush: "post"
    });
    watchEffect(() => {
      if (props2.activeKey !== void 0) {
        let keys2 = [];
        const menuInfo = props2.activeKey ? keyMapStore.value[props2.activeKey] : void 0;
        if (menuInfo && props2.activeKey !== void 0) {
          keys2 = uniq([].concat(unref(menuInfo.parentKeys), props2.activeKey));
        } else {
          keys2 = [];
        }
        if (!shallowequal(activeKeys.value, keys2)) {
          activeKeys.value = keys2;
        }
      }
    });
    watch(() => props2.selectedKeys, (selectedKeys) => {
      if (selectedKeys) {
        mergedSelectedKeys.value = selectedKeys.slice();
      }
    }, {
      immediate: true,
      deep: true
    });
    const selectedSubMenuKeys = ref([]);
    watch([keyMapStore, mergedSelectedKeys], () => {
      let subMenuParentKeys = [];
      mergedSelectedKeys.value.forEach((key2) => {
        const menuInfo = keyMapStore.value[key2];
        if (menuInfo) {
          subMenuParentKeys = subMenuParentKeys.concat(unref(menuInfo.parentKeys));
        }
      });
      subMenuParentKeys = uniq(subMenuParentKeys);
      if (!shallowequal(selectedSubMenuKeys.value, subMenuParentKeys)) {
        selectedSubMenuKeys.value = subMenuParentKeys;
      }
    }, {
      immediate: true
    });
    const triggerSelection = (info) => {
      if (props2.selectable) {
        const {
          key: targetKey
        } = info;
        const exist = mergedSelectedKeys.value.includes(targetKey);
        let newSelectedKeys;
        if (props2.multiple) {
          if (exist) {
            newSelectedKeys = mergedSelectedKeys.value.filter((key2) => key2 !== targetKey);
          } else {
            newSelectedKeys = [...mergedSelectedKeys.value, targetKey];
          }
        } else {
          newSelectedKeys = [targetKey];
        }
        const selectInfo = _extends$1(_extends$1({}, info), {
          selectedKeys: newSelectedKeys
        });
        if (!shallowequal(newSelectedKeys, mergedSelectedKeys.value)) {
          if (props2.selectedKeys === void 0) {
            mergedSelectedKeys.value = newSelectedKeys;
          }
          emit("update:selectedKeys", newSelectedKeys);
          if (exist && props2.multiple) {
            emit("deselect", selectInfo);
          } else {
            emit("select", selectInfo);
          }
        }
      }
      if (mergedMode.value !== "inline" && !props2.multiple && mergedOpenKeys.value.length) {
        triggerOpenKeys(EMPTY_LIST$2);
      }
    };
    const mergedOpenKeys = ref([]);
    watch(() => props2.openKeys, function() {
      let openKeys = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : mergedOpenKeys.value;
      if (!shallowequal(mergedOpenKeys.value, openKeys)) {
        mergedOpenKeys.value = openKeys.slice();
      }
    }, {
      immediate: true,
      deep: true
    });
    let timeout;
    const changeActiveKeys = (keys2) => {
      clearTimeout(timeout);
      timeout = setTimeout(() => {
        if (props2.activeKey === void 0) {
          activeKeys.value = keys2;
        }
        emit("update:activeKey", keys2[keys2.length - 1]);
      });
    };
    const disabled = computed(() => !!props2.disabled);
    const isRtl = computed(() => direction.value === "rtl");
    const mergedMode = ref("vertical");
    const mergedInlineCollapsed = shallowRef(false);
    watchEffect(() => {
      var _a2;
      if ((props2.mode === "inline" || props2.mode === "vertical") && inlineCollapsed.value) {
        mergedMode.value = "vertical";
        mergedInlineCollapsed.value = inlineCollapsed.value;
      } else {
        mergedMode.value = props2.mode;
        mergedInlineCollapsed.value = false;
      }
      if ((_a2 = override === null || override === void 0 ? void 0 : override.mode) === null || _a2 === void 0 ? void 0 : _a2.value) {
        mergedMode.value = override.mode.value;
      }
    });
    const isInlineMode = computed(() => mergedMode.value === "inline");
    const triggerOpenKeys = (keys2) => {
      mergedOpenKeys.value = keys2;
      emit("update:openKeys", keys2);
      emit("openChange", keys2);
    };
    const inlineCacheOpenKeys = ref(mergedOpenKeys.value);
    const mountRef = shallowRef(false);
    watch(mergedOpenKeys, () => {
      if (isInlineMode.value) {
        inlineCacheOpenKeys.value = mergedOpenKeys.value;
      }
    }, {
      immediate: true
    });
    watch(isInlineMode, () => {
      if (!mountRef.value) {
        mountRef.value = true;
        return;
      }
      if (isInlineMode.value) {
        mergedOpenKeys.value = inlineCacheOpenKeys.value;
      } else {
        triggerOpenKeys(EMPTY_LIST$2);
      }
    }, {
      immediate: true
    });
    const className = computed(() => {
      return {
        [`${prefixCls.value}`]: true,
        [`${prefixCls.value}-root`]: true,
        [`${prefixCls.value}-${mergedMode.value}`]: true,
        [`${prefixCls.value}-inline-collapsed`]: mergedInlineCollapsed.value,
        [`${prefixCls.value}-rtl`]: isRtl.value,
        [`${prefixCls.value}-${props2.theme}`]: true
      };
    });
    const rootPrefixCls = computed(() => getPrefixCls());
    const defaultMotions = computed(() => ({
      horizontal: {
        name: `${rootPrefixCls.value}-slide-up`
      },
      inline: collapseMotion(`${rootPrefixCls.value}-motion-collapse`),
      other: {
        name: `${rootPrefixCls.value}-zoom-big`
      }
    }));
    useProvideFirstLevel(true);
    const getChildrenKeys = function() {
      let eventKeys = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      const keys2 = [];
      const storeValue = store.value;
      eventKeys.forEach((eventKey) => {
        const {
          key: key2,
          childrenEventKeys
        } = storeValue.get(eventKey);
        keys2.push(key2, ...getChildrenKeys(unref(childrenEventKeys)));
      });
      return keys2;
    };
    const onInternalClick = (info) => {
      var _a2;
      emit("click", info);
      triggerSelection(info);
      (_a2 = override === null || override === void 0 ? void 0 : override.onClick) === null || _a2 === void 0 ? void 0 : _a2.call(override);
    };
    const onInternalOpenChange = (key2, open2) => {
      var _a2;
      const childrenEventKeys = ((_a2 = keyMapStore.value[key2]) === null || _a2 === void 0 ? void 0 : _a2.childrenEventKeys) || [];
      let newOpenKeys = mergedOpenKeys.value.filter((k2) => k2 !== key2);
      if (open2) {
        newOpenKeys.push(key2);
      } else if (mergedMode.value !== "inline") {
        const subPathKeys = getChildrenKeys(unref(childrenEventKeys));
        newOpenKeys = uniq(newOpenKeys.filter((k2) => !subPathKeys.includes(k2)));
      }
      if (!shallowequal(mergedOpenKeys, newOpenKeys)) {
        triggerOpenKeys(newOpenKeys);
      }
    };
    const registerMenuInfo = (key2, info) => {
      store.value.set(key2, info);
      store.value = new Map(store.value);
    };
    const unRegisterMenuInfo = (key2) => {
      store.value.delete(key2);
      store.value = new Map(store.value);
    };
    const lastVisibleIndex = ref(0);
    const expandIcon = computed(() => {
      var _a2;
      return props2.expandIcon || slots.expandIcon || ((_a2 = override === null || override === void 0 ? void 0 : override.expandIcon) === null || _a2 === void 0 ? void 0 : _a2.value) ? (opt) => {
        let icon = props2.expandIcon || slots.expandIcon;
        icon = typeof icon === "function" ? icon(opt) : icon;
        return cloneElement(icon, {
          class: `${prefixCls.value}-submenu-expand-icon`
        }, false);
      } : null;
    });
    useProvideMenu({
      prefixCls,
      activeKeys,
      openKeys: mergedOpenKeys,
      selectedKeys: mergedSelectedKeys,
      changeActiveKeys,
      disabled,
      rtl: isRtl,
      mode: mergedMode,
      inlineIndent: computed(() => props2.inlineIndent),
      subMenuCloseDelay: computed(() => props2.subMenuCloseDelay),
      subMenuOpenDelay: computed(() => props2.subMenuOpenDelay),
      builtinPlacements: computed(() => props2.builtinPlacements),
      triggerSubMenuAction: computed(() => props2.triggerSubMenuAction),
      getPopupContainer: computed(() => props2.getPopupContainer),
      inlineCollapsed: mergedInlineCollapsed,
      theme: computed(() => props2.theme),
      siderCollapsed,
      defaultMotions: computed(() => isMounted.value ? defaultMotions.value : null),
      motion: computed(() => isMounted.value ? props2.motion : null),
      overflowDisabled: shallowRef(void 0),
      onOpenChange: onInternalOpenChange,
      onItemClick: onInternalClick,
      registerMenuInfo,
      unRegisterMenuInfo,
      selectedSubMenuKeys,
      expandIcon,
      forceSubMenuRender: computed(() => props2.forceSubMenuRender),
      rootClassName: hashId
    });
    const getChildrenList = () => {
      var _a2;
      return itemsNodes.value || flattenChildren((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots));
    };
    return () => {
      var _a2;
      const childList = getChildrenList();
      const allVisible = lastVisibleIndex.value >= childList.length - 1 || mergedMode.value !== "horizontal" || props2.disabledOverflow;
      const getWrapperList = (childList2) => {
        return mergedMode.value !== "horizontal" || props2.disabledOverflow ? childList2 : (
          // Need wrap for overflow dropdown that do not response for open
          childList2.map((child, index2) => (
            // Always wrap provider to avoid sub node re-mount
            createVNode(MenuContextProvider, {
              "key": child.key,
              "overflowDisabled": index2 > lastVisibleIndex.value
            }, {
              default: () => child
            })
          ))
        );
      };
      const overflowedIndicator = ((_a2 = slots.overflowedIndicator) === null || _a2 === void 0 ? void 0 : _a2.call(slots)) || createVNode(EllipsisOutlined, null, null);
      return wrapSSR(createVNode(Overflow, _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "onMousedown": props2.onMousedown,
        "prefixCls": `${prefixCls.value}-overflow`,
        "component": "ul",
        "itemComponent": MenuItem$1,
        "class": [className.value, attrs.class, hashId.value],
        "role": "menu",
        "id": props2.id,
        "data": getWrapperList(childList),
        "renderRawItem": (node2) => node2,
        "renderRawRest": (omitItems) => {
          const len = omitItems.length;
          const originOmitItems = len ? childList.slice(-len) : null;
          return createVNode(Fragment, null, [createVNode(SubMenu$1, {
            "eventKey": OVERFLOW_KEY,
            "key": OVERFLOW_KEY,
            "title": overflowedIndicator,
            "disabled": allVisible,
            "internalPopupClose": len === 0
          }, {
            default: () => originOmitItems
          }), createVNode(PathContext, null, {
            default: () => [createVNode(SubMenu$1, {
              "eventKey": OVERFLOW_KEY,
              "key": OVERFLOW_KEY,
              "title": overflowedIndicator,
              "disabled": allVisible,
              "internalPopupClose": len === 0
            }, {
              default: () => originOmitItems
            })]
          })]);
        },
        "maxCount": mergedMode.value !== "horizontal" || props2.disabledOverflow ? Overflow.INVALIDATE : Overflow.RESPONSIVE,
        "ssr": "full",
        "data-menu-list": true,
        "onVisibleChange": (newLastIndex) => {
          lastVisibleIndex.value = newLastIndex;
        }
      }), {
        default: () => [createVNode(Teleport, {
          "to": "body"
        }, {
          default: () => [createVNode("div", {
            "style": {
              display: "none"
            },
            "aria-hidden": true
          }, [createVNode(PathContext, null, {
            default: () => [getWrapperList(getChildrenList())]
          })])]
        })]
      }));
    };
  }
});
Menu.install = function(app) {
  app.component(Menu.name, Menu);
  app.component(MenuItem$1.name, MenuItem$1);
  app.component(SubMenu$1.name, SubMenu$1);
  app.component(Divider$2.name, Divider$2);
  app.component(ItemGroup.name, ItemGroup);
  return app;
};
Menu.Item = MenuItem$1;
Menu.Divider = Divider$2;
Menu.SubMenu = SubMenu$1;
Menu.ItemGroup = ItemGroup;
const genBreadcrumbStyle = (token2) => {
  const {
    componentCls,
    iconCls
  } = token2;
  return {
    [componentCls]: _extends$1(_extends$1({}, resetComponent(token2)), {
      color: token2.breadcrumbBaseColor,
      fontSize: token2.breadcrumbFontSize,
      [iconCls]: {
        fontSize: token2.breadcrumbIconFontSize
      },
      ol: {
        display: "flex",
        flexWrap: "wrap",
        margin: 0,
        padding: 0,
        listStyle: "none"
      },
      a: _extends$1({
        color: token2.breadcrumbLinkColor,
        transition: `color ${token2.motionDurationMid}`,
        padding: `0 ${token2.paddingXXS}px`,
        borderRadius: token2.borderRadiusSM,
        height: token2.lineHeight * token2.fontSize,
        display: "inline-block",
        marginInline: -token2.marginXXS,
        "&:hover": {
          color: token2.breadcrumbLinkColorHover,
          backgroundColor: token2.colorBgTextHover
        }
      }, genFocusStyle(token2)),
      [`li:last-child`]: {
        color: token2.breadcrumbLastItemColor,
        [`& > ${componentCls}-separator`]: {
          display: "none"
        }
      },
      [`${componentCls}-separator`]: {
        marginInline: token2.breadcrumbSeparatorMargin,
        color: token2.breadcrumbSeparatorColor
      },
      [`${componentCls}-link`]: {
        [`
          > ${iconCls} + span,
          > ${iconCls} + a
        `]: {
          marginInlineStart: token2.marginXXS
        }
      },
      [`${componentCls}-overlay-link`]: {
        borderRadius: token2.borderRadiusSM,
        height: token2.lineHeight * token2.fontSize,
        display: "inline-block",
        padding: `0 ${token2.paddingXXS}px`,
        marginInline: -token2.marginXXS,
        [`> ${iconCls}`]: {
          marginInlineStart: token2.marginXXS,
          fontSize: token2.fontSizeIcon
        },
        "&:hover": {
          color: token2.breadcrumbLinkColorHover,
          backgroundColor: token2.colorBgTextHover,
          a: {
            color: token2.breadcrumbLinkColorHover
          }
        },
        a: {
          "&:hover": {
            backgroundColor: "transparent"
          }
        }
      },
      // rtl style
      [`&${token2.componentCls}-rtl`]: {
        direction: "rtl"
      }
    })
  };
};
const useStyle$y = genComponentStyleHook("Breadcrumb", (token2) => {
  const BreadcrumbToken = merge(token2, {
    breadcrumbBaseColor: token2.colorTextDescription,
    breadcrumbFontSize: token2.fontSize,
    breadcrumbIconFontSize: token2.fontSize,
    breadcrumbLinkColor: token2.colorTextDescription,
    breadcrumbLinkColorHover: token2.colorText,
    breadcrumbLastItemColor: token2.colorText,
    breadcrumbSeparatorMargin: token2.marginXS,
    breadcrumbSeparatorColor: token2.colorTextDescription
  });
  return [genBreadcrumbStyle(BreadcrumbToken)];
});
const breadcrumbProps = () => ({
  prefixCls: String,
  routes: {
    type: Array
  },
  params: PropTypes.any,
  separator: PropTypes.any,
  itemRender: {
    type: Function
  }
});
function getBreadcrumbName(route, params) {
  if (!route.breadcrumbName) {
    return null;
  }
  const paramsKeys = Object.keys(params).join("|");
  const name = route.breadcrumbName.replace(new RegExp(`:(${paramsKeys})`, "g"), (replacement, key2) => params[key2] || replacement);
  return name;
}
function defaultItemRender$1(opt) {
  const {
    route,
    params,
    routes,
    paths
  } = opt;
  const isLastItem = routes.indexOf(route) === routes.length - 1;
  const name = getBreadcrumbName(route, params);
  return isLastItem ? createVNode("span", null, [name]) : createVNode("a", {
    "href": `#/${paths.join("/")}`
  }, [name]);
}
const Breadcrumb = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ABreadcrumb",
  inheritAttrs: false,
  props: breadcrumbProps(),
  slots: Object,
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const {
      prefixCls,
      direction
    } = useConfigInject("breadcrumb", props2);
    const [wrapSSR, hashId] = useStyle$y(prefixCls);
    const getPath = (path2, params) => {
      path2 = (path2 || "").replace(/^\//, "");
      Object.keys(params).forEach((key2) => {
        path2 = path2.replace(`:${key2}`, params[key2]);
      });
      return path2;
    };
    const addChildPath = (paths, childPath, params) => {
      const originalPaths = [...paths];
      const path2 = getPath(childPath || "", params);
      if (path2) {
        originalPaths.push(path2);
      }
      return originalPaths;
    };
    const genForRoutes = (_ref2) => {
      let {
        routes = [],
        params = {},
        separator,
        itemRender = defaultItemRender$1
      } = _ref2;
      const paths = [];
      return routes.map((route) => {
        const path2 = getPath(route.path, params);
        if (path2) {
          paths.push(path2);
        }
        const tempPaths = [...paths];
        let overlay = null;
        if (route.children && route.children.length) {
          overlay = createVNode(Menu, {
            "items": route.children.map((child) => ({
              key: child.path || child.breadcrumbName,
              label: itemRender({
                route: child,
                params,
                routes,
                paths: addChildPath(tempPaths, child.path, params)
              })
            }))
          }, null);
        }
        const itemProps = {
          separator
        };
        if (overlay) {
          itemProps.overlay = overlay;
        }
        return createVNode(BreadcrumbItem, _objectSpread2$1(_objectSpread2$1({}, itemProps), {}, {
          "key": path2 || route.breadcrumbName
        }), {
          default: () => [itemRender({
            route,
            params,
            routes,
            paths: tempPaths
          })]
        });
      });
    };
    return () => {
      var _a2;
      let crumbs;
      const {
        routes,
        params = {}
      } = props2;
      const children = flattenChildren(getPropsSlot(slots, props2));
      const separator = (_a2 = getPropsSlot(slots, props2, "separator")) !== null && _a2 !== void 0 ? _a2 : "/";
      const itemRender = props2.itemRender || slots.itemRender || defaultItemRender$1;
      if (routes && routes.length > 0) {
        crumbs = genForRoutes({
          routes,
          params,
          separator,
          itemRender
        });
      } else if (children.length) {
        crumbs = children.map((element, index2) => {
          warning$1(typeof element.type === "object" && (element.type.__ANT_BREADCRUMB_ITEM || element.type.__ANT_BREADCRUMB_SEPARATOR));
          return cloneVNode(element, {
            separator,
            key: index2
          });
        });
      }
      const breadcrumbClassName = {
        [prefixCls.value]: true,
        [`${prefixCls.value}-rtl`]: direction.value === "rtl",
        [`${attrs.class}`]: !!attrs.class,
        [hashId.value]: true
      };
      return wrapSSR(createVNode("nav", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "class": breadcrumbClassName
      }), [createVNode("ol", null, [crumbs])]));
    };
  }
});
var __rest$R = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const breadcrumbSeparatorProps = () => ({
  prefixCls: String
});
const BreadcrumbSeparator = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ABreadcrumbSeparator",
  __ANT_BREADCRUMB_SEPARATOR: true,
  inheritAttrs: false,
  props: breadcrumbSeparatorProps(),
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const {
      prefixCls
    } = useConfigInject("breadcrumb", props2);
    return () => {
      var _a2;
      const {
        separator,
        class: className
      } = attrs, restAttrs = __rest$R(attrs, ["separator", "class"]);
      const children = flattenChildren((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots));
      return createVNode("span", _objectSpread2$1({
        "class": [`${prefixCls.value}-separator`, className]
      }, restAttrs), [children.length > 0 ? children : "/"]);
    };
  }
});
Breadcrumb.Item = BreadcrumbItem;
Breadcrumb.Separator = BreadcrumbSeparator;
Breadcrumb.install = function(app) {
  app.component(Breadcrumb.name, Breadcrumb);
  app.component(BreadcrumbItem.name, BreadcrumbItem);
  app.component(BreadcrumbSeparator.name, BreadcrumbSeparator);
  return app;
};
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
var dayjs_min$1 = { exports: {} };
var dayjs_min = dayjs_min$1.exports;
var hasRequiredDayjs_min;
function requireDayjs_min() {
  if (hasRequiredDayjs_min) return dayjs_min$1.exports;
  hasRequiredDayjs_min = 1;
  (function(module2, exports2) {
    !function(t2, e2) {
      module2.exports = e2();
    }(dayjs_min, function() {
      var t2 = 1e3, e2 = 6e4, n2 = 36e5, r2 = "millisecond", i2 = "second", s2 = "minute", u2 = "hour", a2 = "day", o2 = "week", c2 = "month", f2 = "quarter", h2 = "year", d2 = "date", l2 = "Invalid Date", $2 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y2 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M2 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t3) {
        var e3 = ["th", "st", "nd", "rd"], n3 = t3 % 100;
        return "[" + t3 + (e3[(n3 - 20) % 10] || e3[n3] || e3[0]) + "]";
      } }, m2 = function(t3, e3, n3) {
        var r3 = String(t3);
        return !r3 || r3.length >= e3 ? t3 : "" + Array(e3 + 1 - r3.length).join(n3) + t3;
      }, v2 = { s: m2, z: function(t3) {
        var e3 = -t3.utcOffset(), n3 = Math.abs(e3), r3 = Math.floor(n3 / 60), i3 = n3 % 60;
        return (e3 <= 0 ? "+" : "-") + m2(r3, 2, "0") + ":" + m2(i3, 2, "0");
      }, m: function t3(e3, n3) {
        if (e3.date() < n3.date()) return -t3(n3, e3);
        var r3 = 12 * (n3.year() - e3.year()) + (n3.month() - e3.month()), i3 = e3.clone().add(r3, c2), s3 = n3 - i3 < 0, u3 = e3.clone().add(r3 + (s3 ? -1 : 1), c2);
        return +(-(r3 + (n3 - i3) / (s3 ? i3 - u3 : u3 - i3)) || 0);
      }, a: function(t3) {
        return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
      }, p: function(t3) {
        return { M: c2, y: h2, w: o2, d: a2, D: d2, h: u2, m: s2, s: i2, ms: r2, Q: f2 }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t3) {
        return void 0 === t3;
      } }, g2 = "en", D2 = {};
      D2[g2] = M2;
      var p = "$isDayjsObject", S2 = function(t3) {
        return t3 instanceof _2 || !(!t3 || !t3[p]);
      }, w2 = function t3(e3, n3, r3) {
        var i3;
        if (!e3) return g2;
        if ("string" == typeof e3) {
          var s3 = e3.toLowerCase();
          D2[s3] && (i3 = s3), n3 && (D2[s3] = n3, i3 = s3);
          var u3 = e3.split("-");
          if (!i3 && u3.length > 1) return t3(u3[0]);
        } else {
          var a3 = e3.name;
          D2[a3] = e3, i3 = a3;
        }
        return !r3 && i3 && (g2 = i3), i3 || !r3 && g2;
      }, O2 = function(t3, e3) {
        if (S2(t3)) return t3.clone();
        var n3 = "object" == typeof e3 ? e3 : {};
        return n3.date = t3, n3.args = arguments, new _2(n3);
      }, b2 = v2;
      b2.l = w2, b2.i = S2, b2.w = function(t3, e3) {
        return O2(t3, { locale: e3.$L, utc: e3.$u, x: e3.$x, $offset: e3.$offset });
      };
      var _2 = function() {
        function M3(t3) {
          this.$L = w2(t3.locale, null, true), this.parse(t3), this.$x = this.$x || t3.x || {}, this[p] = true;
        }
        var m3 = M3.prototype;
        return m3.parse = function(t3) {
          this.$d = function(t4) {
            var e3 = t4.date, n3 = t4.utc;
            if (null === e3) return /* @__PURE__ */ new Date(NaN);
            if (b2.u(e3)) return /* @__PURE__ */ new Date();
            if (e3 instanceof Date) return new Date(e3);
            if ("string" == typeof e3 && !/Z$/i.test(e3)) {
              var r3 = e3.match($2);
              if (r3) {
                var i3 = r3[2] - 1 || 0, s3 = (r3[7] || "0").substring(0, 3);
                return n3 ? new Date(Date.UTC(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3)) : new Date(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3);
              }
            }
            return new Date(e3);
          }(t3), this.init();
        }, m3.init = function() {
          var t3 = this.$d;
          this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
        }, m3.$utils = function() {
          return b2;
        }, m3.isValid = function() {
          return !(this.$d.toString() === l2);
        }, m3.isSame = function(t3, e3) {
          var n3 = O2(t3);
          return this.startOf(e3) <= n3 && n3 <= this.endOf(e3);
        }, m3.isAfter = function(t3, e3) {
          return O2(t3) < this.startOf(e3);
        }, m3.isBefore = function(t3, e3) {
          return this.endOf(e3) < O2(t3);
        }, m3.$g = function(t3, e3, n3) {
          return b2.u(t3) ? this[e3] : this.set(n3, t3);
        }, m3.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m3.valueOf = function() {
          return this.$d.getTime();
        }, m3.startOf = function(t3, e3) {
          var n3 = this, r3 = !!b2.u(e3) || e3, f3 = b2.p(t3), l3 = function(t4, e4) {
            var i3 = b2.w(n3.$u ? Date.UTC(n3.$y, e4, t4) : new Date(n3.$y, e4, t4), n3);
            return r3 ? i3 : i3.endOf(a2);
          }, $3 = function(t4, e4) {
            return b2.w(n3.toDate()[t4].apply(n3.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e4)), n3);
          }, y3 = this.$W, M4 = this.$M, m4 = this.$D, v3 = "set" + (this.$u ? "UTC" : "");
          switch (f3) {
            case h2:
              return r3 ? l3(1, 0) : l3(31, 11);
            case c2:
              return r3 ? l3(1, M4) : l3(0, M4 + 1);
            case o2:
              var g3 = this.$locale().weekStart || 0, D3 = (y3 < g3 ? y3 + 7 : y3) - g3;
              return l3(r3 ? m4 - D3 : m4 + (6 - D3), M4);
            case a2:
            case d2:
              return $3(v3 + "Hours", 0);
            case u2:
              return $3(v3 + "Minutes", 1);
            case s2:
              return $3(v3 + "Seconds", 2);
            case i2:
              return $3(v3 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m3.endOf = function(t3) {
          return this.startOf(t3, false);
        }, m3.$set = function(t3, e3) {
          var n3, o3 = b2.p(t3), f3 = "set" + (this.$u ? "UTC" : ""), l3 = (n3 = {}, n3[a2] = f3 + "Date", n3[d2] = f3 + "Date", n3[c2] = f3 + "Month", n3[h2] = f3 + "FullYear", n3[u2] = f3 + "Hours", n3[s2] = f3 + "Minutes", n3[i2] = f3 + "Seconds", n3[r2] = f3 + "Milliseconds", n3)[o3], $3 = o3 === a2 ? this.$D + (e3 - this.$W) : e3;
          if (o3 === c2 || o3 === h2) {
            var y3 = this.clone().set(d2, 1);
            y3.$d[l3]($3), y3.init(), this.$d = y3.set(d2, Math.min(this.$D, y3.daysInMonth())).$d;
          } else l3 && this.$d[l3]($3);
          return this.init(), this;
        }, m3.set = function(t3, e3) {
          return this.clone().$set(t3, e3);
        }, m3.get = function(t3) {
          return this[b2.p(t3)]();
        }, m3.add = function(r3, f3) {
          var d3, l3 = this;
          r3 = Number(r3);
          var $3 = b2.p(f3), y3 = function(t3) {
            var e3 = O2(l3);
            return b2.w(e3.date(e3.date() + Math.round(t3 * r3)), l3);
          };
          if ($3 === c2) return this.set(c2, this.$M + r3);
          if ($3 === h2) return this.set(h2, this.$y + r3);
          if ($3 === a2) return y3(1);
          if ($3 === o2) return y3(7);
          var M4 = (d3 = {}, d3[s2] = e2, d3[u2] = n2, d3[i2] = t2, d3)[$3] || 1, m4 = this.$d.getTime() + r3 * M4;
          return b2.w(m4, this);
        }, m3.subtract = function(t3, e3) {
          return this.add(-1 * t3, e3);
        }, m3.format = function(t3) {
          var e3 = this, n3 = this.$locale();
          if (!this.isValid()) return n3.invalidDate || l2;
          var r3 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i3 = b2.z(this), s3 = this.$H, u3 = this.$m, a3 = this.$M, o3 = n3.weekdays, c3 = n3.months, f3 = n3.meridiem, h3 = function(t4, n4, i4, s4) {
            return t4 && (t4[n4] || t4(e3, r3)) || i4[n4].slice(0, s4);
          }, d3 = function(t4) {
            return b2.s(s3 % 12 || 12, t4, "0");
          }, $3 = f3 || function(t4, e4, n4) {
            var r4 = t4 < 12 ? "AM" : "PM";
            return n4 ? r4.toLowerCase() : r4;
          };
          return r3.replace(y2, function(t4, r4) {
            return r4 || function(t5) {
              switch (t5) {
                case "YY":
                  return String(e3.$y).slice(-2);
                case "YYYY":
                  return b2.s(e3.$y, 4, "0");
                case "M":
                  return a3 + 1;
                case "MM":
                  return b2.s(a3 + 1, 2, "0");
                case "MMM":
                  return h3(n3.monthsShort, a3, c3, 3);
                case "MMMM":
                  return h3(c3, a3);
                case "D":
                  return e3.$D;
                case "DD":
                  return b2.s(e3.$D, 2, "0");
                case "d":
                  return String(e3.$W);
                case "dd":
                  return h3(n3.weekdaysMin, e3.$W, o3, 2);
                case "ddd":
                  return h3(n3.weekdaysShort, e3.$W, o3, 3);
                case "dddd":
                  return o3[e3.$W];
                case "H":
                  return String(s3);
                case "HH":
                  return b2.s(s3, 2, "0");
                case "h":
                  return d3(1);
                case "hh":
                  return d3(2);
                case "a":
                  return $3(s3, u3, true);
                case "A":
                  return $3(s3, u3, false);
                case "m":
                  return String(u3);
                case "mm":
                  return b2.s(u3, 2, "0");
                case "s":
                  return String(e3.$s);
                case "ss":
                  return b2.s(e3.$s, 2, "0");
                case "SSS":
                  return b2.s(e3.$ms, 3, "0");
                case "Z":
                  return i3;
              }
              return null;
            }(t4) || i3.replace(":", "");
          });
        }, m3.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m3.diff = function(r3, d3, l3) {
          var $3, y3 = this, M4 = b2.p(d3), m4 = O2(r3), v3 = (m4.utcOffset() - this.utcOffset()) * e2, g3 = this - m4, D3 = function() {
            return b2.m(y3, m4);
          };
          switch (M4) {
            case h2:
              $3 = D3() / 12;
              break;
            case c2:
              $3 = D3();
              break;
            case f2:
              $3 = D3() / 3;
              break;
            case o2:
              $3 = (g3 - v3) / 6048e5;
              break;
            case a2:
              $3 = (g3 - v3) / 864e5;
              break;
            case u2:
              $3 = g3 / n2;
              break;
            case s2:
              $3 = g3 / e2;
              break;
            case i2:
              $3 = g3 / t2;
              break;
            default:
              $3 = g3;
          }
          return l3 ? $3 : b2.a($3);
        }, m3.daysInMonth = function() {
          return this.endOf(c2).$D;
        }, m3.$locale = function() {
          return D2[this.$L];
        }, m3.locale = function(t3, e3) {
          if (!t3) return this.$L;
          var n3 = this.clone(), r3 = w2(t3, e3, true);
          return r3 && (n3.$L = r3), n3;
        }, m3.clone = function() {
          return b2.w(this.$d, this);
        }, m3.toDate = function() {
          return new Date(this.valueOf());
        }, m3.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m3.toISOString = function() {
          return this.$d.toISOString();
        }, m3.toString = function() {
          return this.$d.toUTCString();
        }, M3;
      }(), k2 = _2.prototype;
      return O2.prototype = k2, [["$ms", r2], ["$s", i2], ["$m", s2], ["$H", u2], ["$W", a2], ["$M", c2], ["$y", h2], ["$D", d2]].forEach(function(t3) {
        k2[t3[1]] = function(e3) {
          return this.$g(e3, t3[0], t3[1]);
        };
      }), O2.extend = function(t3, e3) {
        return t3.$i || (t3(e3, _2, O2), t3.$i = true), O2;
      }, O2.locale = w2, O2.isDayjs = S2, O2.unix = function(t3) {
        return O2(1e3 * t3);
      }, O2.en = D2[g2], O2.Ls = D2, O2.p = {}, O2;
    });
  })(dayjs_min$1);
  return dayjs_min$1.exports;
}
var dayjs_minExports = requireDayjs_min();
const dayjs = /* @__PURE__ */ getDefaultExportFromCjs(dayjs_minExports);
var weekday$2 = { exports: {} };
var weekday$1 = weekday$2.exports;
var hasRequiredWeekday;
function requireWeekday() {
  if (hasRequiredWeekday) return weekday$2.exports;
  hasRequiredWeekday = 1;
  (function(module2, exports2) {
    !function(e2, t2) {
      module2.exports = t2();
    }(weekday$1, function() {
      return function(e2, t2) {
        t2.prototype.weekday = function(e3) {
          var t3 = this.$locale().weekStart || 0, i2 = this.$W, n2 = (i2 < t3 ? i2 + 7 : i2) - t3;
          return this.$utils().u(e3) ? n2 : this.subtract(n2, "day").add(e3, "day");
        };
      };
    });
  })(weekday$2);
  return weekday$2.exports;
}
var weekdayExports = requireWeekday();
const weekday = /* @__PURE__ */ getDefaultExportFromCjs(weekdayExports);
var localeData$2 = { exports: {} };
var localeData$1 = localeData$2.exports;
var hasRequiredLocaleData;
function requireLocaleData() {
  if (hasRequiredLocaleData) return localeData$2.exports;
  hasRequiredLocaleData = 1;
  (function(module2, exports2) {
    !function(n2, e2) {
      module2.exports = e2();
    }(localeData$1, function() {
      return function(n2, e2, t2) {
        var r2 = e2.prototype, o2 = function(n3) {
          return n3 && (n3.indexOf ? n3 : n3.s);
        }, u2 = function(n3, e3, t3, r3, u3) {
          var i3 = n3.name ? n3 : n3.$locale(), a3 = o2(i3[e3]), s3 = o2(i3[t3]), f2 = a3 || s3.map(function(n4) {
            return n4.slice(0, r3);
          });
          if (!u3) return f2;
          var d2 = i3.weekStart;
          return f2.map(function(n4, e4) {
            return f2[(e4 + (d2 || 0)) % 7];
          });
        }, i2 = function() {
          return t2.Ls[t2.locale()];
        }, a2 = function(n3, e3) {
          return n3.formats[e3] || function(n4) {
            return n4.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(n5, e4, t3) {
              return e4 || t3.slice(1);
            });
          }(n3.formats[e3.toUpperCase()]);
        }, s2 = function() {
          var n3 = this;
          return { months: function(e3) {
            return e3 ? e3.format("MMMM") : u2(n3, "months");
          }, monthsShort: function(e3) {
            return e3 ? e3.format("MMM") : u2(n3, "monthsShort", "months", 3);
          }, firstDayOfWeek: function() {
            return n3.$locale().weekStart || 0;
          }, weekdays: function(e3) {
            return e3 ? e3.format("dddd") : u2(n3, "weekdays");
          }, weekdaysMin: function(e3) {
            return e3 ? e3.format("dd") : u2(n3, "weekdaysMin", "weekdays", 2);
          }, weekdaysShort: function(e3) {
            return e3 ? e3.format("ddd") : u2(n3, "weekdaysShort", "weekdays", 3);
          }, longDateFormat: function(e3) {
            return a2(n3.$locale(), e3);
          }, meridiem: this.$locale().meridiem, ordinal: this.$locale().ordinal };
        };
        r2.localeData = function() {
          return s2.bind(this)();
        }, t2.localeData = function() {
          var n3 = i2();
          return { firstDayOfWeek: function() {
            return n3.weekStart || 0;
          }, weekdays: function() {
            return t2.weekdays();
          }, weekdaysShort: function() {
            return t2.weekdaysShort();
          }, weekdaysMin: function() {
            return t2.weekdaysMin();
          }, months: function() {
            return t2.months();
          }, monthsShort: function() {
            return t2.monthsShort();
          }, longDateFormat: function(e3) {
            return a2(n3, e3);
          }, meridiem: n3.meridiem, ordinal: n3.ordinal };
        }, t2.months = function() {
          return u2(i2(), "months");
        }, t2.monthsShort = function() {
          return u2(i2(), "monthsShort", "months", 3);
        }, t2.weekdays = function(n3) {
          return u2(i2(), "weekdays", null, null, n3);
        }, t2.weekdaysShort = function(n3) {
          return u2(i2(), "weekdaysShort", "weekdays", 3, n3);
        }, t2.weekdaysMin = function(n3) {
          return u2(i2(), "weekdaysMin", "weekdays", 2, n3);
        };
      };
    });
  })(localeData$2);
  return localeData$2.exports;
}
var localeDataExports = requireLocaleData();
const localeData = /* @__PURE__ */ getDefaultExportFromCjs(localeDataExports);
var weekOfYear$2 = { exports: {} };
var weekOfYear$1 = weekOfYear$2.exports;
var hasRequiredWeekOfYear;
function requireWeekOfYear() {
  if (hasRequiredWeekOfYear) return weekOfYear$2.exports;
  hasRequiredWeekOfYear = 1;
  (function(module2, exports2) {
    !function(e2, t2) {
      module2.exports = t2();
    }(weekOfYear$1, function() {
      var e2 = "week", t2 = "year";
      return function(i2, n2, r2) {
        var f2 = n2.prototype;
        f2.week = function(i3) {
          if (void 0 === i3 && (i3 = null), null !== i3) return this.add(7 * (i3 - this.week()), "day");
          var n3 = this.$locale().yearStart || 1;
          if (11 === this.month() && this.date() > 25) {
            var f3 = r2(this).startOf(t2).add(1, t2).date(n3), s2 = r2(this).endOf(e2);
            if (f3.isBefore(s2)) return 1;
          }
          var a2 = r2(this).startOf(t2).date(n3).startOf(e2).subtract(1, "millisecond"), o2 = this.diff(a2, e2, true);
          return o2 < 0 ? r2(this).startOf("week").week() : Math.ceil(o2);
        }, f2.weeks = function(e3) {
          return void 0 === e3 && (e3 = null), this.week(e3);
        };
      };
    });
  })(weekOfYear$2);
  return weekOfYear$2.exports;
}
var weekOfYearExports = requireWeekOfYear();
const weekOfYear = /* @__PURE__ */ getDefaultExportFromCjs(weekOfYearExports);
var weekYear$2 = { exports: {} };
var weekYear$1 = weekYear$2.exports;
var hasRequiredWeekYear;
function requireWeekYear() {
  if (hasRequiredWeekYear) return weekYear$2.exports;
  hasRequiredWeekYear = 1;
  (function(module2, exports2) {
    !function(e2, t2) {
      module2.exports = t2();
    }(weekYear$1, function() {
      return function(e2, t2) {
        t2.prototype.weekYear = function() {
          var e3 = this.month(), t3 = this.week(), n2 = this.year();
          return 1 === t3 && 11 === e3 ? n2 + 1 : 0 === e3 && t3 >= 52 ? n2 - 1 : n2;
        };
      };
    });
  })(weekYear$2);
  return weekYear$2.exports;
}
var weekYearExports = requireWeekYear();
const weekYear = /* @__PURE__ */ getDefaultExportFromCjs(weekYearExports);
var quarterOfYear$2 = { exports: {} };
var quarterOfYear$1 = quarterOfYear$2.exports;
var hasRequiredQuarterOfYear;
function requireQuarterOfYear() {
  if (hasRequiredQuarterOfYear) return quarterOfYear$2.exports;
  hasRequiredQuarterOfYear = 1;
  (function(module2, exports2) {
    !function(t2, n2) {
      module2.exports = n2();
    }(quarterOfYear$1, function() {
      var t2 = "month", n2 = "quarter";
      return function(e2, i2) {
        var r2 = i2.prototype;
        r2.quarter = function(t3) {
          return this.$utils().u(t3) ? Math.ceil((this.month() + 1) / 3) : this.month(this.month() % 3 + 3 * (t3 - 1));
        };
        var s2 = r2.add;
        r2.add = function(e3, i3) {
          return e3 = Number(e3), this.$utils().p(i3) === n2 ? this.add(3 * e3, t2) : s2.bind(this)(e3, i3);
        };
        var u2 = r2.startOf;
        r2.startOf = function(e3, i3) {
          var r3 = this.$utils(), s3 = !!r3.u(i3) || i3;
          if (r3.p(e3) === n2) {
            var o2 = this.quarter() - 1;
            return s3 ? this.month(3 * o2).startOf(t2).startOf("day") : this.month(3 * o2 + 2).endOf(t2).endOf("day");
          }
          return u2.bind(this)(e3, i3);
        };
      };
    });
  })(quarterOfYear$2);
  return quarterOfYear$2.exports;
}
var quarterOfYearExports = requireQuarterOfYear();
const quarterOfYear = /* @__PURE__ */ getDefaultExportFromCjs(quarterOfYearExports);
var advancedFormat$2 = { exports: {} };
var advancedFormat$1 = advancedFormat$2.exports;
var hasRequiredAdvancedFormat;
function requireAdvancedFormat() {
  if (hasRequiredAdvancedFormat) return advancedFormat$2.exports;
  hasRequiredAdvancedFormat = 1;
  (function(module2, exports2) {
    !function(e2, t2) {
      module2.exports = t2();
    }(advancedFormat$1, function() {
      return function(e2, t2) {
        var r2 = t2.prototype, n2 = r2.format;
        r2.format = function(e3) {
          var t3 = this, r3 = this.$locale();
          if (!this.isValid()) return n2.bind(this)(e3);
          var s2 = this.$utils(), a2 = (e3 || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(e4) {
            switch (e4) {
              case "Q":
                return Math.ceil((t3.$M + 1) / 3);
              case "Do":
                return r3.ordinal(t3.$D);
              case "gggg":
                return t3.weekYear();
              case "GGGG":
                return t3.isoWeekYear();
              case "wo":
                return r3.ordinal(t3.week(), "W");
              case "w":
              case "ww":
                return s2.s(t3.week(), "w" === e4 ? 1 : 2, "0");
              case "W":
              case "WW":
                return s2.s(t3.isoWeek(), "W" === e4 ? 1 : 2, "0");
              case "k":
              case "kk":
                return s2.s(String(0 === t3.$H ? 24 : t3.$H), "k" === e4 ? 1 : 2, "0");
              case "X":
                return Math.floor(t3.$d.getTime() / 1e3);
              case "x":
                return t3.$d.getTime();
              case "z":
                return "[" + t3.offsetName() + "]";
              case "zzz":
                return "[" + t3.offsetName("long") + "]";
              default:
                return e4;
            }
          });
          return n2.bind(this)(a2);
        };
      };
    });
  })(advancedFormat$2);
  return advancedFormat$2.exports;
}
var advancedFormatExports = requireAdvancedFormat();
const advancedFormat = /* @__PURE__ */ getDefaultExportFromCjs(advancedFormatExports);
var customParseFormat$2 = { exports: {} };
var customParseFormat$1 = customParseFormat$2.exports;
var hasRequiredCustomParseFormat;
function requireCustomParseFormat() {
  if (hasRequiredCustomParseFormat) return customParseFormat$2.exports;
  hasRequiredCustomParseFormat = 1;
  (function(module2, exports2) {
    !function(e2, t2) {
      module2.exports = t2();
    }(customParseFormat$1, function() {
      var e2 = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, t2 = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|Q|YYYY|YY?|ww?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n2 = /\d/, r2 = /\d\d/, i2 = /\d\d?/, o2 = /\d*[^-_:/,()\s\d]+/, s2 = {}, a2 = function(e3) {
        return (e3 = +e3) + (e3 > 68 ? 1900 : 2e3);
      };
      var f2 = function(e3) {
        return function(t3) {
          this[e3] = +t3;
        };
      }, h2 = [/[+-]\d\d:?(\d\d)?|Z/, function(e3) {
        (this.zone || (this.zone = {})).offset = function(e4) {
          if (!e4) return 0;
          if ("Z" === e4) return 0;
          var t3 = e4.match(/([+-]|\d\d)/g), n3 = 60 * t3[1] + (+t3[2] || 0);
          return 0 === n3 ? 0 : "+" === t3[0] ? -n3 : n3;
        }(e3);
      }], u2 = function(e3) {
        var t3 = s2[e3];
        return t3 && (t3.indexOf ? t3 : t3.s.concat(t3.f));
      }, d2 = function(e3, t3) {
        var n3, r3 = s2.meridiem;
        if (r3) {
          for (var i3 = 1; i3 <= 24; i3 += 1) if (e3.indexOf(r3(i3, 0, t3)) > -1) {
            n3 = i3 > 12;
            break;
          }
        } else n3 = e3 === (t3 ? "pm" : "PM");
        return n3;
      }, c2 = { A: [o2, function(e3) {
        this.afternoon = d2(e3, false);
      }], a: [o2, function(e3) {
        this.afternoon = d2(e3, true);
      }], Q: [n2, function(e3) {
        this.month = 3 * (e3 - 1) + 1;
      }], S: [n2, function(e3) {
        this.milliseconds = 100 * +e3;
      }], SS: [r2, function(e3) {
        this.milliseconds = 10 * +e3;
      }], SSS: [/\d{3}/, function(e3) {
        this.milliseconds = +e3;
      }], s: [i2, f2("seconds")], ss: [i2, f2("seconds")], m: [i2, f2("minutes")], mm: [i2, f2("minutes")], H: [i2, f2("hours")], h: [i2, f2("hours")], HH: [i2, f2("hours")], hh: [i2, f2("hours")], D: [i2, f2("day")], DD: [r2, f2("day")], Do: [o2, function(e3) {
        var t3 = s2.ordinal, n3 = e3.match(/\d+/);
        if (this.day = n3[0], t3) for (var r3 = 1; r3 <= 31; r3 += 1) t3(r3).replace(/\[|\]/g, "") === e3 && (this.day = r3);
      }], w: [i2, f2("week")], ww: [r2, f2("week")], M: [i2, f2("month")], MM: [r2, f2("month")], MMM: [o2, function(e3) {
        var t3 = u2("months"), n3 = (u2("monthsShort") || t3.map(function(e4) {
          return e4.slice(0, 3);
        })).indexOf(e3) + 1;
        if (n3 < 1) throw new Error();
        this.month = n3 % 12 || n3;
      }], MMMM: [o2, function(e3) {
        var t3 = u2("months").indexOf(e3) + 1;
        if (t3 < 1) throw new Error();
        this.month = t3 % 12 || t3;
      }], Y: [/[+-]?\d+/, f2("year")], YY: [r2, function(e3) {
        this.year = a2(e3);
      }], YYYY: [/\d{4}/, f2("year")], Z: h2, ZZ: h2 };
      function l2(n3) {
        var r3, i3;
        r3 = n3, i3 = s2 && s2.formats;
        for (var o3 = (n3 = r3.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t3, n4, r4) {
          var o4 = r4 && r4.toUpperCase();
          return n4 || i3[r4] || e2[r4] || i3[o4].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e3, t4, n5) {
            return t4 || n5.slice(1);
          });
        })).match(t2), a3 = o3.length, f3 = 0; f3 < a3; f3 += 1) {
          var h3 = o3[f3], u3 = c2[h3], d3 = u3 && u3[0], l3 = u3 && u3[1];
          o3[f3] = l3 ? { regex: d3, parser: l3 } : h3.replace(/^\[|\]$/g, "");
        }
        return function(e3) {
          for (var t3 = {}, n4 = 0, r4 = 0; n4 < a3; n4 += 1) {
            var i4 = o3[n4];
            if ("string" == typeof i4) r4 += i4.length;
            else {
              var s3 = i4.regex, f4 = i4.parser, h4 = e3.slice(r4), u4 = s3.exec(h4)[0];
              f4.call(t3, u4), e3 = e3.replace(u4, "");
            }
          }
          return function(e4) {
            var t4 = e4.afternoon;
            if (void 0 !== t4) {
              var n5 = e4.hours;
              t4 ? n5 < 12 && (e4.hours += 12) : 12 === n5 && (e4.hours = 0), delete e4.afternoon;
            }
          }(t3), t3;
        };
      }
      return function(e3, t3, n3) {
        n3.p.customParseFormat = true, e3 && e3.parseTwoDigitYear && (a2 = e3.parseTwoDigitYear);
        var r3 = t3.prototype, i3 = r3.parse;
        r3.parse = function(e4) {
          var t4 = e4.date, r4 = e4.utc, o3 = e4.args;
          this.$u = r4;
          var a3 = o3[1];
          if ("string" == typeof a3) {
            var f3 = true === o3[2], h3 = true === o3[3], u3 = f3 || h3, d3 = o3[2];
            h3 && (d3 = o3[2]), s2 = this.$locale(), !f3 && d3 && (s2 = n3.Ls[d3]), this.$d = function(e5, t5, n4, r5) {
              try {
                if (["x", "X"].indexOf(t5) > -1) return new Date(("X" === t5 ? 1e3 : 1) * e5);
                var i4 = l2(t5)(e5), o4 = i4.year, s3 = i4.month, a4 = i4.day, f4 = i4.hours, h4 = i4.minutes, u4 = i4.seconds, d4 = i4.milliseconds, c4 = i4.zone, m3 = i4.week, M3 = /* @__PURE__ */ new Date(), Y2 = a4 || (o4 || s3 ? 1 : M3.getDate()), p = o4 || M3.getFullYear(), v2 = 0;
                o4 && !s3 || (v2 = s3 > 0 ? s3 - 1 : M3.getMonth());
                var D2, w2 = f4 || 0, g2 = h4 || 0, y2 = u4 || 0, L2 = d4 || 0;
                return c4 ? new Date(Date.UTC(p, v2, Y2, w2, g2, y2, L2 + 60 * c4.offset * 1e3)) : n4 ? new Date(Date.UTC(p, v2, Y2, w2, g2, y2, L2)) : (D2 = new Date(p, v2, Y2, w2, g2, y2, L2), m3 && (D2 = r5(D2).week(m3).toDate()), D2);
              } catch (e6) {
                return /* @__PURE__ */ new Date("");
              }
            }(t4, a3, r4, n3), this.init(), d3 && true !== d3 && (this.$L = this.locale(d3).$L), u3 && t4 != this.format(a3) && (this.$d = /* @__PURE__ */ new Date("")), s2 = {};
          } else if (a3 instanceof Array) for (var c3 = a3.length, m2 = 1; m2 <= c3; m2 += 1) {
            o3[1] = a3[m2 - 1];
            var M2 = n3.apply(this, o3);
            if (M2.isValid()) {
              this.$d = M2.$d, this.$L = M2.$L, this.init();
              break;
            }
            m2 === c3 && (this.$d = /* @__PURE__ */ new Date(""));
          }
          else i3.call(this, e4);
        };
      };
    });
  })(customParseFormat$2);
  return customParseFormat$2.exports;
}
var customParseFormatExports = requireCustomParseFormat();
const customParseFormat = /* @__PURE__ */ getDefaultExportFromCjs(customParseFormatExports);
dayjs.extend(customParseFormat);
dayjs.extend(advancedFormat);
dayjs.extend(weekday);
dayjs.extend(localeData);
dayjs.extend(weekOfYear);
dayjs.extend(weekYear);
dayjs.extend(quarterOfYear);
dayjs.extend((_o, c2) => {
  const proto = c2.prototype;
  const oldFormat = proto.format;
  proto.format = function f2(formatStr) {
    const str = (formatStr || "").replace("Wo", "wo");
    return oldFormat.bind(this)(str);
  };
});
const localeMap = {
  // ar_EG:
  // az_AZ:
  // bg_BG:
  bn_BD: "bn-bd",
  by_BY: "be",
  // ca_ES:
  // cs_CZ:
  // da_DK:
  // de_DE:
  // el_GR:
  en_GB: "en-gb",
  en_US: "en",
  // es_ES:
  // et_EE:
  // fa_IR:
  // fi_FI:
  fr_BE: "fr",
  fr_CA: "fr-ca",
  // fr_FR:
  // ga_IE:
  // gl_ES:
  // he_IL:
  // hi_IN:
  // hr_HR:
  // hu_HU:
  hy_AM: "hy-am",
  // id_ID:
  // is_IS:
  // it_IT:
  // ja_JP:
  // ka_GE:
  // kk_KZ:
  // km_KH:
  kmr_IQ: "ku",
  // kn_IN:
  // ko_KR:
  // ku_IQ: // previous ku in antd
  // lt_LT:
  // lv_LV:
  // mk_MK:
  // ml_IN:
  // mn_MN:
  // ms_MY:
  // nb_NO:
  // ne_NP:
  nl_BE: "nl-be",
  // nl_NL:
  // pl_PL:
  pt_BR: "pt-br",
  // pt_PT:
  // ro_RO:
  // ru_RU:
  // sk_SK:
  // sl_SI:
  // sr_RS:
  // sv_SE:
  // ta_IN:
  // th_TH:
  // tr_TR:
  // uk_UA:
  // ur_PK:
  // vi_VN:
  zh_CN: "zh-cn",
  zh_HK: "zh-hk",
  zh_TW: "zh-tw"
};
const parseLocale = (locale2) => {
  const mapLocale = localeMap[locale2];
  return mapLocale || locale2.split("_")[0];
};
const parseNoMatchNotice = () => {
  noteOnce(false, "Not match any format. Please help to fire a issue about this.");
};
const advancedFormatRegex = /\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|k{1,2}|S/g;
function findTargetStr(val, index2, segmentation) {
  const items = [...new Set(val.split(segmentation))];
  let idx = 0;
  for (let i2 = 0; i2 < items.length; i2++) {
    const item = items[i2];
    idx += item.length;
    if (idx > index2) {
      return item;
    }
    idx += segmentation.length;
  }
}
const toDateWithValueFormat = (val, valueFormat) => {
  if (!val) return null;
  if (dayjs.isDayjs(val)) {
    return val;
  }
  const matchs = valueFormat.matchAll(advancedFormatRegex);
  let baseDate = dayjs(val, valueFormat);
  if (matchs === null) {
    return baseDate;
  }
  for (const match2 of matchs) {
    const origin = match2[0];
    const index2 = match2["index"];
    if (origin === "Q") {
      const segmentation = val.slice(index2 - 1, index2);
      const quarterStr = findTargetStr(val, index2, segmentation).match(/\d+/)[0];
      baseDate = baseDate.quarter(parseInt(quarterStr));
    }
    if (origin.toLowerCase() === "wo") {
      const segmentation = val.slice(index2 - 1, index2);
      const weekStr = findTargetStr(val, index2, segmentation).match(/\d+/)[0];
      baseDate = baseDate.week(parseInt(weekStr));
    }
    if (origin.toLowerCase() === "ww") {
      baseDate = baseDate.week(parseInt(val.slice(index2, index2 + origin.length)));
    }
    if (origin.toLowerCase() === "w") {
      baseDate = baseDate.week(parseInt(val.slice(index2, index2 + origin.length + 1)));
    }
  }
  return baseDate;
};
const generateConfig = {
  // get
  getNow: () => dayjs(),
  getFixedDate: (string3) => dayjs(string3, ["YYYY-M-DD", "YYYY-MM-DD"]),
  getEndDate: (date4) => date4.endOf("month"),
  getWeekDay: (date4) => {
    const clone2 = date4.locale("en");
    return clone2.weekday() + clone2.localeData().firstDayOfWeek();
  },
  getYear: (date4) => date4.year(),
  getMonth: (date4) => date4.month(),
  getDate: (date4) => date4.date(),
  getHour: (date4) => date4.hour(),
  getMinute: (date4) => date4.minute(),
  getSecond: (date4) => date4.second(),
  // set
  addYear: (date4, diff) => date4.add(diff, "year"),
  addMonth: (date4, diff) => date4.add(diff, "month"),
  addDate: (date4, diff) => date4.add(diff, "day"),
  setYear: (date4, year) => date4.year(year),
  setMonth: (date4, month) => date4.month(month),
  setDate: (date4, num) => date4.date(num),
  setHour: (date4, hour) => date4.hour(hour),
  setMinute: (date4, minute) => date4.minute(minute),
  setSecond: (date4, second) => date4.second(second),
  // Compare
  isAfter: (date1, date22) => date1.isAfter(date22),
  isValidate: (date4) => date4.isValid(),
  locale: {
    getWeekFirstDay: (locale2) => dayjs().locale(parseLocale(locale2)).localeData().firstDayOfWeek(),
    getWeekFirstDate: (locale2, date4) => date4.locale(parseLocale(locale2)).weekday(0),
    getWeek: (locale2, date4) => date4.locale(parseLocale(locale2)).week(),
    getShortWeekDays: (locale2) => dayjs().locale(parseLocale(locale2)).localeData().weekdaysMin(),
    getShortMonths: (locale2) => dayjs().locale(parseLocale(locale2)).localeData().monthsShort(),
    format: (locale2, date4, format2) => date4.locale(parseLocale(locale2)).format(format2),
    parse: (locale2, text, formats) => {
      const localeStr = parseLocale(locale2);
      for (let i2 = 0; i2 < formats.length; i2 += 1) {
        const format2 = formats[i2];
        const formatText = text;
        if (format2.includes("wo") || format2.includes("Wo")) {
          const year = formatText.split("-")[0];
          const weekStr = formatText.split("-")[1];
          const firstWeek = dayjs(year, "YYYY").startOf("year").locale(localeStr);
          for (let j2 = 0; j2 <= 52; j2 += 1) {
            const nextWeek = firstWeek.add(j2, "week");
            if (nextWeek.format("Wo") === weekStr) {
              return nextWeek;
            }
          }
          parseNoMatchNotice();
          return null;
        }
        const date4 = dayjs(formatText, format2, true).locale(localeStr);
        if (date4.isValid()) {
          return date4;
        }
      }
      if (!text) {
        parseNoMatchNotice();
      }
      return null;
    }
  },
  toDate: (value, valueFormat) => {
    if (Array.isArray(value)) {
      return value.map((val) => toDateWithValueFormat(val, valueFormat));
    } else {
      return toDateWithValueFormat(value, valueFormat);
    }
  },
  toString: (value, valueFormat) => {
    if (Array.isArray(value)) {
      return value.map((val) => dayjs.isDayjs(val) ? val.format(valueFormat) : val);
    } else {
      return dayjs.isDayjs(value) ? value.format(valueFormat) : value;
    }
  }
};
function useMergeProps(props2) {
  const attrs = useAttrs();
  return _extends$1(_extends$1({}, props2), attrs);
}
const PanelContextKey = Symbol("PanelContextProps");
const useProvidePanel = (props2) => {
  provide(PanelContextKey, props2);
};
const useInjectPanel = () => {
  return inject(PanelContextKey, {});
};
const HIDDEN_STYLE$1 = {
  visibility: "hidden"
};
function Header$2(_props, _ref) {
  let {
    slots
  } = _ref;
  var _a2;
  const props2 = useMergeProps(_props);
  const {
    prefixCls,
    prevIcon = "‹",
    nextIcon = "›",
    superPrevIcon = "«",
    superNextIcon = "»",
    onSuperPrev,
    onSuperNext,
    onPrev,
    onNext
  } = props2;
  const {
    hideNextBtn,
    hidePrevBtn
  } = useInjectPanel();
  return createVNode("div", {
    "class": prefixCls
  }, [onSuperPrev && createVNode("button", {
    "type": "button",
    "onClick": onSuperPrev,
    "tabindex": -1,
    "class": `${prefixCls}-super-prev-btn`,
    "style": hidePrevBtn.value ? HIDDEN_STYLE$1 : {}
  }, [superPrevIcon]), onPrev && createVNode("button", {
    "type": "button",
    "onClick": onPrev,
    "tabindex": -1,
    "class": `${prefixCls}-prev-btn`,
    "style": hidePrevBtn.value ? HIDDEN_STYLE$1 : {}
  }, [prevIcon]), createVNode("div", {
    "class": `${prefixCls}-view`
  }, [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]), onNext && createVNode("button", {
    "type": "button",
    "onClick": onNext,
    "tabindex": -1,
    "class": `${prefixCls}-next-btn`,
    "style": hideNextBtn.value ? HIDDEN_STYLE$1 : {}
  }, [nextIcon]), onSuperNext && createVNode("button", {
    "type": "button",
    "onClick": onSuperNext,
    "tabindex": -1,
    "class": `${prefixCls}-super-next-btn`,
    "style": hideNextBtn.value ? HIDDEN_STYLE$1 : {}
  }, [superNextIcon])]);
}
Header$2.displayName = "Header";
Header$2.inheritAttrs = false;
function DecadeHeader(_props) {
  const props2 = useMergeProps(_props);
  const {
    prefixCls,
    generateConfig: generateConfig2,
    viewDate,
    onPrevDecades,
    onNextDecades
  } = props2;
  const {
    hideHeader
  } = useInjectPanel();
  if (hideHeader) {
    return null;
  }
  const headerPrefixCls = `${prefixCls}-header`;
  const yearNumber = generateConfig2.getYear(viewDate);
  const startYear = Math.floor(yearNumber / DECADE_DISTANCE_COUNT) * DECADE_DISTANCE_COUNT;
  const endYear = startYear + DECADE_DISTANCE_COUNT - 1;
  return createVNode(Header$2, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "prefixCls": headerPrefixCls,
    "onSuperPrev": onPrevDecades,
    "onSuperNext": onNextDecades
  }), {
    default: () => [startYear, createTextVNode("-"), endYear]
  });
}
DecadeHeader.displayName = "DecadeHeader";
DecadeHeader.inheritAttrs = false;
function setTime(generateConfig2, date4, hour, minute, second) {
  let nextTime = generateConfig2.setHour(date4, hour);
  nextTime = generateConfig2.setMinute(nextTime, minute);
  nextTime = generateConfig2.setSecond(nextTime, second);
  return nextTime;
}
function setDateTime(generateConfig2, date4, defaultDate) {
  if (!defaultDate) {
    return date4;
  }
  let newDate = date4;
  newDate = generateConfig2.setHour(newDate, generateConfig2.getHour(defaultDate));
  newDate = generateConfig2.setMinute(newDate, generateConfig2.getMinute(defaultDate));
  newDate = generateConfig2.setSecond(newDate, generateConfig2.getSecond(defaultDate));
  return newDate;
}
function getLowerBoundTime(hour, minute, second, hourStep, minuteStep, secondStep) {
  const lowerBoundHour = Math.floor(hour / hourStep) * hourStep;
  if (lowerBoundHour < hour) {
    return [lowerBoundHour, 60 - minuteStep, 60 - secondStep];
  }
  const lowerBoundMinute = Math.floor(minute / minuteStep) * minuteStep;
  if (lowerBoundMinute < minute) {
    return [lowerBoundHour, lowerBoundMinute, 60 - secondStep];
  }
  const lowerBoundSecond = Math.floor(second / secondStep) * secondStep;
  return [lowerBoundHour, lowerBoundMinute, lowerBoundSecond];
}
function getLastDay(generateConfig2, date4) {
  const year = generateConfig2.getYear(date4);
  const month = generateConfig2.getMonth(date4) + 1;
  const endDate = generateConfig2.getEndDate(generateConfig2.getFixedDate(`${year}-${month}-01`));
  const lastDay = generateConfig2.getDate(endDate);
  const monthShow = month < 10 ? `0${month}` : `${month}`;
  return `${year}-${monthShow}-${lastDay}`;
}
function PanelBody(_props) {
  const {
    prefixCls,
    disabledDate,
    onSelect,
    picker,
    rowNum,
    colNum,
    prefixColumn,
    rowClassName,
    baseDate,
    getCellClassName,
    getCellText,
    getCellNode,
    getCellDate,
    generateConfig: generateConfig2,
    titleCell,
    headerCells
  } = useMergeProps(_props);
  const {
    onDateMouseenter,
    onDateMouseleave,
    mode
  } = useInjectPanel();
  const cellPrefixCls = `${prefixCls}-cell`;
  const rows = [];
  for (let i2 = 0; i2 < rowNum; i2 += 1) {
    const row = [];
    let rowStartDate;
    for (let j2 = 0; j2 < colNum; j2 += 1) {
      const offset3 = i2 * colNum + j2;
      const currentDate = getCellDate(baseDate, offset3);
      const disabled = getCellDateDisabled({
        cellDate: currentDate,
        mode: mode.value,
        disabledDate,
        generateConfig: generateConfig2
      });
      if (j2 === 0) {
        rowStartDate = currentDate;
        if (prefixColumn) {
          row.push(prefixColumn(rowStartDate));
        }
      }
      const title = titleCell && titleCell(currentDate);
      row.push(createVNode("td", {
        "key": j2,
        "title": title,
        "class": classNames(cellPrefixCls, _extends$1({
          [`${cellPrefixCls}-disabled`]: disabled,
          [`${cellPrefixCls}-start`]: getCellText(currentDate) === 1 || picker === "year" && Number(title) % 10 === 0,
          [`${cellPrefixCls}-end`]: title === getLastDay(generateConfig2, currentDate) || picker === "year" && Number(title) % 10 === 9
        }, getCellClassName(currentDate))),
        "onClick": (e2) => {
          e2.stopPropagation();
          if (!disabled) {
            onSelect(currentDate);
          }
        },
        "onMouseenter": () => {
          if (!disabled && onDateMouseenter) {
            onDateMouseenter(currentDate);
          }
        },
        "onMouseleave": () => {
          if (!disabled && onDateMouseleave) {
            onDateMouseleave(currentDate);
          }
        }
      }, [getCellNode ? getCellNode(currentDate) : createVNode("div", {
        "class": `${cellPrefixCls}-inner`
      }, [getCellText(currentDate)])]));
    }
    rows.push(createVNode("tr", {
      "key": i2,
      "class": rowClassName && rowClassName(rowStartDate)
    }, [row]));
  }
  return createVNode("div", {
    "class": `${prefixCls}-body`
  }, [createVNode("table", {
    "class": `${prefixCls}-content`
  }, [headerCells && createVNode("thead", null, [createVNode("tr", null, [headerCells])]), createVNode("tbody", null, [rows])])]);
}
PanelBody.displayName = "PanelBody";
PanelBody.inheritAttrs = false;
const DECADE_COL_COUNT = 3;
const DECADE_ROW_COUNT = 4;
function DecadeBody(_props) {
  const props2 = useMergeProps(_props);
  const DECADE_UNIT_DIFF_DES = DECADE_UNIT_DIFF - 1;
  const {
    prefixCls,
    viewDate,
    generateConfig: generateConfig2
  } = props2;
  const cellPrefixCls = `${prefixCls}-cell`;
  const yearNumber = generateConfig2.getYear(viewDate);
  const decadeYearNumber = Math.floor(yearNumber / DECADE_UNIT_DIFF) * DECADE_UNIT_DIFF;
  const startDecadeYear = Math.floor(yearNumber / DECADE_DISTANCE_COUNT) * DECADE_DISTANCE_COUNT;
  const endDecadeYear = startDecadeYear + DECADE_DISTANCE_COUNT - 1;
  const baseDecadeYear = generateConfig2.setYear(viewDate, startDecadeYear - Math.ceil((DECADE_COL_COUNT * DECADE_ROW_COUNT * DECADE_UNIT_DIFF - DECADE_DISTANCE_COUNT) / 2));
  const getCellClassName = (date4) => {
    const startDecadeNumber = generateConfig2.getYear(date4);
    const endDecadeNumber = startDecadeNumber + DECADE_UNIT_DIFF_DES;
    return {
      [`${cellPrefixCls}-in-view`]: startDecadeYear <= startDecadeNumber && endDecadeNumber <= endDecadeYear,
      [`${cellPrefixCls}-selected`]: startDecadeNumber === decadeYearNumber
    };
  };
  return createVNode(PanelBody, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "rowNum": DECADE_ROW_COUNT,
    "colNum": DECADE_COL_COUNT,
    "baseDate": baseDecadeYear,
    "getCellText": (date4) => {
      const startDecadeNumber = generateConfig2.getYear(date4);
      return `${startDecadeNumber}-${startDecadeNumber + DECADE_UNIT_DIFF_DES}`;
    },
    "getCellClassName": getCellClassName,
    "getCellDate": (date4, offset3) => generateConfig2.addYear(date4, offset3 * DECADE_UNIT_DIFF)
  }), null);
}
DecadeBody.displayName = "DecadeBody";
DecadeBody.inheritAttrs = false;
const scrollIds = /* @__PURE__ */ new Map();
function waitElementReady(element, callback) {
  let id;
  function tryOrNextFrame() {
    if (isVisible(element)) {
      callback();
    } else {
      id = wrapperRaf(() => {
        tryOrNextFrame();
      });
    }
  }
  tryOrNextFrame();
  return () => {
    wrapperRaf.cancel(id);
  };
}
function scrollTo(element, to, duration) {
  if (scrollIds.get(element)) {
    wrapperRaf.cancel(scrollIds.get(element));
  }
  if (duration <= 0) {
    scrollIds.set(element, wrapperRaf(() => {
      element.scrollTop = to;
    }));
    return;
  }
  const difference = to - element.scrollTop;
  const perTick = difference / duration * 10;
  scrollIds.set(element, wrapperRaf(() => {
    element.scrollTop += perTick;
    if (element.scrollTop !== to) {
      scrollTo(element, to, duration - 10);
    }
  }));
}
function createKeydownHandler(event, _ref) {
  let {
    onLeftRight,
    onCtrlLeftRight,
    onUpDown,
    onPageUpDown,
    onEnter
  } = _ref;
  const {
    which,
    ctrlKey,
    metaKey
  } = event;
  switch (which) {
    case KeyCode.LEFT:
      if (ctrlKey || metaKey) {
        if (onCtrlLeftRight) {
          onCtrlLeftRight(-1);
          return true;
        }
      } else if (onLeftRight) {
        onLeftRight(-1);
        return true;
      }
      break;
    case KeyCode.RIGHT:
      if (ctrlKey || metaKey) {
        if (onCtrlLeftRight) {
          onCtrlLeftRight(1);
          return true;
        }
      } else if (onLeftRight) {
        onLeftRight(1);
        return true;
      }
      break;
    case KeyCode.UP:
      if (onUpDown) {
        onUpDown(-1);
        return true;
      }
      break;
    case KeyCode.DOWN:
      if (onUpDown) {
        onUpDown(1);
        return true;
      }
      break;
    case KeyCode.PAGE_UP:
      if (onPageUpDown) {
        onPageUpDown(-1);
        return true;
      }
      break;
    case KeyCode.PAGE_DOWN:
      if (onPageUpDown) {
        onPageUpDown(1);
        return true;
      }
      break;
    case KeyCode.ENTER:
      if (onEnter) {
        onEnter();
        return true;
      }
      break;
  }
  return false;
}
function getDefaultFormat(format2, picker, showTime, use12Hours) {
  let mergedFormat = format2;
  if (!mergedFormat) {
    switch (picker) {
      case "time":
        mergedFormat = use12Hours ? "hh:mm:ss a" : "HH:mm:ss";
        break;
      case "week":
        mergedFormat = "gggg-wo";
        break;
      case "month":
        mergedFormat = "YYYY-MM";
        break;
      case "quarter":
        mergedFormat = "YYYY-[Q]Q";
        break;
      case "year":
        mergedFormat = "YYYY";
        break;
      default:
        mergedFormat = showTime ? "YYYY-MM-DD HH:mm:ss" : "YYYY-MM-DD";
    }
  }
  return mergedFormat;
}
function getInputSize(picker, format2, generateConfig2) {
  const defaultSize = picker === "time" ? 8 : 10;
  const length2 = typeof format2 === "function" ? format2(generateConfig2.getNow()).length : format2.length;
  return Math.max(defaultSize, length2) + 2;
}
let globalClickFunc = null;
const clickCallbacks = /* @__PURE__ */ new Set();
function addGlobalMousedownEvent(callback) {
  if (!globalClickFunc && typeof window !== "undefined" && window.addEventListener) {
    globalClickFunc = (e2) => {
      [...clickCallbacks].forEach((queueFunc) => {
        queueFunc(e2);
      });
    };
    window.addEventListener("mousedown", globalClickFunc);
  }
  clickCallbacks.add(callback);
  return () => {
    clickCallbacks.delete(callback);
    if (clickCallbacks.size === 0) {
      window.removeEventListener("mousedown", globalClickFunc);
      globalClickFunc = null;
    }
  };
}
function getTargetFromEvent(e2) {
  var _a2;
  const target = e2.target;
  if (e2.composed && target.shadowRoot) {
    return ((_a2 = e2.composedPath) === null || _a2 === void 0 ? void 0 : _a2.call(e2)[0]) || target;
  }
  return target;
}
const getYearNextMode = (next2) => {
  if (next2 === "month" || next2 === "date") {
    return "year";
  }
  return next2;
};
const getMonthNextMode = (next2) => {
  if (next2 === "date") {
    return "month";
  }
  return next2;
};
const getQuarterNextMode = (next2) => {
  if (next2 === "month" || next2 === "date") {
    return "quarter";
  }
  return next2;
};
const getWeekNextMode = (next2) => {
  if (next2 === "date") {
    return "week";
  }
  return next2;
};
const PickerModeMap = {
  year: getYearNextMode,
  month: getMonthNextMode,
  quarter: getQuarterNextMode,
  week: getWeekNextMode,
  time: null,
  date: null
};
function elementsContains(elements, target) {
  return elements.some((ele) => ele && ele.contains(target));
}
const DECADE_UNIT_DIFF = 10;
const DECADE_DISTANCE_COUNT = DECADE_UNIT_DIFF * 10;
function DecadePanel(_props) {
  const props2 = useMergeProps(_props);
  const {
    prefixCls,
    onViewDateChange,
    generateConfig: generateConfig2,
    viewDate,
    operationRef,
    onSelect,
    onPanelChange
  } = props2;
  const panelPrefixCls = `${prefixCls}-decade-panel`;
  operationRef.value = {
    onKeydown: (event) => createKeydownHandler(event, {
      onLeftRight: (diff) => {
        onSelect(generateConfig2.addYear(viewDate, diff * DECADE_UNIT_DIFF), "key");
      },
      onCtrlLeftRight: (diff) => {
        onSelect(generateConfig2.addYear(viewDate, diff * DECADE_DISTANCE_COUNT), "key");
      },
      onUpDown: (diff) => {
        onSelect(generateConfig2.addYear(viewDate, diff * DECADE_UNIT_DIFF * DECADE_COL_COUNT), "key");
      },
      onEnter: () => {
        onPanelChange("year", viewDate);
      }
    })
  };
  const onDecadesChange = (diff) => {
    const newDate = generateConfig2.addYear(viewDate, diff * DECADE_DISTANCE_COUNT);
    onViewDateChange(newDate);
    onPanelChange(null, newDate);
  };
  const onInternalSelect = (date4) => {
    onSelect(date4, "mouse");
    onPanelChange("year", date4);
  };
  return createVNode("div", {
    "class": panelPrefixCls
  }, [createVNode(DecadeHeader, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "prefixCls": prefixCls,
    "onPrevDecades": () => {
      onDecadesChange(-1);
    },
    "onNextDecades": () => {
      onDecadesChange(1);
    }
  }), null), createVNode(DecadeBody, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "prefixCls": prefixCls,
    "onSelect": onInternalSelect
  }), null)]);
}
DecadePanel.displayName = "DecadePanel";
DecadePanel.inheritAttrs = false;
const WEEK_DAY_COUNT = 7;
function isNullEqual(value1, value2) {
  if (!value1 && !value2) {
    return true;
  }
  if (!value1 || !value2) {
    return false;
  }
  return void 0;
}
function isSameDecade(generateConfig2, decade1, decade2) {
  const equal = isNullEqual(decade1, decade2);
  if (typeof equal === "boolean") {
    return equal;
  }
  const num1 = Math.floor(generateConfig2.getYear(decade1) / 10);
  const num2 = Math.floor(generateConfig2.getYear(decade2) / 10);
  return num1 === num2;
}
function isSameYear(generateConfig2, year1, year2) {
  const equal = isNullEqual(year1, year2);
  if (typeof equal === "boolean") {
    return equal;
  }
  return generateConfig2.getYear(year1) === generateConfig2.getYear(year2);
}
function getQuarter(generateConfig2, date4) {
  const quota = Math.floor(generateConfig2.getMonth(date4) / 3);
  return quota + 1;
}
function isSameQuarter(generateConfig2, quarter1, quarter2) {
  const equal = isNullEqual(quarter1, quarter2);
  if (typeof equal === "boolean") {
    return equal;
  }
  return isSameYear(generateConfig2, quarter1, quarter2) && getQuarter(generateConfig2, quarter1) === getQuarter(generateConfig2, quarter2);
}
function isSameMonth(generateConfig2, month1, month2) {
  const equal = isNullEqual(month1, month2);
  if (typeof equal === "boolean") {
    return equal;
  }
  return isSameYear(generateConfig2, month1, month2) && generateConfig2.getMonth(month1) === generateConfig2.getMonth(month2);
}
function isSameDate(generateConfig2, date1, date22) {
  const equal = isNullEqual(date1, date22);
  if (typeof equal === "boolean") {
    return equal;
  }
  return generateConfig2.getYear(date1) === generateConfig2.getYear(date22) && generateConfig2.getMonth(date1) === generateConfig2.getMonth(date22) && generateConfig2.getDate(date1) === generateConfig2.getDate(date22);
}
function isSameTime(generateConfig2, time1, time2) {
  const equal = isNullEqual(time1, time2);
  if (typeof equal === "boolean") {
    return equal;
  }
  return generateConfig2.getHour(time1) === generateConfig2.getHour(time2) && generateConfig2.getMinute(time1) === generateConfig2.getMinute(time2) && generateConfig2.getSecond(time1) === generateConfig2.getSecond(time2);
}
function isSameWeek(generateConfig2, locale2, date1, date22) {
  const equal = isNullEqual(date1, date22);
  if (typeof equal === "boolean") {
    return equal;
  }
  return generateConfig2.locale.getWeek(locale2, date1) === generateConfig2.locale.getWeek(locale2, date22);
}
function isEqual$1(generateConfig2, value1, value2) {
  return isSameDate(generateConfig2, value1, value2) && isSameTime(generateConfig2, value1, value2);
}
function isInRange(generateConfig2, startDate, endDate, current) {
  if (!startDate || !endDate || !current) {
    return false;
  }
  return !isSameDate(generateConfig2, startDate, current) && !isSameDate(generateConfig2, endDate, current) && generateConfig2.isAfter(current, startDate) && generateConfig2.isAfter(endDate, current);
}
function getWeekStartDate(locale2, generateConfig2, value) {
  const weekFirstDay = generateConfig2.locale.getWeekFirstDay(locale2);
  const monthStartDate = generateConfig2.setDate(value, 1);
  const startDateWeekDay = generateConfig2.getWeekDay(monthStartDate);
  let alignStartDate = generateConfig2.addDate(monthStartDate, weekFirstDay - startDateWeekDay);
  if (generateConfig2.getMonth(alignStartDate) === generateConfig2.getMonth(value) && generateConfig2.getDate(alignStartDate) > 1) {
    alignStartDate = generateConfig2.addDate(alignStartDate, -7);
  }
  return alignStartDate;
}
function getClosingViewDate(viewDate, picker, generateConfig2) {
  let offset3 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
  switch (picker) {
    case "year":
      return generateConfig2.addYear(viewDate, offset3 * 10);
    case "quarter":
    case "month":
      return generateConfig2.addYear(viewDate, offset3);
    default:
      return generateConfig2.addMonth(viewDate, offset3);
  }
}
function formatValue(value, _ref) {
  let {
    generateConfig: generateConfig2,
    locale: locale2,
    format: format2
  } = _ref;
  return typeof format2 === "function" ? format2(value) : generateConfig2.locale.format(locale2.locale, value, format2);
}
function parseValue(value, _ref2) {
  let {
    generateConfig: generateConfig2,
    locale: locale2,
    formatList
  } = _ref2;
  if (!value || typeof formatList[0] === "function") {
    return null;
  }
  return generateConfig2.locale.parse(locale2.locale, value, formatList);
}
function getCellDateDisabled(_ref3) {
  let {
    cellDate,
    mode,
    disabledDate,
    generateConfig: generateConfig2
  } = _ref3;
  if (!disabledDate) return false;
  const getDisabledFromRange = (currentMode, start, end) => {
    let current = start;
    while (current <= end) {
      let date4;
      switch (currentMode) {
        case "date": {
          date4 = generateConfig2.setDate(cellDate, current);
          if (!disabledDate(date4)) {
            return false;
          }
          break;
        }
        case "month": {
          date4 = generateConfig2.setMonth(cellDate, current);
          if (!getCellDateDisabled({
            cellDate: date4,
            mode: "month",
            generateConfig: generateConfig2,
            disabledDate
          })) {
            return false;
          }
          break;
        }
        case "year": {
          date4 = generateConfig2.setYear(cellDate, current);
          if (!getCellDateDisabled({
            cellDate: date4,
            mode: "year",
            generateConfig: generateConfig2,
            disabledDate
          })) {
            return false;
          }
          break;
        }
      }
      current += 1;
    }
    return true;
  };
  switch (mode) {
    case "date":
    case "week": {
      return disabledDate(cellDate);
    }
    case "month": {
      const startDate = 1;
      const endDate = generateConfig2.getDate(generateConfig2.getEndDate(cellDate));
      return getDisabledFromRange("date", startDate, endDate);
    }
    case "quarter": {
      const startMonth = Math.floor(generateConfig2.getMonth(cellDate) / 3) * 3;
      const endMonth = startMonth + 2;
      return getDisabledFromRange("month", startMonth, endMonth);
    }
    case "year": {
      return getDisabledFromRange("month", 0, 11);
    }
    case "decade": {
      const year = generateConfig2.getYear(cellDate);
      const startYear = Math.floor(year / DECADE_UNIT_DIFF) * DECADE_UNIT_DIFF;
      const endYear = startYear + DECADE_UNIT_DIFF - 1;
      return getDisabledFromRange("year", startYear, endYear);
    }
  }
}
function TimeHeader(_props) {
  const props2 = useMergeProps(_props);
  const {
    hideHeader
  } = useInjectPanel();
  if (hideHeader.value) {
    return null;
  }
  const {
    prefixCls,
    generateConfig: generateConfig2,
    locale: locale2,
    value,
    format: format2
  } = props2;
  const headerPrefixCls = `${prefixCls}-header`;
  return createVNode(Header$2, {
    "prefixCls": headerPrefixCls
  }, {
    default: () => [value ? formatValue(value, {
      locale: locale2,
      format: format2,
      generateConfig: generateConfig2
    }) : " "]
  });
}
TimeHeader.displayName = "TimeHeader";
TimeHeader.inheritAttrs = false;
const TimeUnitColumn = defineComponent({
  name: "TimeUnitColumn",
  props: ["prefixCls", "units", "onSelect", "value", "active", "hideDisabledOptions"],
  setup(props2) {
    const {
      open: open2
    } = useInjectPanel();
    const ulRef = shallowRef(null);
    const liRefs = ref(/* @__PURE__ */ new Map());
    const scrollRef = ref();
    watch(() => props2.value, () => {
      const li = liRefs.value.get(props2.value);
      if (li && open2.value !== false) {
        scrollTo(ulRef.value, li.offsetTop, 120);
      }
    });
    onBeforeUnmount(() => {
      var _a2;
      (_a2 = scrollRef.value) === null || _a2 === void 0 ? void 0 : _a2.call(scrollRef);
    });
    watch(open2, () => {
      var _a2;
      (_a2 = scrollRef.value) === null || _a2 === void 0 ? void 0 : _a2.call(scrollRef);
      nextTick(() => {
        if (open2.value) {
          const li = liRefs.value.get(props2.value);
          if (li) {
            scrollRef.value = waitElementReady(li, () => {
              scrollTo(ulRef.value, li.offsetTop, 0);
            });
          }
        }
      });
    }, {
      immediate: true,
      flush: "post"
    });
    return () => {
      const {
        prefixCls,
        units,
        onSelect,
        value,
        active,
        hideDisabledOptions
      } = props2;
      const cellPrefixCls = `${prefixCls}-cell`;
      return createVNode("ul", {
        "class": classNames(`${prefixCls}-column`, {
          [`${prefixCls}-column-active`]: active
        }),
        "ref": ulRef,
        "style": {
          position: "relative"
        }
      }, [units.map((unit) => {
        if (hideDisabledOptions && unit.disabled) {
          return null;
        }
        return createVNode("li", {
          "key": unit.value,
          "ref": (element) => {
            liRefs.value.set(unit.value, element);
          },
          "class": classNames(cellPrefixCls, {
            [`${cellPrefixCls}-disabled`]: unit.disabled,
            [`${cellPrefixCls}-selected`]: value === unit.value
          }),
          "onClick": () => {
            if (unit.disabled) {
              return;
            }
            onSelect(unit.value);
          }
        }, [createVNode("div", {
          "class": `${cellPrefixCls}-inner`
        }, [unit.label])]);
      })]);
    };
  }
});
function leftPad(str, length2) {
  let fill = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0";
  let current = String(str);
  while (current.length < length2) {
    current = `${fill}${str}`;
  }
  return current;
}
const tuple = function() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return args;
};
function toArray$5(val) {
  if (val === null || val === void 0) {
    return [];
  }
  return Array.isArray(val) ? val : [val];
}
function getDataOrAriaProps(props2) {
  const retProps = {};
  Object.keys(props2).forEach((key2) => {
    if ((key2.startsWith("data-") || key2.startsWith("aria-") || key2 === "role" || key2 === "name") && !key2.startsWith("data-__")) {
      retProps[key2] = props2[key2];
    }
  });
  return retProps;
}
function getValue$2(values, index2) {
  return values ? values[index2] : null;
}
function updateValues(values, value, index2) {
  const newValues = [getValue$2(values, 0), getValue$2(values, 1)];
  newValues[index2] = typeof value === "function" ? value(newValues[index2]) : value;
  if (!newValues[0] && !newValues[1]) {
    return null;
  }
  return newValues;
}
function generateUnits(start, end, step, disabledUnits) {
  const units = [];
  for (let i2 = start; i2 <= end; i2 += step) {
    units.push({
      label: leftPad(i2, 2),
      value: i2,
      disabled: (disabledUnits || []).includes(i2)
    });
  }
  return units;
}
const TimeBody = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "TimeBody",
  inheritAttrs: false,
  props: ["generateConfig", "prefixCls", "operationRef", "activeColumnIndex", "value", "showHour", "showMinute", "showSecond", "use12Hours", "hourStep", "minuteStep", "secondStep", "disabledHours", "disabledMinutes", "disabledSeconds", "disabledTime", "hideDisabledOptions", "onSelect"],
  setup(props2) {
    const originHour = computed(() => props2.value ? props2.generateConfig.getHour(props2.value) : -1);
    const isPM = computed(() => {
      if (props2.use12Hours) {
        return originHour.value >= 12;
      } else {
        return false;
      }
    });
    const hour = computed(() => {
      if (props2.use12Hours) {
        return originHour.value % 12;
      } else {
        return originHour.value;
      }
    });
    const minute = computed(() => props2.value ? props2.generateConfig.getMinute(props2.value) : -1);
    const second = computed(() => props2.value ? props2.generateConfig.getSecond(props2.value) : -1);
    const now2 = ref(props2.generateConfig.getNow());
    const mergedDisabledHours = ref();
    const mergedDisabledMinutes = ref();
    const mergedDisabledSeconds = ref();
    onBeforeUpdate(() => {
      now2.value = props2.generateConfig.getNow();
    });
    watchEffect(() => {
      if (props2.disabledTime) {
        const disabledConfig = props2.disabledTime(now2);
        [mergedDisabledHours.value, mergedDisabledMinutes.value, mergedDisabledSeconds.value] = [disabledConfig.disabledHours, disabledConfig.disabledMinutes, disabledConfig.disabledSeconds];
      } else {
        [mergedDisabledHours.value, mergedDisabledMinutes.value, mergedDisabledSeconds.value] = [props2.disabledHours, props2.disabledMinutes, props2.disabledSeconds];
      }
    });
    const setTime$1 = (isNewPM, newHour, newMinute, newSecond) => {
      let newDate = props2.value || props2.generateConfig.getNow();
      const mergedHour = Math.max(0, newHour);
      const mergedMinute = Math.max(0, newMinute);
      const mergedSecond = Math.max(0, newSecond);
      newDate = setTime(props2.generateConfig, newDate, !props2.use12Hours || !isNewPM ? mergedHour : mergedHour + 12, mergedMinute, mergedSecond);
      return newDate;
    };
    const rawHours = computed(() => {
      var _a2;
      return generateUnits(0, 23, (_a2 = props2.hourStep) !== null && _a2 !== void 0 ? _a2 : 1, mergedDisabledHours.value && mergedDisabledHours.value());
    });
    const AMPMDisabled = computed(() => {
      if (!props2.use12Hours) {
        return [false, false];
      }
      const AMPMDisabled2 = [true, true];
      rawHours.value.forEach((_ref) => {
        let {
          disabled,
          value: hourValue
        } = _ref;
        if (disabled) return;
        if (hourValue >= 12) {
          AMPMDisabled2[1] = false;
        } else {
          AMPMDisabled2[0] = false;
        }
      });
      return AMPMDisabled2;
    });
    const hours = computed(() => {
      if (!props2.use12Hours) return rawHours.value;
      return rawHours.value.filter(isPM.value ? (hourMeta) => hourMeta.value >= 12 : (hourMeta) => hourMeta.value < 12).map((hourMeta) => {
        const hourValue = hourMeta.value % 12;
        const hourLabel = hourValue === 0 ? "12" : leftPad(hourValue, 2);
        return _extends$1(_extends$1({}, hourMeta), {
          label: hourLabel,
          value: hourValue
        });
      });
    });
    const minutes = computed(() => {
      var _a2;
      return generateUnits(0, 59, (_a2 = props2.minuteStep) !== null && _a2 !== void 0 ? _a2 : 1, mergedDisabledMinutes.value && mergedDisabledMinutes.value(originHour.value));
    });
    const seconds = computed(() => {
      var _a2;
      return generateUnits(0, 59, (_a2 = props2.secondStep) !== null && _a2 !== void 0 ? _a2 : 1, mergedDisabledSeconds.value && mergedDisabledSeconds.value(originHour.value, minute.value));
    });
    return () => {
      const {
        prefixCls,
        operationRef,
        activeColumnIndex,
        showHour,
        showMinute,
        showSecond,
        use12Hours,
        hideDisabledOptions,
        onSelect
      } = props2;
      const columns = [];
      const contentPrefixCls = `${prefixCls}-content`;
      const columnPrefixCls = `${prefixCls}-time-panel`;
      operationRef.value = {
        onUpDown: (diff) => {
          const column2 = columns[activeColumnIndex];
          if (column2) {
            const valueIndex = column2.units.findIndex((unit) => unit.value === column2.value);
            const unitLen = column2.units.length;
            for (let i2 = 1; i2 < unitLen; i2 += 1) {
              const nextUnit = column2.units[(valueIndex + diff * i2 + unitLen) % unitLen];
              if (nextUnit.disabled !== true) {
                column2.onSelect(nextUnit.value);
                break;
              }
            }
          }
        }
      };
      function addColumnNode(condition, node2, columnValue, units, onColumnSelect) {
        if (condition !== false) {
          columns.push({
            node: cloneElement(node2, {
              prefixCls: columnPrefixCls,
              value: columnValue,
              active: activeColumnIndex === columns.length,
              onSelect: onColumnSelect,
              units,
              hideDisabledOptions
            }),
            onSelect: onColumnSelect,
            value: columnValue,
            units
          });
        }
      }
      addColumnNode(showHour, createVNode(TimeUnitColumn, {
        "key": "hour"
      }, null), hour.value, hours.value, (num) => {
        onSelect(setTime$1(isPM.value, num, minute.value, second.value), "mouse");
      });
      addColumnNode(showMinute, createVNode(TimeUnitColumn, {
        "key": "minute"
      }, null), minute.value, minutes.value, (num) => {
        onSelect(setTime$1(isPM.value, hour.value, num, second.value), "mouse");
      });
      addColumnNode(showSecond, createVNode(TimeUnitColumn, {
        "key": "second"
      }, null), second.value, seconds.value, (num) => {
        onSelect(setTime$1(isPM.value, hour.value, minute.value, num), "mouse");
      });
      let PMIndex = -1;
      if (typeof isPM.value === "boolean") {
        PMIndex = isPM.value ? 1 : 0;
      }
      addColumnNode(use12Hours === true, createVNode(TimeUnitColumn, {
        "key": "12hours"
      }, null), PMIndex, [{
        label: "AM",
        value: 0,
        disabled: AMPMDisabled.value[0]
      }, {
        label: "PM",
        value: 1,
        disabled: AMPMDisabled.value[1]
      }], (num) => {
        onSelect(setTime$1(!!num, hour.value, minute.value, second.value), "mouse");
      });
      return createVNode("div", {
        "class": contentPrefixCls
      }, [columns.map((_ref2) => {
        let {
          node: node2
        } = _ref2;
        return node2;
      })]);
    };
  }
});
const countBoolean = (boolList) => boolList.filter((bool) => bool !== false).length;
function TimePanel(_props) {
  const props2 = useMergeProps(_props);
  const {
    generateConfig: generateConfig2,
    format: format2 = "HH:mm:ss",
    prefixCls,
    active,
    operationRef,
    showHour,
    showMinute,
    showSecond,
    use12Hours = false,
    onSelect,
    value
  } = props2;
  const panelPrefixCls = `${prefixCls}-time-panel`;
  const bodyOperationRef = ref();
  const activeColumnIndex = ref(-1);
  const columnsCount = countBoolean([showHour, showMinute, showSecond, use12Hours]);
  operationRef.value = {
    onKeydown: (event) => createKeydownHandler(event, {
      onLeftRight: (diff) => {
        activeColumnIndex.value = (activeColumnIndex.value + diff + columnsCount) % columnsCount;
      },
      onUpDown: (diff) => {
        if (activeColumnIndex.value === -1) {
          activeColumnIndex.value = 0;
        } else if (bodyOperationRef.value) {
          bodyOperationRef.value.onUpDown(diff);
        }
      },
      onEnter: () => {
        onSelect(value || generateConfig2.getNow(), "key");
        activeColumnIndex.value = -1;
      }
    }),
    onBlur: () => {
      activeColumnIndex.value = -1;
    }
  };
  return createVNode("div", {
    "class": classNames(panelPrefixCls, {
      [`${panelPrefixCls}-active`]: active
    })
  }, [createVNode(TimeHeader, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "format": format2,
    "prefixCls": prefixCls
  }), null), createVNode(TimeBody, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "prefixCls": prefixCls,
    "activeColumnIndex": activeColumnIndex.value,
    "operationRef": bodyOperationRef
  }), null)]);
}
TimePanel.displayName = "TimePanel";
TimePanel.inheritAttrs = false;
function useCellClassName(_ref) {
  let {
    cellPrefixCls,
    generateConfig: generateConfig2,
    rangedValue,
    hoverRangedValue,
    isInView,
    isSameCell,
    offsetCell,
    today,
    value
  } = _ref;
  function getClassName(currentDate) {
    const prevDate = offsetCell(currentDate, -1);
    const nextDate = offsetCell(currentDate, 1);
    const rangeStart = getValue$2(rangedValue, 0);
    const rangeEnd = getValue$2(rangedValue, 1);
    const hoverStart = getValue$2(hoverRangedValue, 0);
    const hoverEnd = getValue$2(hoverRangedValue, 1);
    const isRangeHovered = isInRange(generateConfig2, hoverStart, hoverEnd, currentDate);
    function isRangeStart(date4) {
      return isSameCell(rangeStart, date4);
    }
    function isRangeEnd(date4) {
      return isSameCell(rangeEnd, date4);
    }
    const isHoverStart = isSameCell(hoverStart, currentDate);
    const isHoverEnd = isSameCell(hoverEnd, currentDate);
    const isHoverEdgeStart = (isRangeHovered || isHoverEnd) && (!isInView(prevDate) || isRangeEnd(prevDate));
    const isHoverEdgeEnd = (isRangeHovered || isHoverStart) && (!isInView(nextDate) || isRangeStart(nextDate));
    return {
      // In view
      [`${cellPrefixCls}-in-view`]: isInView(currentDate),
      // Range
      [`${cellPrefixCls}-in-range`]: isInRange(generateConfig2, rangeStart, rangeEnd, currentDate),
      [`${cellPrefixCls}-range-start`]: isRangeStart(currentDate),
      [`${cellPrefixCls}-range-end`]: isRangeEnd(currentDate),
      [`${cellPrefixCls}-range-start-single`]: isRangeStart(currentDate) && !rangeEnd,
      [`${cellPrefixCls}-range-end-single`]: isRangeEnd(currentDate) && !rangeStart,
      [`${cellPrefixCls}-range-start-near-hover`]: isRangeStart(currentDate) && (isSameCell(prevDate, hoverStart) || isInRange(generateConfig2, hoverStart, hoverEnd, prevDate)),
      [`${cellPrefixCls}-range-end-near-hover`]: isRangeEnd(currentDate) && (isSameCell(nextDate, hoverEnd) || isInRange(generateConfig2, hoverStart, hoverEnd, nextDate)),
      // Range Hover
      [`${cellPrefixCls}-range-hover`]: isRangeHovered,
      [`${cellPrefixCls}-range-hover-start`]: isHoverStart,
      [`${cellPrefixCls}-range-hover-end`]: isHoverEnd,
      // Range Edge
      [`${cellPrefixCls}-range-hover-edge-start`]: isHoverEdgeStart,
      [`${cellPrefixCls}-range-hover-edge-end`]: isHoverEdgeEnd,
      [`${cellPrefixCls}-range-hover-edge-start-near-range`]: isHoverEdgeStart && isSameCell(prevDate, rangeEnd),
      [`${cellPrefixCls}-range-hover-edge-end-near-range`]: isHoverEdgeEnd && isSameCell(nextDate, rangeStart),
      // Others
      [`${cellPrefixCls}-today`]: isSameCell(today, currentDate),
      [`${cellPrefixCls}-selected`]: isSameCell(value, currentDate)
    };
  }
  return getClassName;
}
const RangeContextKey = Symbol("RangeContextProps");
const useProvideRange = (props2) => {
  provide(RangeContextKey, props2);
};
const useInjectRange = () => {
  return inject(RangeContextKey, {
    rangedValue: ref(),
    hoverRangedValue: ref(),
    inRange: ref(),
    panelPosition: ref()
  });
};
const RangeContextProvider = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "PanelContextProvider",
  inheritAttrs: false,
  props: {
    value: {
      type: Object,
      default: () => ({})
    }
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const value = {
      rangedValue: ref(props2.value.rangedValue),
      hoverRangedValue: ref(props2.value.hoverRangedValue),
      inRange: ref(props2.value.inRange),
      panelPosition: ref(props2.value.panelPosition)
    };
    useProvideRange(value);
    watch(() => props2.value, () => {
      Object.keys(props2.value).forEach((key2) => {
        if (value[key2]) {
          value[key2].value = props2.value[key2];
        }
      });
    });
    return () => {
      var _a2;
      return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
    };
  }
});
function DateBody(_props) {
  const props2 = useMergeProps(_props);
  const {
    prefixCls,
    generateConfig: generateConfig2,
    prefixColumn,
    locale: locale2,
    rowCount,
    viewDate,
    value,
    dateRender
  } = props2;
  const {
    rangedValue,
    hoverRangedValue
  } = useInjectRange();
  const baseDate = getWeekStartDate(locale2.locale, generateConfig2, viewDate);
  const cellPrefixCls = `${prefixCls}-cell`;
  const weekFirstDay = generateConfig2.locale.getWeekFirstDay(locale2.locale);
  const today = generateConfig2.getNow();
  const headerCells = [];
  const weekDaysLocale = locale2.shortWeekDays || (generateConfig2.locale.getShortWeekDays ? generateConfig2.locale.getShortWeekDays(locale2.locale) : []);
  if (prefixColumn) {
    headerCells.push(createVNode("th", {
      "key": "empty",
      "aria-label": "empty cell"
    }, null));
  }
  for (let i2 = 0; i2 < WEEK_DAY_COUNT; i2 += 1) {
    headerCells.push(createVNode("th", {
      "key": i2
    }, [weekDaysLocale[(i2 + weekFirstDay) % WEEK_DAY_COUNT]]));
  }
  const getCellClassName = useCellClassName({
    cellPrefixCls,
    today,
    value,
    generateConfig: generateConfig2,
    rangedValue: prefixColumn ? null : rangedValue.value,
    hoverRangedValue: prefixColumn ? null : hoverRangedValue.value,
    isSameCell: (current, target) => isSameDate(generateConfig2, current, target),
    isInView: (date4) => isSameMonth(generateConfig2, date4, viewDate),
    offsetCell: (date4, offset3) => generateConfig2.addDate(date4, offset3)
  });
  const getCellNode = dateRender ? (date4) => dateRender({
    current: date4,
    today
  }) : void 0;
  return createVNode(PanelBody, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "rowNum": rowCount,
    "colNum": WEEK_DAY_COUNT,
    "baseDate": baseDate,
    "getCellNode": getCellNode,
    "getCellText": generateConfig2.getDate,
    "getCellClassName": getCellClassName,
    "getCellDate": generateConfig2.addDate,
    "titleCell": (date4) => formatValue(date4, {
      locale: locale2,
      format: "YYYY-MM-DD",
      generateConfig: generateConfig2
    }),
    "headerCells": headerCells
  }), null);
}
DateBody.displayName = "DateBody";
DateBody.inheritAttrs = false;
DateBody.props = [
  "prefixCls",
  "generateConfig",
  "value?",
  "viewDate",
  "locale",
  "rowCount",
  "onSelect",
  "dateRender?",
  "disabledDate?",
  // Used for week panel
  "prefixColumn?",
  "rowClassName?"
];
function DateHeader(_props) {
  const props2 = useMergeProps(_props);
  const {
    prefixCls,
    generateConfig: generateConfig2,
    locale: locale2,
    viewDate,
    onNextMonth,
    onPrevMonth,
    onNextYear,
    onPrevYear,
    onYearClick,
    onMonthClick
  } = props2;
  const {
    hideHeader
  } = useInjectPanel();
  if (hideHeader.value) {
    return null;
  }
  const headerPrefixCls = `${prefixCls}-header`;
  const monthsLocale = locale2.shortMonths || (generateConfig2.locale.getShortMonths ? generateConfig2.locale.getShortMonths(locale2.locale) : []);
  const month = generateConfig2.getMonth(viewDate);
  const yearNode = createVNode("button", {
    "type": "button",
    "key": "year",
    "onClick": onYearClick,
    "tabindex": -1,
    "class": `${prefixCls}-year-btn`
  }, [formatValue(viewDate, {
    locale: locale2,
    format: locale2.yearFormat,
    generateConfig: generateConfig2
  })]);
  const monthNode = createVNode("button", {
    "type": "button",
    "key": "month",
    "onClick": onMonthClick,
    "tabindex": -1,
    "class": `${prefixCls}-month-btn`
  }, [locale2.monthFormat ? formatValue(viewDate, {
    locale: locale2,
    format: locale2.monthFormat,
    generateConfig: generateConfig2
  }) : monthsLocale[month]]);
  const monthYearNodes = locale2.monthBeforeYear ? [monthNode, yearNode] : [yearNode, monthNode];
  return createVNode(Header$2, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "prefixCls": headerPrefixCls,
    "onSuperPrev": onPrevYear,
    "onPrev": onPrevMonth,
    "onNext": onNextMonth,
    "onSuperNext": onNextYear
  }), {
    default: () => [monthYearNodes]
  });
}
DateHeader.displayName = "DateHeader";
DateHeader.inheritAttrs = false;
const DATE_ROW_COUNT = 6;
function DatePanel(_props) {
  const props2 = useMergeProps(_props);
  const {
    prefixCls,
    panelName = "date",
    keyboardConfig,
    active,
    operationRef,
    generateConfig: generateConfig2,
    value,
    viewDate,
    onViewDateChange,
    onPanelChange,
    onSelect
  } = props2;
  const panelPrefixCls = `${prefixCls}-${panelName}-panel`;
  operationRef.value = {
    onKeydown: (event) => createKeydownHandler(event, _extends$1({
      onLeftRight: (diff) => {
        onSelect(generateConfig2.addDate(value || viewDate, diff), "key");
      },
      onCtrlLeftRight: (diff) => {
        onSelect(generateConfig2.addYear(value || viewDate, diff), "key");
      },
      onUpDown: (diff) => {
        onSelect(generateConfig2.addDate(value || viewDate, diff * WEEK_DAY_COUNT), "key");
      },
      onPageUpDown: (diff) => {
        onSelect(generateConfig2.addMonth(value || viewDate, diff), "key");
      }
    }, keyboardConfig))
  };
  const onYearChange = (diff) => {
    const newDate = generateConfig2.addYear(viewDate, diff);
    onViewDateChange(newDate);
    onPanelChange(null, newDate);
  };
  const onMonthChange = (diff) => {
    const newDate = generateConfig2.addMonth(viewDate, diff);
    onViewDateChange(newDate);
    onPanelChange(null, newDate);
  };
  return createVNode("div", {
    "class": classNames(panelPrefixCls, {
      [`${panelPrefixCls}-active`]: active
    })
  }, [createVNode(DateHeader, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "prefixCls": prefixCls,
    "value": value,
    "viewDate": viewDate,
    "onPrevYear": () => {
      onYearChange(-1);
    },
    "onNextYear": () => {
      onYearChange(1);
    },
    "onPrevMonth": () => {
      onMonthChange(-1);
    },
    "onNextMonth": () => {
      onMonthChange(1);
    },
    "onMonthClick": () => {
      onPanelChange("month", viewDate);
    },
    "onYearClick": () => {
      onPanelChange("year", viewDate);
    }
  }), null), createVNode(DateBody, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "onSelect": (date4) => onSelect(date4, "mouse"),
    "prefixCls": prefixCls,
    "value": value,
    "viewDate": viewDate,
    "rowCount": DATE_ROW_COUNT
  }), null)]);
}
DatePanel.displayName = "DatePanel";
DatePanel.inheritAttrs = false;
const ACTIVE_PANEL = tuple("date", "time");
function DatetimePanel(_props) {
  const props2 = useMergeProps(_props);
  const {
    prefixCls,
    operationRef,
    generateConfig: generateConfig2,
    value,
    defaultValue,
    disabledTime,
    showTime,
    onSelect
  } = props2;
  const panelPrefixCls = `${prefixCls}-datetime-panel`;
  const activePanel = ref(null);
  const dateOperationRef = ref({});
  const timeOperationRef = ref({});
  const timeProps = typeof showTime === "object" ? _extends$1({}, showTime) : {};
  function getNextActive(offset3) {
    const activeIndex = ACTIVE_PANEL.indexOf(activePanel.value) + offset3;
    const nextActivePanel = ACTIVE_PANEL[activeIndex] || null;
    return nextActivePanel;
  }
  const onBlur = (e2) => {
    if (timeOperationRef.value.onBlur) {
      timeOperationRef.value.onBlur(e2);
    }
    activePanel.value = null;
  };
  operationRef.value = {
    onKeydown: (event) => {
      if (event.which === KeyCode.TAB) {
        const nextActivePanel = getNextActive(event.shiftKey ? -1 : 1);
        activePanel.value = nextActivePanel;
        if (nextActivePanel) {
          event.preventDefault();
        }
        return true;
      }
      if (activePanel.value) {
        const ref2 = activePanel.value === "date" ? dateOperationRef : timeOperationRef;
        if (ref2.value && ref2.value.onKeydown) {
          ref2.value.onKeydown(event);
        }
        return true;
      }
      if ([KeyCode.LEFT, KeyCode.RIGHT, KeyCode.UP, KeyCode.DOWN].includes(event.which)) {
        activePanel.value = "date";
        return true;
      }
      return false;
    },
    onBlur,
    onClose: onBlur
  };
  const onInternalSelect = (date4, source) => {
    let selectedDate = date4;
    if (source === "date" && !value && timeProps.defaultValue) {
      selectedDate = generateConfig2.setHour(selectedDate, generateConfig2.getHour(timeProps.defaultValue));
      selectedDate = generateConfig2.setMinute(selectedDate, generateConfig2.getMinute(timeProps.defaultValue));
      selectedDate = generateConfig2.setSecond(selectedDate, generateConfig2.getSecond(timeProps.defaultValue));
    } else if (source === "time" && !value && defaultValue) {
      selectedDate = generateConfig2.setYear(selectedDate, generateConfig2.getYear(defaultValue));
      selectedDate = generateConfig2.setMonth(selectedDate, generateConfig2.getMonth(defaultValue));
      selectedDate = generateConfig2.setDate(selectedDate, generateConfig2.getDate(defaultValue));
    }
    if (onSelect) {
      onSelect(selectedDate, "mouse");
    }
  };
  const disabledTimes = disabledTime ? disabledTime(value || null) : {};
  return createVNode("div", {
    "class": classNames(panelPrefixCls, {
      [`${panelPrefixCls}-active`]: activePanel.value
    })
  }, [createVNode(DatePanel, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "operationRef": dateOperationRef,
    "active": activePanel.value === "date",
    "onSelect": (date4) => {
      onInternalSelect(setDateTime(generateConfig2, date4, !value && typeof showTime === "object" ? showTime.defaultValue : null), "date");
    }
  }), null), createVNode(TimePanel, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "format": void 0
  }, timeProps), disabledTimes), {}, {
    "disabledTime": null,
    "defaultValue": void 0,
    "operationRef": timeOperationRef,
    "active": activePanel.value === "time",
    "onSelect": (date4) => {
      onInternalSelect(date4, "time");
    }
  }), null)]);
}
DatetimePanel.displayName = "DatetimePanel";
DatetimePanel.inheritAttrs = false;
function WeekPanel(_props) {
  const props2 = useMergeProps(_props);
  const {
    prefixCls,
    generateConfig: generateConfig2,
    locale: locale2,
    value
  } = props2;
  const cellPrefixCls = `${prefixCls}-cell`;
  const prefixColumn = (date4) => createVNode("td", {
    "key": "week",
    "class": classNames(cellPrefixCls, `${cellPrefixCls}-week`)
  }, [generateConfig2.locale.getWeek(locale2.locale, date4)]);
  const rowPrefixCls = `${prefixCls}-week-panel-row`;
  const rowClassName = (date4) => classNames(rowPrefixCls, {
    [`${rowPrefixCls}-selected`]: isSameWeek(generateConfig2, locale2.locale, value, date4)
  });
  return createVNode(DatePanel, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "panelName": "week",
    "prefixColumn": prefixColumn,
    "rowClassName": rowClassName,
    "keyboardConfig": {
      onLeftRight: null
    }
  }), null);
}
WeekPanel.displayName = "WeekPanel";
WeekPanel.inheritAttrs = false;
function MonthHeader(_props) {
  const props2 = useMergeProps(_props);
  const {
    prefixCls,
    generateConfig: generateConfig2,
    locale: locale2,
    viewDate,
    onNextYear,
    onPrevYear,
    onYearClick
  } = props2;
  const {
    hideHeader
  } = useInjectPanel();
  if (hideHeader.value) {
    return null;
  }
  const headerPrefixCls = `${prefixCls}-header`;
  return createVNode(Header$2, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "prefixCls": headerPrefixCls,
    "onSuperPrev": onPrevYear,
    "onSuperNext": onNextYear
  }), {
    default: () => [createVNode("button", {
      "type": "button",
      "onClick": onYearClick,
      "class": `${prefixCls}-year-btn`
    }, [formatValue(viewDate, {
      locale: locale2,
      format: locale2.yearFormat,
      generateConfig: generateConfig2
    })])]
  });
}
MonthHeader.displayName = "MonthHeader";
MonthHeader.inheritAttrs = false;
const MONTH_COL_COUNT = 3;
const MONTH_ROW_COUNT = 4;
function MonthBody(_props) {
  const props2 = useMergeProps(_props);
  const {
    prefixCls,
    locale: locale2,
    value,
    viewDate,
    generateConfig: generateConfig2,
    monthCellRender
  } = props2;
  const {
    rangedValue,
    hoverRangedValue
  } = useInjectRange();
  const cellPrefixCls = `${prefixCls}-cell`;
  const getCellClassName = useCellClassName({
    cellPrefixCls,
    value,
    generateConfig: generateConfig2,
    rangedValue: rangedValue.value,
    hoverRangedValue: hoverRangedValue.value,
    isSameCell: (current, target) => isSameMonth(generateConfig2, current, target),
    isInView: () => true,
    offsetCell: (date4, offset3) => generateConfig2.addMonth(date4, offset3)
  });
  const monthsLocale = locale2.shortMonths || (generateConfig2.locale.getShortMonths ? generateConfig2.locale.getShortMonths(locale2.locale) : []);
  const baseMonth = generateConfig2.setMonth(viewDate, 0);
  const getCellNode = monthCellRender ? (date4) => monthCellRender({
    current: date4,
    locale: locale2
  }) : void 0;
  return createVNode(PanelBody, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "rowNum": MONTH_ROW_COUNT,
    "colNum": MONTH_COL_COUNT,
    "baseDate": baseMonth,
    "getCellNode": getCellNode,
    "getCellText": (date4) => locale2.monthFormat ? formatValue(date4, {
      locale: locale2,
      format: locale2.monthFormat,
      generateConfig: generateConfig2
    }) : monthsLocale[generateConfig2.getMonth(date4)],
    "getCellClassName": getCellClassName,
    "getCellDate": generateConfig2.addMonth,
    "titleCell": (date4) => formatValue(date4, {
      locale: locale2,
      format: "YYYY-MM",
      generateConfig: generateConfig2
    })
  }), null);
}
MonthBody.displayName = "MonthBody";
MonthBody.inheritAttrs = false;
function MonthPanel(_props) {
  const props2 = useMergeProps(_props);
  const {
    prefixCls,
    operationRef,
    onViewDateChange,
    generateConfig: generateConfig2,
    value,
    viewDate,
    onPanelChange,
    onSelect
  } = props2;
  const panelPrefixCls = `${prefixCls}-month-panel`;
  operationRef.value = {
    onKeydown: (event) => createKeydownHandler(event, {
      onLeftRight: (diff) => {
        onSelect(generateConfig2.addMonth(value || viewDate, diff), "key");
      },
      onCtrlLeftRight: (diff) => {
        onSelect(generateConfig2.addYear(value || viewDate, diff), "key");
      },
      onUpDown: (diff) => {
        onSelect(generateConfig2.addMonth(value || viewDate, diff * MONTH_COL_COUNT), "key");
      },
      onEnter: () => {
        onPanelChange("date", value || viewDate);
      }
    })
  };
  const onYearChange = (diff) => {
    const newDate = generateConfig2.addYear(viewDate, diff);
    onViewDateChange(newDate);
    onPanelChange(null, newDate);
  };
  return createVNode("div", {
    "class": panelPrefixCls
  }, [createVNode(MonthHeader, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "prefixCls": prefixCls,
    "onPrevYear": () => {
      onYearChange(-1);
    },
    "onNextYear": () => {
      onYearChange(1);
    },
    "onYearClick": () => {
      onPanelChange("year", viewDate);
    }
  }), null), createVNode(MonthBody, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "prefixCls": prefixCls,
    "onSelect": (date4) => {
      onSelect(date4, "mouse");
      onPanelChange("date", date4);
    }
  }), null)]);
}
MonthPanel.displayName = "MonthPanel";
MonthPanel.inheritAttrs = false;
function QuarterHeader(_props) {
  const props2 = useMergeProps(_props);
  const {
    prefixCls,
    generateConfig: generateConfig2,
    locale: locale2,
    viewDate,
    onNextYear,
    onPrevYear,
    onYearClick
  } = props2;
  const {
    hideHeader
  } = useInjectPanel();
  if (hideHeader.value) {
    return null;
  }
  const headerPrefixCls = `${prefixCls}-header`;
  return createVNode(Header$2, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "prefixCls": headerPrefixCls,
    "onSuperPrev": onPrevYear,
    "onSuperNext": onNextYear
  }), {
    default: () => [createVNode("button", {
      "type": "button",
      "onClick": onYearClick,
      "class": `${prefixCls}-year-btn`
    }, [formatValue(viewDate, {
      locale: locale2,
      format: locale2.yearFormat,
      generateConfig: generateConfig2
    })])]
  });
}
QuarterHeader.displayName = "QuarterHeader";
QuarterHeader.inheritAttrs = false;
const QUARTER_COL_COUNT = 4;
const QUARTER_ROW_COUNT = 1;
function QuarterBody(_props) {
  const props2 = useMergeProps(_props);
  const {
    prefixCls,
    locale: locale2,
    value,
    viewDate,
    generateConfig: generateConfig2
  } = props2;
  const {
    rangedValue,
    hoverRangedValue
  } = useInjectRange();
  const cellPrefixCls = `${prefixCls}-cell`;
  const getCellClassName = useCellClassName({
    cellPrefixCls,
    value,
    generateConfig: generateConfig2,
    rangedValue: rangedValue.value,
    hoverRangedValue: hoverRangedValue.value,
    isSameCell: (current, target) => isSameQuarter(generateConfig2, current, target),
    isInView: () => true,
    offsetCell: (date4, offset3) => generateConfig2.addMonth(date4, offset3 * 3)
  });
  const baseQuarter = generateConfig2.setDate(generateConfig2.setMonth(viewDate, 0), 1);
  return createVNode(PanelBody, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "rowNum": QUARTER_ROW_COUNT,
    "colNum": QUARTER_COL_COUNT,
    "baseDate": baseQuarter,
    "getCellText": (date4) => formatValue(date4, {
      locale: locale2,
      format: locale2.quarterFormat || "[Q]Q",
      generateConfig: generateConfig2
    }),
    "getCellClassName": getCellClassName,
    "getCellDate": (date4, offset3) => generateConfig2.addMonth(date4, offset3 * 3),
    "titleCell": (date4) => formatValue(date4, {
      locale: locale2,
      format: "YYYY-[Q]Q",
      generateConfig: generateConfig2
    })
  }), null);
}
QuarterBody.displayName = "QuarterBody";
QuarterBody.inheritAttrs = false;
function QuarterPanel(_props) {
  const props2 = useMergeProps(_props);
  const {
    prefixCls,
    operationRef,
    onViewDateChange,
    generateConfig: generateConfig2,
    value,
    viewDate,
    onPanelChange,
    onSelect
  } = props2;
  const panelPrefixCls = `${prefixCls}-quarter-panel`;
  operationRef.value = {
    onKeydown: (event) => createKeydownHandler(event, {
      onLeftRight: (diff) => {
        onSelect(generateConfig2.addMonth(value || viewDate, diff * 3), "key");
      },
      onCtrlLeftRight: (diff) => {
        onSelect(generateConfig2.addYear(value || viewDate, diff), "key");
      },
      onUpDown: (diff) => {
        onSelect(generateConfig2.addYear(value || viewDate, diff), "key");
      }
    })
  };
  const onYearChange = (diff) => {
    const newDate = generateConfig2.addYear(viewDate, diff);
    onViewDateChange(newDate);
    onPanelChange(null, newDate);
  };
  return createVNode("div", {
    "class": panelPrefixCls
  }, [createVNode(QuarterHeader, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "prefixCls": prefixCls,
    "onPrevYear": () => {
      onYearChange(-1);
    },
    "onNextYear": () => {
      onYearChange(1);
    },
    "onYearClick": () => {
      onPanelChange("year", viewDate);
    }
  }), null), createVNode(QuarterBody, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "prefixCls": prefixCls,
    "onSelect": (date4) => {
      onSelect(date4, "mouse");
    }
  }), null)]);
}
QuarterPanel.displayName = "QuarterPanel";
QuarterPanel.inheritAttrs = false;
function YearHeader(_props) {
  const props2 = useMergeProps(_props);
  const {
    prefixCls,
    generateConfig: generateConfig2,
    viewDate,
    onPrevDecade,
    onNextDecade,
    onDecadeClick
  } = props2;
  const {
    hideHeader
  } = useInjectPanel();
  if (hideHeader.value) {
    return null;
  }
  const headerPrefixCls = `${prefixCls}-header`;
  const yearNumber = generateConfig2.getYear(viewDate);
  const startYear = Math.floor(yearNumber / YEAR_DECADE_COUNT) * YEAR_DECADE_COUNT;
  const endYear = startYear + YEAR_DECADE_COUNT - 1;
  return createVNode(Header$2, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "prefixCls": headerPrefixCls,
    "onSuperPrev": onPrevDecade,
    "onSuperNext": onNextDecade
  }), {
    default: () => [createVNode("button", {
      "type": "button",
      "onClick": onDecadeClick,
      "class": `${prefixCls}-decade-btn`
    }, [startYear, createTextVNode("-"), endYear])]
  });
}
YearHeader.displayName = "YearHeader";
YearHeader.inheritAttrs = false;
const YEAR_COL_COUNT = 3;
const YEAR_ROW_COUNT = 4;
function YearBody(_props) {
  const props2 = useMergeProps(_props);
  const {
    prefixCls,
    value,
    viewDate,
    locale: locale2,
    generateConfig: generateConfig2
  } = props2;
  const {
    rangedValue,
    hoverRangedValue
  } = useInjectRange();
  const yearPrefixCls = `${prefixCls}-cell`;
  const yearNumber = generateConfig2.getYear(viewDate);
  const startYear = Math.floor(yearNumber / YEAR_DECADE_COUNT) * YEAR_DECADE_COUNT;
  const endYear = startYear + YEAR_DECADE_COUNT - 1;
  const baseYear = generateConfig2.setYear(viewDate, startYear - Math.ceil((YEAR_COL_COUNT * YEAR_ROW_COUNT - YEAR_DECADE_COUNT) / 2));
  const isInView = (date4) => {
    const currentYearNumber = generateConfig2.getYear(date4);
    return startYear <= currentYearNumber && currentYearNumber <= endYear;
  };
  const getCellClassName = useCellClassName({
    cellPrefixCls: yearPrefixCls,
    value,
    generateConfig: generateConfig2,
    rangedValue: rangedValue.value,
    hoverRangedValue: hoverRangedValue.value,
    isSameCell: (current, target) => isSameYear(generateConfig2, current, target),
    isInView,
    offsetCell: (date4, offset3) => generateConfig2.addYear(date4, offset3)
  });
  return createVNode(PanelBody, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "rowNum": YEAR_ROW_COUNT,
    "colNum": YEAR_COL_COUNT,
    "baseDate": baseYear,
    "getCellText": generateConfig2.getYear,
    "getCellClassName": getCellClassName,
    "getCellDate": generateConfig2.addYear,
    "titleCell": (date4) => formatValue(date4, {
      locale: locale2,
      format: "YYYY",
      generateConfig: generateConfig2
    })
  }), null);
}
YearBody.displayName = "YearBody";
YearBody.inheritAttrs = false;
const YEAR_DECADE_COUNT = 10;
function YearPanel(_props) {
  const props2 = useMergeProps(_props);
  const {
    prefixCls,
    operationRef,
    onViewDateChange,
    generateConfig: generateConfig2,
    value,
    viewDate,
    sourceMode,
    onSelect,
    onPanelChange
  } = props2;
  const panelPrefixCls = `${prefixCls}-year-panel`;
  operationRef.value = {
    onKeydown: (event) => createKeydownHandler(event, {
      onLeftRight: (diff) => {
        onSelect(generateConfig2.addYear(value || viewDate, diff), "key");
      },
      onCtrlLeftRight: (diff) => {
        onSelect(generateConfig2.addYear(value || viewDate, diff * YEAR_DECADE_COUNT), "key");
      },
      onUpDown: (diff) => {
        onSelect(generateConfig2.addYear(value || viewDate, diff * YEAR_COL_COUNT), "key");
      },
      onEnter: () => {
        onPanelChange(sourceMode === "date" ? "date" : "month", value || viewDate);
      }
    })
  };
  const onDecadeChange = (diff) => {
    const newDate = generateConfig2.addYear(viewDate, diff * 10);
    onViewDateChange(newDate);
    onPanelChange(null, newDate);
  };
  return createVNode("div", {
    "class": panelPrefixCls
  }, [createVNode(YearHeader, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "prefixCls": prefixCls,
    "onPrevDecade": () => {
      onDecadeChange(-1);
    },
    "onNextDecade": () => {
      onDecadeChange(1);
    },
    "onDecadeClick": () => {
      onPanelChange("decade", viewDate);
    }
  }), null), createVNode(YearBody, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
    "prefixCls": prefixCls,
    "onSelect": (date4) => {
      onPanelChange(sourceMode === "date" ? "date" : "month", date4);
      onSelect(date4, "mouse");
    }
  }), null)]);
}
YearPanel.displayName = "YearPanel";
YearPanel.inheritAttrs = false;
function getExtraFooter(prefixCls, mode, renderExtraFooter) {
  if (!renderExtraFooter) {
    return null;
  }
  return createVNode("div", {
    "class": `${prefixCls}-footer-extra`
  }, [renderExtraFooter(mode)]);
}
function getRanges(_ref) {
  let {
    prefixCls,
    components = {},
    needConfirmButton,
    onNow,
    onOk,
    okDisabled,
    showNow,
    locale: locale2
  } = _ref;
  let presetNode;
  let okNode;
  if (needConfirmButton) {
    const Button2 = components.button || "button";
    if (onNow && showNow !== false) {
      presetNode = createVNode("li", {
        "class": `${prefixCls}-now`
      }, [createVNode("a", {
        "class": `${prefixCls}-now-btn`,
        "onClick": onNow
      }, [locale2.now])]);
    }
    okNode = needConfirmButton && createVNode("li", {
      "class": `${prefixCls}-ok`
    }, [createVNode(Button2, {
      "disabled": okDisabled,
      "onClick": (e2) => {
        e2.stopPropagation();
        onOk && onOk();
      }
    }, {
      default: () => [locale2.ok]
    })]);
  }
  if (!presetNode && !okNode) {
    return null;
  }
  return createVNode("ul", {
    "class": `${prefixCls}-ranges`
  }, [presetNode, okNode]);
}
function PickerPanel() {
  return defineComponent({
    name: "PickerPanel",
    inheritAttrs: false,
    props: {
      prefixCls: String,
      locale: Object,
      generateConfig: Object,
      value: Object,
      defaultValue: Object,
      pickerValue: Object,
      defaultPickerValue: Object,
      disabledDate: Function,
      mode: String,
      picker: {
        type: String,
        default: "date"
      },
      tabindex: {
        type: [Number, String],
        default: 0
      },
      showNow: {
        type: Boolean,
        default: void 0
      },
      showTime: [Boolean, Object],
      showToday: Boolean,
      renderExtraFooter: Function,
      dateRender: Function,
      hideHeader: {
        type: Boolean,
        default: void 0
      },
      onSelect: Function,
      onChange: Function,
      onPanelChange: Function,
      onMousedown: Function,
      onPickerValueChange: Function,
      onOk: Function,
      components: Object,
      direction: String,
      hourStep: {
        type: Number,
        default: 1
      },
      minuteStep: {
        type: Number,
        default: 1
      },
      secondStep: {
        type: Number,
        default: 1
      }
    },
    setup(props2, _ref) {
      let {
        attrs
      } = _ref;
      const needConfirmButton = computed(() => props2.picker === "date" && !!props2.showTime || props2.picker === "time");
      const isHourStepValid = computed(() => 24 % props2.hourStep === 0);
      const isMinuteStepValid = computed(() => 60 % props2.minuteStep === 0);
      const isSecondStepValid = computed(() => 60 % props2.secondStep === 0);
      const panelContext = useInjectPanel();
      const {
        operationRef,
        onSelect: onContextSelect,
        hideRanges,
        defaultOpenValue
      } = panelContext;
      const {
        inRange,
        panelPosition,
        rangedValue,
        hoverRangedValue
      } = useInjectRange();
      const panelRef = ref({});
      const [mergedValue, setInnerValue] = useMergedState(null, {
        value: toRef(props2, "value"),
        defaultValue: props2.defaultValue,
        postState: (val) => {
          if (!val && (defaultOpenValue === null || defaultOpenValue === void 0 ? void 0 : defaultOpenValue.value) && props2.picker === "time") {
            return defaultOpenValue.value;
          }
          return val;
        }
      });
      const [viewDate, setInnerViewDate] = useMergedState(null, {
        value: toRef(props2, "pickerValue"),
        defaultValue: props2.defaultPickerValue || mergedValue.value,
        postState: (date4) => {
          const {
            generateConfig: generateConfig2,
            showTime,
            defaultValue
          } = props2;
          const now2 = generateConfig2.getNow();
          if (!date4) return now2;
          if (!mergedValue.value && props2.showTime) {
            if (typeof showTime === "object") {
              return setDateTime(generateConfig2, Array.isArray(date4) ? date4[0] : date4, showTime.defaultValue || now2);
            }
            if (defaultValue) {
              return setDateTime(generateConfig2, Array.isArray(date4) ? date4[0] : date4, defaultValue);
            }
            return setDateTime(generateConfig2, Array.isArray(date4) ? date4[0] : date4, now2);
          }
          return date4;
        }
      });
      const setViewDate = (date4) => {
        setInnerViewDate(date4);
        if (props2.onPickerValueChange) {
          props2.onPickerValueChange(date4);
        }
      };
      const getInternalNextMode = (nextMode) => {
        const getNextMode = PickerModeMap[props2.picker];
        if (getNextMode) {
          return getNextMode(nextMode);
        }
        return nextMode;
      };
      const [mergedMode, setInnerMode] = useMergedState(() => {
        if (props2.picker === "time") {
          return "time";
        }
        return getInternalNextMode("date");
      }, {
        value: toRef(props2, "mode")
      });
      watch(() => props2.picker, () => {
        setInnerMode(props2.picker);
      });
      const sourceMode = ref(mergedMode.value);
      const setSourceMode = (val) => {
        sourceMode.value = val;
      };
      const onInternalPanelChange = (newMode, viewValue) => {
        const {
          onPanelChange,
          generateConfig: generateConfig2
        } = props2;
        const nextMode = getInternalNextMode(newMode || mergedMode.value);
        setSourceMode(mergedMode.value);
        setInnerMode(nextMode);
        if (onPanelChange && (mergedMode.value !== nextMode || isEqual$1(generateConfig2, viewDate.value, viewDate.value))) {
          onPanelChange(viewValue, nextMode);
        }
      };
      const triggerSelect = function(date4, type4) {
        let forceTriggerSelect = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        const {
          picker,
          generateConfig: generateConfig2,
          onSelect,
          onChange,
          disabledDate
        } = props2;
        if (mergedMode.value === picker || forceTriggerSelect) {
          setInnerValue(date4);
          if (onSelect) {
            onSelect(date4);
          }
          if (onContextSelect) {
            onContextSelect(date4, type4);
          }
          if (onChange && !isEqual$1(generateConfig2, date4, mergedValue.value) && !(disabledDate === null || disabledDate === void 0 ? void 0 : disabledDate(date4))) {
            onChange(date4);
          }
        }
      };
      const onInternalKeydown = (e2) => {
        if (panelRef.value && panelRef.value.onKeydown) {
          if ([KeyCode.LEFT, KeyCode.RIGHT, KeyCode.UP, KeyCode.DOWN, KeyCode.PAGE_UP, KeyCode.PAGE_DOWN, KeyCode.ENTER].includes(e2.which)) {
            e2.preventDefault();
          }
          return panelRef.value.onKeydown(e2);
        }
        {
          return false;
        }
      };
      const onInternalBlur = (e2) => {
        if (panelRef.value && panelRef.value.onBlur) {
          panelRef.value.onBlur(e2);
        }
      };
      const onNow = () => {
        const {
          generateConfig: generateConfig2,
          hourStep,
          minuteStep,
          secondStep
        } = props2;
        const now2 = generateConfig2.getNow();
        const lowerBoundTime = getLowerBoundTime(generateConfig2.getHour(now2), generateConfig2.getMinute(now2), generateConfig2.getSecond(now2), isHourStepValid.value ? hourStep : 1, isMinuteStepValid.value ? minuteStep : 1, isSecondStepValid.value ? secondStep : 1);
        const adjustedNow = setTime(
          generateConfig2,
          now2,
          lowerBoundTime[0],
          // hour
          lowerBoundTime[1],
          // minute
          lowerBoundTime[2]
        );
        triggerSelect(adjustedNow, "submit");
      };
      const classString = computed(() => {
        const {
          prefixCls,
          direction
        } = props2;
        return classNames(`${prefixCls}-panel`, {
          [`${prefixCls}-panel-has-range`]: rangedValue && rangedValue.value && rangedValue.value[0] && rangedValue.value[1],
          [`${prefixCls}-panel-has-range-hover`]: hoverRangedValue && hoverRangedValue.value && hoverRangedValue.value[0] && hoverRangedValue.value[1],
          [`${prefixCls}-panel-rtl`]: direction === "rtl"
        });
      });
      useProvidePanel(_extends$1(_extends$1({}, panelContext), {
        mode: mergedMode,
        hideHeader: computed(() => {
          var _a2;
          return props2.hideHeader !== void 0 ? props2.hideHeader : (_a2 = panelContext.hideHeader) === null || _a2 === void 0 ? void 0 : _a2.value;
        }),
        hidePrevBtn: computed(() => inRange.value && panelPosition.value === "right"),
        hideNextBtn: computed(() => inRange.value && panelPosition.value === "left")
      }));
      watch(() => props2.value, () => {
        if (props2.value) {
          setInnerViewDate(props2.value);
        }
      });
      return () => {
        const {
          prefixCls = "ant-picker",
          locale: locale2,
          generateConfig: generateConfig2,
          disabledDate,
          picker = "date",
          tabindex = 0,
          showNow,
          showTime,
          showToday,
          renderExtraFooter,
          onMousedown,
          onOk,
          components
        } = props2;
        if (operationRef && panelPosition.value !== "right") {
          operationRef.value = {
            onKeydown: onInternalKeydown,
            onClose: () => {
              if (panelRef.value && panelRef.value.onClose) {
                panelRef.value.onClose();
              }
            }
          };
        }
        let panelNode;
        const pickerProps = _extends$1(_extends$1(_extends$1({}, attrs), props2), {
          operationRef: panelRef,
          prefixCls,
          viewDate: viewDate.value,
          value: mergedValue.value,
          onViewDateChange: setViewDate,
          sourceMode: sourceMode.value,
          onPanelChange: onInternalPanelChange,
          disabledDate
        });
        delete pickerProps.onChange;
        delete pickerProps.onSelect;
        switch (mergedMode.value) {
          case "decade":
            panelNode = createVNode(DecadePanel, _objectSpread2$1(_objectSpread2$1({}, pickerProps), {}, {
              "onSelect": (date4, type4) => {
                setViewDate(date4);
                triggerSelect(date4, type4);
              }
            }), null);
            break;
          case "year":
            panelNode = createVNode(YearPanel, _objectSpread2$1(_objectSpread2$1({}, pickerProps), {}, {
              "onSelect": (date4, type4) => {
                setViewDate(date4);
                triggerSelect(date4, type4);
              }
            }), null);
            break;
          case "month":
            panelNode = createVNode(MonthPanel, _objectSpread2$1(_objectSpread2$1({}, pickerProps), {}, {
              "onSelect": (date4, type4) => {
                setViewDate(date4);
                triggerSelect(date4, type4);
              }
            }), null);
            break;
          case "quarter":
            panelNode = createVNode(QuarterPanel, _objectSpread2$1(_objectSpread2$1({}, pickerProps), {}, {
              "onSelect": (date4, type4) => {
                setViewDate(date4);
                triggerSelect(date4, type4);
              }
            }), null);
            break;
          case "week":
            panelNode = createVNode(WeekPanel, _objectSpread2$1(_objectSpread2$1({}, pickerProps), {}, {
              "onSelect": (date4, type4) => {
                setViewDate(date4);
                triggerSelect(date4, type4);
              }
            }), null);
            break;
          case "time":
            delete pickerProps.showTime;
            panelNode = createVNode(TimePanel, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, pickerProps), typeof showTime === "object" ? showTime : null), {}, {
              "onSelect": (date4, type4) => {
                setViewDate(date4);
                triggerSelect(date4, type4);
              }
            }), null);
            break;
          default:
            if (showTime) {
              panelNode = createVNode(DatetimePanel, _objectSpread2$1(_objectSpread2$1({}, pickerProps), {}, {
                "onSelect": (date4, type4) => {
                  setViewDate(date4);
                  triggerSelect(date4, type4);
                }
              }), null);
            } else {
              panelNode = createVNode(DatePanel, _objectSpread2$1(_objectSpread2$1({}, pickerProps), {}, {
                "onSelect": (date4, type4) => {
                  setViewDate(date4);
                  triggerSelect(date4, type4);
                }
              }), null);
            }
        }
        let extraFooter;
        let rangesNode;
        if (!(hideRanges === null || hideRanges === void 0 ? void 0 : hideRanges.value)) {
          extraFooter = getExtraFooter(prefixCls, mergedMode.value, renderExtraFooter);
          rangesNode = getRanges({
            prefixCls,
            components,
            needConfirmButton: needConfirmButton.value,
            okDisabled: !mergedValue.value || disabledDate && disabledDate(mergedValue.value),
            locale: locale2,
            showNow,
            onNow: needConfirmButton.value && onNow,
            onOk: () => {
              if (mergedValue.value) {
                triggerSelect(mergedValue.value, "submit", true);
                if (onOk) {
                  onOk(mergedValue.value);
                }
              }
            }
          });
        }
        let todayNode;
        if (showToday && mergedMode.value === "date" && picker === "date" && !showTime) {
          const now2 = generateConfig2.getNow();
          const todayCls = `${prefixCls}-today-btn`;
          const disabled = disabledDate && disabledDate(now2);
          todayNode = createVNode("a", {
            "class": classNames(todayCls, disabled && `${todayCls}-disabled`),
            "aria-disabled": disabled,
            "onClick": () => {
              if (!disabled) {
                triggerSelect(now2, "mouse", true);
              }
            }
          }, [locale2.today]);
        }
        return createVNode("div", {
          "tabindex": tabindex,
          "class": classNames(classString.value, attrs.class),
          "style": attrs.style,
          "onKeydown": onInternalKeydown,
          "onBlur": onInternalBlur,
          "onMousedown": onMousedown
        }, [panelNode, extraFooter || rangesNode || todayNode ? createVNode("div", {
          "class": `${prefixCls}-footer`
        }, [extraFooter, rangesNode, todayNode]) : null]);
      };
    }
  });
}
const InterPickerPanel = PickerPanel();
const PickerPanel$1 = (props2) => createVNode(InterPickerPanel, props2);
const BUILT_IN_PLACEMENTS = {
  bottomLeft: {
    points: ["tl", "bl"],
    offset: [0, 4],
    overflow: {
      adjustX: 1,
      adjustY: 1
    }
  },
  bottomRight: {
    points: ["tr", "br"],
    offset: [0, 4],
    overflow: {
      adjustX: 1,
      adjustY: 1
    }
  },
  topLeft: {
    points: ["bl", "tl"],
    offset: [0, -4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  },
  topRight: {
    points: ["br", "tr"],
    offset: [0, -4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  }
};
function PickerTrigger(props2, _ref) {
  let {
    slots
  } = _ref;
  const {
    prefixCls,
    popupStyle,
    visible,
    dropdownClassName,
    dropdownAlign,
    transitionName: transitionName2,
    getPopupContainer,
    range: range3,
    popupPlacement,
    direction
  } = useMergeProps(props2);
  const dropdownPrefixCls = `${prefixCls}-dropdown`;
  const getPopupPlacement = () => {
    if (popupPlacement !== void 0) {
      return popupPlacement;
    }
    return direction === "rtl" ? "bottomRight" : "bottomLeft";
  };
  return createVNode(Trigger, {
    "showAction": [],
    "hideAction": [],
    "popupPlacement": getPopupPlacement(),
    "builtinPlacements": BUILT_IN_PLACEMENTS,
    "prefixCls": dropdownPrefixCls,
    "popupTransitionName": transitionName2,
    "popupAlign": dropdownAlign,
    "popupVisible": visible,
    "popupClassName": classNames(dropdownClassName, {
      [`${dropdownPrefixCls}-range`]: range3,
      [`${dropdownPrefixCls}-rtl`]: direction === "rtl"
    }),
    "popupStyle": popupStyle,
    "getPopupContainer": getPopupContainer
  }, {
    default: slots.default,
    popup: slots.popupElement
  });
}
const PresetPanel = defineComponent({
  name: "PresetPanel",
  props: {
    prefixCls: String,
    presets: {
      type: Array,
      default: () => []
    },
    onClick: Function,
    onHover: Function
  },
  setup(props2) {
    return () => {
      if (!props2.presets.length) {
        return null;
      }
      return createVNode("div", {
        "class": `${props2.prefixCls}-presets`
      }, [createVNode("ul", null, [props2.presets.map((_ref, index2) => {
        let {
          label,
          value
        } = _ref;
        return createVNode("li", {
          "key": index2,
          "onClick": (e2) => {
            e2.stopPropagation();
            props2.onClick(value);
          },
          "onMouseenter": () => {
            var _a2;
            (_a2 = props2.onHover) === null || _a2 === void 0 ? void 0 : _a2.call(props2, value);
          },
          "onMouseleave": () => {
            var _a2;
            (_a2 = props2.onHover) === null || _a2 === void 0 ? void 0 : _a2.call(props2, null);
          }
        }, [label]);
      })])]);
    };
  }
});
function usePickerInput(_ref) {
  let {
    open: open2,
    value,
    isClickOutside,
    triggerOpen,
    forwardKeydown,
    onKeydown,
    blurToCancel,
    onSubmit,
    onCancel,
    onFocus,
    onBlur
  } = _ref;
  const typing = shallowRef(false);
  const focused = shallowRef(false);
  const preventBlurRef = shallowRef(false);
  const valueChangedRef = shallowRef(false);
  const preventDefaultRef = shallowRef(false);
  const inputProps2 = computed(() => ({
    onMousedown: () => {
      typing.value = true;
      triggerOpen(true);
    },
    onKeydown: (e2) => {
      const preventDefault = () => {
        preventDefaultRef.value = true;
      };
      onKeydown(e2, preventDefault);
      if (preventDefaultRef.value) return;
      switch (e2.which) {
        case KeyCode.ENTER: {
          if (!open2.value) {
            triggerOpen(true);
          } else if (onSubmit() !== false) {
            typing.value = true;
          }
          e2.preventDefault();
          return;
        }
        case KeyCode.TAB: {
          if (typing.value && open2.value && !e2.shiftKey) {
            typing.value = false;
            e2.preventDefault();
          } else if (!typing.value && open2.value) {
            if (!forwardKeydown(e2) && e2.shiftKey) {
              typing.value = true;
              e2.preventDefault();
            }
          }
          return;
        }
        case KeyCode.ESC: {
          typing.value = true;
          onCancel();
          return;
        }
      }
      if (!open2.value && ![KeyCode.SHIFT].includes(e2.which)) {
        triggerOpen(true);
      } else if (!typing.value) {
        forwardKeydown(e2);
      }
    },
    onFocus: (e2) => {
      typing.value = true;
      focused.value = true;
      if (onFocus) {
        onFocus(e2);
      }
    },
    onBlur: (e2) => {
      if (preventBlurRef.value || !isClickOutside(document.activeElement)) {
        preventBlurRef.value = false;
        return;
      }
      if (blurToCancel.value) {
        setTimeout(() => {
          let {
            activeElement
          } = document;
          while (activeElement && activeElement.shadowRoot) {
            activeElement = activeElement.shadowRoot.activeElement;
          }
          if (isClickOutside(activeElement)) {
            onCancel();
          }
        }, 0);
      } else if (open2.value) {
        triggerOpen(false);
        if (valueChangedRef.value) {
          onSubmit();
        }
      }
      focused.value = false;
      if (onBlur) {
        onBlur(e2);
      }
    }
  }));
  watch(open2, () => {
    valueChangedRef.value = false;
  });
  watch(value, () => {
    valueChangedRef.value = true;
  });
  const globalMousedownEvent = shallowRef();
  onMounted(() => {
    globalMousedownEvent.value = addGlobalMousedownEvent((e2) => {
      const target = getTargetFromEvent(e2);
      if (open2.value) {
        const clickedOutside = isClickOutside(target);
        if (!clickedOutside) {
          preventBlurRef.value = true;
          wrapperRaf(() => {
            preventBlurRef.value = false;
          });
        } else if (!focused.value || clickedOutside) {
          triggerOpen(false);
        }
      }
    });
  });
  onBeforeUnmount(() => {
    globalMousedownEvent.value && globalMousedownEvent.value();
  });
  return [inputProps2, {
    focused,
    typing
  }];
}
function useTextValueMapping(_ref) {
  let {
    valueTexts,
    onTextChange
  } = _ref;
  const text = ref("");
  function triggerTextChange(value) {
    text.value = value;
    onTextChange(value);
  }
  function resetText() {
    text.value = valueTexts.value[0];
  }
  watch(() => [...valueTexts.value], function(cur) {
    let pre = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    if (cur.join("||") !== pre.join("||") && valueTexts.value.every((valText) => valText !== text.value)) {
      resetText();
    }
  }, {
    immediate: true
  });
  return [text, triggerTextChange, resetText];
}
function useValueTexts(value, _ref) {
  let {
    formatList,
    generateConfig: generateConfig2,
    locale: locale2
  } = _ref;
  const texts = useMemo(() => {
    if (!value.value) {
      return [[""], ""];
    }
    let firstValueText2 = "";
    const fullValueTexts2 = [];
    for (let i2 = 0; i2 < formatList.value.length; i2 += 1) {
      const format2 = formatList.value[i2];
      const formatStr = formatValue(value.value, {
        generateConfig: generateConfig2.value,
        locale: locale2.value,
        format: format2
      });
      fullValueTexts2.push(formatStr);
      if (i2 === 0) {
        firstValueText2 = formatStr;
      }
    }
    return [fullValueTexts2, firstValueText2];
  }, [value, formatList], (next2, prev2) => prev2[0] !== next2[0] || !shallowequal(prev2[1], next2[1]));
  const fullValueTexts = computed(() => texts.value[0]);
  const firstValueText = computed(() => texts.value[1]);
  return [fullValueTexts, firstValueText];
}
function useHoverValue(valueText, _ref) {
  let {
    formatList,
    generateConfig: generateConfig2,
    locale: locale2
  } = _ref;
  const innerValue = ref(null);
  let rafId;
  function setValue2(val) {
    let immediately = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    wrapperRaf.cancel(rafId);
    if (immediately) {
      innerValue.value = val;
      return;
    }
    rafId = wrapperRaf(() => {
      innerValue.value = val;
    });
  }
  const [, firstText] = useValueTexts(innerValue, {
    formatList,
    generateConfig: generateConfig2,
    locale: locale2
  });
  function onEnter(date4) {
    setValue2(date4);
  }
  function onLeave() {
    let immediately = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    setValue2(null, immediately);
  }
  watch(valueText, () => {
    onLeave(true);
  });
  onBeforeUnmount(() => {
    wrapperRaf.cancel(rafId);
  });
  return [firstText, onEnter, onLeave];
}
function usePresets(presets, legacyRanges) {
  return computed(() => {
    if (presets === null || presets === void 0 ? void 0 : presets.value) {
      return presets.value;
    }
    if (legacyRanges === null || legacyRanges === void 0 ? void 0 : legacyRanges.value) {
      warningOnce(false, "`ranges` is deprecated. Please use `presets` instead.");
      const rangeLabels = Object.keys(legacyRanges.value);
      return rangeLabels.map((label) => {
        const range3 = legacyRanges.value[label];
        const newValues = typeof range3 === "function" ? range3() : range3;
        return {
          label,
          value: newValues
        };
      });
    }
    return [];
  });
}
function Picker() {
  return defineComponent({
    name: "Picker",
    inheritAttrs: false,
    props: ["prefixCls", "id", "tabindex", "dropdownClassName", "dropdownAlign", "popupStyle", "transitionName", "generateConfig", "locale", "inputReadOnly", "allowClear", "autofocus", "showTime", "showNow", "showHour", "showMinute", "showSecond", "picker", "format", "use12Hours", "value", "defaultValue", "open", "defaultOpen", "defaultOpenValue", "suffixIcon", "presets", "clearIcon", "disabled", "disabledDate", "placeholder", "getPopupContainer", "panelRender", "inputRender", "onChange", "onOpenChange", "onPanelChange", "onFocus", "onBlur", "onMousedown", "onMouseup", "onMouseenter", "onMouseleave", "onContextmenu", "onClick", "onKeydown", "onSelect", "direction", "autocomplete", "showToday", "renderExtraFooter", "dateRender", "minuteStep", "hourStep", "secondStep", "hideDisabledOptions"],
    setup(props2, _ref) {
      let {
        attrs,
        expose
      } = _ref;
      const inputRef = ref(null);
      const presets = computed(() => props2.presets);
      const presetList = usePresets(presets);
      const picker = computed(() => {
        var _a2;
        return (_a2 = props2.picker) !== null && _a2 !== void 0 ? _a2 : "date";
      });
      const needConfirmButton = computed(() => picker.value === "date" && !!props2.showTime || picker.value === "time");
      const formatList = computed(() => toArray$5(getDefaultFormat(props2.format, picker.value, props2.showTime, props2.use12Hours)));
      const panelDivRef = ref(null);
      const inputDivRef = ref(null);
      const containerRef = ref(null);
      const [mergedValue, setInnerValue] = useMergedState(null, {
        value: toRef(props2, "value"),
        defaultValue: props2.defaultValue
      });
      const selectedValue = ref(mergedValue.value);
      const setSelectedValue = (val) => {
        selectedValue.value = val;
      };
      const operationRef = ref(null);
      const [mergedOpen, triggerInnerOpen] = useMergedState(false, {
        value: toRef(props2, "open"),
        defaultValue: props2.defaultOpen,
        postState: (postOpen) => props2.disabled ? false : postOpen,
        onChange: (newOpen) => {
          if (props2.onOpenChange) {
            props2.onOpenChange(newOpen);
          }
          if (!newOpen && operationRef.value && operationRef.value.onClose) {
            operationRef.value.onClose();
          }
        }
      });
      const [valueTexts, firstValueText] = useValueTexts(selectedValue, {
        formatList,
        generateConfig: toRef(props2, "generateConfig"),
        locale: toRef(props2, "locale")
      });
      const [text, triggerTextChange, resetText] = useTextValueMapping({
        valueTexts,
        onTextChange: (newText) => {
          const inputDate = parseValue(newText, {
            locale: props2.locale,
            formatList: formatList.value,
            generateConfig: props2.generateConfig
          });
          if (inputDate && (!props2.disabledDate || !props2.disabledDate(inputDate))) {
            setSelectedValue(inputDate);
          }
        }
      });
      const triggerChange = (newValue) => {
        const {
          onChange,
          generateConfig: generateConfig2,
          locale: locale2
        } = props2;
        setSelectedValue(newValue);
        setInnerValue(newValue);
        if (onChange && !isEqual$1(generateConfig2, mergedValue.value, newValue)) {
          onChange(newValue, newValue ? formatValue(newValue, {
            generateConfig: generateConfig2,
            locale: locale2,
            format: formatList.value[0]
          }) : "");
        }
      };
      const triggerOpen = (newOpen) => {
        if (props2.disabled && newOpen) {
          return;
        }
        triggerInnerOpen(newOpen);
      };
      const forwardKeydown = (e2) => {
        if (mergedOpen.value && operationRef.value && operationRef.value.onKeydown) {
          return operationRef.value.onKeydown(e2);
        }
        {
          return false;
        }
      };
      const onInternalMouseup = function() {
        if (props2.onMouseup) {
          props2.onMouseup(...arguments);
        }
        if (inputRef.value) {
          inputRef.value.focus();
          triggerOpen(true);
        }
      };
      const [inputProps2, {
        focused,
        typing
      }] = usePickerInput({
        blurToCancel: needConfirmButton,
        open: mergedOpen,
        value: text,
        triggerOpen,
        forwardKeydown,
        isClickOutside: (target) => !elementsContains([panelDivRef.value, inputDivRef.value, containerRef.value], target),
        onSubmit: () => {
          if (
            // When user typing disabledDate with keyboard and enter, this value will be empty
            !selectedValue.value || // Normal disabled check
            props2.disabledDate && props2.disabledDate(selectedValue.value)
          ) {
            return false;
          }
          triggerChange(selectedValue.value);
          triggerOpen(false);
          resetText();
          return true;
        },
        onCancel: () => {
          triggerOpen(false);
          setSelectedValue(mergedValue.value);
          resetText();
        },
        onKeydown: (e2, preventDefault) => {
          var _a2;
          (_a2 = props2.onKeydown) === null || _a2 === void 0 ? void 0 : _a2.call(props2, e2, preventDefault);
        },
        onFocus: (e2) => {
          var _a2;
          (_a2 = props2.onFocus) === null || _a2 === void 0 ? void 0 : _a2.call(props2, e2);
        },
        onBlur: (e2) => {
          var _a2;
          (_a2 = props2.onBlur) === null || _a2 === void 0 ? void 0 : _a2.call(props2, e2);
        }
      });
      watch([mergedOpen, valueTexts], () => {
        if (!mergedOpen.value) {
          setSelectedValue(mergedValue.value);
          if (!valueTexts.value.length || valueTexts.value[0] === "") {
            triggerTextChange("");
          } else if (firstValueText.value !== text.value) {
            resetText();
          }
        }
      });
      watch(picker, () => {
        if (!mergedOpen.value) {
          resetText();
        }
      });
      watch(mergedValue, () => {
        setSelectedValue(mergedValue.value);
      });
      const [hoverValue, onEnter, onLeave] = useHoverValue(text, {
        formatList,
        generateConfig: toRef(props2, "generateConfig"),
        locale: toRef(props2, "locale")
      });
      const onContextSelect = (date4, type4) => {
        if (type4 === "submit" || type4 !== "key" && !needConfirmButton.value) {
          triggerChange(date4);
          triggerOpen(false);
        }
      };
      useProvidePanel({
        operationRef,
        hideHeader: computed(() => picker.value === "time"),
        onSelect: onContextSelect,
        open: mergedOpen,
        defaultOpenValue: toRef(props2, "defaultOpenValue"),
        onDateMouseenter: onEnter,
        onDateMouseleave: onLeave
      });
      expose({
        focus: () => {
          if (inputRef.value) {
            inputRef.value.focus();
          }
        },
        blur: () => {
          if (inputRef.value) {
            inputRef.value.blur();
          }
        }
      });
      return () => {
        const {
          prefixCls = "rc-picker",
          id,
          tabindex,
          dropdownClassName,
          dropdownAlign,
          popupStyle,
          transitionName: transitionName2,
          generateConfig: generateConfig2,
          locale: locale2,
          inputReadOnly,
          allowClear,
          autofocus,
          picker: picker2 = "date",
          defaultOpenValue,
          suffixIcon,
          clearIcon,
          disabled,
          placeholder,
          getPopupContainer,
          panelRender,
          onMousedown,
          onMouseenter,
          onMouseleave,
          onContextmenu,
          onClick,
          onSelect,
          direction,
          autocomplete = "off"
        } = props2;
        const panelProps = _extends$1(_extends$1(_extends$1({}, props2), attrs), {
          class: classNames({
            [`${prefixCls}-panel-focused`]: !typing.value
          }),
          style: void 0,
          pickerValue: void 0,
          onPickerValueChange: void 0,
          onChange: null
        });
        let panelNode = createVNode("div", {
          "class": `${prefixCls}-panel-layout`
        }, [createVNode(PresetPanel, {
          "prefixCls": prefixCls,
          "presets": presetList.value,
          "onClick": (nextValue) => {
            triggerChange(nextValue);
            triggerOpen(false);
          }
        }, null), createVNode(PickerPanel$1, _objectSpread2$1(_objectSpread2$1({}, panelProps), {}, {
          "generateConfig": generateConfig2,
          "value": selectedValue.value,
          "locale": locale2,
          "tabindex": -1,
          "onSelect": (date4) => {
            onSelect === null || onSelect === void 0 ? void 0 : onSelect(date4);
            setSelectedValue(date4);
          },
          "direction": direction,
          "onPanelChange": (viewDate, mode) => {
            const {
              onPanelChange
            } = props2;
            onLeave(true);
            onPanelChange === null || onPanelChange === void 0 ? void 0 : onPanelChange(viewDate, mode);
          }
        }), null)]);
        if (panelRender) {
          panelNode = panelRender(panelNode);
        }
        const panel = createVNode("div", {
          "class": `${prefixCls}-panel-container`,
          "ref": panelDivRef,
          "onMousedown": (e2) => {
            e2.preventDefault();
          }
        }, [panelNode]);
        let suffixNode;
        if (suffixIcon) {
          suffixNode = createVNode("span", {
            "class": `${prefixCls}-suffix`
          }, [suffixIcon]);
        }
        let clearNode;
        if (allowClear && mergedValue.value && !disabled) {
          clearNode = createVNode("span", {
            "onMousedown": (e2) => {
              e2.preventDefault();
              e2.stopPropagation();
            },
            "onMouseup": (e2) => {
              e2.preventDefault();
              e2.stopPropagation();
              triggerChange(null);
              triggerOpen(false);
            },
            "class": `${prefixCls}-clear`,
            "role": "button"
          }, [clearIcon || createVNode("span", {
            "class": `${prefixCls}-clear-btn`
          }, null)]);
        }
        const mergedInputProps = _extends$1(_extends$1(_extends$1(_extends$1({
          id,
          tabindex,
          disabled,
          readonly: inputReadOnly || typeof formatList.value[0] === "function" || !typing.value,
          value: hoverValue.value || text.value,
          onInput: (e2) => {
            triggerTextChange(e2.target.value);
          },
          autofocus,
          placeholder,
          ref: inputRef,
          title: text.value
        }, inputProps2.value), {
          size: getInputSize(picker2, formatList.value[0], generateConfig2)
        }), getDataOrAriaProps(props2)), {
          autocomplete
        });
        const inputNode = props2.inputRender ? props2.inputRender(mergedInputProps) : createVNode("input", mergedInputProps, null);
        const popupPlacement = direction === "rtl" ? "bottomRight" : "bottomLeft";
        return createVNode("div", {
          "ref": containerRef,
          "class": classNames(prefixCls, attrs.class, {
            [`${prefixCls}-disabled`]: disabled,
            [`${prefixCls}-focused`]: focused.value,
            [`${prefixCls}-rtl`]: direction === "rtl"
          }),
          "style": attrs.style,
          "onMousedown": onMousedown,
          "onMouseup": onInternalMouseup,
          "onMouseenter": onMouseenter,
          "onMouseleave": onMouseleave,
          "onContextmenu": onContextmenu,
          "onClick": onClick
        }, [createVNode("div", {
          "class": classNames(`${prefixCls}-input`, {
            [`${prefixCls}-input-placeholder`]: !!hoverValue.value
          }),
          "ref": inputDivRef
        }, [inputNode, suffixNode, clearNode]), createVNode(PickerTrigger, {
          "visible": mergedOpen.value,
          "popupStyle": popupStyle,
          "prefixCls": prefixCls,
          "dropdownClassName": dropdownClassName,
          "dropdownAlign": dropdownAlign,
          "getPopupContainer": getPopupContainer,
          "transitionName": transitionName2,
          "popupPlacement": popupPlacement,
          "direction": direction
        }, {
          default: () => [createVNode("div", {
            "style": {
              pointerEvents: "none",
              position: "absolute",
              top: 0,
              bottom: 0,
              left: 0,
              right: 0
            }
          }, null)],
          popupElement: () => panel
        })]);
      };
    }
  });
}
const Picker$1 = Picker();
function useRangeDisabled(_ref, openRecordsRef) {
  let {
    picker,
    locale: locale2,
    selectedValue,
    disabledDate,
    disabled,
    generateConfig: generateConfig2
  } = _ref;
  const startDate = computed(() => getValue$2(selectedValue.value, 0));
  const endDate = computed(() => getValue$2(selectedValue.value, 1));
  function weekFirstDate(date4) {
    return generateConfig2.value.locale.getWeekFirstDate(locale2.value.locale, date4);
  }
  function monthNumber(date4) {
    const year = generateConfig2.value.getYear(date4);
    const month = generateConfig2.value.getMonth(date4);
    return year * 100 + month;
  }
  function quarterNumber(date4) {
    const year = generateConfig2.value.getYear(date4);
    const quarter = getQuarter(generateConfig2.value, date4);
    return year * 10 + quarter;
  }
  const disabledStartDate = (date4) => {
    var _a2;
    if (disabledDate && ((_a2 = disabledDate === null || disabledDate === void 0 ? void 0 : disabledDate.value) === null || _a2 === void 0 ? void 0 : _a2.call(disabledDate, date4))) {
      return true;
    }
    if (disabled[1] && endDate) {
      return !isSameDate(generateConfig2.value, date4, endDate.value) && generateConfig2.value.isAfter(date4, endDate.value);
    }
    if (openRecordsRef.value[1] && endDate.value) {
      switch (picker.value) {
        case "quarter":
          return quarterNumber(date4) > quarterNumber(endDate.value);
        case "month":
          return monthNumber(date4) > monthNumber(endDate.value);
        case "week":
          return weekFirstDate(date4) > weekFirstDate(endDate.value);
        default:
          return !isSameDate(generateConfig2.value, date4, endDate.value) && generateConfig2.value.isAfter(date4, endDate.value);
      }
    }
    return false;
  };
  const disabledEndDate = (date4) => {
    var _a2;
    if ((_a2 = disabledDate.value) === null || _a2 === void 0 ? void 0 : _a2.call(disabledDate, date4)) {
      return true;
    }
    if (disabled[0] && startDate) {
      return !isSameDate(generateConfig2.value, date4, endDate.value) && generateConfig2.value.isAfter(startDate.value, date4);
    }
    if (openRecordsRef.value[0] && startDate.value) {
      switch (picker.value) {
        case "quarter":
          return quarterNumber(date4) < quarterNumber(startDate.value);
        case "month":
          return monthNumber(date4) < monthNumber(startDate.value);
        case "week":
          return weekFirstDate(date4) < weekFirstDate(startDate.value);
        default:
          return !isSameDate(generateConfig2.value, date4, startDate.value) && generateConfig2.value.isAfter(startDate.value, date4);
      }
    }
    return false;
  };
  return [disabledStartDate, disabledEndDate];
}
function getStartEndDistance(startDate, endDate, picker, generateConfig2) {
  const startNext = getClosingViewDate(startDate, picker, generateConfig2, 1);
  function getDistance(compareFunc) {
    if (compareFunc(startDate, endDate)) {
      return "same";
    }
    if (compareFunc(startNext, endDate)) {
      return "closing";
    }
    return "far";
  }
  switch (picker) {
    case "year":
      return getDistance((start, end) => isSameDecade(generateConfig2, start, end));
    case "quarter":
    case "month":
      return getDistance((start, end) => isSameYear(generateConfig2, start, end));
    default:
      return getDistance((start, end) => isSameMonth(generateConfig2, start, end));
  }
}
function getRangeViewDate(values, index2, picker, generateConfig2) {
  const startDate = getValue$2(values, 0);
  const endDate = getValue$2(values, 1);
  if (index2 === 0) {
    return startDate;
  }
  if (startDate && endDate) {
    const distance = getStartEndDistance(startDate, endDate, picker, generateConfig2);
    switch (distance) {
      case "same":
        return startDate;
      case "closing":
        return startDate;
      default:
        return getClosingViewDate(endDate, picker, generateConfig2, -1);
    }
  }
  return startDate;
}
function useRangeViewDates(_ref) {
  let {
    values,
    picker,
    defaultDates,
    generateConfig: generateConfig2
  } = _ref;
  const defaultViewDates = ref([getValue$2(defaultDates, 0), getValue$2(defaultDates, 1)]);
  const viewDates = ref(null);
  const startDate = computed(() => getValue$2(values.value, 0));
  const endDate = computed(() => getValue$2(values.value, 1));
  const getViewDate = (index2) => {
    if (defaultViewDates.value[index2]) {
      return defaultViewDates.value[index2];
    }
    return getValue$2(viewDates.value, index2) || getRangeViewDate(values.value, index2, picker.value, generateConfig2.value) || startDate.value || endDate.value || generateConfig2.value.getNow();
  };
  const startViewDate = ref(null);
  const endViewDate = ref(null);
  watchEffect(() => {
    startViewDate.value = getViewDate(0);
    endViewDate.value = getViewDate(1);
  });
  function setViewDate(viewDate, index2) {
    if (viewDate) {
      let newViewDates = updateValues(viewDates.value, viewDate, index2);
      defaultViewDates.value = updateValues(defaultViewDates.value, null, index2) || [null, null];
      const anotherIndex = (index2 + 1) % 2;
      if (!getValue$2(values.value, anotherIndex)) {
        newViewDates = updateValues(newViewDates, viewDate, anotherIndex);
      }
      viewDates.value = newViewDates;
    } else if (startDate.value || endDate.value) {
      viewDates.value = null;
    }
  }
  return [startViewDate, endViewDate, setViewDate];
}
function tryOnScopeDispose(fn) {
  if (getCurrentScope()) {
    onScopeDispose(fn);
    return true;
  }
  return false;
}
function resolveUnref(r2) {
  return typeof r2 === "function" ? r2() : unref(r2);
}
function unrefElement(elRef) {
  var _a2;
  const plain = resolveUnref(elRef);
  return (_a2 = plain === null || plain === void 0 ? void 0 : plain.$el) !== null && _a2 !== void 0 ? _a2 : plain;
}
function tryOnMounted(fn) {
  let sync = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  if (getCurrentInstance()) onMounted(fn);
  else if (sync) fn();
  else nextTick(fn);
}
function useSupported(callback) {
  let sync = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  const isSupported = shallowRef();
  const update = () => isSupported.value = Boolean(callback());
  update();
  tryOnMounted(update, sync);
  return isSupported;
}
var _a;
const isClient = typeof window !== "undefined";
isClient && ((_a = window === null || window === void 0 ? void 0 : window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
const defaultWindow = isClient ? window : void 0;
var __rest$Q = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
function useResizeObserver(target, callback) {
  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const {
    window: window2 = defaultWindow
  } = options, observerOptions = __rest$Q(options, ["window"]);
  let observer;
  const isSupported = useSupported(() => window2 && "ResizeObserver" in window2);
  const cleanup2 = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };
  const stopWatch = watch(() => unrefElement(target), (el) => {
    cleanup2();
    if (isSupported.value && window2 && el) {
      observer = new ResizeObserver(callback);
      observer.observe(el, observerOptions);
    }
  }, {
    immediate: true,
    flush: "post"
  });
  const stop = () => {
    cleanup2();
    stopWatch();
  };
  tryOnScopeDispose(stop);
  return {
    isSupported,
    stop
  };
}
function useElementSize(target) {
  let initialSize = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    width: 0,
    height: 0
  };
  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const {
    box: box2 = "content-box"
  } = options;
  const width = shallowRef(initialSize.width);
  const height = shallowRef(initialSize.height);
  useResizeObserver(target, (_ref) => {
    let [entry] = _ref;
    const boxSize = box2 === "border-box" ? entry.borderBoxSize : box2 === "content-box" ? entry.contentBoxSize : entry.devicePixelContentBoxSize;
    if (boxSize) {
      width.value = boxSize.reduce((acc, _ref2) => {
        let {
          inlineSize
        } = _ref2;
        return acc + inlineSize;
      }, 0);
      height.value = boxSize.reduce((acc, _ref3) => {
        let {
          blockSize
        } = _ref3;
        return acc + blockSize;
      }, 0);
    } else {
      width.value = entry.contentRect.width;
      height.value = entry.contentRect.height;
    }
  }, options);
  watch(() => unrefElement(target), (ele) => {
    width.value = ele ? initialSize.width : 0;
    height.value = ele ? initialSize.height : 0;
  });
  return {
    width,
    height
  };
}
function reorderValues(values, generateConfig2) {
  if (values && values[0] && values[1] && generateConfig2.isAfter(values[0], values[1])) {
    return [values[1], values[0]];
  }
  return values;
}
function canValueTrigger(value, index2, disabled, allowEmpty) {
  if (value) {
    return true;
  }
  if (allowEmpty && allowEmpty[index2]) {
    return true;
  }
  if (disabled[(index2 + 1) % 2]) {
    return true;
  }
  return false;
}
function RangerPicker() {
  return defineComponent({
    name: "RangerPicker",
    inheritAttrs: false,
    props: ["prefixCls", "id", "popupStyle", "dropdownClassName", "transitionName", "dropdownAlign", "getPopupContainer", "generateConfig", "locale", "placeholder", "autofocus", "disabled", "format", "picker", "showTime", "showNow", "showHour", "showMinute", "showSecond", "use12Hours", "separator", "value", "defaultValue", "defaultPickerValue", "open", "defaultOpen", "disabledDate", "disabledTime", "dateRender", "panelRender", "ranges", "allowEmpty", "allowClear", "suffixIcon", "clearIcon", "pickerRef", "inputReadOnly", "mode", "renderExtraFooter", "onChange", "onOpenChange", "onPanelChange", "onCalendarChange", "onFocus", "onBlur", "onMousedown", "onMouseup", "onMouseenter", "onMouseleave", "onClick", "onOk", "onKeydown", "components", "order", "direction", "activePickerIndex", "autocomplete", "minuteStep", "hourStep", "secondStep", "hideDisabledOptions", "disabledMinutes", "presets", "prevIcon", "nextIcon", "superPrevIcon", "superNextIcon"],
    setup(props2, _ref) {
      let {
        attrs,
        expose
      } = _ref;
      const needConfirmButton = computed(() => props2.picker === "date" && !!props2.showTime || props2.picker === "time");
      const presets = computed(() => props2.presets);
      const ranges = computed(() => props2.ranges);
      const presetList = usePresets(presets, ranges);
      const openRecordsRef = ref({});
      const containerRef = ref(null);
      const panelDivRef = ref(null);
      const startInputDivRef = ref(null);
      const endInputDivRef = ref(null);
      const separatorRef = ref(null);
      const startInputRef = ref(null);
      const endInputRef = ref(null);
      const arrowRef = ref(null);
      const formatList = computed(() => toArray$5(getDefaultFormat(props2.format, props2.picker, props2.showTime, props2.use12Hours)));
      const [mergedActivePickerIndex, setMergedActivePickerIndex] = useMergedState(0, {
        value: toRef(props2, "activePickerIndex")
      });
      const operationRef = ref(null);
      const mergedDisabled = computed(() => {
        const {
          disabled
        } = props2;
        if (Array.isArray(disabled)) {
          return disabled;
        }
        return [disabled || false, disabled || false];
      });
      const [mergedValue, setInnerValue] = useMergedState(null, {
        value: toRef(props2, "value"),
        defaultValue: props2.defaultValue,
        postState: (values) => props2.picker === "time" && !props2.order ? values : reorderValues(values, props2.generateConfig)
      });
      const [startViewDate, endViewDate, setViewDate] = useRangeViewDates({
        values: mergedValue,
        picker: toRef(props2, "picker"),
        defaultDates: props2.defaultPickerValue,
        generateConfig: toRef(props2, "generateConfig")
      });
      const [selectedValue, setSelectedValue] = useMergedState(mergedValue.value, {
        postState: (values) => {
          let postValues = values;
          if (mergedDisabled.value[0] && mergedDisabled.value[1]) {
            return postValues;
          }
          for (let i2 = 0; i2 < 2; i2 += 1) {
            if (mergedDisabled.value[i2] && !getValue$2(postValues, i2) && !getValue$2(props2.allowEmpty, i2)) {
              postValues = updateValues(postValues, props2.generateConfig.getNow(), i2);
            }
          }
          return postValues;
        }
      });
      const [mergedModes, setInnerModes] = useMergedState([props2.picker, props2.picker], {
        value: toRef(props2, "mode")
      });
      watch(() => props2.picker, () => {
        setInnerModes([props2.picker, props2.picker]);
      });
      const triggerModesChange = (modes, values) => {
        var _a2;
        setInnerModes(modes);
        (_a2 = props2.onPanelChange) === null || _a2 === void 0 ? void 0 : _a2.call(props2, values, modes);
      };
      const [disabledStartDate, disabledEndDate] = useRangeDisabled({
        picker: toRef(props2, "picker"),
        selectedValue,
        locale: toRef(props2, "locale"),
        disabled: mergedDisabled,
        disabledDate: toRef(props2, "disabledDate"),
        generateConfig: toRef(props2, "generateConfig")
      }, openRecordsRef);
      const [mergedOpen, triggerInnerOpen] = useMergedState(false, {
        value: toRef(props2, "open"),
        defaultValue: props2.defaultOpen,
        postState: (postOpen) => mergedDisabled.value[mergedActivePickerIndex.value] ? false : postOpen,
        onChange: (newOpen) => {
          var _a2;
          (_a2 = props2.onOpenChange) === null || _a2 === void 0 ? void 0 : _a2.call(props2, newOpen);
          if (!newOpen && operationRef.value && operationRef.value.onClose) {
            operationRef.value.onClose();
          }
        }
      });
      const startOpen = computed(() => mergedOpen.value && mergedActivePickerIndex.value === 0);
      const endOpen = computed(() => mergedOpen.value && mergedActivePickerIndex.value === 1);
      const panelLeft = ref(0);
      const arrowLeft = ref(0);
      const popupMinWidth = ref(0);
      const {
        width: containerWidth
      } = useElementSize(containerRef);
      watch([mergedOpen, containerWidth], () => {
        if (!mergedOpen.value && containerRef.value) {
          popupMinWidth.value = containerWidth.value;
        }
      });
      const {
        width: panelDivWidth
      } = useElementSize(panelDivRef);
      const {
        width: arrowWidth
      } = useElementSize(arrowRef);
      const {
        width: startInputDivWidth
      } = useElementSize(startInputDivRef);
      const {
        width: separatorWidth
      } = useElementSize(separatorRef);
      watch([mergedActivePickerIndex, mergedOpen, panelDivWidth, arrowWidth, startInputDivWidth, separatorWidth, () => props2.direction], () => {
        arrowLeft.value = 0;
        if (mergedActivePickerIndex.value) {
          if (startInputDivRef.value && separatorRef.value) {
            arrowLeft.value = startInputDivWidth.value + separatorWidth.value;
            if (panelDivWidth.value && arrowWidth.value && arrowLeft.value > panelDivWidth.value - arrowWidth.value - (props2.direction === "rtl" || arrowRef.value.offsetLeft > arrowLeft.value ? 0 : arrowRef.value.offsetLeft)) {
              panelLeft.value = arrowLeft.value;
            }
          }
        } else if (mergedActivePickerIndex.value === 0) {
          panelLeft.value = 0;
        }
      }, {
        immediate: true
      });
      const triggerRef2 = ref();
      function triggerOpen(newOpen, index2) {
        if (newOpen) {
          clearTimeout(triggerRef2.value);
          openRecordsRef.value[index2] = true;
          setMergedActivePickerIndex(index2);
          triggerInnerOpen(newOpen);
          if (!mergedOpen.value) {
            setViewDate(null, index2);
          }
        } else if (mergedActivePickerIndex.value === index2) {
          triggerInnerOpen(newOpen);
          const openRecords = openRecordsRef.value;
          triggerRef2.value = setTimeout(() => {
            if (openRecords === openRecordsRef.value) {
              openRecordsRef.value = {};
            }
          });
        }
      }
      function triggerOpenAndFocus(index2) {
        triggerOpen(true, index2);
        setTimeout(() => {
          const inputRef = [startInputRef, endInputRef][index2];
          if (inputRef.value) {
            inputRef.value.focus();
          }
        }, 0);
      }
      function triggerChange(newValue, sourceIndex) {
        let values = newValue;
        let startValue = getValue$2(values, 0);
        let endValue = getValue$2(values, 1);
        const {
          generateConfig: generateConfig2,
          locale: locale2,
          picker,
          order,
          onCalendarChange,
          allowEmpty,
          onChange,
          showTime
        } = props2;
        if (startValue && endValue && generateConfig2.isAfter(startValue, endValue)) {
          if (
            // WeekPicker only compare week
            picker === "week" && !isSameWeek(generateConfig2, locale2.locale, startValue, endValue) || // QuotaPicker only compare week
            picker === "quarter" && !isSameQuarter(generateConfig2, startValue, endValue) || // Other non-TimePicker compare date
            picker !== "week" && picker !== "quarter" && picker !== "time" && !(showTime ? isEqual$1(generateConfig2, startValue, endValue) : isSameDate(generateConfig2, startValue, endValue))
          ) {
            if (sourceIndex === 0) {
              values = [startValue, null];
              endValue = null;
            } else {
              startValue = null;
              values = [null, endValue];
            }
            openRecordsRef.value = {
              [sourceIndex]: true
            };
          } else if (picker !== "time" || order !== false) {
            values = reorderValues(values, generateConfig2);
          }
        }
        setSelectedValue(values);
        const startStr2 = values && values[0] ? formatValue(values[0], {
          generateConfig: generateConfig2,
          locale: locale2,
          format: formatList.value[0]
        }) : "";
        const endStr2 = values && values[1] ? formatValue(values[1], {
          generateConfig: generateConfig2,
          locale: locale2,
          format: formatList.value[0]
        }) : "";
        if (onCalendarChange) {
          const info = {
            range: sourceIndex === 0 ? "start" : "end"
          };
          onCalendarChange(values, [startStr2, endStr2], info);
        }
        const canStartValueTrigger = canValueTrigger(startValue, 0, mergedDisabled.value, allowEmpty);
        const canEndValueTrigger = canValueTrigger(endValue, 1, mergedDisabled.value, allowEmpty);
        const canTrigger = values === null || canStartValueTrigger && canEndValueTrigger;
        if (canTrigger) {
          setInnerValue(values);
          if (onChange && (!isEqual$1(generateConfig2, getValue$2(mergedValue.value, 0), startValue) || !isEqual$1(generateConfig2, getValue$2(mergedValue.value, 1), endValue))) {
            onChange(values, [startStr2, endStr2]);
          }
        }
        let nextOpenIndex = null;
        if (sourceIndex === 0 && !mergedDisabled.value[1]) {
          nextOpenIndex = 1;
        } else if (sourceIndex === 1 && !mergedDisabled.value[0]) {
          nextOpenIndex = 0;
        }
        if (nextOpenIndex !== null && nextOpenIndex !== mergedActivePickerIndex.value && (!openRecordsRef.value[nextOpenIndex] || !getValue$2(values, nextOpenIndex)) && getValue$2(values, sourceIndex)) {
          triggerOpenAndFocus(nextOpenIndex);
        } else {
          triggerOpen(false, sourceIndex);
        }
      }
      const forwardKeydown = (e2) => {
        if (mergedOpen && operationRef.value && operationRef.value.onKeydown) {
          return operationRef.value.onKeydown(e2);
        }
        {
          return false;
        }
      };
      const sharedTextHooksProps = {
        formatList,
        generateConfig: toRef(props2, "generateConfig"),
        locale: toRef(props2, "locale")
      };
      const [startValueTexts, firstStartValueText] = useValueTexts(computed(() => getValue$2(selectedValue.value, 0)), sharedTextHooksProps);
      const [endValueTexts, firstEndValueText] = useValueTexts(computed(() => getValue$2(selectedValue.value, 1)), sharedTextHooksProps);
      const onTextChange = (newText, index2) => {
        const inputDate = parseValue(newText, {
          locale: props2.locale,
          formatList: formatList.value,
          generateConfig: props2.generateConfig
        });
        const disabledFunc = index2 === 0 ? disabledStartDate : disabledEndDate;
        if (inputDate && !disabledFunc(inputDate)) {
          setSelectedValue(updateValues(selectedValue.value, inputDate, index2));
          setViewDate(inputDate, index2);
        }
      };
      const [startText, triggerStartTextChange, resetStartText] = useTextValueMapping({
        valueTexts: startValueTexts,
        onTextChange: (newText) => onTextChange(newText, 0)
      });
      const [endText, triggerEndTextChange, resetEndText] = useTextValueMapping({
        valueTexts: endValueTexts,
        onTextChange: (newText) => onTextChange(newText, 1)
      });
      const [rangeHoverValue, setRangeHoverValue] = useState(null);
      const [hoverRangedValue, setHoverRangedValue] = useState(null);
      const [startHoverValue, onStartEnter, onStartLeave] = useHoverValue(startText, sharedTextHooksProps);
      const [endHoverValue, onEndEnter, onEndLeave] = useHoverValue(endText, sharedTextHooksProps);
      const onDateMouseenter = (date4) => {
        setHoverRangedValue(updateValues(selectedValue.value, date4, mergedActivePickerIndex.value));
        if (mergedActivePickerIndex.value === 0) {
          onStartEnter(date4);
        } else {
          onEndEnter(date4);
        }
      };
      const onDateMouseleave = () => {
        setHoverRangedValue(updateValues(selectedValue.value, null, mergedActivePickerIndex.value));
        if (mergedActivePickerIndex.value === 0) {
          onStartLeave();
        } else {
          onEndLeave();
        }
      };
      const getSharedInputHookProps = (index2, resetText) => ({
        forwardKeydown,
        onBlur: (e2) => {
          var _a2;
          (_a2 = props2.onBlur) === null || _a2 === void 0 ? void 0 : _a2.call(props2, e2);
        },
        isClickOutside: (target) => !elementsContains([panelDivRef.value, startInputDivRef.value, endInputDivRef.value, containerRef.value], target),
        onFocus: (e2) => {
          var _a2;
          setMergedActivePickerIndex(index2);
          (_a2 = props2.onFocus) === null || _a2 === void 0 ? void 0 : _a2.call(props2, e2);
        },
        triggerOpen: (newOpen) => {
          triggerOpen(newOpen, index2);
        },
        onSubmit: () => {
          if (
            // When user typing disabledDate with keyboard and enter, this value will be empty
            !selectedValue.value || // Normal disabled check
            props2.disabledDate && props2.disabledDate(selectedValue.value[index2])
          ) {
            return false;
          }
          triggerChange(selectedValue.value, index2);
          resetText();
        },
        onCancel: () => {
          triggerOpen(false, index2);
          setSelectedValue(mergedValue.value);
          resetText();
        }
      });
      const [startInputProps, {
        focused: startFocused,
        typing: startTyping
      }] = usePickerInput(_extends$1(_extends$1({}, getSharedInputHookProps(0, resetStartText)), {
        blurToCancel: needConfirmButton,
        open: startOpen,
        value: startText,
        onKeydown: (e2, preventDefault) => {
          var _a2;
          (_a2 = props2.onKeydown) === null || _a2 === void 0 ? void 0 : _a2.call(props2, e2, preventDefault);
        }
      }));
      const [endInputProps, {
        focused: endFocused,
        typing: endTyping
      }] = usePickerInput(_extends$1(_extends$1({}, getSharedInputHookProps(1, resetEndText)), {
        blurToCancel: needConfirmButton,
        open: endOpen,
        value: endText,
        onKeydown: (e2, preventDefault) => {
          var _a2;
          (_a2 = props2.onKeydown) === null || _a2 === void 0 ? void 0 : _a2.call(props2, e2, preventDefault);
        }
      }));
      const onPickerClick = (e2) => {
        var _a2;
        (_a2 = props2.onClick) === null || _a2 === void 0 ? void 0 : _a2.call(props2, e2);
        if (!mergedOpen.value && !startInputRef.value.contains(e2.target) && !endInputRef.value.contains(e2.target)) {
          if (!mergedDisabled.value[0]) {
            triggerOpenAndFocus(0);
          } else if (!mergedDisabled.value[1]) {
            triggerOpenAndFocus(1);
          }
        }
      };
      const onPickerMousedown = (e2) => {
        var _a2;
        (_a2 = props2.onMousedown) === null || _a2 === void 0 ? void 0 : _a2.call(props2, e2);
        if (mergedOpen.value && (startFocused.value || endFocused.value) && !startInputRef.value.contains(e2.target) && !endInputRef.value.contains(e2.target)) {
          e2.preventDefault();
        }
      };
      const startStr = computed(() => {
        var _a2;
        return ((_a2 = mergedValue.value) === null || _a2 === void 0 ? void 0 : _a2[0]) ? formatValue(mergedValue.value[0], {
          locale: props2.locale,
          format: "YYYYMMDDHHmmss",
          generateConfig: props2.generateConfig
        }) : "";
      });
      const endStr = computed(() => {
        var _a2;
        return ((_a2 = mergedValue.value) === null || _a2 === void 0 ? void 0 : _a2[1]) ? formatValue(mergedValue.value[1], {
          locale: props2.locale,
          format: "YYYYMMDDHHmmss",
          generateConfig: props2.generateConfig
        }) : "";
      });
      watch([mergedOpen, startValueTexts, endValueTexts], () => {
        if (!mergedOpen.value) {
          setSelectedValue(mergedValue.value);
          if (!startValueTexts.value.length || startValueTexts.value[0] === "") {
            triggerStartTextChange("");
          } else if (firstStartValueText.value !== startText.value) {
            resetStartText();
          }
          if (!endValueTexts.value.length || endValueTexts.value[0] === "") {
            triggerEndTextChange("");
          } else if (firstEndValueText.value !== endText.value) {
            resetEndText();
          }
        }
      });
      watch([startStr, endStr], () => {
        setSelectedValue(mergedValue.value);
      });
      expose({
        focus: () => {
          if (startInputRef.value) {
            startInputRef.value.focus();
          }
        },
        blur: () => {
          if (startInputRef.value) {
            startInputRef.value.blur();
          }
          if (endInputRef.value) {
            endInputRef.value.blur();
          }
        }
      });
      const panelHoverRangedValue = computed(() => {
        if (mergedOpen.value && hoverRangedValue.value && hoverRangedValue.value[0] && hoverRangedValue.value[1] && props2.generateConfig.isAfter(hoverRangedValue.value[1], hoverRangedValue.value[0])) {
          return hoverRangedValue.value;
        } else {
          return null;
        }
      });
      function renderPanel() {
        let panelPosition = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        let panelProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          generateConfig: generateConfig2,
          showTime,
          dateRender,
          direction,
          disabledTime,
          prefixCls,
          locale: locale2
        } = props2;
        let panelShowTime = showTime;
        if (showTime && typeof showTime === "object" && showTime.defaultValue) {
          const timeDefaultValues = showTime.defaultValue;
          panelShowTime = _extends$1(_extends$1({}, showTime), {
            defaultValue: getValue$2(timeDefaultValues, mergedActivePickerIndex.value) || void 0
          });
        }
        let panelDateRender = null;
        if (dateRender) {
          panelDateRender = (_ref2) => {
            let {
              current: date4,
              today
            } = _ref2;
            return dateRender({
              current: date4,
              today,
              info: {
                range: mergedActivePickerIndex.value ? "end" : "start"
              }
            });
          };
        }
        return createVNode(RangeContextProvider, {
          "value": {
            inRange: true,
            panelPosition,
            rangedValue: rangeHoverValue.value || selectedValue.value,
            hoverRangedValue: panelHoverRangedValue.value
          }
        }, {
          default: () => [createVNode(PickerPanel$1, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, props2), panelProps), {}, {
            "dateRender": panelDateRender,
            "showTime": panelShowTime,
            "mode": mergedModes.value[mergedActivePickerIndex.value],
            "generateConfig": generateConfig2,
            "style": void 0,
            "direction": direction,
            "disabledDate": mergedActivePickerIndex.value === 0 ? disabledStartDate : disabledEndDate,
            "disabledTime": (date4) => {
              if (disabledTime) {
                return disabledTime(date4, mergedActivePickerIndex.value === 0 ? "start" : "end");
              }
              return false;
            },
            "class": classNames({
              [`${prefixCls}-panel-focused`]: mergedActivePickerIndex.value === 0 ? !startTyping.value : !endTyping.value
            }),
            "value": getValue$2(selectedValue.value, mergedActivePickerIndex.value),
            "locale": locale2,
            "tabIndex": -1,
            "onPanelChange": (date4, newMode) => {
              if (mergedActivePickerIndex.value === 0) {
                onStartLeave(true);
              }
              if (mergedActivePickerIndex.value === 1) {
                onEndLeave(true);
              }
              triggerModesChange(updateValues(mergedModes.value, newMode, mergedActivePickerIndex.value), updateValues(selectedValue.value, date4, mergedActivePickerIndex.value));
              let viewDate = date4;
              if (panelPosition === "right" && mergedModes.value[mergedActivePickerIndex.value] === newMode) {
                viewDate = getClosingViewDate(viewDate, newMode, generateConfig2, -1);
              }
              setViewDate(viewDate, mergedActivePickerIndex.value);
            },
            "onOk": null,
            "onSelect": void 0,
            "onChange": void 0,
            "defaultValue": mergedActivePickerIndex.value === 0 ? getValue$2(selectedValue.value, 1) : getValue$2(selectedValue.value, 0)
          }), null)]
        });
      }
      const onContextSelect = (date4, type4) => {
        const values = updateValues(selectedValue.value, date4, mergedActivePickerIndex.value);
        if (type4 === "submit" || type4 !== "key" && !needConfirmButton.value) {
          triggerChange(values, mergedActivePickerIndex.value);
          if (mergedActivePickerIndex.value === 0) {
            onStartLeave();
          } else {
            onEndLeave();
          }
        } else {
          setSelectedValue(values);
        }
      };
      useProvidePanel({
        operationRef,
        hideHeader: computed(() => props2.picker === "time"),
        onDateMouseenter,
        onDateMouseleave,
        hideRanges: computed(() => true),
        onSelect: onContextSelect,
        open: mergedOpen
      });
      return () => {
        const {
          prefixCls = "rc-picker",
          id,
          popupStyle,
          dropdownClassName,
          transitionName: transitionName2,
          dropdownAlign,
          getPopupContainer,
          generateConfig: generateConfig2,
          locale: locale2,
          placeholder,
          autofocus,
          picker = "date",
          showTime,
          separator = "~",
          disabledDate,
          panelRender,
          allowClear,
          suffixIcon,
          clearIcon,
          inputReadOnly,
          renderExtraFooter,
          onMouseenter,
          onMouseleave,
          onMouseup,
          onOk,
          components,
          direction,
          autocomplete = "off"
        } = props2;
        const arrowPositionStyle = direction === "rtl" ? {
          right: `${arrowLeft.value}px`
        } : {
          left: `${arrowLeft.value}px`
        };
        function renderPanels() {
          let panels;
          const extraNode = getExtraFooter(prefixCls, mergedModes.value[mergedActivePickerIndex.value], renderExtraFooter);
          const rangesNode = getRanges({
            prefixCls,
            components,
            needConfirmButton: needConfirmButton.value,
            okDisabled: !getValue$2(selectedValue.value, mergedActivePickerIndex.value) || disabledDate && disabledDate(selectedValue.value[mergedActivePickerIndex.value]),
            locale: locale2,
            onOk: () => {
              if (getValue$2(selectedValue.value, mergedActivePickerIndex.value)) {
                triggerChange(selectedValue.value, mergedActivePickerIndex.value);
                if (onOk) {
                  onOk(selectedValue.value);
                }
              }
            }
          });
          if (picker !== "time" && !showTime) {
            const viewDate = mergedActivePickerIndex.value === 0 ? startViewDate.value : endViewDate.value;
            const nextViewDate = getClosingViewDate(viewDate, picker, generateConfig2);
            const currentMode = mergedModes.value[mergedActivePickerIndex.value];
            const showDoublePanel = currentMode === picker;
            const leftPanel = renderPanel(showDoublePanel ? "left" : false, {
              pickerValue: viewDate,
              onPickerValueChange: (newViewDate) => {
                setViewDate(newViewDate, mergedActivePickerIndex.value);
              }
            });
            const rightPanel = renderPanel("right", {
              pickerValue: nextViewDate,
              onPickerValueChange: (newViewDate) => {
                setViewDate(getClosingViewDate(newViewDate, picker, generateConfig2, -1), mergedActivePickerIndex.value);
              }
            });
            if (direction === "rtl") {
              panels = createVNode(Fragment, null, [rightPanel, showDoublePanel && leftPanel]);
            } else {
              panels = createVNode(Fragment, null, [leftPanel, showDoublePanel && rightPanel]);
            }
          } else {
            panels = renderPanel();
          }
          let mergedNodes = createVNode("div", {
            "class": `${prefixCls}-panel-layout`
          }, [createVNode(PresetPanel, {
            "prefixCls": prefixCls,
            "presets": presetList.value,
            "onClick": (nextValue) => {
              triggerChange(nextValue, null);
              triggerOpen(false, mergedActivePickerIndex.value);
            },
            "onHover": (hoverValue) => {
              setRangeHoverValue(hoverValue);
            }
          }, null), createVNode("div", null, [createVNode("div", {
            "class": `${prefixCls}-panels`
          }, [panels]), (extraNode || rangesNode) && createVNode("div", {
            "class": `${prefixCls}-footer`
          }, [extraNode, rangesNode])])]);
          if (panelRender) {
            mergedNodes = panelRender(mergedNodes);
          }
          return createVNode("div", {
            "class": `${prefixCls}-panel-container`,
            "style": {
              marginLeft: `${panelLeft.value}px`
            },
            "ref": panelDivRef,
            "onMousedown": (e2) => {
              e2.preventDefault();
            }
          }, [mergedNodes]);
        }
        const rangePanel = createVNode("div", {
          "class": classNames(`${prefixCls}-range-wrapper`, `${prefixCls}-${picker}-range-wrapper`),
          "style": {
            minWidth: `${popupMinWidth.value}px`
          }
        }, [createVNode("div", {
          "ref": arrowRef,
          "class": `${prefixCls}-range-arrow`,
          "style": arrowPositionStyle
        }, null), renderPanels()]);
        let suffixNode;
        if (suffixIcon) {
          suffixNode = createVNode("span", {
            "class": `${prefixCls}-suffix`
          }, [suffixIcon]);
        }
        let clearNode;
        if (allowClear && (getValue$2(mergedValue.value, 0) && !mergedDisabled.value[0] || getValue$2(mergedValue.value, 1) && !mergedDisabled.value[1])) {
          clearNode = createVNode("span", {
            "onMousedown": (e2) => {
              e2.preventDefault();
              e2.stopPropagation();
            },
            "onMouseup": (e2) => {
              e2.preventDefault();
              e2.stopPropagation();
              let values = mergedValue.value;
              if (!mergedDisabled.value[0]) {
                values = updateValues(values, null, 0);
              }
              if (!mergedDisabled.value[1]) {
                values = updateValues(values, null, 1);
              }
              triggerChange(values, null);
              triggerOpen(false, mergedActivePickerIndex.value);
            },
            "class": `${prefixCls}-clear`
          }, [clearIcon || createVNode("span", {
            "class": `${prefixCls}-clear-btn`
          }, null)]);
        }
        const inputSharedProps = {
          size: getInputSize(picker, formatList.value[0], generateConfig2)
        };
        let activeBarLeft = 0;
        let activeBarWidth = 0;
        if (startInputDivRef.value && endInputDivRef.value && separatorRef.value) {
          if (mergedActivePickerIndex.value === 0) {
            activeBarWidth = startInputDivRef.value.offsetWidth;
          } else {
            activeBarLeft = arrowLeft.value;
            activeBarWidth = endInputDivRef.value.offsetWidth;
          }
        }
        const activeBarPositionStyle = direction === "rtl" ? {
          right: `${activeBarLeft}px`
        } : {
          left: `${activeBarLeft}px`
        };
        return createVNode("div", _objectSpread2$1({
          "ref": containerRef,
          "class": classNames(prefixCls, `${prefixCls}-range`, attrs.class, {
            [`${prefixCls}-disabled`]: mergedDisabled.value[0] && mergedDisabled.value[1],
            [`${prefixCls}-focused`]: mergedActivePickerIndex.value === 0 ? startFocused.value : endFocused.value,
            [`${prefixCls}-rtl`]: direction === "rtl"
          }),
          "style": attrs.style,
          "onClick": onPickerClick,
          "onMouseenter": onMouseenter,
          "onMouseleave": onMouseleave,
          "onMousedown": onPickerMousedown,
          "onMouseup": onMouseup
        }, getDataOrAriaProps(props2)), [createVNode("div", {
          "class": classNames(`${prefixCls}-input`, {
            [`${prefixCls}-input-active`]: mergedActivePickerIndex.value === 0,
            [`${prefixCls}-input-placeholder`]: !!startHoverValue.value
          }),
          "ref": startInputDivRef
        }, [createVNode("input", _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
          "id": id,
          "disabled": mergedDisabled.value[0],
          "readonly": inputReadOnly || typeof formatList.value[0] === "function" || !startTyping.value,
          "value": startHoverValue.value || startText.value,
          "onInput": (e2) => {
            triggerStartTextChange(e2.target.value);
          },
          "autofocus": autofocus,
          "placeholder": getValue$2(placeholder, 0) || "",
          "ref": startInputRef
        }, startInputProps.value), inputSharedProps), {}, {
          "autocomplete": autocomplete
        }), null)]), createVNode("div", {
          "class": `${prefixCls}-range-separator`,
          "ref": separatorRef
        }, [separator]), createVNode("div", {
          "class": classNames(`${prefixCls}-input`, {
            [`${prefixCls}-input-active`]: mergedActivePickerIndex.value === 1,
            [`${prefixCls}-input-placeholder`]: !!endHoverValue.value
          }),
          "ref": endInputDivRef
        }, [createVNode("input", _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
          "disabled": mergedDisabled.value[1],
          "readonly": inputReadOnly || typeof formatList.value[0] === "function" || !endTyping.value,
          "value": endHoverValue.value || endText.value,
          "onInput": (e2) => {
            triggerEndTextChange(e2.target.value);
          },
          "placeholder": getValue$2(placeholder, 1) || "",
          "ref": endInputRef
        }, endInputProps.value), inputSharedProps), {}, {
          "autocomplete": autocomplete
        }), null)]), createVNode("div", {
          "class": `${prefixCls}-active-bar`,
          "style": _extends$1(_extends$1({}, activeBarPositionStyle), {
            width: `${activeBarWidth}px`,
            position: "absolute"
          })
        }, null), suffixNode, clearNode, createVNode(PickerTrigger, {
          "visible": mergedOpen.value,
          "popupStyle": popupStyle,
          "prefixCls": prefixCls,
          "dropdownClassName": dropdownClassName,
          "dropdownAlign": dropdownAlign,
          "getPopupContainer": getPopupContainer,
          "transitionName": transitionName2,
          "range": true,
          "direction": direction
        }, {
          default: () => [createVNode("div", {
            "style": {
              pointerEvents: "none",
              position: "absolute",
              top: 0,
              bottom: 0,
              left: 0,
              right: 0
            }
          }, null)],
          popupElement: () => rangePanel
        })]);
      };
    }
  });
}
const InterRangerPicker = RangerPicker();
var __rest$P = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const checkboxProps$1 = {
  prefixCls: String,
  name: String,
  id: String,
  type: String,
  defaultChecked: {
    type: [Boolean, Number],
    default: void 0
  },
  checked: {
    type: [Boolean, Number],
    default: void 0
  },
  disabled: Boolean,
  tabindex: {
    type: [Number, String]
  },
  readonly: Boolean,
  autofocus: Boolean,
  value: PropTypes.any,
  required: Boolean
};
const VcCheckbox = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Checkbox",
  inheritAttrs: false,
  props: initDefaultProps(checkboxProps$1, {
    prefixCls: "rc-checkbox",
    type: "checkbox",
    defaultChecked: false
  }),
  emits: ["click", "change"],
  setup(props2, _ref) {
    let {
      attrs,
      emit,
      expose
    } = _ref;
    const checked = ref(props2.checked === void 0 ? props2.defaultChecked : props2.checked);
    const inputRef = ref();
    watch(() => props2.checked, () => {
      checked.value = props2.checked;
    });
    expose({
      focus() {
        var _a2;
        (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
      },
      blur() {
        var _a2;
        (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
      }
    });
    const eventShiftKey = ref();
    const handleChange = (e2) => {
      if (props2.disabled) {
        return;
      }
      if (props2.checked === void 0) {
        checked.value = e2.target.checked;
      }
      e2.shiftKey = eventShiftKey.value;
      const eventObj = {
        target: _extends$1(_extends$1({}, props2), {
          checked: e2.target.checked
        }),
        stopPropagation() {
          e2.stopPropagation();
        },
        preventDefault() {
          e2.preventDefault();
        },
        nativeEvent: e2
      };
      if (props2.checked !== void 0) {
        inputRef.value.checked = !!props2.checked;
      }
      emit("change", eventObj);
      eventShiftKey.value = false;
    };
    const onClick = (e2) => {
      emit("click", e2);
      eventShiftKey.value = e2.shiftKey;
    };
    return () => {
      const {
        prefixCls,
        name,
        id,
        type: type4,
        disabled,
        readonly,
        tabindex,
        autofocus,
        value,
        required: required4
      } = props2, others = __rest$P(props2, ["prefixCls", "name", "id", "type", "disabled", "readonly", "tabindex", "autofocus", "value", "required"]);
      const {
        class: className,
        onFocus,
        onBlur,
        onKeydown,
        onKeypress,
        onKeyup
      } = attrs;
      const othersAndAttrs = _extends$1(_extends$1({}, others), attrs);
      const globalProps = Object.keys(othersAndAttrs).reduce((prev2, key2) => {
        if (key2.startsWith("data-") || key2.startsWith("aria-") || key2 === "role") {
          prev2[key2] = othersAndAttrs[key2];
        }
        return prev2;
      }, {});
      const classString = classNames(prefixCls, className, {
        [`${prefixCls}-checked`]: checked.value,
        [`${prefixCls}-disabled`]: disabled
      });
      const inputProps2 = _extends$1(_extends$1({
        name,
        id,
        type: type4,
        readonly,
        disabled,
        tabindex,
        class: `${prefixCls}-input`,
        checked: !!checked.value,
        autofocus,
        value
      }, globalProps), {
        onChange: handleChange,
        onClick,
        onFocus,
        onBlur,
        onKeydown,
        onKeypress,
        onKeyup,
        required: required4
      });
      return createVNode("span", {
        "class": classString
      }, [createVNode("input", _objectSpread2$1({
        "ref": inputRef
      }, inputProps2), null), createVNode("span", {
        "class": `${prefixCls}-inner`
      }, null)]);
    };
  }
});
const radioGroupContextKey = Symbol("radioGroupContextKey");
const useProvideRadioGroupContext = (props2) => {
  provide(radioGroupContextKey, props2);
};
const useInjectRadioGroupContext = () => {
  return inject(radioGroupContextKey, void 0);
};
const radioOptionTypeContextKey = Symbol("radioOptionTypeContextKey");
const useProvideRadioOptionTypeContext = (props2) => {
  provide(radioOptionTypeContextKey, props2);
};
const useInjectRadioOptionTypeContext = () => {
  return inject(radioOptionTypeContextKey, void 0);
};
const antRadioEffect = new Keyframe("antRadioEffect", {
  "0%": {
    transform: "scale(1)",
    opacity: 0.5
  },
  "100%": {
    transform: "scale(1.6)",
    opacity: 0
  }
});
const getGroupRadioStyle = (token2) => {
  const {
    componentCls,
    antCls
  } = token2;
  const groupPrefixCls = `${componentCls}-group`;
  return {
    [groupPrefixCls]: _extends$1(_extends$1({}, resetComponent(token2)), {
      display: "inline-block",
      fontSize: 0,
      // RTL
      [`&${groupPrefixCls}-rtl`]: {
        direction: "rtl"
      },
      [`${antCls}-badge ${antCls}-badge-count`]: {
        zIndex: 1
      },
      [`> ${antCls}-badge:not(:first-child) > ${antCls}-button-wrapper`]: {
        borderInlineStart: "none"
      }
    })
  };
};
const getRadioBasicStyle = (token2) => {
  const {
    componentCls,
    radioWrapperMarginRight,
    radioCheckedColor,
    radioSize,
    motionDurationSlow,
    motionDurationMid,
    motionEaseInOut,
    motionEaseInOutCirc,
    radioButtonBg,
    colorBorder,
    lineWidth,
    radioDotSize,
    colorBgContainerDisabled,
    colorTextDisabled,
    paddingXS,
    radioDotDisabledColor,
    lineType,
    radioDotDisabledSize,
    wireframe,
    colorWhite
  } = token2;
  const radioInnerPrefixCls = `${componentCls}-inner`;
  return {
    [`${componentCls}-wrapper`]: _extends$1(_extends$1({}, resetComponent(token2)), {
      position: "relative",
      display: "inline-flex",
      alignItems: "baseline",
      marginInlineStart: 0,
      marginInlineEnd: radioWrapperMarginRight,
      cursor: "pointer",
      // RTL
      [`&${componentCls}-wrapper-rtl`]: {
        direction: "rtl"
      },
      "&-disabled": {
        cursor: "not-allowed",
        color: token2.colorTextDisabled
      },
      "&::after": {
        display: "inline-block",
        width: 0,
        overflow: "hidden",
        content: '"\\a0"'
      },
      // hashId 在 wrapper 上，只能铺平
      [`${componentCls}-checked::after`]: {
        position: "absolute",
        insetBlockStart: 0,
        insetInlineStart: 0,
        width: "100%",
        height: "100%",
        border: `${lineWidth}px ${lineType} ${radioCheckedColor}`,
        borderRadius: "50%",
        visibility: "hidden",
        animationName: antRadioEffect,
        animationDuration: motionDurationSlow,
        animationTimingFunction: motionEaseInOut,
        animationFillMode: "both",
        content: '""'
      },
      [componentCls]: _extends$1(_extends$1({}, resetComponent(token2)), {
        position: "relative",
        display: "inline-block",
        outline: "none",
        cursor: "pointer",
        alignSelf: "center"
      }),
      [`${componentCls}-wrapper:hover &,
        &:hover ${radioInnerPrefixCls}`]: {
        borderColor: radioCheckedColor
      },
      [`${componentCls}-input:focus-visible + ${radioInnerPrefixCls}`]: _extends$1({}, genFocusOutline(token2)),
      [`${componentCls}:hover::after, ${componentCls}-wrapper:hover &::after`]: {
        visibility: "visible"
      },
      [`${componentCls}-inner`]: {
        "&::after": {
          boxSizing: "border-box",
          position: "absolute",
          insetBlockStart: "50%",
          insetInlineStart: "50%",
          display: "block",
          width: radioSize,
          height: radioSize,
          marginBlockStart: radioSize / -2,
          marginInlineStart: radioSize / -2,
          backgroundColor: wireframe ? radioCheckedColor : colorWhite,
          borderBlockStart: 0,
          borderInlineStart: 0,
          borderRadius: radioSize,
          transform: "scale(0)",
          opacity: 0,
          transition: `all ${motionDurationSlow} ${motionEaseInOutCirc}`,
          content: '""'
        },
        boxSizing: "border-box",
        position: "relative",
        insetBlockStart: 0,
        insetInlineStart: 0,
        display: "block",
        width: radioSize,
        height: radioSize,
        backgroundColor: radioButtonBg,
        borderColor: colorBorder,
        borderStyle: "solid",
        borderWidth: lineWidth,
        borderRadius: "50%",
        transition: `all ${motionDurationMid}`
      },
      [`${componentCls}-input`]: {
        position: "absolute",
        insetBlockStart: 0,
        insetInlineEnd: 0,
        insetBlockEnd: 0,
        insetInlineStart: 0,
        zIndex: 1,
        cursor: "pointer",
        opacity: 0
      },
      // 选中状态
      [`${componentCls}-checked`]: {
        [radioInnerPrefixCls]: {
          borderColor: radioCheckedColor,
          backgroundColor: wireframe ? radioButtonBg : radioCheckedColor,
          "&::after": {
            transform: `scale(${radioDotSize / radioSize})`,
            opacity: 1,
            transition: `all ${motionDurationSlow} ${motionEaseInOutCirc}`
          }
        }
      },
      [`${componentCls}-disabled`]: {
        cursor: "not-allowed",
        [radioInnerPrefixCls]: {
          backgroundColor: colorBgContainerDisabled,
          borderColor: colorBorder,
          cursor: "not-allowed",
          "&::after": {
            backgroundColor: radioDotDisabledColor
          }
        },
        [`${componentCls}-input`]: {
          cursor: "not-allowed"
        },
        [`${componentCls}-disabled + span`]: {
          color: colorTextDisabled,
          cursor: "not-allowed"
        },
        [`&${componentCls}-checked`]: {
          [radioInnerPrefixCls]: {
            "&::after": {
              transform: `scale(${radioDotDisabledSize / radioSize})`
            }
          }
        }
      },
      [`span${componentCls} + *`]: {
        paddingInlineStart: paddingXS,
        paddingInlineEnd: paddingXS
      }
    })
  };
};
const getRadioButtonStyle = (token2) => {
  const {
    radioButtonColor,
    controlHeight,
    componentCls,
    lineWidth,
    lineType,
    colorBorder,
    motionDurationSlow,
    motionDurationMid,
    radioButtonPaddingHorizontal,
    fontSize,
    radioButtonBg,
    fontSizeLG,
    controlHeightLG,
    controlHeightSM,
    paddingXS,
    borderRadius,
    borderRadiusSM,
    borderRadiusLG,
    radioCheckedColor,
    radioButtonCheckedBg,
    radioButtonHoverColor,
    radioButtonActiveColor,
    radioSolidCheckedColor,
    colorTextDisabled,
    colorBgContainerDisabled,
    radioDisabledButtonCheckedColor,
    radioDisabledButtonCheckedBg
  } = token2;
  return {
    [`${componentCls}-button-wrapper`]: {
      position: "relative",
      display: "inline-block",
      height: controlHeight,
      margin: 0,
      paddingInline: radioButtonPaddingHorizontal,
      paddingBlock: 0,
      color: radioButtonColor,
      fontSize,
      lineHeight: `${controlHeight - lineWidth * 2}px`,
      background: radioButtonBg,
      border: `${lineWidth}px ${lineType} ${colorBorder}`,
      // strange align fix for chrome but works
      // https://gw.alipayobjects.com/zos/rmsportal/VFTfKXJuogBAXcvfAUWJ.gif
      borderBlockStartWidth: lineWidth + 0.02,
      borderInlineStartWidth: 0,
      borderInlineEndWidth: lineWidth,
      cursor: "pointer",
      transition: [`color ${motionDurationMid}`, `background ${motionDurationMid}`, `border-color ${motionDurationMid}`, `box-shadow ${motionDurationMid}`].join(","),
      a: {
        color: radioButtonColor
      },
      [`> ${componentCls}-button`]: {
        position: "absolute",
        insetBlockStart: 0,
        insetInlineStart: 0,
        zIndex: -1,
        width: "100%",
        height: "100%"
      },
      "&:not(:first-child)": {
        "&::before": {
          position: "absolute",
          insetBlockStart: -lineWidth,
          insetInlineStart: -lineWidth,
          display: "block",
          boxSizing: "content-box",
          width: 1,
          height: "100%",
          paddingBlock: lineWidth,
          paddingInline: 0,
          backgroundColor: colorBorder,
          transition: `background-color ${motionDurationSlow}`,
          content: '""'
        }
      },
      "&:first-child": {
        borderInlineStart: `${lineWidth}px ${lineType} ${colorBorder}`,
        borderStartStartRadius: borderRadius,
        borderEndStartRadius: borderRadius
      },
      "&:last-child": {
        borderStartEndRadius: borderRadius,
        borderEndEndRadius: borderRadius
      },
      "&:first-child:last-child": {
        borderRadius
      },
      [`${componentCls}-group-large &`]: {
        height: controlHeightLG,
        fontSize: fontSizeLG,
        lineHeight: `${controlHeightLG - lineWidth * 2}px`,
        "&:first-child": {
          borderStartStartRadius: borderRadiusLG,
          borderEndStartRadius: borderRadiusLG
        },
        "&:last-child": {
          borderStartEndRadius: borderRadiusLG,
          borderEndEndRadius: borderRadiusLG
        }
      },
      [`${componentCls}-group-small &`]: {
        height: controlHeightSM,
        paddingInline: paddingXS - lineWidth,
        paddingBlock: 0,
        lineHeight: `${controlHeightSM - lineWidth * 2}px`,
        "&:first-child": {
          borderStartStartRadius: borderRadiusSM,
          borderEndStartRadius: borderRadiusSM
        },
        "&:last-child": {
          borderStartEndRadius: borderRadiusSM,
          borderEndEndRadius: borderRadiusSM
        }
      },
      "&:hover": {
        position: "relative",
        color: radioCheckedColor
      },
      "&:has(:focus-visible)": _extends$1({}, genFocusOutline(token2)),
      [`${componentCls}-inner, input[type='checkbox'], input[type='radio']`]: {
        width: 0,
        height: 0,
        opacity: 0,
        pointerEvents: "none"
      },
      [`&-checked:not(${componentCls}-button-wrapper-disabled)`]: {
        zIndex: 1,
        color: radioCheckedColor,
        background: radioButtonCheckedBg,
        borderColor: radioCheckedColor,
        "&::before": {
          backgroundColor: radioCheckedColor
        },
        "&:first-child": {
          borderColor: radioCheckedColor
        },
        "&:hover": {
          color: radioButtonHoverColor,
          borderColor: radioButtonHoverColor,
          "&::before": {
            backgroundColor: radioButtonHoverColor
          }
        },
        "&:active": {
          color: radioButtonActiveColor,
          borderColor: radioButtonActiveColor,
          "&::before": {
            backgroundColor: radioButtonActiveColor
          }
        }
      },
      [`${componentCls}-group-solid &-checked:not(${componentCls}-button-wrapper-disabled)`]: {
        color: radioSolidCheckedColor,
        background: radioCheckedColor,
        borderColor: radioCheckedColor,
        "&:hover": {
          color: radioSolidCheckedColor,
          background: radioButtonHoverColor,
          borderColor: radioButtonHoverColor
        },
        "&:active": {
          color: radioSolidCheckedColor,
          background: radioButtonActiveColor,
          borderColor: radioButtonActiveColor
        }
      },
      "&-disabled": {
        color: colorTextDisabled,
        backgroundColor: colorBgContainerDisabled,
        borderColor: colorBorder,
        cursor: "not-allowed",
        "&:first-child, &:hover": {
          color: colorTextDisabled,
          backgroundColor: colorBgContainerDisabled,
          borderColor: colorBorder
        }
      },
      [`&-disabled${componentCls}-button-wrapper-checked`]: {
        color: radioDisabledButtonCheckedColor,
        backgroundColor: radioDisabledButtonCheckedBg,
        borderColor: colorBorder,
        boxShadow: "none"
      }
    }
  };
};
const useStyle$x = genComponentStyleHook("Radio", (token2) => {
  const {
    padding,
    lineWidth,
    controlItemBgActiveDisabled,
    colorTextDisabled,
    colorBgContainer,
    fontSizeLG,
    controlOutline,
    colorPrimaryHover,
    colorPrimaryActive,
    colorText,
    colorPrimary,
    marginXS,
    controlOutlineWidth,
    colorTextLightSolid,
    wireframe
  } = token2;
  const radioFocusShadow = `0 0 0 ${controlOutlineWidth}px ${controlOutline}`;
  const radioButtonFocusShadow = radioFocusShadow;
  const radioSize = fontSizeLG;
  const dotPadding = 4;
  const radioDotDisabledSize = radioSize - dotPadding * 2;
  const radioDotSize = wireframe ? radioDotDisabledSize : radioSize - (dotPadding + lineWidth) * 2;
  const radioCheckedColor = colorPrimary;
  const radioButtonColor = colorText;
  const radioButtonHoverColor = colorPrimaryHover;
  const radioButtonActiveColor = colorPrimaryActive;
  const radioButtonPaddingHorizontal = padding - lineWidth;
  const radioDisabledButtonCheckedColor = colorTextDisabled;
  const radioWrapperMarginRight = marginXS;
  const radioToken = merge(token2, {
    radioFocusShadow,
    radioButtonFocusShadow,
    radioSize,
    radioDotSize,
    radioDotDisabledSize,
    radioCheckedColor,
    radioDotDisabledColor: colorTextDisabled,
    radioSolidCheckedColor: colorTextLightSolid,
    radioButtonBg: colorBgContainer,
    radioButtonCheckedBg: colorBgContainer,
    radioButtonColor,
    radioButtonHoverColor,
    radioButtonActiveColor,
    radioButtonPaddingHorizontal,
    radioDisabledButtonCheckedBg: controlItemBgActiveDisabled,
    radioDisabledButtonCheckedColor,
    radioWrapperMarginRight
  });
  return [getGroupRadioStyle(radioToken), getRadioBasicStyle(radioToken), getRadioButtonStyle(radioToken)];
});
var __rest$O = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const radioProps = () => ({
  prefixCls: String,
  checked: booleanType(),
  disabled: booleanType(),
  isGroup: booleanType(),
  value: PropTypes.any,
  name: String,
  id: String,
  autofocus: booleanType(),
  onChange: functionType(),
  onFocus: functionType(),
  onBlur: functionType(),
  onClick: functionType(),
  "onUpdate:checked": functionType(),
  "onUpdate:value": functionType()
});
const Radio = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ARadio",
  inheritAttrs: false,
  props: radioProps(),
  setup(props2, _ref) {
    let {
      emit,
      expose,
      slots,
      attrs
    } = _ref;
    const formItemContext = useInjectFormItemContext();
    const formItemInputContext = FormItemInputContext.useInject();
    const radioOptionTypeContext = useInjectRadioOptionTypeContext();
    const radioGroupContext = useInjectRadioGroupContext();
    const disabledContext = useInjectDisabled();
    const mergedDisabled = computed(() => {
      var _a2;
      return (_a2 = disabled.value) !== null && _a2 !== void 0 ? _a2 : disabledContext.value;
    });
    const vcCheckbox = ref();
    const {
      prefixCls: radioPrefixCls,
      direction,
      disabled
    } = useConfigInject("radio", props2);
    const prefixCls = computed(() => (radioGroupContext === null || radioGroupContext === void 0 ? void 0 : radioGroupContext.optionType.value) === "button" || radioOptionTypeContext === "button" ? `${radioPrefixCls.value}-button` : radioPrefixCls.value);
    const contextDisabled = useInjectDisabled();
    const [wrapSSR, hashId] = useStyle$x(radioPrefixCls);
    const focus = () => {
      vcCheckbox.value.focus();
    };
    const blur = () => {
      vcCheckbox.value.blur();
    };
    expose({
      focus,
      blur
    });
    const handleChange = (event) => {
      const targetChecked = event.target.checked;
      emit("update:checked", targetChecked);
      emit("update:value", targetChecked);
      emit("change", event);
      formItemContext.onFieldChange();
    };
    const onChange = (e2) => {
      emit("change", e2);
      if (radioGroupContext && radioGroupContext.onChange) {
        radioGroupContext.onChange(e2);
      }
    };
    return () => {
      var _a2;
      const radioGroup = radioGroupContext;
      const {
        prefixCls: customizePrefixCls,
        id = formItemContext.id.value
      } = props2, restProps = __rest$O(props2, ["prefixCls", "id"]);
      const rProps = _extends$1(_extends$1({
        prefixCls: prefixCls.value,
        id
      }, omit$1(restProps, ["onUpdate:checked", "onUpdate:value"])), {
        disabled: (_a2 = disabled.value) !== null && _a2 !== void 0 ? _a2 : contextDisabled.value
      });
      if (radioGroup) {
        rProps.name = radioGroup.name.value;
        rProps.onChange = onChange;
        rProps.checked = props2.value === radioGroup.value.value;
        rProps.disabled = mergedDisabled.value || radioGroup.disabled.value;
      } else {
        rProps.onChange = handleChange;
      }
      const wrapperClassString = classNames({
        [`${prefixCls.value}-wrapper`]: true,
        [`${prefixCls.value}-wrapper-checked`]: rProps.checked,
        [`${prefixCls.value}-wrapper-disabled`]: rProps.disabled,
        [`${prefixCls.value}-wrapper-rtl`]: direction.value === "rtl",
        [`${prefixCls.value}-wrapper-in-form-item`]: formItemInputContext.isFormItemInput
      }, attrs.class, hashId.value);
      return wrapSSR(createVNode("label", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "class": wrapperClassString
      }), [createVNode(VcCheckbox, _objectSpread2$1(_objectSpread2$1({}, rProps), {}, {
        "type": "radio",
        "ref": vcCheckbox
      }), null), slots.default && createVNode("span", null, [slots.default()])]));
    };
  }
});
const radioGroupProps = () => ({
  prefixCls: String,
  value: PropTypes.any,
  size: stringType(),
  options: arrayType(),
  disabled: booleanType(),
  name: String,
  buttonStyle: stringType("outline"),
  id: String,
  optionType: stringType("default"),
  onChange: functionType(),
  "onUpdate:value": functionType()
});
const Group$2 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ARadioGroup",
  inheritAttrs: false,
  props: radioGroupProps(),
  // emits: ['update:value', 'change'],
  setup(props2, _ref) {
    let {
      slots,
      emit,
      attrs
    } = _ref;
    const formItemContext = useInjectFormItemContext();
    const {
      prefixCls,
      direction,
      size
    } = useConfigInject("radio", props2);
    const [wrapSSR, hashId] = useStyle$x(prefixCls);
    const stateValue = ref(props2.value);
    const updatingValue = ref(false);
    watch(() => props2.value, (val) => {
      stateValue.value = val;
      updatingValue.value = false;
    });
    const onRadioChange = (ev) => {
      const lastValue = stateValue.value;
      const {
        value
      } = ev.target;
      if (!("value" in props2)) {
        stateValue.value = value;
      }
      if (!updatingValue.value && value !== lastValue) {
        updatingValue.value = true;
        emit("update:value", value);
        emit("change", ev);
        formItemContext.onFieldChange();
      }
      nextTick(() => {
        updatingValue.value = false;
      });
    };
    useProvideRadioGroupContext({
      onChange: onRadioChange,
      value: stateValue,
      disabled: computed(() => props2.disabled),
      name: computed(() => props2.name),
      optionType: computed(() => props2.optionType)
    });
    return () => {
      var _a2;
      const {
        options,
        buttonStyle,
        id = formItemContext.id.value
      } = props2;
      const groupPrefixCls = `${prefixCls.value}-group`;
      const classString = classNames(groupPrefixCls, `${groupPrefixCls}-${buttonStyle}`, {
        [`${groupPrefixCls}-${size.value}`]: size.value,
        [`${groupPrefixCls}-rtl`]: direction.value === "rtl"
      }, attrs.class, hashId.value);
      let children = null;
      if (options && options.length > 0) {
        children = options.map((option) => {
          if (typeof option === "string" || typeof option === "number") {
            return createVNode(Radio, {
              "key": option,
              "prefixCls": prefixCls.value,
              "disabled": props2.disabled,
              "value": option,
              "checked": stateValue.value === option
            }, {
              default: () => [option]
            });
          }
          const {
            value,
            disabled,
            label
          } = option;
          return createVNode(Radio, {
            "key": `radio-group-value-options-${value}`,
            "prefixCls": prefixCls.value,
            "disabled": disabled || props2.disabled,
            "value": value,
            "checked": stateValue.value === value
          }, {
            default: () => [label]
          });
        });
      } else {
        children = (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
      }
      return wrapSSR(createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "class": classString,
        "id": id
      }), [children]));
    };
  }
});
const Button = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ARadioButton",
  inheritAttrs: false,
  props: radioProps(),
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const {
      prefixCls
    } = useConfigInject("radio", props2);
    useProvideRadioOptionTypeContext("button");
    return () => {
      var _a2;
      return createVNode(Radio, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, attrs), props2), {}, {
        "prefixCls": prefixCls.value
      }), {
        default: () => [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]
      });
    };
  }
});
Radio.Group = Group$2;
Radio.Button = Button;
Radio.install = function(app) {
  app.component(Radio.name, Radio);
  app.component(Radio.Group.name, Radio.Group);
  app.component(Radio.Button.name, Radio.Button);
  return app;
};
const YearSelectOffset = 10;
const YearSelectTotal = 20;
function YearSelect(props2) {
  const {
    fullscreen,
    validRange,
    generateConfig: generateConfig2,
    locale: locale2,
    prefixCls,
    value,
    onChange,
    divRef
  } = props2;
  const year = generateConfig2.getYear(value || generateConfig2.getNow());
  let start = year - YearSelectOffset;
  let end = start + YearSelectTotal;
  if (validRange) {
    start = generateConfig2.getYear(validRange[0]);
    end = generateConfig2.getYear(validRange[1]) + 1;
  }
  const suffix = locale2 && locale2.year === "年" ? "年" : "";
  const options = [];
  for (let index2 = start; index2 < end; index2++) {
    options.push({
      label: `${index2}${suffix}`,
      value: index2
    });
  }
  return createVNode(Select, {
    "size": fullscreen ? void 0 : "small",
    "options": options,
    "value": year,
    "class": `${prefixCls}-year-select`,
    "onChange": (numYear) => {
      let newDate = generateConfig2.setYear(value, numYear);
      if (validRange) {
        const [startDate, endDate] = validRange;
        const newYear = generateConfig2.getYear(newDate);
        const newMonth = generateConfig2.getMonth(newDate);
        if (newYear === generateConfig2.getYear(endDate) && newMonth > generateConfig2.getMonth(endDate)) {
          newDate = generateConfig2.setMonth(newDate, generateConfig2.getMonth(endDate));
        }
        if (newYear === generateConfig2.getYear(startDate) && newMonth < generateConfig2.getMonth(startDate)) {
          newDate = generateConfig2.setMonth(newDate, generateConfig2.getMonth(startDate));
        }
      }
      onChange(newDate);
    },
    "getPopupContainer": () => divRef.value
  }, null);
}
YearSelect.inheritAttrs = false;
function MonthSelect(props2) {
  const {
    prefixCls,
    fullscreen,
    validRange,
    value,
    generateConfig: generateConfig2,
    locale: locale2,
    onChange,
    divRef
  } = props2;
  const month = generateConfig2.getMonth(value || generateConfig2.getNow());
  let start = 0;
  let end = 11;
  if (validRange) {
    const [rangeStart, rangeEnd] = validRange;
    const currentYear = generateConfig2.getYear(value);
    if (generateConfig2.getYear(rangeEnd) === currentYear) {
      end = generateConfig2.getMonth(rangeEnd);
    }
    if (generateConfig2.getYear(rangeStart) === currentYear) {
      start = generateConfig2.getMonth(rangeStart);
    }
  }
  const months = locale2.shortMonths || generateConfig2.locale.getShortMonths(locale2.locale);
  const options = [];
  for (let index2 = start; index2 <= end; index2 += 1) {
    options.push({
      label: months[index2],
      value: index2
    });
  }
  return createVNode(Select, {
    "size": fullscreen ? void 0 : "small",
    "class": `${prefixCls}-month-select`,
    "value": month,
    "options": options,
    "onChange": (newMonth) => {
      onChange(generateConfig2.setMonth(value, newMonth));
    },
    "getPopupContainer": () => divRef.value
  }, null);
}
MonthSelect.inheritAttrs = false;
function ModeSwitch(props2) {
  const {
    prefixCls,
    locale: locale2,
    mode,
    fullscreen,
    onModeChange
  } = props2;
  return createVNode(Group$2, {
    "onChange": (_ref) => {
      let {
        target: {
          value
        }
      } = _ref;
      onModeChange(value);
    },
    "value": mode,
    "size": fullscreen ? void 0 : "small",
    "class": `${prefixCls}-mode-switch`
  }, {
    default: () => [createVNode(Button, {
      "value": "month"
    }, {
      default: () => [locale2.month]
    }), createVNode(Button, {
      "value": "year"
    }, {
      default: () => [locale2.year]
    })]
  });
}
ModeSwitch.inheritAttrs = false;
const CalendarHeader = defineComponent({
  name: "CalendarHeader",
  inheritAttrs: false,
  props: ["mode", "prefixCls", "value", "validRange", "generateConfig", "locale", "mode", "fullscreen"],
  setup(_props, _ref2) {
    let {
      attrs
    } = _ref2;
    const divRef = ref(null);
    const formItemInputContext = FormItemInputContext.useInject();
    FormItemInputContext.useProvide(formItemInputContext, {
      isFormItemInput: false
    });
    return () => {
      const props2 = _extends$1(_extends$1({}, _props), attrs);
      const {
        prefixCls,
        fullscreen,
        mode,
        onChange,
        onModeChange
      } = props2;
      const sharedProps = _extends$1(_extends$1({}, props2), {
        fullscreen,
        divRef
      });
      return createVNode("div", {
        "class": `${prefixCls}-header`,
        "ref": divRef
      }, [createVNode(YearSelect, _objectSpread2$1(_objectSpread2$1({}, sharedProps), {}, {
        "onChange": (v2) => {
          onChange(v2, "year");
        }
      }), null), mode === "month" && createVNode(MonthSelect, _objectSpread2$1(_objectSpread2$1({}, sharedProps), {}, {
        "onChange": (v2) => {
          onChange(v2, "month");
        }
      }), null), createVNode(ModeSwitch, _objectSpread2$1(_objectSpread2$1({}, sharedProps), {}, {
        "onModeChange": onModeChange
      }), null)]);
    };
  }
});
const genPlaceholderStyle = (color) => ({
  // Firefox
  "&::-moz-placeholder": {
    opacity: 1
  },
  "&::placeholder": {
    color,
    userSelect: "none"
    // https://github.com/ant-design/ant-design/pull/32639
  },
  "&:placeholder-shown": {
    textOverflow: "ellipsis"
  }
});
const genHoverStyle = (token2) => ({
  borderColor: token2.inputBorderHoverColor,
  borderInlineEndWidth: token2.lineWidth
});
const genActiveStyle = (token2) => ({
  borderColor: token2.inputBorderHoverColor,
  boxShadow: `0 0 0 ${token2.controlOutlineWidth}px ${token2.controlOutline}`,
  borderInlineEndWidth: token2.lineWidth,
  outline: 0
});
const genDisabledStyle = (token2) => ({
  color: token2.colorTextDisabled,
  backgroundColor: token2.colorBgContainerDisabled,
  borderColor: token2.colorBorder,
  boxShadow: "none",
  cursor: "not-allowed",
  opacity: 1,
  "&:hover": _extends$1({}, genHoverStyle(merge(token2, {
    inputBorderHoverColor: token2.colorBorder
  })))
});
const genInputLargeStyle = (token2) => {
  const {
    inputPaddingVerticalLG,
    fontSizeLG,
    lineHeightLG,
    borderRadiusLG,
    inputPaddingHorizontalLG
  } = token2;
  return {
    padding: `${inputPaddingVerticalLG}px ${inputPaddingHorizontalLG}px`,
    fontSize: fontSizeLG,
    lineHeight: lineHeightLG,
    borderRadius: borderRadiusLG
  };
};
const genInputSmallStyle = (token2) => ({
  padding: `${token2.inputPaddingVerticalSM}px ${token2.controlPaddingHorizontalSM - 1}px`,
  borderRadius: token2.borderRadiusSM
});
const genStatusStyle = (token2, parentCls) => {
  const {
    componentCls,
    colorError,
    colorWarning,
    colorErrorOutline,
    colorWarningOutline,
    colorErrorBorderHover,
    colorWarningBorderHover
  } = token2;
  return {
    [`&-status-error:not(${parentCls}-disabled):not(${parentCls}-borderless)${parentCls}`]: {
      borderColor: colorError,
      "&:hover": {
        borderColor: colorErrorBorderHover
      },
      "&:focus, &-focused": _extends$1({}, genActiveStyle(merge(token2, {
        inputBorderActiveColor: colorError,
        inputBorderHoverColor: colorError,
        controlOutline: colorErrorOutline
      }))),
      [`${componentCls}-prefix`]: {
        color: colorError
      }
    },
    [`&-status-warning:not(${parentCls}-disabled):not(${parentCls}-borderless)${parentCls}`]: {
      borderColor: colorWarning,
      "&:hover": {
        borderColor: colorWarningBorderHover
      },
      "&:focus, &-focused": _extends$1({}, genActiveStyle(merge(token2, {
        inputBorderActiveColor: colorWarning,
        inputBorderHoverColor: colorWarning,
        controlOutline: colorWarningOutline
      }))),
      [`${componentCls}-prefix`]: {
        color: colorWarning
      }
    }
  };
};
const genBasicInputStyle = (token2) => _extends$1(_extends$1({
  position: "relative",
  display: "inline-block",
  width: "100%",
  minWidth: 0,
  padding: `${token2.inputPaddingVertical}px ${token2.inputPaddingHorizontal}px`,
  color: token2.colorText,
  fontSize: token2.fontSize,
  lineHeight: token2.lineHeight,
  backgroundColor: token2.colorBgContainer,
  backgroundImage: "none",
  borderWidth: token2.lineWidth,
  borderStyle: token2.lineType,
  borderColor: token2.colorBorder,
  borderRadius: token2.borderRadius,
  transition: `all ${token2.motionDurationMid}`
}, genPlaceholderStyle(token2.colorTextPlaceholder)), {
  "&:hover": _extends$1({}, genHoverStyle(token2)),
  "&:focus, &-focused": _extends$1({}, genActiveStyle(token2)),
  "&-disabled, &[disabled]": _extends$1({}, genDisabledStyle(token2)),
  "&-borderless": {
    "&, &:hover, &:focus, &-focused, &-disabled, &[disabled]": {
      backgroundColor: "transparent",
      border: "none",
      boxShadow: "none"
    }
  },
  // Reset height for `textarea`s
  "textarea&": {
    maxWidth: "100%",
    height: "auto",
    minHeight: token2.controlHeight,
    lineHeight: token2.lineHeight,
    verticalAlign: "bottom",
    transition: `all ${token2.motionDurationSlow}, height 0s`,
    resize: "vertical"
  },
  // Size
  "&-lg": _extends$1({}, genInputLargeStyle(token2)),
  "&-sm": _extends$1({}, genInputSmallStyle(token2)),
  // RTL
  "&-rtl": {
    direction: "rtl"
  },
  "&-textarea-rtl": {
    direction: "rtl"
  }
});
const genInputGroupStyle = (token2) => {
  const {
    componentCls,
    antCls
  } = token2;
  return {
    position: "relative",
    display: "table",
    width: "100%",
    borderCollapse: "separate",
    borderSpacing: 0,
    // Undo padding and float of grid classes
    [`&[class*='col-']`]: {
      paddingInlineEnd: token2.paddingXS,
      "&:last-child": {
        paddingInlineEnd: 0
      }
    },
    // Sizing options
    [`&-lg ${componentCls}, &-lg > ${componentCls}-group-addon`]: _extends$1({}, genInputLargeStyle(token2)),
    [`&-sm ${componentCls}, &-sm > ${componentCls}-group-addon`]: _extends$1({}, genInputSmallStyle(token2)),
    [`> ${componentCls}`]: {
      display: "table-cell",
      "&:not(:first-child):not(:last-child)": {
        borderRadius: 0
      }
    },
    [`${componentCls}-group`]: {
      [`&-addon, &-wrap`]: {
        display: "table-cell",
        width: 1,
        whiteSpace: "nowrap",
        verticalAlign: "middle",
        "&:not(:first-child):not(:last-child)": {
          borderRadius: 0
        }
      },
      "&-wrap > *": {
        display: "block !important"
      },
      "&-addon": {
        position: "relative",
        padding: `0 ${token2.inputPaddingHorizontal}px`,
        color: token2.colorText,
        fontWeight: "normal",
        fontSize: token2.fontSize,
        textAlign: "center",
        backgroundColor: token2.colorFillAlter,
        border: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`,
        borderRadius: token2.borderRadius,
        transition: `all ${token2.motionDurationSlow}`,
        lineHeight: 1,
        // Reset Select's style in addon
        [`${antCls}-select`]: {
          margin: `-${token2.inputPaddingVertical + 1}px -${token2.inputPaddingHorizontal}px`,
          [`&${antCls}-select-single:not(${antCls}-select-customize-input)`]: {
            [`${antCls}-select-selector`]: {
              backgroundColor: "inherit",
              border: `${token2.lineWidth}px ${token2.lineType} transparent`,
              boxShadow: "none"
            }
          },
          "&-open, &-focused": {
            [`${antCls}-select-selector`]: {
              color: token2.colorPrimary
            }
          }
        },
        // https://github.com/ant-design/ant-design/issues/31333
        [`${antCls}-cascader-picker`]: {
          margin: `-9px -${token2.inputPaddingHorizontal}px`,
          backgroundColor: "transparent",
          [`${antCls}-cascader-input`]: {
            textAlign: "start",
            border: 0,
            boxShadow: "none"
          }
        }
      },
      "&-addon:first-child": {
        borderInlineEnd: 0
      },
      "&-addon:last-child": {
        borderInlineStart: 0
      }
    },
    [`${componentCls}`]: {
      float: "inline-start",
      width: "100%",
      marginBottom: 0,
      textAlign: "inherit",
      "&:focus": {
        zIndex: 1,
        borderInlineEndWidth: 1
      },
      "&:hover": {
        zIndex: 1,
        borderInlineEndWidth: 1,
        [`${componentCls}-search-with-button &`]: {
          zIndex: 0
        }
      }
    },
    // Reset rounded corners
    [`> ${componentCls}:first-child, ${componentCls}-group-addon:first-child`]: {
      borderStartEndRadius: 0,
      borderEndEndRadius: 0,
      // Reset Select's style in addon
      [`${antCls}-select ${antCls}-select-selector`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`> ${componentCls}-affix-wrapper`]: {
      [`&:not(:first-child) ${componentCls}`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      },
      [`&:not(:last-child) ${componentCls}`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`> ${componentCls}:last-child, ${componentCls}-group-addon:last-child`]: {
      borderStartStartRadius: 0,
      borderEndStartRadius: 0,
      // Reset Select's style in addon
      [`${antCls}-select ${antCls}-select-selector`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`${componentCls}-affix-wrapper`]: {
      "&:not(:last-child)": {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0,
        [`${componentCls}-search &`]: {
          borderStartStartRadius: token2.borderRadius,
          borderEndStartRadius: token2.borderRadius
        }
      },
      [`&:not(:first-child), ${componentCls}-search &:not(:first-child)`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`&${componentCls}-group-compact`]: _extends$1(_extends$1({
      display: "block"
    }, clearFix()), {
      [`${componentCls}-group-addon, ${componentCls}-group-wrap, > ${componentCls}`]: {
        "&:not(:first-child):not(:last-child)": {
          borderInlineEndWidth: token2.lineWidth,
          "&:hover": {
            zIndex: 1
          },
          "&:focus": {
            zIndex: 1
          }
        }
      },
      "& > *": {
        display: "inline-block",
        float: "none",
        verticalAlign: "top",
        borderRadius: 0
      },
      [`& > ${componentCls}-affix-wrapper`]: {
        display: "inline-flex"
      },
      [`& > ${antCls}-picker-range`]: {
        display: "inline-flex"
      },
      "& > *:not(:last-child)": {
        marginInlineEnd: -token2.lineWidth,
        borderInlineEndWidth: token2.lineWidth
      },
      // Undo float for .ant-input-group .ant-input
      [`${componentCls}`]: {
        float: "none"
      },
      // reset border for Select, DatePicker, AutoComplete, Cascader, Mention, TimePicker, Input
      [`& > ${antCls}-select > ${antCls}-select-selector,
      & > ${antCls}-select-auto-complete ${componentCls},
      & > ${antCls}-cascader-picker ${componentCls},
      & > ${componentCls}-group-wrapper ${componentCls}`]: {
        borderInlineEndWidth: token2.lineWidth,
        borderRadius: 0,
        "&:hover": {
          zIndex: 1
        },
        "&:focus": {
          zIndex: 1
        }
      },
      [`& > ${antCls}-select-focused`]: {
        zIndex: 1
      },
      // update z-index for arrow icon
      [`& > ${antCls}-select > ${antCls}-select-arrow`]: {
        zIndex: 1
        // https://github.com/ant-design/ant-design/issues/20371
      },
      [`& > *:first-child,
      & > ${antCls}-select:first-child > ${antCls}-select-selector,
      & > ${antCls}-select-auto-complete:first-child ${componentCls},
      & > ${antCls}-cascader-picker:first-child ${componentCls}`]: {
        borderStartStartRadius: token2.borderRadius,
        borderEndStartRadius: token2.borderRadius
      },
      [`& > *:last-child,
      & > ${antCls}-select:last-child > ${antCls}-select-selector,
      & > ${antCls}-cascader-picker:last-child ${componentCls},
      & > ${antCls}-cascader-picker-focused:last-child ${componentCls}`]: {
        borderInlineEndWidth: token2.lineWidth,
        borderStartEndRadius: token2.borderRadius,
        borderEndEndRadius: token2.borderRadius
      },
      // https://github.com/ant-design/ant-design/issues/12493
      [`& > ${antCls}-select-auto-complete ${componentCls}`]: {
        verticalAlign: "top"
      },
      [`${componentCls}-group-wrapper + ${componentCls}-group-wrapper`]: {
        marginInlineStart: -token2.lineWidth,
        [`${componentCls}-affix-wrapper`]: {
          borderRadius: 0
        }
      },
      [`${componentCls}-group-wrapper:not(:last-child)`]: {
        [`&${componentCls}-search > ${componentCls}-group`]: {
          [`& > ${componentCls}-group-addon > ${componentCls}-search-button`]: {
            borderRadius: 0
          },
          [`& > ${componentCls}`]: {
            borderStartStartRadius: token2.borderRadius,
            borderStartEndRadius: 0,
            borderEndEndRadius: 0,
            borderEndStartRadius: token2.borderRadius
          }
        }
      }
    }),
    [`&&-sm ${antCls}-btn`]: {
      fontSize: token2.fontSizeSM,
      height: token2.controlHeightSM,
      lineHeight: "normal"
    },
    [`&&-lg ${antCls}-btn`]: {
      fontSize: token2.fontSizeLG,
      height: token2.controlHeightLG,
      lineHeight: "normal"
    },
    // Fix https://github.com/ant-design/ant-design/issues/5754
    [`&&-lg ${antCls}-select-single ${antCls}-select-selector`]: {
      height: `${token2.controlHeightLG}px`,
      [`${antCls}-select-selection-item, ${antCls}-select-selection-placeholder`]: {
        // -2 is for the border size & override default
        lineHeight: `${token2.controlHeightLG - 2}px`
      },
      [`${antCls}-select-selection-search-input`]: {
        height: `${token2.controlHeightLG}px`
      }
    },
    [`&&-sm ${antCls}-select-single ${antCls}-select-selector`]: {
      height: `${token2.controlHeightSM}px`,
      [`${antCls}-select-selection-item, ${antCls}-select-selection-placeholder`]: {
        // -2 is for the border size & override default
        lineHeight: `${token2.controlHeightSM - 2}px`
      },
      [`${antCls}-select-selection-search-input`]: {
        height: `${token2.controlHeightSM}px`
      }
    }
  };
};
const genInputStyle = (token2) => {
  const {
    componentCls,
    controlHeightSM,
    lineWidth
  } = token2;
  const FIXED_CHROME_COLOR_HEIGHT = 16;
  const colorSmallPadding = (controlHeightSM - lineWidth * 2 - FIXED_CHROME_COLOR_HEIGHT) / 2;
  return {
    [componentCls]: _extends$1(_extends$1(_extends$1(_extends$1({}, resetComponent(token2)), genBasicInputStyle(token2)), genStatusStyle(token2, componentCls)), {
      '&[type="color"]': {
        height: token2.controlHeight,
        [`&${componentCls}-lg`]: {
          height: token2.controlHeightLG
        },
        [`&${componentCls}-sm`]: {
          height: controlHeightSM,
          paddingTop: colorSmallPadding,
          paddingBottom: colorSmallPadding
        }
      }
    })
  };
};
const genAllowClearStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    // ========================= Input =========================
    [`${componentCls}-clear-icon`]: {
      margin: 0,
      color: token2.colorTextQuaternary,
      fontSize: token2.fontSizeIcon,
      verticalAlign: -1,
      // https://github.com/ant-design/ant-design/pull/18151
      // https://codesandbox.io/s/wizardly-sun-u10br
      cursor: "pointer",
      transition: `color ${token2.motionDurationSlow}`,
      "&:hover": {
        color: token2.colorTextTertiary
      },
      "&:active": {
        color: token2.colorText
      },
      "&-hidden": {
        visibility: "hidden"
      },
      "&-has-suffix": {
        margin: `0 ${token2.inputAffixPadding}px`
      }
    },
    // ======================= TextArea ========================
    "&-textarea-with-clear-btn": {
      padding: "0 !important",
      border: "0 !important",
      [`${componentCls}-clear-icon`]: {
        position: "absolute",
        insetBlockStart: token2.paddingXS,
        insetInlineEnd: token2.paddingXS,
        zIndex: 1
      }
    }
  };
};
const genAffixStyle = (token2) => {
  const {
    componentCls,
    inputAffixPadding,
    colorTextDescription,
    motionDurationSlow,
    colorIcon,
    colorIconHover,
    iconCls
  } = token2;
  return {
    [`${componentCls}-affix-wrapper`]: _extends$1(_extends$1(_extends$1(_extends$1(_extends$1({}, genBasicInputStyle(token2)), {
      display: "inline-flex",
      [`&:not(${componentCls}-affix-wrapper-disabled):hover`]: _extends$1(_extends$1({}, genHoverStyle(token2)), {
        zIndex: 1,
        [`${componentCls}-search-with-button &`]: {
          zIndex: 0
        }
      }),
      "&-focused, &:focus": {
        zIndex: 1
      },
      "&-disabled": {
        [`${componentCls}[disabled]`]: {
          background: "transparent"
        }
      },
      [`> input${componentCls}`]: {
        padding: 0,
        fontSize: "inherit",
        border: "none",
        borderRadius: 0,
        outline: "none",
        "&:focus": {
          boxShadow: "none !important"
        }
      },
      "&::before": {
        width: 0,
        visibility: "hidden",
        content: '"\\a0"'
      },
      [`${componentCls}`]: {
        "&-prefix, &-suffix": {
          display: "flex",
          flex: "none",
          alignItems: "center",
          "> *:not(:last-child)": {
            marginInlineEnd: token2.paddingXS
          }
        },
        "&-show-count-suffix": {
          color: colorTextDescription
        },
        "&-show-count-has-suffix": {
          marginInlineEnd: token2.paddingXXS
        },
        "&-prefix": {
          marginInlineEnd: inputAffixPadding
        },
        "&-suffix": {
          marginInlineStart: inputAffixPadding
        }
      }
    }), genAllowClearStyle(token2)), {
      // password
      [`${iconCls}${componentCls}-password-icon`]: {
        color: colorIcon,
        cursor: "pointer",
        transition: `all ${motionDurationSlow}`,
        "&:hover": {
          color: colorIconHover
        }
      }
    }), genStatusStyle(token2, `${componentCls}-affix-wrapper`))
  };
};
const genGroupStyle = (token2) => {
  const {
    componentCls,
    colorError,
    colorSuccess,
    borderRadiusLG,
    borderRadiusSM
  } = token2;
  return {
    [`${componentCls}-group`]: _extends$1(_extends$1(_extends$1({}, resetComponent(token2)), genInputGroupStyle(token2)), {
      "&-rtl": {
        direction: "rtl"
      },
      "&-wrapper": {
        display: "inline-block",
        width: "100%",
        textAlign: "start",
        verticalAlign: "top",
        "&-rtl": {
          direction: "rtl"
        },
        // Size
        "&-lg": {
          [`${componentCls}-group-addon`]: {
            borderRadius: borderRadiusLG
          }
        },
        "&-sm": {
          [`${componentCls}-group-addon`]: {
            borderRadius: borderRadiusSM
          }
        },
        // Status
        "&-status-error": {
          [`${componentCls}-group-addon`]: {
            color: colorError,
            borderColor: colorError
          }
        },
        "&-status-warning": {
          [`${componentCls}-group-addon:last-child`]: {
            color: colorSuccess,
            borderColor: colorSuccess
          }
        }
      }
    })
  };
};
const genSearchInputStyle = (token2) => {
  const {
    componentCls,
    antCls
  } = token2;
  const searchPrefixCls = `${componentCls}-search`;
  return {
    [searchPrefixCls]: {
      [`${componentCls}`]: {
        "&:hover, &:focus": {
          borderColor: token2.colorPrimaryHover,
          [`+ ${componentCls}-group-addon ${searchPrefixCls}-button:not(${antCls}-btn-primary)`]: {
            borderInlineStartColor: token2.colorPrimaryHover
          }
        }
      },
      [`${componentCls}-affix-wrapper`]: {
        borderRadius: 0
      },
      // fix slight height diff in Firefox:
      // https://ant.design/components/auto-complete-cn/#components-auto-complete-demo-certain-category
      [`${componentCls}-lg`]: {
        lineHeight: token2.lineHeightLG - 2e-4
      },
      [`> ${componentCls}-group`]: {
        [`> ${componentCls}-group-addon:last-child`]: {
          insetInlineStart: -1,
          padding: 0,
          border: 0,
          [`${searchPrefixCls}-button`]: {
            paddingTop: 0,
            paddingBottom: 0,
            borderStartStartRadius: 0,
            borderStartEndRadius: token2.borderRadius,
            borderEndEndRadius: token2.borderRadius,
            borderEndStartRadius: 0
          },
          [`${searchPrefixCls}-button:not(${antCls}-btn-primary)`]: {
            color: token2.colorTextDescription,
            "&:hover": {
              color: token2.colorPrimaryHover
            },
            "&:active": {
              color: token2.colorPrimaryActive
            },
            [`&${antCls}-btn-loading::before`]: {
              insetInlineStart: 0,
              insetInlineEnd: 0,
              insetBlockStart: 0,
              insetBlockEnd: 0
            }
          }
        }
      },
      [`${searchPrefixCls}-button`]: {
        height: token2.controlHeight,
        "&:hover, &:focus": {
          zIndex: 1
        }
      },
      [`&-large ${searchPrefixCls}-button`]: {
        height: token2.controlHeightLG
      },
      [`&-small ${searchPrefixCls}-button`]: {
        height: token2.controlHeightSM
      },
      "&-rtl": {
        direction: "rtl"
      },
      // ===================== Compact Item Customized Styles =====================
      [`&${componentCls}-compact-item`]: {
        [`&:not(${componentCls}-compact-last-item)`]: {
          [`${componentCls}-group-addon`]: {
            [`${componentCls}-search-button`]: {
              marginInlineEnd: -token2.lineWidth,
              borderRadius: 0
            }
          }
        },
        [`&:not(${componentCls}-compact-first-item)`]: {
          [`${componentCls},${componentCls}-affix-wrapper`]: {
            borderRadius: 0
          }
        },
        [`> ${componentCls}-group-addon ${componentCls}-search-button,
        > ${componentCls},
        ${componentCls}-affix-wrapper`]: {
          "&:hover,&:focus,&:active": {
            zIndex: 2
          }
        },
        [`> ${componentCls}-affix-wrapper-focused`]: {
          zIndex: 2
        }
      }
    }
  };
};
function initInputToken(token2) {
  return merge(token2, {
    inputAffixPadding: token2.paddingXXS,
    inputPaddingVertical: Math.max(Math.round((token2.controlHeight - token2.fontSize * token2.lineHeight) / 2 * 10) / 10 - token2.lineWidth, 3),
    inputPaddingVerticalLG: Math.ceil((token2.controlHeightLG - token2.fontSizeLG * token2.lineHeightLG) / 2 * 10) / 10 - token2.lineWidth,
    inputPaddingVerticalSM: Math.max(Math.round((token2.controlHeightSM - token2.fontSize * token2.lineHeight) / 2 * 10) / 10 - token2.lineWidth, 0),
    inputPaddingHorizontal: token2.paddingSM - token2.lineWidth,
    inputPaddingHorizontalSM: token2.paddingXS - token2.lineWidth,
    inputPaddingHorizontalLG: token2.controlPaddingHorizontal - token2.lineWidth,
    inputBorderHoverColor: token2.colorPrimaryHover,
    inputBorderActiveColor: token2.colorPrimaryHover
  });
}
const genTextAreaStyle = (token2) => {
  const {
    componentCls,
    inputPaddingHorizontal,
    paddingLG
  } = token2;
  const textareaPrefixCls = `${componentCls}-textarea`;
  return {
    [textareaPrefixCls]: {
      position: "relative",
      [`${textareaPrefixCls}-suffix`]: {
        position: "absolute",
        top: 0,
        insetInlineEnd: inputPaddingHorizontal,
        bottom: 0,
        zIndex: 1,
        display: "inline-flex",
        alignItems: "center",
        margin: "auto"
      },
      [`&-status-error,
        &-status-warning,
        &-status-success,
        &-status-validating`]: {
        [`&${textareaPrefixCls}-has-feedback`]: {
          [`${componentCls}`]: {
            paddingInlineEnd: paddingLG
          }
        }
      },
      "&-show-count": {
        // https://github.com/ant-design/ant-design/issues/33049
        [`> ${componentCls}`]: {
          height: "100%"
        },
        "&::after": {
          color: token2.colorTextDescription,
          whiteSpace: "nowrap",
          content: "attr(data-count)",
          pointerEvents: "none",
          float: "right"
        }
      },
      "&-rtl": {
        "&::after": {
          float: "left"
        }
      }
    }
  };
};
const useStyle$w = genComponentStyleHook("Input", (token2) => {
  const inputToken = initInputToken(token2);
  return [
    genInputStyle(inputToken),
    genTextAreaStyle(inputToken),
    genAffixStyle(inputToken),
    genGroupStyle(inputToken),
    genSearchInputStyle(inputToken),
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    genCompactItemStyle(inputToken)
  ];
});
const genPikerPadding = (token2, inputHeight, fontSize, paddingHorizontal) => {
  const {
    lineHeight
  } = token2;
  const fontHeight = Math.floor(fontSize * lineHeight) + 2;
  const paddingTop = Math.max((inputHeight - fontHeight) / 2, 0);
  const paddingBottom = Math.max(inputHeight - fontHeight - paddingTop, 0);
  return {
    padding: `${paddingTop}px ${paddingHorizontal}px ${paddingBottom}px`
  };
};
const genPickerCellInnerStyle = (token2) => {
  const {
    componentCls,
    pickerCellCls,
    pickerCellInnerCls,
    pickerPanelCellHeight,
    motionDurationSlow,
    borderRadiusSM,
    motionDurationMid,
    controlItemBgHover,
    lineWidth,
    lineType,
    colorPrimary,
    controlItemBgActive,
    colorTextLightSolid,
    controlHeightSM,
    pickerDateHoverRangeBorderColor,
    pickerCellBorderGap,
    pickerBasicCellHoverWithRangeColor,
    pickerPanelCellWidth,
    colorTextDisabled,
    colorBgContainerDisabled
  } = token2;
  return {
    "&::before": {
      position: "absolute",
      top: "50%",
      insetInlineStart: 0,
      insetInlineEnd: 0,
      zIndex: 1,
      height: pickerPanelCellHeight,
      transform: "translateY(-50%)",
      transition: `all ${motionDurationSlow}`,
      content: '""'
    },
    // >>> Default
    [pickerCellInnerCls]: {
      position: "relative",
      zIndex: 2,
      display: "inline-block",
      minWidth: pickerPanelCellHeight,
      height: pickerPanelCellHeight,
      lineHeight: `${pickerPanelCellHeight}px`,
      borderRadius: borderRadiusSM,
      transition: `background ${motionDurationMid}, border ${motionDurationMid}`
    },
    // >>> Hover
    [`&:hover:not(${pickerCellCls}-in-view),
    &:hover:not(${pickerCellCls}-selected):not(${pickerCellCls}-range-start):not(${pickerCellCls}-range-end):not(${pickerCellCls}-range-hover-start):not(${pickerCellCls}-range-hover-end)`]: {
      [pickerCellInnerCls]: {
        background: controlItemBgHover
      }
    },
    // >>> Today
    [`&-in-view${pickerCellCls}-today ${pickerCellInnerCls}`]: {
      "&::before": {
        position: "absolute",
        top: 0,
        insetInlineEnd: 0,
        bottom: 0,
        insetInlineStart: 0,
        zIndex: 1,
        border: `${lineWidth}px ${lineType} ${colorPrimary}`,
        borderRadius: borderRadiusSM,
        content: '""'
      }
    },
    // >>> In Range
    [`&-in-view${pickerCellCls}-in-range`]: {
      position: "relative",
      "&::before": {
        background: controlItemBgActive
      }
    },
    // >>> Selected
    [`&-in-view${pickerCellCls}-selected ${pickerCellInnerCls},
      &-in-view${pickerCellCls}-range-start ${pickerCellInnerCls},
      &-in-view${pickerCellCls}-range-end ${pickerCellInnerCls}`]: {
      color: colorTextLightSolid,
      background: colorPrimary
    },
    [`&-in-view${pickerCellCls}-range-start:not(${pickerCellCls}-range-start-single),
      &-in-view${pickerCellCls}-range-end:not(${pickerCellCls}-range-end-single)`]: {
      "&::before": {
        background: controlItemBgActive
      }
    },
    [`&-in-view${pickerCellCls}-range-start::before`]: {
      insetInlineStart: "50%"
    },
    [`&-in-view${pickerCellCls}-range-end::before`]: {
      insetInlineEnd: "50%"
    },
    // >>> Range Hover
    [`&-in-view${pickerCellCls}-range-hover-start:not(${pickerCellCls}-in-range):not(${pickerCellCls}-range-start):not(${pickerCellCls}-range-end),
      &-in-view${pickerCellCls}-range-hover-end:not(${pickerCellCls}-in-range):not(${pickerCellCls}-range-start):not(${pickerCellCls}-range-end),
      &-in-view${pickerCellCls}-range-hover-start${pickerCellCls}-range-start-single,
      &-in-view${pickerCellCls}-range-hover-start${pickerCellCls}-range-start${pickerCellCls}-range-end${pickerCellCls}-range-end-near-hover,
      &-in-view${pickerCellCls}-range-hover-end${pickerCellCls}-range-start${pickerCellCls}-range-end${pickerCellCls}-range-start-near-hover,
      &-in-view${pickerCellCls}-range-hover-end${pickerCellCls}-range-end-single,
      &-in-view${pickerCellCls}-range-hover:not(${pickerCellCls}-in-range)`]: {
      "&::after": {
        position: "absolute",
        top: "50%",
        zIndex: 0,
        height: controlHeightSM,
        borderTop: `${lineWidth}px dashed ${pickerDateHoverRangeBorderColor}`,
        borderBottom: `${lineWidth}px dashed ${pickerDateHoverRangeBorderColor}`,
        transform: "translateY(-50%)",
        transition: `all ${motionDurationSlow}`,
        content: '""'
      }
    },
    // Add space for stash
    [`&-range-hover-start::after,
      &-range-hover-end::after,
      &-range-hover::after`]: {
      insetInlineEnd: 0,
      insetInlineStart: pickerCellBorderGap
    },
    // Hover with in range
    [`&-in-view${pickerCellCls}-in-range${pickerCellCls}-range-hover::before,
      &-in-view${pickerCellCls}-range-start${pickerCellCls}-range-hover::before,
      &-in-view${pickerCellCls}-range-end${pickerCellCls}-range-hover::before,
      &-in-view${pickerCellCls}-range-start:not(${pickerCellCls}-range-start-single)${pickerCellCls}-range-hover-start::before,
      &-in-view${pickerCellCls}-range-end:not(${pickerCellCls}-range-end-single)${pickerCellCls}-range-hover-end::before,
      ${componentCls}-panel
      > :not(${componentCls}-date-panel)
      &-in-view${pickerCellCls}-in-range${pickerCellCls}-range-hover-start::before,
      ${componentCls}-panel
      > :not(${componentCls}-date-panel)
      &-in-view${pickerCellCls}-in-range${pickerCellCls}-range-hover-end::before`]: {
      background: pickerBasicCellHoverWithRangeColor
    },
    // range start border-radius
    [`&-in-view${pickerCellCls}-range-start:not(${pickerCellCls}-range-start-single):not(${pickerCellCls}-range-end) ${pickerCellInnerCls}`]: {
      borderStartStartRadius: borderRadiusSM,
      borderEndStartRadius: borderRadiusSM,
      borderStartEndRadius: 0,
      borderEndEndRadius: 0
    },
    // range end border-radius
    [`&-in-view${pickerCellCls}-range-end:not(${pickerCellCls}-range-end-single):not(${pickerCellCls}-range-start) ${pickerCellInnerCls}`]: {
      borderStartStartRadius: 0,
      borderEndStartRadius: 0,
      borderStartEndRadius: borderRadiusSM,
      borderEndEndRadius: borderRadiusSM
    },
    [`&-range-hover${pickerCellCls}-range-end::after`]: {
      insetInlineStart: "50%"
    },
    // Edge start
    [`tr > &-in-view${pickerCellCls}-range-hover:first-child::after,
      tr > &-in-view${pickerCellCls}-range-hover-end:first-child::after,
      &-in-view${pickerCellCls}-start${pickerCellCls}-range-hover-edge-start${pickerCellCls}-range-hover-edge-start-near-range::after,
      &-in-view${pickerCellCls}-range-hover-edge-start:not(${pickerCellCls}-range-hover-edge-start-near-range)::after,
      &-in-view${pickerCellCls}-range-hover-start::after`]: {
      insetInlineStart: (pickerPanelCellWidth - pickerPanelCellHeight) / 2,
      borderInlineStart: `${lineWidth}px dashed ${pickerDateHoverRangeBorderColor}`,
      borderStartStartRadius: lineWidth,
      borderEndStartRadius: lineWidth
    },
    // Edge end
    [`tr > &-in-view${pickerCellCls}-range-hover:last-child::after,
      tr > &-in-view${pickerCellCls}-range-hover-start:last-child::after,
      &-in-view${pickerCellCls}-end${pickerCellCls}-range-hover-edge-end${pickerCellCls}-range-hover-edge-end-near-range::after,
      &-in-view${pickerCellCls}-range-hover-edge-end:not(${pickerCellCls}-range-hover-edge-end-near-range)::after,
      &-in-view${pickerCellCls}-range-hover-end::after`]: {
      insetInlineEnd: (pickerPanelCellWidth - pickerPanelCellHeight) / 2,
      borderInlineEnd: `${lineWidth}px dashed ${pickerDateHoverRangeBorderColor}`,
      borderStartEndRadius: lineWidth,
      borderEndEndRadius: lineWidth
    },
    // >>> Disabled
    "&-disabled": {
      color: colorTextDisabled,
      pointerEvents: "none",
      [pickerCellInnerCls]: {
        background: "transparent"
      },
      "&::before": {
        background: colorBgContainerDisabled
      }
    },
    [`&-disabled${pickerCellCls}-today ${pickerCellInnerCls}::before`]: {
      borderColor: colorTextDisabled
    }
  };
};
const genPanelStyle = (token2) => {
  const {
    componentCls,
    pickerCellInnerCls,
    pickerYearMonthCellWidth,
    pickerControlIconSize,
    pickerPanelCellWidth,
    paddingSM,
    paddingXS,
    paddingXXS,
    colorBgContainer,
    lineWidth,
    lineType,
    borderRadiusLG,
    colorPrimary,
    colorTextHeading,
    colorSplit,
    pickerControlIconBorderWidth,
    colorIcon,
    pickerTextHeight,
    motionDurationMid,
    colorIconHover,
    fontWeightStrong,
    pickerPanelCellHeight,
    pickerCellPaddingVertical,
    colorTextDisabled,
    colorText,
    fontSize,
    pickerBasicCellHoverWithRangeColor,
    motionDurationSlow,
    pickerPanelWithoutTimeCellHeight,
    pickerQuarterPanelContentHeight,
    colorLink,
    colorLinkActive,
    colorLinkHover,
    pickerDateHoverRangeBorderColor,
    borderRadiusSM,
    colorTextLightSolid,
    borderRadius,
    controlItemBgHover,
    pickerTimePanelColumnHeight,
    pickerTimePanelColumnWidth,
    pickerTimePanelCellHeight,
    controlItemBgActive,
    marginXXS
  } = token2;
  const pickerPanelWidth = pickerPanelCellWidth * 7 + paddingSM * 2 + 4;
  const hoverCellFixedDistance = (pickerPanelWidth - paddingXS * 2) / 3 - pickerYearMonthCellWidth - paddingSM;
  return {
    [componentCls]: {
      "&-panel": {
        display: "inline-flex",
        flexDirection: "column",
        textAlign: "center",
        background: colorBgContainer,
        border: `${lineWidth}px ${lineType} ${colorSplit}`,
        borderRadius: borderRadiusLG,
        outline: "none",
        "&-focused": {
          borderColor: colorPrimary
        },
        "&-rtl": {
          direction: "rtl",
          [`${componentCls}-prev-icon,
              ${componentCls}-super-prev-icon`]: {
            transform: "rotate(45deg)"
          },
          [`${componentCls}-next-icon,
              ${componentCls}-super-next-icon`]: {
            transform: "rotate(-135deg)"
          }
        }
      },
      // ========================================================
      // =                     Shared Panel                     =
      // ========================================================
      [`&-decade-panel,
        &-year-panel,
        &-quarter-panel,
        &-month-panel,
        &-week-panel,
        &-date-panel,
        &-time-panel`]: {
        display: "flex",
        flexDirection: "column",
        width: pickerPanelWidth
      },
      // ======================= Header =======================
      "&-header": {
        display: "flex",
        padding: `0 ${paddingXS}px`,
        color: colorTextHeading,
        borderBottom: `${lineWidth}px ${lineType} ${colorSplit}`,
        "> *": {
          flex: "none"
        },
        button: {
          padding: 0,
          color: colorIcon,
          lineHeight: `${pickerTextHeight}px`,
          background: "transparent",
          border: 0,
          cursor: "pointer",
          transition: `color ${motionDurationMid}`
        },
        "> button": {
          minWidth: "1.6em",
          fontSize,
          "&:hover": {
            color: colorIconHover
          }
        },
        "&-view": {
          flex: "auto",
          fontWeight: fontWeightStrong,
          lineHeight: `${pickerTextHeight}px`,
          button: {
            color: "inherit",
            fontWeight: "inherit",
            verticalAlign: "top",
            "&:not(:first-child)": {
              marginInlineStart: paddingXS
            },
            "&:hover": {
              color: colorPrimary
            }
          }
        }
      },
      // Arrow button
      [`&-prev-icon,
        &-next-icon,
        &-super-prev-icon,
        &-super-next-icon`]: {
        position: "relative",
        display: "inline-block",
        width: pickerControlIconSize,
        height: pickerControlIconSize,
        "&::before": {
          position: "absolute",
          top: 0,
          insetInlineStart: 0,
          display: "inline-block",
          width: pickerControlIconSize,
          height: pickerControlIconSize,
          border: `0 solid currentcolor`,
          borderBlockStartWidth: pickerControlIconBorderWidth,
          borderBlockEndWidth: 0,
          borderInlineStartWidth: pickerControlIconBorderWidth,
          borderInlineEndWidth: 0,
          content: '""'
        }
      },
      [`&-super-prev-icon,
        &-super-next-icon`]: {
        "&::after": {
          position: "absolute",
          top: Math.ceil(pickerControlIconSize / 2),
          insetInlineStart: Math.ceil(pickerControlIconSize / 2),
          display: "inline-block",
          width: pickerControlIconSize,
          height: pickerControlIconSize,
          border: "0 solid currentcolor",
          borderBlockStartWidth: pickerControlIconBorderWidth,
          borderBlockEndWidth: 0,
          borderInlineStartWidth: pickerControlIconBorderWidth,
          borderInlineEndWidth: 0,
          content: '""'
        }
      },
      [`&-prev-icon,
        &-super-prev-icon`]: {
        transform: "rotate(-45deg)"
      },
      [`&-next-icon,
        &-super-next-icon`]: {
        transform: "rotate(135deg)"
      },
      // ======================== Body ========================
      "&-content": {
        width: "100%",
        tableLayout: "fixed",
        borderCollapse: "collapse",
        "th, td": {
          position: "relative",
          minWidth: pickerPanelCellHeight,
          fontWeight: "normal"
        },
        th: {
          height: pickerPanelCellHeight + pickerCellPaddingVertical * 2,
          color: colorText,
          verticalAlign: "middle"
        }
      },
      "&-cell": _extends$1({
        padding: `${pickerCellPaddingVertical}px 0`,
        color: colorTextDisabled,
        cursor: "pointer",
        // In view
        "&-in-view": {
          color: colorText
        }
      }, genPickerCellInnerStyle(token2)),
      // DatePanel only
      [`&-date-panel ${componentCls}-cell-in-view${componentCls}-cell-in-range${componentCls}-cell-range-hover-start ${pickerCellInnerCls},
        &-date-panel ${componentCls}-cell-in-view${componentCls}-cell-in-range${componentCls}-cell-range-hover-end ${pickerCellInnerCls}`]: {
        "&::after": {
          position: "absolute",
          top: 0,
          bottom: 0,
          zIndex: -1,
          background: pickerBasicCellHoverWithRangeColor,
          transition: `all ${motionDurationSlow}`,
          content: '""'
        }
      },
      [`&-date-panel
        ${componentCls}-cell-in-view${componentCls}-cell-in-range${componentCls}-cell-range-hover-start
        ${pickerCellInnerCls}::after`]: {
        insetInlineEnd: -(pickerPanelCellWidth - pickerPanelCellHeight) / 2,
        insetInlineStart: 0
      },
      [`&-date-panel ${componentCls}-cell-in-view${componentCls}-cell-in-range${componentCls}-cell-range-hover-end ${pickerCellInnerCls}::after`]: {
        insetInlineEnd: 0,
        insetInlineStart: -(pickerPanelCellWidth - pickerPanelCellHeight) / 2
      },
      // Hover with range start & end
      [`&-range-hover${componentCls}-range-start::after`]: {
        insetInlineEnd: "50%"
      },
      [`&-decade-panel,
        &-year-panel,
        &-quarter-panel,
        &-month-panel`]: {
        [`${componentCls}-content`]: {
          height: pickerPanelWithoutTimeCellHeight * 4
        },
        [pickerCellInnerCls]: {
          padding: `0 ${paddingXS}px`
        }
      },
      "&-quarter-panel": {
        [`${componentCls}-content`]: {
          height: pickerQuarterPanelContentHeight
        }
      },
      // ======================== Footer ========================
      [`&-panel ${componentCls}-footer`]: {
        borderTop: `${lineWidth}px ${lineType} ${colorSplit}`
      },
      "&-footer": {
        width: "min-content",
        minWidth: "100%",
        lineHeight: `${pickerTextHeight - 2 * lineWidth}px`,
        textAlign: "center",
        "&-extra": {
          padding: `0 ${paddingSM}`,
          lineHeight: `${pickerTextHeight - 2 * lineWidth}px`,
          textAlign: "start",
          "&:not(:last-child)": {
            borderBottom: `${lineWidth}px ${lineType} ${colorSplit}`
          }
        }
      },
      "&-now": {
        textAlign: "start"
      },
      "&-today-btn": {
        color: colorLink,
        "&:hover": {
          color: colorLinkHover
        },
        "&:active": {
          color: colorLinkActive
        },
        [`&${componentCls}-today-btn-disabled`]: {
          color: colorTextDisabled,
          cursor: "not-allowed"
        }
      },
      // ========================================================
      // =                       Special                        =
      // ========================================================
      // ===================== Decade Panel =====================
      "&-decade-panel": {
        [pickerCellInnerCls]: {
          padding: `0 ${paddingXS / 2}px`
        },
        [`${componentCls}-cell::before`]: {
          display: "none"
        }
      },
      // ============= Year & Quarter & Month Panel =============
      [`&-year-panel,
        &-quarter-panel,
        &-month-panel`]: {
        [`${componentCls}-body`]: {
          padding: `0 ${paddingXS}px`
        },
        [pickerCellInnerCls]: {
          width: pickerYearMonthCellWidth
        },
        [`${componentCls}-cell-range-hover-start::after`]: {
          insetInlineStart: hoverCellFixedDistance,
          borderInlineStart: `${lineWidth}px dashed ${pickerDateHoverRangeBorderColor}`,
          borderStartStartRadius: borderRadiusSM,
          borderBottomStartRadius: borderRadiusSM,
          borderStartEndRadius: 0,
          borderBottomEndRadius: 0,
          [`${componentCls}-panel-rtl &`]: {
            insetInlineEnd: hoverCellFixedDistance,
            borderInlineEnd: `${lineWidth}px dashed ${pickerDateHoverRangeBorderColor}`,
            borderStartStartRadius: 0,
            borderBottomStartRadius: 0,
            borderStartEndRadius: borderRadiusSM,
            borderBottomEndRadius: borderRadiusSM
          }
        },
        [`${componentCls}-cell-range-hover-end::after`]: {
          insetInlineEnd: hoverCellFixedDistance,
          borderInlineEnd: `${lineWidth}px dashed ${pickerDateHoverRangeBorderColor}`,
          borderStartStartRadius: 0,
          borderEndStartRadius: 0,
          borderStartEndRadius: borderRadius,
          borderEndEndRadius: borderRadius,
          [`${componentCls}-panel-rtl &`]: {
            insetInlineStart: hoverCellFixedDistance,
            borderInlineStart: `${lineWidth}px dashed ${pickerDateHoverRangeBorderColor}`,
            borderStartStartRadius: borderRadius,
            borderEndStartRadius: borderRadius,
            borderStartEndRadius: 0,
            borderEndEndRadius: 0
          }
        }
      },
      // ====================== Week Panel ======================
      "&-week-panel": {
        [`${componentCls}-body`]: {
          padding: `${paddingXS}px ${paddingSM}px`
        },
        // Clear cell style
        [`${componentCls}-cell`]: {
          [`&:hover ${pickerCellInnerCls},
            &-selected ${pickerCellInnerCls},
            ${pickerCellInnerCls}`]: {
            background: "transparent !important"
          }
        },
        "&-row": {
          td: {
            transition: `background ${motionDurationMid}`,
            "&:first-child": {
              borderStartStartRadius: borderRadiusSM,
              borderEndStartRadius: borderRadiusSM
            },
            "&:last-child": {
              borderStartEndRadius: borderRadiusSM,
              borderEndEndRadius: borderRadiusSM
            }
          },
          "&:hover td": {
            background: controlItemBgHover
          },
          [`&-selected td,
            &-selected:hover td`]: {
            background: colorPrimary,
            [`&${componentCls}-cell-week`]: {
              color: new TinyColor(colorTextLightSolid).setAlpha(0.5).toHexString()
            },
            [`&${componentCls}-cell-today ${pickerCellInnerCls}::before`]: {
              borderColor: colorTextLightSolid
            },
            [pickerCellInnerCls]: {
              color: colorTextLightSolid
            }
          }
        }
      },
      // ====================== Date Panel ======================
      "&-date-panel": {
        [`${componentCls}-body`]: {
          padding: `${paddingXS}px ${paddingSM}px`
        },
        [`${componentCls}-content`]: {
          width: pickerPanelCellWidth * 7,
          th: {
            width: pickerPanelCellWidth
          }
        }
      },
      // ==================== Datetime Panel ====================
      "&-datetime-panel": {
        display: "flex",
        [`${componentCls}-time-panel`]: {
          borderInlineStart: `${lineWidth}px ${lineType} ${colorSplit}`
        },
        [`${componentCls}-date-panel,
          ${componentCls}-time-panel`]: {
          transition: `opacity ${motionDurationSlow}`
        },
        // Keyboard
        "&-active": {
          [`${componentCls}-date-panel,
            ${componentCls}-time-panel`]: {
            opacity: 0.3,
            "&-active": {
              opacity: 1
            }
          }
        }
      },
      // ====================== Time Panel ======================
      "&-time-panel": {
        width: "auto",
        minWidth: "auto",
        direction: "ltr",
        [`${componentCls}-content`]: {
          display: "flex",
          flex: "auto",
          height: pickerTimePanelColumnHeight
        },
        "&-column": {
          flex: "1 0 auto",
          width: pickerTimePanelColumnWidth,
          margin: `${paddingXXS}px 0`,
          padding: 0,
          overflowY: "hidden",
          textAlign: "start",
          listStyle: "none",
          transition: `background ${motionDurationMid}`,
          overflowX: "hidden",
          "&::after": {
            display: "block",
            height: pickerTimePanelColumnHeight - pickerTimePanelCellHeight,
            content: '""'
          },
          "&:not(:first-child)": {
            borderInlineStart: `${lineWidth}px ${lineType} ${colorSplit}`
          },
          "&-active": {
            background: new TinyColor(controlItemBgActive).setAlpha(0.2).toHexString()
          },
          "&:hover": {
            overflowY: "auto"
          },
          "> li": {
            margin: 0,
            padding: 0,
            [`&${componentCls}-time-panel-cell`]: {
              marginInline: marginXXS,
              [`${componentCls}-time-panel-cell-inner`]: {
                display: "block",
                width: pickerTimePanelColumnWidth - 2 * marginXXS,
                height: pickerTimePanelCellHeight,
                margin: 0,
                paddingBlock: 0,
                paddingInlineEnd: 0,
                paddingInlineStart: (pickerTimePanelColumnWidth - pickerTimePanelCellHeight) / 2,
                color: colorText,
                lineHeight: `${pickerTimePanelCellHeight}px`,
                borderRadius: borderRadiusSM,
                cursor: "pointer",
                transition: `background ${motionDurationMid}`,
                "&:hover": {
                  background: controlItemBgHover
                }
              },
              "&-selected": {
                [`${componentCls}-time-panel-cell-inner`]: {
                  background: controlItemBgActive
                }
              },
              "&-disabled": {
                [`${componentCls}-time-panel-cell-inner`]: {
                  color: colorTextDisabled,
                  background: "transparent",
                  cursor: "not-allowed"
                }
              }
            }
          }
        }
      },
      // https://github.com/ant-design/ant-design/issues/39227
      [`&-datetime-panel ${componentCls}-time-panel-column:after`]: {
        height: pickerTimePanelColumnHeight - pickerTimePanelCellHeight + paddingXXS * 2
      }
    }
  };
};
const genPickerStatusStyle = (token2) => {
  const {
    componentCls,
    colorBgContainer,
    colorError,
    colorErrorOutline,
    colorWarning,
    colorWarningOutline
  } = token2;
  return {
    [componentCls]: {
      [`&-status-error${componentCls}`]: {
        "&, &:not([disabled]):hover": {
          backgroundColor: colorBgContainer,
          borderColor: colorError
        },
        "&-focused, &:focus": _extends$1({}, genActiveStyle(merge(token2, {
          inputBorderActiveColor: colorError,
          inputBorderHoverColor: colorError,
          controlOutline: colorErrorOutline
        }))),
        [`${componentCls}-active-bar`]: {
          background: colorError
        }
      },
      [`&-status-warning${componentCls}`]: {
        "&, &:not([disabled]):hover": {
          backgroundColor: colorBgContainer,
          borderColor: colorWarning
        },
        "&-focused, &:focus": _extends$1({}, genActiveStyle(merge(token2, {
          inputBorderActiveColor: colorWarning,
          inputBorderHoverColor: colorWarning,
          controlOutline: colorWarningOutline
        }))),
        [`${componentCls}-active-bar`]: {
          background: colorWarning
        }
      }
    }
  };
};
const genPickerStyle = (token2) => {
  const {
    componentCls,
    antCls,
    boxShadowPopoverArrow,
    controlHeight,
    fontSize,
    inputPaddingHorizontal,
    colorBgContainer,
    lineWidth,
    lineType,
    colorBorder,
    borderRadius,
    motionDurationMid,
    colorBgContainerDisabled,
    colorTextDisabled,
    colorTextPlaceholder,
    controlHeightLG,
    fontSizeLG,
    controlHeightSM,
    inputPaddingHorizontalSM,
    paddingXS,
    marginXS,
    colorTextDescription,
    lineWidthBold,
    lineHeight,
    colorPrimary,
    motionDurationSlow,
    zIndexPopup,
    paddingXXS,
    paddingSM,
    pickerTextHeight,
    controlItemBgActive,
    colorPrimaryBorder,
    sizePopupArrow,
    borderRadiusXS,
    borderRadiusOuter,
    colorBgElevated,
    borderRadiusLG,
    boxShadowSecondary,
    borderRadiusSM,
    colorSplit,
    controlItemBgHover,
    presetsWidth,
    presetsMaxWidth
  } = token2;
  return [
    {
      [componentCls]: _extends$1(_extends$1(_extends$1({}, resetComponent(token2)), genPikerPadding(token2, controlHeight, fontSize, inputPaddingHorizontal)), {
        position: "relative",
        display: "inline-flex",
        alignItems: "center",
        background: colorBgContainer,
        lineHeight: 1,
        border: `${lineWidth}px ${lineType} ${colorBorder}`,
        borderRadius,
        transition: `border ${motionDurationMid}, box-shadow ${motionDurationMid}`,
        "&:hover, &-focused": _extends$1({}, genHoverStyle(token2)),
        "&-focused": _extends$1({}, genActiveStyle(token2)),
        [`&${componentCls}-disabled`]: {
          background: colorBgContainerDisabled,
          borderColor: colorBorder,
          cursor: "not-allowed",
          [`${componentCls}-suffix`]: {
            color: colorTextDisabled
          }
        },
        [`&${componentCls}-borderless`]: {
          backgroundColor: "transparent !important",
          borderColor: "transparent !important",
          boxShadow: "none !important"
        },
        // ======================== Input =========================
        [`${componentCls}-input`]: {
          position: "relative",
          display: "inline-flex",
          alignItems: "center",
          width: "100%",
          "> input": _extends$1(_extends$1({}, genBasicInputStyle(token2)), {
            flex: "auto",
            // Fix Firefox flex not correct:
            // https://github.com/ant-design/ant-design/pull/20023#issuecomment-564389553
            minWidth: 1,
            height: "auto",
            padding: 0,
            background: "transparent",
            border: 0,
            "&:focus": {
              boxShadow: "none"
            },
            "&[disabled]": {
              background: "transparent"
            }
          }),
          "&:hover": {
            [`${componentCls}-clear`]: {
              opacity: 1
            }
          },
          "&-placeholder": {
            "> input": {
              color: colorTextPlaceholder
            }
          }
        },
        // Size
        "&-large": _extends$1(_extends$1({}, genPikerPadding(token2, controlHeightLG, fontSizeLG, inputPaddingHorizontal)), {
          [`${componentCls}-input > input`]: {
            fontSize: fontSizeLG
          }
        }),
        "&-small": _extends$1({}, genPikerPadding(token2, controlHeightSM, fontSize, inputPaddingHorizontalSM)),
        [`${componentCls}-suffix`]: {
          display: "flex",
          flex: "none",
          alignSelf: "center",
          marginInlineStart: paddingXS / 2,
          color: colorTextDisabled,
          lineHeight: 1,
          pointerEvents: "none",
          "> *": {
            verticalAlign: "top",
            "&:not(:last-child)": {
              marginInlineEnd: marginXS
            }
          }
        },
        [`${componentCls}-clear`]: {
          position: "absolute",
          top: "50%",
          insetInlineEnd: 0,
          color: colorTextDisabled,
          lineHeight: 1,
          background: colorBgContainer,
          transform: "translateY(-50%)",
          cursor: "pointer",
          opacity: 0,
          transition: `opacity ${motionDurationMid}, color ${motionDurationMid}`,
          "> *": {
            verticalAlign: "top"
          },
          "&:hover": {
            color: colorTextDescription
          }
        },
        [`${componentCls}-separator`]: {
          position: "relative",
          display: "inline-block",
          width: "1em",
          height: fontSizeLG,
          color: colorTextDisabled,
          fontSize: fontSizeLG,
          verticalAlign: "top",
          cursor: "default",
          [`${componentCls}-focused &`]: {
            color: colorTextDescription
          },
          [`${componentCls}-range-separator &`]: {
            [`${componentCls}-disabled &`]: {
              cursor: "not-allowed"
            }
          }
        },
        // ======================== Range =========================
        "&-range": {
          position: "relative",
          display: "inline-flex",
          // Clear
          [`${componentCls}-clear`]: {
            insetInlineEnd: inputPaddingHorizontal
          },
          "&:hover": {
            [`${componentCls}-clear`]: {
              opacity: 1
            }
          },
          // Active bar
          [`${componentCls}-active-bar`]: {
            bottom: -lineWidth,
            height: lineWidthBold,
            marginInlineStart: inputPaddingHorizontal,
            background: colorPrimary,
            opacity: 0,
            transition: `all ${motionDurationSlow} ease-out`,
            pointerEvents: "none"
          },
          [`&${componentCls}-focused`]: {
            [`${componentCls}-active-bar`]: {
              opacity: 1
            }
          },
          [`${componentCls}-range-separator`]: {
            alignItems: "center",
            padding: `0 ${paddingXS}px`,
            lineHeight: 1
          },
          [`&${componentCls}-small`]: {
            [`${componentCls}-clear`]: {
              insetInlineEnd: inputPaddingHorizontalSM
            },
            [`${componentCls}-active-bar`]: {
              marginInlineStart: inputPaddingHorizontalSM
            }
          }
        },
        // ======================= Dropdown =======================
        "&-dropdown": _extends$1(_extends$1(_extends$1({}, resetComponent(token2)), genPanelStyle(token2)), {
          position: "absolute",
          // Fix incorrect position of picker popup
          // https://github.com/ant-design/ant-design/issues/35590
          top: -9999,
          left: {
            _skip_check_: true,
            value: -9999
          },
          zIndex: zIndexPopup,
          [`&${componentCls}-dropdown-hidden`]: {
            display: "none"
          },
          [`&${componentCls}-dropdown-placement-bottomLeft`]: {
            [`${componentCls}-range-arrow`]: {
              top: 0,
              display: "block",
              transform: "translateY(-100%)"
            }
          },
          [`&${componentCls}-dropdown-placement-topLeft`]: {
            [`${componentCls}-range-arrow`]: {
              bottom: 0,
              display: "block",
              transform: "translateY(100%) rotate(180deg)"
            }
          },
          [`&${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-topLeft,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-topRight,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-topLeft,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-topRight`]: {
            animationName: slideDownIn
          },
          [`&${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-bottomLeft,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-bottomRight,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-bottomLeft,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-bottomRight`]: {
            animationName: slideUpIn
          },
          [`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-topLeft,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-topRight`]: {
            animationName: slideDownOut
          },
          [`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-bottomLeft,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-bottomRight`]: {
            animationName: slideUpOut
          },
          // Time picker with additional style
          [`${componentCls}-panel > ${componentCls}-time-panel`]: {
            paddingTop: paddingXXS
          },
          // ======================== Ranges ========================
          [`${componentCls}-ranges`]: {
            marginBottom: 0,
            padding: `${paddingXXS}px ${paddingSM}px`,
            overflow: "hidden",
            lineHeight: `${pickerTextHeight - 2 * lineWidth - paddingXS / 2}px`,
            textAlign: "start",
            listStyle: "none",
            display: "flex",
            justifyContent: "space-between",
            "> li": {
              display: "inline-block"
            },
            // https://github.com/ant-design/ant-design/issues/23687
            [`${componentCls}-preset > ${antCls}-tag-blue`]: {
              color: colorPrimary,
              background: controlItemBgActive,
              borderColor: colorPrimaryBorder,
              cursor: "pointer"
            },
            [`${componentCls}-ok`]: {
              marginInlineStart: "auto"
            }
          },
          [`${componentCls}-range-wrapper`]: {
            display: "flex",
            position: "relative"
          },
          [`${componentCls}-range-arrow`]: _extends$1({
            position: "absolute",
            zIndex: 1,
            display: "none",
            marginInlineStart: inputPaddingHorizontal * 1.5,
            transition: `left ${motionDurationSlow} ease-out`
          }, roundedArrow(sizePopupArrow, borderRadiusXS, borderRadiusOuter, colorBgElevated, boxShadowPopoverArrow)),
          [`${componentCls}-panel-container`]: {
            overflow: "hidden",
            verticalAlign: "top",
            background: colorBgElevated,
            borderRadius: borderRadiusLG,
            boxShadow: boxShadowSecondary,
            transition: `margin ${motionDurationSlow}`,
            // ======================== Layout ========================
            [`${componentCls}-panel-layout`]: {
              display: "flex",
              flexWrap: "nowrap",
              alignItems: "stretch"
            },
            // ======================== Preset ========================
            [`${componentCls}-presets`]: {
              display: "flex",
              flexDirection: "column",
              minWidth: presetsWidth,
              maxWidth: presetsMaxWidth,
              ul: {
                height: 0,
                flex: "auto",
                listStyle: "none",
                overflow: "auto",
                margin: 0,
                padding: paddingXS,
                borderInlineEnd: `${lineWidth}px ${lineType} ${colorSplit}`,
                li: _extends$1(_extends$1({}, textEllipsis), {
                  borderRadius: borderRadiusSM,
                  paddingInline: paddingXS,
                  paddingBlock: (controlHeightSM - Math.round(fontSize * lineHeight)) / 2,
                  cursor: "pointer",
                  transition: `all ${motionDurationSlow}`,
                  "+ li": {
                    marginTop: marginXS
                  },
                  "&:hover": {
                    background: controlItemBgHover
                  }
                })
              }
            },
            // ======================== Panels ========================
            [`${componentCls}-panels`]: {
              display: "inline-flex",
              flexWrap: "nowrap",
              direction: "ltr",
              [`${componentCls}-panel`]: {
                borderWidth: `0 0 ${lineWidth}px`
              },
              "&:last-child": {
                [`${componentCls}-panel`]: {
                  borderWidth: 0
                }
              }
            },
            [`${componentCls}-panel`]: {
              verticalAlign: "top",
              background: "transparent",
              borderRadius: 0,
              borderWidth: 0,
              [`${componentCls}-content,
            table`]: {
                textAlign: "center"
              },
              "&-focused": {
                borderColor: colorBorder
              }
            }
          }
        }),
        "&-dropdown-range": {
          padding: `${sizePopupArrow * 2 / 3}px 0`,
          "&-hidden": {
            display: "none"
          }
        },
        "&-rtl": {
          direction: "rtl",
          [`${componentCls}-separator`]: {
            transform: "rotate(180deg)"
          },
          [`${componentCls}-footer`]: {
            "&-extra": {
              direction: "rtl"
            }
          }
        }
      })
    },
    // Follow code may reuse in other components
    initSlideMotion(token2, "slide-up"),
    initSlideMotion(token2, "slide-down"),
    initMoveMotion(token2, "move-up"),
    initMoveMotion(token2, "move-down")
  ];
};
const initPickerPanelToken = (token2) => {
  const pickerTimePanelCellHeight = 28;
  const {
    componentCls,
    controlHeightLG,
    controlHeightSM,
    colorPrimary,
    paddingXXS
  } = token2;
  return {
    pickerCellCls: `${componentCls}-cell`,
    pickerCellInnerCls: `${componentCls}-cell-inner`,
    pickerTextHeight: controlHeightLG,
    pickerPanelCellWidth: controlHeightSM * 1.5,
    pickerPanelCellHeight: controlHeightSM,
    pickerDateHoverRangeBorderColor: new TinyColor(colorPrimary).lighten(20).toHexString(),
    pickerBasicCellHoverWithRangeColor: new TinyColor(colorPrimary).lighten(35).toHexString(),
    pickerPanelWithoutTimeCellHeight: controlHeightLG * 1.65,
    pickerYearMonthCellWidth: controlHeightLG * 1.5,
    pickerTimePanelColumnHeight: pickerTimePanelCellHeight * 8,
    pickerTimePanelColumnWidth: controlHeightLG * 1.4,
    pickerTimePanelCellHeight,
    pickerQuarterPanelContentHeight: controlHeightLG * 1.4,
    pickerCellPaddingVertical: paddingXXS,
    pickerCellBorderGap: 2,
    pickerControlIconSize: 7,
    pickerControlIconBorderWidth: 1.5
  };
};
const useStyle$v = genComponentStyleHook("DatePicker", (token2) => {
  const pickerToken = merge(initInputToken(token2), initPickerPanelToken(token2));
  return [
    genPickerStyle(pickerToken),
    genPickerStatusStyle(pickerToken),
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    genCompactItemStyle(token2, {
      focusElCls: `${token2.componentCls}-focused`
    })
  ];
}, (token2) => ({
  presetsWidth: 120,
  presetsMaxWidth: 200,
  zIndexPopup: token2.zIndexPopupBase + 50
}));
const genCalendarStyles = (token2) => {
  const {
    calendarCls,
    componentCls,
    calendarFullBg,
    calendarFullPanelBg,
    calendarItemActiveBg
  } = token2;
  return {
    [calendarCls]: _extends$1(_extends$1(_extends$1({}, genPanelStyle(token2)), resetComponent(token2)), {
      background: calendarFullBg,
      "&-rtl": {
        direction: "rtl"
      },
      [`${calendarCls}-header`]: {
        display: "flex",
        justifyContent: "flex-end",
        padding: `${token2.paddingSM}px 0`,
        [`${calendarCls}-year-select`]: {
          minWidth: token2.yearControlWidth
        },
        [`${calendarCls}-month-select`]: {
          minWidth: token2.monthControlWidth,
          marginInlineStart: token2.marginXS
        },
        [`${calendarCls}-mode-switch`]: {
          marginInlineStart: token2.marginXS
        }
      }
    }),
    [`${calendarCls} ${componentCls}-panel`]: {
      background: calendarFullPanelBg,
      border: 0,
      borderTop: `${token2.lineWidth}px ${token2.lineType} ${token2.colorSplit}`,
      borderRadius: 0,
      [`${componentCls}-month-panel, ${componentCls}-date-panel`]: {
        width: "auto"
      },
      [`${componentCls}-body`]: {
        padding: `${token2.paddingXS}px 0`
      },
      [`${componentCls}-content`]: {
        width: "100%"
      }
    },
    [`${calendarCls}-mini`]: {
      borderRadius: token2.borderRadiusLG,
      [`${calendarCls}-header`]: {
        paddingInlineEnd: token2.paddingXS,
        paddingInlineStart: token2.paddingXS
      },
      [`${componentCls}-panel`]: {
        borderRadius: `0 0 ${token2.borderRadiusLG}px ${token2.borderRadiusLG}px`
      },
      [`${componentCls}-content`]: {
        height: token2.miniContentHeight,
        th: {
          height: "auto",
          padding: 0,
          lineHeight: `${token2.weekHeight}px`
        }
      },
      [`${componentCls}-cell::before`]: {
        pointerEvents: "none"
      }
    },
    [`${calendarCls}${calendarCls}-full`]: {
      [`${componentCls}-panel`]: {
        display: "block",
        width: "100%",
        textAlign: "end",
        background: calendarFullBg,
        border: 0,
        [`${componentCls}-body`]: {
          "th, td": {
            padding: 0
          },
          th: {
            height: "auto",
            paddingInlineEnd: token2.paddingSM,
            paddingBottom: token2.paddingXXS,
            lineHeight: `${token2.weekHeight}px`
          }
        }
      },
      [`${componentCls}-cell`]: {
        "&::before": {
          display: "none"
        },
        "&:hover": {
          [`${calendarCls}-date`]: {
            background: token2.controlItemBgHover
          }
        },
        [`${calendarCls}-date-today::before`]: {
          display: "none"
        },
        // >>> Selected
        [`&-in-view${componentCls}-cell-selected`]: {
          [`${calendarCls}-date, ${calendarCls}-date-today`]: {
            background: calendarItemActiveBg
          }
        },
        "&-selected, &-selected:hover": {
          [`${calendarCls}-date, ${calendarCls}-date-today`]: {
            [`${calendarCls}-date-value`]: {
              color: token2.colorPrimary
            }
          }
        }
      },
      [`${calendarCls}-date`]: {
        display: "block",
        width: "auto",
        height: "auto",
        margin: `0 ${token2.marginXS / 2}px`,
        padding: `${token2.paddingXS / 2}px ${token2.paddingXS}px 0`,
        border: 0,
        borderTop: `${token2.lineWidthBold}px ${token2.lineType} ${token2.colorSplit}`,
        borderRadius: 0,
        transition: `background ${token2.motionDurationSlow}`,
        "&-value": {
          lineHeight: `${token2.dateValueHeight}px`,
          transition: `color ${token2.motionDurationSlow}`
        },
        "&-content": {
          position: "static",
          width: "auto",
          height: token2.dateContentHeight,
          overflowY: "auto",
          color: token2.colorText,
          lineHeight: token2.lineHeight,
          textAlign: "start"
        },
        "&-today": {
          borderColor: token2.colorPrimary,
          [`${calendarCls}-date-value`]: {
            color: token2.colorText
          }
        }
      }
    },
    [`@media only screen and (max-width: ${token2.screenXS}px) `]: {
      [`${calendarCls}`]: {
        [`${calendarCls}-header`]: {
          display: "block",
          [`${calendarCls}-year-select`]: {
            width: "50%"
          },
          [`${calendarCls}-month-select`]: {
            width: `calc(50% - ${token2.paddingXS}px)`
          },
          [`${calendarCls}-mode-switch`]: {
            width: "100%",
            marginTop: token2.marginXS,
            marginInlineStart: 0,
            "> label": {
              width: "50%",
              textAlign: "center"
            }
          }
        }
      }
    }
  };
};
const useStyle$u = genComponentStyleHook("Calendar", (token2) => {
  const calendarCls = `${token2.componentCls}-calendar`;
  const calendarToken = merge(initInputToken(token2), initPickerPanelToken(token2), {
    calendarCls,
    pickerCellInnerCls: `${token2.componentCls}-cell-inner`,
    calendarFullBg: token2.colorBgContainer,
    calendarFullPanelBg: token2.colorBgContainer,
    calendarItemActiveBg: token2.controlItemBgActive,
    dateValueHeight: token2.controlHeightSM,
    weekHeight: token2.controlHeightSM * 0.75,
    dateContentHeight: (token2.fontSizeSM * token2.lineHeightSM + token2.marginXS) * 3 + token2.lineWidth * 2
  });
  return [genCalendarStyles(calendarToken)];
}, {
  yearControlWidth: 80,
  monthControlWidth: 70,
  miniContentHeight: 256
});
function generateCalendar(generateConfig2) {
  function isSameYear2(date1, date22) {
    return date1 && date22 && generateConfig2.getYear(date1) === generateConfig2.getYear(date22);
  }
  function isSameMonth2(date1, date22) {
    return isSameYear2(date1, date22) && generateConfig2.getMonth(date1) === generateConfig2.getMonth(date22);
  }
  function isSameDate2(date1, date22) {
    return isSameMonth2(date1, date22) && generateConfig2.getDate(date1) === generateConfig2.getDate(date22);
  }
  const Calendar2 = defineComponent({
    name: "ACalendar",
    inheritAttrs: false,
    props: {
      prefixCls: String,
      locale: {
        type: Object,
        default: void 0
      },
      validRange: {
        type: Array,
        default: void 0
      },
      disabledDate: {
        type: Function,
        default: void 0
      },
      dateFullCellRender: {
        type: Function,
        default: void 0
      },
      dateCellRender: {
        type: Function,
        default: void 0
      },
      monthFullCellRender: {
        type: Function,
        default: void 0
      },
      monthCellRender: {
        type: Function,
        default: void 0
      },
      headerRender: {
        type: Function,
        default: void 0
      },
      value: {
        type: [Object, String],
        default: void 0
      },
      defaultValue: {
        type: [Object, String],
        default: void 0
      },
      mode: {
        type: String,
        default: void 0
      },
      fullscreen: {
        type: Boolean,
        default: void 0
      },
      onChange: {
        type: Function,
        default: void 0
      },
      "onUpdate:value": {
        type: Function,
        default: void 0
      },
      onPanelChange: {
        type: Function,
        default: void 0
      },
      onSelect: {
        type: Function,
        default: void 0
      },
      valueFormat: {
        type: String,
        default: void 0
      }
    },
    slots: Object,
    setup(p, _ref) {
      let {
        emit,
        slots,
        attrs
      } = _ref;
      const props2 = p;
      const {
        prefixCls,
        direction
      } = useConfigInject("picker", props2);
      const [wrapSSR, hashId] = useStyle$u(prefixCls);
      const calendarPrefixCls = computed(() => `${prefixCls.value}-calendar`);
      const maybeToString = (date4) => {
        return props2.valueFormat ? generateConfig2.toString(date4, props2.valueFormat) : date4;
      };
      const value = computed(() => {
        if (props2.value) {
          return props2.valueFormat ? generateConfig2.toDate(props2.value, props2.valueFormat) : props2.value;
        }
        return props2.value === "" ? void 0 : props2.value;
      });
      const defaultValue = computed(() => {
        if (props2.defaultValue) {
          return props2.valueFormat ? generateConfig2.toDate(props2.defaultValue, props2.valueFormat) : props2.defaultValue;
        }
        return props2.defaultValue === "" ? void 0 : props2.defaultValue;
      });
      const [mergedValue, setMergedValue] = useMergedState(() => value.value || generateConfig2.getNow(), {
        defaultValue: defaultValue.value,
        value
      });
      const [mergedMode, setMergedMode] = useMergedState("month", {
        value: toRef(props2, "mode")
      });
      const panelMode = computed(() => mergedMode.value === "year" ? "month" : "date");
      const mergedDisabledDate = computed(() => {
        return (date4) => {
          var _a2;
          const notInRange = props2.validRange ? generateConfig2.isAfter(props2.validRange[0], date4) || generateConfig2.isAfter(date4, props2.validRange[1]) : false;
          return notInRange || !!((_a2 = props2.disabledDate) === null || _a2 === void 0 ? void 0 : _a2.call(props2, date4));
        };
      });
      const triggerPanelChange = (date4, newMode) => {
        emit("panelChange", maybeToString(date4), newMode);
      };
      const triggerChange = (date4) => {
        setMergedValue(date4);
        if (!isSameDate2(date4, mergedValue.value)) {
          if (panelMode.value === "date" && !isSameMonth2(date4, mergedValue.value) || panelMode.value === "month" && !isSameYear2(date4, mergedValue.value)) {
            triggerPanelChange(date4, mergedMode.value);
          }
          const val = maybeToString(date4);
          emit("update:value", val);
          emit("change", val);
        }
      };
      const triggerModeChange = (newMode) => {
        setMergedMode(newMode);
        triggerPanelChange(mergedValue.value, newMode);
      };
      const onInternalSelect = (date4, source) => {
        triggerChange(date4);
        emit("select", maybeToString(date4), {
          source
        });
      };
      const defaultLocale = computed(() => {
        const {
          locale: locale2
        } = props2;
        const result = _extends$1(_extends$1({}, locale$1), locale2);
        result.lang = _extends$1(_extends$1({}, result.lang), (locale2 || {}).lang);
        return result;
      });
      const [mergedLocale] = useLocaleReceiver("Calendar", defaultLocale);
      return () => {
        const today = generateConfig2.getNow();
        const {
          dateFullCellRender = slots === null || slots === void 0 ? void 0 : slots.dateFullCellRender,
          dateCellRender = slots === null || slots === void 0 ? void 0 : slots.dateCellRender,
          monthFullCellRender = slots === null || slots === void 0 ? void 0 : slots.monthFullCellRender,
          monthCellRender = slots === null || slots === void 0 ? void 0 : slots.monthCellRender,
          headerRender = slots === null || slots === void 0 ? void 0 : slots.headerRender,
          fullscreen = true,
          validRange
        } = props2;
        const dateRender = (_ref2) => {
          let {
            current: date4
          } = _ref2;
          if (dateFullCellRender) {
            return dateFullCellRender({
              current: date4
            });
          }
          return createVNode("div", {
            "class": classNames(`${prefixCls.value}-cell-inner`, `${calendarPrefixCls.value}-date`, {
              [`${calendarPrefixCls.value}-date-today`]: isSameDate2(today, date4)
            })
          }, [createVNode("div", {
            "class": `${calendarPrefixCls.value}-date-value`
          }, [String(generateConfig2.getDate(date4)).padStart(2, "0")]), createVNode("div", {
            "class": `${calendarPrefixCls.value}-date-content`
          }, [dateCellRender && dateCellRender({
            current: date4
          })])]);
        };
        const monthRender = (_ref3, locale2) => {
          let {
            current: date4
          } = _ref3;
          if (monthFullCellRender) {
            return monthFullCellRender({
              current: date4
            });
          }
          const months = locale2.shortMonths || generateConfig2.locale.getShortMonths(locale2.locale);
          return createVNode("div", {
            "class": classNames(`${prefixCls.value}-cell-inner`, `${calendarPrefixCls.value}-date`, {
              [`${calendarPrefixCls.value}-date-today`]: isSameMonth2(today, date4)
            })
          }, [createVNode("div", {
            "class": `${calendarPrefixCls.value}-date-value`
          }, [months[generateConfig2.getMonth(date4)]]), createVNode("div", {
            "class": `${calendarPrefixCls.value}-date-content`
          }, [monthCellRender && monthCellRender({
            current: date4
          })])]);
        };
        return wrapSSR(createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
          "class": classNames(calendarPrefixCls.value, {
            [`${calendarPrefixCls.value}-full`]: fullscreen,
            [`${calendarPrefixCls.value}-mini`]: !fullscreen,
            [`${calendarPrefixCls.value}-rtl`]: direction.value === "rtl"
          }, attrs.class, hashId.value)
        }), [headerRender ? headerRender({
          value: mergedValue.value,
          type: mergedMode.value,
          onChange: (nextDate) => {
            onInternalSelect(nextDate, "customize");
          },
          onTypeChange: triggerModeChange
        }) : createVNode(CalendarHeader, {
          "prefixCls": calendarPrefixCls.value,
          "value": mergedValue.value,
          "generateConfig": generateConfig2,
          "mode": mergedMode.value,
          "fullscreen": fullscreen,
          "locale": mergedLocale.value.lang,
          "validRange": validRange,
          "onChange": onInternalSelect,
          "onModeChange": triggerModeChange
        }, null), createVNode(PickerPanel$1, {
          "value": mergedValue.value,
          "prefixCls": prefixCls.value,
          "locale": mergedLocale.value.lang,
          "generateConfig": generateConfig2,
          "dateRender": dateRender,
          "monthCellRender": (obj) => monthRender(obj, mergedLocale.value.lang),
          "onSelect": (nextDate) => {
            onInternalSelect(nextDate, panelMode.value);
          },
          "mode": panelMode.value,
          "picker": panelMode.value,
          "disabledDate": mergedDisabledDate.value,
          "hideHeader": true
        }, null)]));
      };
    }
  });
  Calendar2.install = function(app) {
    app.component(Calendar2.name, Calendar2);
    return app;
  };
  return Calendar2;
}
const Calendar = generateCalendar(generateConfig);
const Calendar$1 = withInstall(Calendar);
function useRaf(callback) {
  const rafRef = shallowRef();
  const removedRef = shallowRef(false);
  function trigger() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (!removedRef.value) {
      wrapperRaf.cancel(rafRef.value);
      rafRef.value = wrapperRaf(() => {
        callback(...args);
      });
    }
  }
  onBeforeUnmount(() => {
    removedRef.value = true;
    wrapperRaf.cancel(rafRef.value);
  });
  return trigger;
}
function useRafState(defaultState) {
  const batchRef = shallowRef([]);
  const state = shallowRef(typeof defaultState === "function" ? defaultState() : defaultState);
  const flushUpdate = useRaf(() => {
    let value = state.value;
    batchRef.value.forEach((callback) => {
      value = callback(value);
    });
    batchRef.value = [];
    state.value = value;
  });
  function updater(callback) {
    batchRef.value.push(callback);
    flushUpdate();
  }
  return [state, updater];
}
const TabNode = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "TabNode",
  props: {
    id: {
      type: String
    },
    prefixCls: {
      type: String
    },
    tab: {
      type: Object
    },
    active: {
      type: Boolean
    },
    closable: {
      type: Boolean
    },
    editable: {
      type: Object
    },
    onClick: {
      type: Function
    },
    onResize: {
      type: Function
    },
    renderWrapper: {
      type: Function
    },
    removeAriaLabel: {
      type: String
    },
    // onRemove: { type: Function as PropType<() => void> },
    onFocus: {
      type: Function
    }
  },
  emits: ["click", "resize", "remove", "focus"],
  setup(props2, _ref) {
    let {
      expose,
      attrs
    } = _ref;
    const domRef = ref();
    function onInternalClick(e2) {
      var _a2;
      if ((_a2 = props2.tab) === null || _a2 === void 0 ? void 0 : _a2.disabled) {
        return;
      }
      props2.onClick(e2);
    }
    expose({
      domRef
    });
    function onRemoveTab(event) {
      var _a2;
      event.preventDefault();
      event.stopPropagation();
      props2.editable.onEdit("remove", {
        key: (_a2 = props2.tab) === null || _a2 === void 0 ? void 0 : _a2.key,
        event
      });
    }
    const removable = computed(() => {
      var _a2;
      return props2.editable && props2.closable !== false && !((_a2 = props2.tab) === null || _a2 === void 0 ? void 0 : _a2.disabled);
    });
    return () => {
      var _a2;
      const {
        prefixCls,
        id,
        active,
        tab: {
          key: key2,
          tab,
          disabled,
          closeIcon
        },
        renderWrapper,
        removeAriaLabel,
        editable,
        onFocus
      } = props2;
      const tabPrefix = `${prefixCls}-tab`;
      const node2 = createVNode("div", {
        "key": key2,
        "ref": domRef,
        "class": classNames(tabPrefix, {
          [`${tabPrefix}-with-remove`]: removable.value,
          [`${tabPrefix}-active`]: active,
          [`${tabPrefix}-disabled`]: disabled
        }),
        "style": attrs.style,
        "onClick": onInternalClick
      }, [createVNode("div", {
        "role": "tab",
        "aria-selected": active,
        "id": id && `${id}-tab-${key2}`,
        "class": `${tabPrefix}-btn`,
        "aria-controls": id && `${id}-panel-${key2}`,
        "aria-disabled": disabled,
        "tabindex": disabled ? null : 0,
        "onClick": (e2) => {
          e2.stopPropagation();
          onInternalClick(e2);
        },
        "onKeydown": (e2) => {
          if ([KeyCode.SPACE, KeyCode.ENTER].includes(e2.which)) {
            e2.preventDefault();
            onInternalClick(e2);
          }
        },
        "onFocus": onFocus
      }, [typeof tab === "function" ? tab() : tab]), removable.value && createVNode("button", {
        "type": "button",
        "aria-label": removeAriaLabel || "remove",
        "tabindex": 0,
        "class": `${tabPrefix}-remove`,
        "onClick": (e2) => {
          e2.stopPropagation();
          onRemoveTab(e2);
        }
      }, [(closeIcon === null || closeIcon === void 0 ? void 0 : closeIcon()) || ((_a2 = editable.removeIcon) === null || _a2 === void 0 ? void 0 : _a2.call(editable)) || "×"])]);
      return renderWrapper ? renderWrapper(node2) : node2;
    };
  }
});
const DEFAULT_SIZE$2 = {
  width: 0,
  height: 0,
  left: 0,
  top: 0
};
function useOffsets(tabs, tabSizes) {
  const offsetMap = ref(/* @__PURE__ */ new Map());
  watchEffect(() => {
    var _a2, _b;
    const map = /* @__PURE__ */ new Map();
    const tabsValue = tabs.value;
    const lastOffset = tabSizes.value.get((_a2 = tabsValue[0]) === null || _a2 === void 0 ? void 0 : _a2.key) || DEFAULT_SIZE$2;
    const rightOffset = lastOffset.left + lastOffset.width;
    for (let i2 = 0; i2 < tabsValue.length; i2 += 1) {
      const {
        key: key2
      } = tabsValue[i2];
      let data = tabSizes.value.get(key2);
      if (!data) {
        data = tabSizes.value.get((_b = tabsValue[i2 - 1]) === null || _b === void 0 ? void 0 : _b.key) || DEFAULT_SIZE$2;
      }
      const entity = map.get(key2) || _extends$1({}, data);
      entity.right = rightOffset - entity.left - entity.width;
      map.set(key2, entity);
    }
    offsetMap.value = new Map(map);
  });
  return offsetMap;
}
const AddButton = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AddButton",
  inheritAttrs: false,
  props: {
    prefixCls: String,
    editable: {
      type: Object
    },
    locale: {
      type: Object,
      default: void 0
    }
  },
  setup(props2, _ref) {
    let {
      expose,
      attrs
    } = _ref;
    const domRef = ref();
    expose({
      domRef
    });
    return () => {
      const {
        prefixCls,
        editable,
        locale: locale2
      } = props2;
      if (!editable || editable.showAdd === false) {
        return null;
      }
      return createVNode("button", {
        "ref": domRef,
        "type": "button",
        "class": `${prefixCls}-nav-add`,
        "style": attrs.style,
        "aria-label": (locale2 === null || locale2 === void 0 ? void 0 : locale2.addAriaLabel) || "Add tab",
        "onClick": (event) => {
          editable.onEdit("add", {
            event
          });
        }
      }, [editable.addIcon ? editable.addIcon() : "+"]);
    };
  }
});
const operationNodeProps = {
  prefixCls: {
    type: String
  },
  id: {
    type: String
  },
  tabs: {
    type: Object
  },
  rtl: {
    type: Boolean
  },
  tabBarGutter: {
    type: Number
  },
  activeKey: {
    type: [String, Number]
  },
  mobile: {
    type: Boolean
  },
  moreIcon: PropTypes.any,
  moreTransitionName: {
    type: String
  },
  editable: {
    type: Object
  },
  locale: {
    type: Object,
    default: void 0
  },
  removeAriaLabel: String,
  onTabClick: {
    type: Function
  },
  popupClassName: String,
  getPopupContainer: functionType()
};
const OperationNode = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "OperationNode",
  inheritAttrs: false,
  props: operationNodeProps,
  emits: ["tabClick"],
  slots: Object,
  setup(props2, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const [open2, setOpen] = useState(false);
    const [selectedKey, setSelectedKey] = useState(null);
    const selectOffset = (offset3) => {
      const enabledTabs = props2.tabs.filter((tab) => !tab.disabled);
      let selectedIndex = enabledTabs.findIndex((tab) => tab.key === selectedKey.value) || 0;
      const len = enabledTabs.length;
      for (let i2 = 0; i2 < len; i2 += 1) {
        selectedIndex = (selectedIndex + offset3 + len) % len;
        const tab = enabledTabs[selectedIndex];
        if (!tab.disabled) {
          setSelectedKey(tab.key);
          return;
        }
      }
    };
    const onKeyDown2 = (e2) => {
      const {
        which
      } = e2;
      if (!open2.value) {
        if ([KeyCode.DOWN, KeyCode.SPACE, KeyCode.ENTER].includes(which)) {
          setOpen(true);
          e2.preventDefault();
        }
        return;
      }
      switch (which) {
        case KeyCode.UP:
          selectOffset(-1);
          e2.preventDefault();
          break;
        case KeyCode.DOWN:
          selectOffset(1);
          e2.preventDefault();
          break;
        case KeyCode.ESC:
          setOpen(false);
          break;
        case KeyCode.SPACE:
        case KeyCode.ENTER:
          if (selectedKey.value !== null) props2.onTabClick(selectedKey.value, e2);
          break;
      }
    };
    const popupId = computed(() => `${props2.id}-more-popup`);
    const selectedItemId = computed(() => selectedKey.value !== null ? `${popupId.value}-${selectedKey.value}` : null);
    const onRemoveTab = (event, key2) => {
      event.preventDefault();
      event.stopPropagation();
      props2.editable.onEdit("remove", {
        key: key2,
        event
      });
    };
    onMounted(() => {
      watch(selectedKey, () => {
        const ele = document.getElementById(selectedItemId.value);
        if (ele && ele.scrollIntoView) {
          ele.scrollIntoView(false);
        }
      }, {
        flush: "post",
        immediate: true
      });
    });
    watch(open2, () => {
      if (!open2.value) {
        setSelectedKey(null);
      }
    });
    useProvideOverride({});
    return () => {
      var _a2;
      const {
        prefixCls,
        id,
        tabs,
        locale: locale2,
        mobile,
        moreIcon = ((_a2 = slots.moreIcon) === null || _a2 === void 0 ? void 0 : _a2.call(slots)) || createVNode(EllipsisOutlined, null, null),
        moreTransitionName,
        editable,
        tabBarGutter,
        rtl: rtl2,
        onTabClick,
        popupClassName
      } = props2;
      if (!tabs.length) return null;
      const dropdownPrefix = `${prefixCls}-dropdown`;
      const dropdownAriaLabel = locale2 === null || locale2 === void 0 ? void 0 : locale2.dropdownAriaLabel;
      const moreStyle = {
        [rtl2 ? "marginRight" : "marginLeft"]: tabBarGutter
      };
      if (!tabs.length) {
        moreStyle.visibility = "hidden";
        moreStyle.order = 1;
      }
      const overlayClassName = classNames({
        [`${dropdownPrefix}-rtl`]: rtl2,
        [`${popupClassName}`]: true
      });
      const moreNode = mobile ? null : createVNode(Dropdown$1, {
        "prefixCls": dropdownPrefix,
        "trigger": ["hover"],
        "visible": open2.value,
        "transitionName": moreTransitionName,
        "onVisibleChange": setOpen,
        "overlayClassName": overlayClassName,
        "mouseEnterDelay": 0.1,
        "mouseLeaveDelay": 0.1,
        "getPopupContainer": props2.getPopupContainer
      }, {
        overlay: () => createVNode(Menu, {
          "onClick": (_ref2) => {
            let {
              key: key2,
              domEvent
            } = _ref2;
            onTabClick(key2, domEvent);
            setOpen(false);
          },
          "id": popupId.value,
          "tabindex": -1,
          "role": "listbox",
          "aria-activedescendant": selectedItemId.value,
          "selectedKeys": [selectedKey.value],
          "aria-label": dropdownAriaLabel !== void 0 ? dropdownAriaLabel : "expanded dropdown"
        }, {
          default: () => [tabs.map((tab) => {
            var _a3, _b;
            const removable = editable && tab.closable !== false && !tab.disabled;
            return createVNode(MenuItem$1, {
              "key": tab.key,
              "id": `${popupId.value}-${tab.key}`,
              "role": "option",
              "aria-controls": id && `${id}-panel-${tab.key}`,
              "disabled": tab.disabled
            }, {
              default: () => [createVNode("span", null, [typeof tab.tab === "function" ? tab.tab() : tab.tab]), removable && createVNode("button", {
                "type": "button",
                "aria-label": props2.removeAriaLabel || "remove",
                "tabindex": 0,
                "class": `${dropdownPrefix}-menu-item-remove`,
                "onClick": (e2) => {
                  e2.stopPropagation();
                  onRemoveTab(e2, tab.key);
                }
              }, [((_a3 = tab.closeIcon) === null || _a3 === void 0 ? void 0 : _a3.call(tab)) || ((_b = editable.removeIcon) === null || _b === void 0 ? void 0 : _b.call(editable)) || "×"])]
            });
          })]
        }),
        default: () => createVNode("button", {
          "type": "button",
          "class": `${prefixCls}-nav-more`,
          "style": moreStyle,
          "tabindex": -1,
          "aria-hidden": "true",
          "aria-haspopup": "listbox",
          "aria-controls": popupId.value,
          "id": `${id}-more`,
          "aria-expanded": open2.value,
          "onKeydown": onKeyDown2
        }, [moreIcon])
      });
      return createVNode("div", {
        "class": classNames(`${prefixCls}-nav-operations`, attrs.class),
        "style": attrs.style
      }, [moreNode, createVNode(AddButton, {
        "prefixCls": prefixCls,
        "locale": locale2,
        "editable": editable
      }, null)]);
    };
  }
});
const TabsContextKey = Symbol("tabsContextKey");
const useProvideTabs = (props2) => {
  provide(TabsContextKey, props2);
};
const useInjectTabs = () => {
  return inject(TabsContextKey, {
    tabs: ref([]),
    prefixCls: ref()
  });
};
const MIN_SWIPE_DISTANCE = 0.1;
const STOP_SWIPE_DISTANCE = 0.01;
const REFRESH_INTERVAL = 20;
const SPEED_OFF_MULTIPLE = Math.pow(0.995, REFRESH_INTERVAL);
function useTouchMove(domRef, onOffset) {
  const [touchPosition, setTouchPosition] = useState();
  const [lastTimestamp, setLastTimestamp] = useState(0);
  const [lastTimeDiff, setLastTimeDiff] = useState(0);
  const [lastOffset, setLastOffset] = useState();
  const motionInterval = ref();
  function onTouchStart(e2) {
    const {
      screenX,
      screenY
    } = e2.touches[0];
    setTouchPosition({
      x: screenX,
      y: screenY
    });
    clearInterval(motionInterval.value);
  }
  function onTouchMove(e2) {
    if (!touchPosition.value) return;
    e2.preventDefault();
    const {
      screenX,
      screenY
    } = e2.touches[0];
    const offsetX = screenX - touchPosition.value.x;
    const offsetY = screenY - touchPosition.value.y;
    onOffset(offsetX, offsetY);
    setTouchPosition({
      x: screenX,
      y: screenY
    });
    const now2 = Date.now();
    setLastTimeDiff(now2 - lastTimestamp.value);
    setLastTimestamp(now2);
    setLastOffset({
      x: offsetX,
      y: offsetY
    });
  }
  function onTouchEnd() {
    if (!touchPosition.value) return;
    const lastOffsetValue = lastOffset.value;
    setTouchPosition(null);
    setLastOffset(null);
    if (lastOffsetValue) {
      const distanceX = lastOffsetValue.x / lastTimeDiff.value;
      const distanceY = lastOffsetValue.y / lastTimeDiff.value;
      const absX = Math.abs(distanceX);
      const absY = Math.abs(distanceY);
      if (Math.max(absX, absY) < MIN_SWIPE_DISTANCE) return;
      let currentX = distanceX;
      let currentY = distanceY;
      motionInterval.value = setInterval(() => {
        if (Math.abs(currentX) < STOP_SWIPE_DISTANCE && Math.abs(currentY) < STOP_SWIPE_DISTANCE) {
          clearInterval(motionInterval.value);
          return;
        }
        currentX *= SPEED_OFF_MULTIPLE;
        currentY *= SPEED_OFF_MULTIPLE;
        onOffset(currentX * REFRESH_INTERVAL, currentY * REFRESH_INTERVAL);
      }, REFRESH_INTERVAL);
    }
  }
  const lastWheelDirectionRef = ref();
  function onWheel(e2) {
    const {
      deltaX,
      deltaY
    } = e2;
    let mixed = 0;
    const absX = Math.abs(deltaX);
    const absY = Math.abs(deltaY);
    if (absX === absY) {
      mixed = lastWheelDirectionRef.value === "x" ? deltaX : deltaY;
    } else if (absX > absY) {
      mixed = deltaX;
      lastWheelDirectionRef.value = "x";
    } else {
      mixed = deltaY;
      lastWheelDirectionRef.value = "y";
    }
    if (onOffset(-mixed, -mixed)) {
      e2.preventDefault();
    }
  }
  const touchEventsRef = ref({
    onTouchStart,
    onTouchMove,
    onTouchEnd,
    onWheel
  });
  function onProxyTouchStart(e2) {
    touchEventsRef.value.onTouchStart(e2);
  }
  function onProxyTouchMove(e2) {
    touchEventsRef.value.onTouchMove(e2);
  }
  function onProxyTouchEnd(e2) {
    touchEventsRef.value.onTouchEnd(e2);
  }
  function onProxyWheel(e2) {
    touchEventsRef.value.onWheel(e2);
  }
  onMounted(() => {
    var _a2, _b;
    document.addEventListener("touchmove", onProxyTouchMove, {
      passive: false
    });
    document.addEventListener("touchend", onProxyTouchEnd, {
      passive: false
    });
    (_a2 = domRef.value) === null || _a2 === void 0 ? void 0 : _a2.addEventListener("touchstart", onProxyTouchStart, {
      passive: false
    });
    (_b = domRef.value) === null || _b === void 0 ? void 0 : _b.addEventListener("wheel", onProxyWheel, {
      passive: false
    });
  });
  onBeforeUnmount(() => {
    document.removeEventListener("touchmove", onProxyTouchMove);
    document.removeEventListener("touchend", onProxyTouchEnd);
  });
}
function useSyncState(defaultState, onChange) {
  const stateRef = ref(defaultState);
  function setState(updater) {
    const newValue = typeof updater === "function" ? updater(stateRef.value) : updater;
    if (newValue !== stateRef.value) {
      onChange(newValue, stateRef.value);
    }
    stateRef.value = newValue;
  }
  return [stateRef, setState];
}
const useRefs = () => {
  const refs = ref(/* @__PURE__ */ new Map());
  const setRef = (key2) => (el) => {
    refs.value.set(key2, el);
  };
  onBeforeUpdate(() => {
    refs.value = /* @__PURE__ */ new Map();
  });
  return [setRef, refs];
};
const DEFAULT_SIZE$1 = {
  width: 0,
  height: 0,
  left: 0,
  top: 0,
  right: 0
};
const tabNavListProps = () => {
  return {
    id: {
      type: String
    },
    tabPosition: {
      type: String
    },
    activeKey: {
      type: [String, Number]
    },
    rtl: {
      type: Boolean
    },
    animated: objectType(),
    editable: objectType(),
    moreIcon: PropTypes.any,
    moreTransitionName: {
      type: String
    },
    mobile: {
      type: Boolean
    },
    tabBarGutter: {
      type: Number
    },
    renderTabBar: {
      type: Function
    },
    locale: objectType(),
    popupClassName: String,
    getPopupContainer: functionType(),
    onTabClick: {
      type: Function
    },
    onTabScroll: {
      type: Function
    }
  };
};
const getTabSize = (tab, containerRect) => {
  const {
    offsetWidth,
    offsetHeight,
    offsetTop,
    offsetLeft
  } = tab;
  const {
    width,
    height,
    x: x2,
    y: y2
  } = tab.getBoundingClientRect();
  if (Math.abs(width - offsetWidth) < 1) {
    return [width, height, x2 - containerRect.x, y2 - containerRect.y];
  }
  return [offsetWidth, offsetHeight, offsetLeft, offsetTop];
};
const TabNavList = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "TabNavList",
  inheritAttrs: false,
  props: tabNavListProps(),
  slots: Object,
  emits: ["tabClick", "tabScroll"],
  setup(props2, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const {
      tabs,
      prefixCls
    } = useInjectTabs();
    const tabsWrapperRef = shallowRef();
    const tabListRef = shallowRef();
    const operationsRef = shallowRef();
    const innerAddButtonRef = shallowRef();
    const [setRef, btnRefs] = useRefs();
    const tabPositionTopOrBottom = computed(() => props2.tabPosition === "top" || props2.tabPosition === "bottom");
    const [transformLeft, setTransformLeft] = useSyncState(0, (next2, prev2) => {
      if (tabPositionTopOrBottom.value && props2.onTabScroll) {
        props2.onTabScroll({
          direction: next2 > prev2 ? "left" : "right"
        });
      }
    });
    const [transformTop, setTransformTop] = useSyncState(0, (next2, prev2) => {
      if (!tabPositionTopOrBottom.value && props2.onTabScroll) {
        props2.onTabScroll({
          direction: next2 > prev2 ? "top" : "bottom"
        });
      }
    });
    const [wrapperScrollWidth, setWrapperScrollWidth] = useState(0);
    const [wrapperScrollHeight, setWrapperScrollHeight] = useState(0);
    const [wrapperWidth, setWrapperWidth] = useState(null);
    const [wrapperHeight, setWrapperHeight] = useState(null);
    const [addWidth, setAddWidth] = useState(0);
    const [addHeight, setAddHeight] = useState(0);
    const [tabSizes, setTabSizes] = useRafState(/* @__PURE__ */ new Map());
    const tabOffsets = useOffsets(tabs, tabSizes);
    const operationsHiddenClassName = computed(() => `${prefixCls.value}-nav-operations-hidden`);
    const transformMin = shallowRef(0);
    const transformMax = shallowRef(0);
    watchEffect(() => {
      if (!tabPositionTopOrBottom.value) {
        transformMin.value = Math.min(0, wrapperHeight.value - wrapperScrollHeight.value);
        transformMax.value = 0;
      } else if (props2.rtl) {
        transformMin.value = 0;
        transformMax.value = Math.max(0, wrapperScrollWidth.value - wrapperWidth.value);
      } else {
        transformMin.value = Math.min(0, wrapperWidth.value - wrapperScrollWidth.value);
        transformMax.value = 0;
      }
    });
    const alignInRange = (value) => {
      if (value < transformMin.value) {
        return transformMin.value;
      }
      if (value > transformMax.value) {
        return transformMax.value;
      }
      return value;
    };
    const touchMovingRef = shallowRef();
    const [lockAnimation, setLockAnimation] = useState();
    const doLockAnimation = () => {
      setLockAnimation(Date.now());
    };
    const clearTouchMoving = () => {
      clearTimeout(touchMovingRef.value);
    };
    const doMove = (setState, offset3) => {
      setState((value) => {
        const newValue = alignInRange(value + offset3);
        return newValue;
      });
    };
    useTouchMove(tabsWrapperRef, (offsetX, offsetY) => {
      if (tabPositionTopOrBottom.value) {
        if (wrapperWidth.value >= wrapperScrollWidth.value) {
          return false;
        }
        doMove(setTransformLeft, offsetX);
      } else {
        if (wrapperHeight.value >= wrapperScrollHeight.value) {
          return false;
        }
        doMove(setTransformTop, offsetY);
      }
      clearTouchMoving();
      doLockAnimation();
      return true;
    });
    watch(lockAnimation, () => {
      clearTouchMoving();
      if (lockAnimation.value) {
        touchMovingRef.value = setTimeout(() => {
          setLockAnimation(0);
        }, 100);
      }
    });
    const scrollToTab = function() {
      let key2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : props2.activeKey;
      const tabOffset = tabOffsets.value.get(key2) || {
        width: 0,
        height: 0,
        left: 0,
        right: 0,
        top: 0
      };
      if (tabPositionTopOrBottom.value) {
        let newTransform = transformLeft.value;
        if (props2.rtl) {
          if (tabOffset.right < transformLeft.value) {
            newTransform = tabOffset.right;
          } else if (tabOffset.right + tabOffset.width > transformLeft.value + wrapperWidth.value) {
            newTransform = tabOffset.right + tabOffset.width - wrapperWidth.value;
          }
        } else if (tabOffset.left < -transformLeft.value) {
          newTransform = -tabOffset.left;
        } else if (tabOffset.left + tabOffset.width > -transformLeft.value + wrapperWidth.value) {
          newTransform = -(tabOffset.left + tabOffset.width - wrapperWidth.value);
        }
        setTransformTop(0);
        setTransformLeft(alignInRange(newTransform));
      } else {
        let newTransform = transformTop.value;
        if (tabOffset.top < -transformTop.value) {
          newTransform = -tabOffset.top;
        } else if (tabOffset.top + tabOffset.height > -transformTop.value + wrapperHeight.value) {
          newTransform = -(tabOffset.top + tabOffset.height - wrapperHeight.value);
        }
        setTransformLeft(0);
        setTransformTop(alignInRange(newTransform));
      }
    };
    const visibleStart = shallowRef(0);
    const visibleEnd = shallowRef(0);
    watchEffect(() => {
      let unit;
      let position2;
      let transformSize;
      let basicSize;
      let tabContentSize;
      let addSize;
      const tabOffsetsValue = tabOffsets.value;
      if (["top", "bottom"].includes(props2.tabPosition)) {
        unit = "width";
        basicSize = wrapperWidth.value;
        tabContentSize = wrapperScrollWidth.value;
        addSize = addWidth.value;
        position2 = props2.rtl ? "right" : "left";
        transformSize = Math.abs(transformLeft.value);
      } else {
        unit = "height";
        basicSize = wrapperHeight.value;
        tabContentSize = wrapperScrollWidth.value;
        addSize = addHeight.value;
        position2 = "top";
        transformSize = -transformTop.value;
      }
      let mergedBasicSize = basicSize;
      if (tabContentSize + addSize > basicSize && tabContentSize < basicSize) {
        mergedBasicSize = basicSize - addSize;
      }
      const tabsVal = tabs.value;
      if (!tabsVal.length) {
        return [visibleStart.value, visibleEnd.value] = [0, 0];
      }
      const len = tabsVal.length;
      let endIndex = len;
      for (let i2 = 0; i2 < len; i2 += 1) {
        const offset3 = tabOffsetsValue.get(tabsVal[i2].key) || DEFAULT_SIZE$1;
        if (offset3[position2] + offset3[unit] > transformSize + mergedBasicSize) {
          endIndex = i2 - 1;
          break;
        }
      }
      let startIndex = 0;
      for (let i2 = len - 1; i2 >= 0; i2 -= 1) {
        const offset3 = tabOffsetsValue.get(tabsVal[i2].key) || DEFAULT_SIZE$1;
        if (offset3[position2] < transformSize) {
          startIndex = i2 + 1;
          break;
        }
      }
      return [visibleStart.value, visibleEnd.value] = [startIndex, endIndex];
    });
    const updateTabSizes = () => {
      setTabSizes(() => {
        var _a2;
        const newSizes = /* @__PURE__ */ new Map();
        const listRect = (_a2 = tabListRef.value) === null || _a2 === void 0 ? void 0 : _a2.getBoundingClientRect();
        tabs.value.forEach((_ref2) => {
          let {
            key: key2
          } = _ref2;
          const btnRef = btnRefs.value.get(key2);
          const btnNode = (btnRef === null || btnRef === void 0 ? void 0 : btnRef.$el) || btnRef;
          if (btnNode) {
            const [width, height, left, top] = getTabSize(btnNode, listRect);
            newSizes.set(key2, {
              width,
              height,
              left,
              top
            });
          }
        });
        return newSizes;
      });
    };
    watch(() => tabs.value.map((tab) => tab.key).join("%%"), () => {
      updateTabSizes();
    }, {
      flush: "post"
    });
    const onListHolderResize = () => {
      var _a2, _b, _c, _d, _e;
      const offsetWidth = ((_a2 = tabsWrapperRef.value) === null || _a2 === void 0 ? void 0 : _a2.offsetWidth) || 0;
      const offsetHeight = ((_b = tabsWrapperRef.value) === null || _b === void 0 ? void 0 : _b.offsetHeight) || 0;
      const addDom = ((_c = innerAddButtonRef.value) === null || _c === void 0 ? void 0 : _c.$el) || {};
      const newAddWidth = addDom.offsetWidth || 0;
      const newAddHeight = addDom.offsetHeight || 0;
      setWrapperWidth(offsetWidth);
      setWrapperHeight(offsetHeight);
      setAddWidth(newAddWidth);
      setAddHeight(newAddHeight);
      const newWrapperScrollWidth = (((_d = tabListRef.value) === null || _d === void 0 ? void 0 : _d.offsetWidth) || 0) - newAddWidth;
      const newWrapperScrollHeight = (((_e = tabListRef.value) === null || _e === void 0 ? void 0 : _e.offsetHeight) || 0) - newAddHeight;
      setWrapperScrollWidth(newWrapperScrollWidth);
      setWrapperScrollHeight(newWrapperScrollHeight);
      updateTabSizes();
    };
    const hiddenTabs = computed(() => [...tabs.value.slice(0, visibleStart.value), ...tabs.value.slice(visibleEnd.value + 1)]);
    const [inkStyle, setInkStyle] = useState();
    const activeTabOffset = computed(() => tabOffsets.value.get(props2.activeKey));
    const inkBarRafRef = shallowRef();
    const cleanInkBarRaf = () => {
      wrapperRaf.cancel(inkBarRafRef.value);
    };
    watch([activeTabOffset, tabPositionTopOrBottom, () => props2.rtl], () => {
      const newInkStyle = {};
      if (activeTabOffset.value) {
        if (tabPositionTopOrBottom.value) {
          if (props2.rtl) {
            newInkStyle.right = toPx(activeTabOffset.value.right);
          } else {
            newInkStyle.left = toPx(activeTabOffset.value.left);
          }
          newInkStyle.width = toPx(activeTabOffset.value.width);
        } else {
          newInkStyle.top = toPx(activeTabOffset.value.top);
          newInkStyle.height = toPx(activeTabOffset.value.height);
        }
      }
      cleanInkBarRaf();
      inkBarRafRef.value = wrapperRaf(() => {
        setInkStyle(newInkStyle);
      });
    });
    watch([() => props2.activeKey, activeTabOffset, tabOffsets, tabPositionTopOrBottom], () => {
      scrollToTab();
    }, {
      flush: "post"
    });
    watch([() => props2.rtl, () => props2.tabBarGutter, () => props2.activeKey, () => tabs.value], () => {
      onListHolderResize();
    }, {
      flush: "post"
    });
    const ExtraContent = (_ref3) => {
      let {
        position: position2,
        prefixCls: prefixCls2,
        extra
      } = _ref3;
      if (!extra) return null;
      const content = extra === null || extra === void 0 ? void 0 : extra({
        position: position2
      });
      return content ? createVNode("div", {
        "class": `${prefixCls2}-extra-content`
      }, [content]) : null;
    };
    onBeforeUnmount(() => {
      clearTouchMoving();
      cleanInkBarRaf();
    });
    return () => {
      const {
        id,
        animated,
        activeKey,
        rtl: rtl2,
        editable,
        locale: locale2,
        tabPosition,
        tabBarGutter,
        onTabClick
      } = props2;
      const {
        class: className,
        style
      } = attrs;
      const pre = prefixCls.value;
      const hasDropdown = !!hiddenTabs.value.length;
      const wrapPrefix = `${pre}-nav-wrap`;
      let pingLeft;
      let pingRight;
      let pingTop;
      let pingBottom;
      if (tabPositionTopOrBottom.value) {
        if (rtl2) {
          pingRight = transformLeft.value > 0;
          pingLeft = transformLeft.value + wrapperWidth.value < wrapperScrollWidth.value;
        } else {
          pingLeft = transformLeft.value < 0;
          pingRight = -transformLeft.value + wrapperWidth.value < wrapperScrollWidth.value;
        }
      } else {
        pingTop = transformTop.value < 0;
        pingBottom = -transformTop.value + wrapperHeight.value < wrapperScrollHeight.value;
      }
      const tabNodeStyle = {};
      if (tabPosition === "top" || tabPosition === "bottom") {
        tabNodeStyle[rtl2 ? "marginRight" : "marginLeft"] = typeof tabBarGutter === "number" ? `${tabBarGutter}px` : tabBarGutter;
      } else {
        tabNodeStyle.marginTop = typeof tabBarGutter === "number" ? `${tabBarGutter}px` : tabBarGutter;
      }
      const tabNodes = tabs.value.map((tab, i2) => {
        const {
          key: key2
        } = tab;
        return createVNode(TabNode, {
          "id": id,
          "prefixCls": pre,
          "key": key2,
          "tab": tab,
          "style": i2 === 0 ? void 0 : tabNodeStyle,
          "closable": tab.closable,
          "editable": editable,
          "active": key2 === activeKey,
          "removeAriaLabel": locale2 === null || locale2 === void 0 ? void 0 : locale2.removeAriaLabel,
          "ref": setRef(key2),
          "onClick": (e2) => {
            onTabClick(key2, e2);
          },
          "onFocus": () => {
            scrollToTab(key2);
            doLockAnimation();
            if (!tabsWrapperRef.value) {
              return;
            }
            if (!rtl2) {
              tabsWrapperRef.value.scrollLeft = 0;
            }
            tabsWrapperRef.value.scrollTop = 0;
          }
        }, slots);
      });
      return createVNode("div", {
        "role": "tablist",
        "class": classNames(`${pre}-nav`, className),
        "style": style,
        "onKeydown": () => {
          doLockAnimation();
        }
      }, [createVNode(ExtraContent, {
        "position": "left",
        "prefixCls": pre,
        "extra": slots.leftExtra
      }, null), createVNode(ResizeObserver$1, {
        "onResize": onListHolderResize
      }, {
        default: () => [createVNode("div", {
          "class": classNames(wrapPrefix, {
            [`${wrapPrefix}-ping-left`]: pingLeft,
            [`${wrapPrefix}-ping-right`]: pingRight,
            [`${wrapPrefix}-ping-top`]: pingTop,
            [`${wrapPrefix}-ping-bottom`]: pingBottom
          }),
          "ref": tabsWrapperRef
        }, [createVNode(ResizeObserver$1, {
          "onResize": onListHolderResize
        }, {
          default: () => [createVNode("div", {
            "ref": tabListRef,
            "class": `${pre}-nav-list`,
            "style": {
              transform: `translate(${transformLeft.value}px, ${transformTop.value}px)`,
              transition: lockAnimation.value ? "none" : void 0
            }
          }, [tabNodes, createVNode(AddButton, {
            "ref": innerAddButtonRef,
            "prefixCls": pre,
            "locale": locale2,
            "editable": editable,
            "style": _extends$1(_extends$1({}, tabNodes.length === 0 ? void 0 : tabNodeStyle), {
              visibility: hasDropdown ? "hidden" : null
            })
          }, null), createVNode("div", {
            "class": classNames(`${pre}-ink-bar`, {
              [`${pre}-ink-bar-animated`]: animated.inkBar
            }),
            "style": inkStyle.value
          }, null)])]
        })])]
      }), createVNode(OperationNode, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
        "removeAriaLabel": locale2 === null || locale2 === void 0 ? void 0 : locale2.removeAriaLabel,
        "ref": operationsRef,
        "prefixCls": pre,
        "tabs": hiddenTabs.value,
        "class": !hasDropdown && operationsHiddenClassName.value
      }), pick(slots, ["moreIcon"])), createVNode(ExtraContent, {
        "position": "right",
        "prefixCls": pre,
        "extra": slots.rightExtra
      }, null), createVNode(ExtraContent, {
        "position": "right",
        "prefixCls": pre,
        "extra": slots.tabBarExtraContent
      }, null)]);
    };
  }
});
const TabPanelList = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "TabPanelList",
  inheritAttrs: false,
  props: {
    activeKey: {
      type: [String, Number]
    },
    id: {
      type: String
    },
    rtl: {
      type: Boolean
    },
    animated: {
      type: Object,
      default: void 0
    },
    tabPosition: {
      type: String
    },
    destroyInactiveTabPane: {
      type: Boolean
    }
  },
  setup(props2) {
    const {
      tabs,
      prefixCls
    } = useInjectTabs();
    return () => {
      const {
        id,
        activeKey,
        animated,
        tabPosition,
        rtl: rtl2,
        destroyInactiveTabPane
      } = props2;
      const tabPaneAnimated = animated.tabPane;
      const pre = prefixCls.value;
      const activeIndex = tabs.value.findIndex((tab) => tab.key === activeKey);
      return createVNode("div", {
        "class": `${pre}-content-holder`
      }, [createVNode("div", {
        "class": [`${pre}-content`, `${pre}-content-${tabPosition}`, {
          [`${pre}-content-animated`]: tabPaneAnimated
        }],
        "style": activeIndex && tabPaneAnimated ? {
          [rtl2 ? "marginRight" : "marginLeft"]: `-${activeIndex}00%`
        } : null
      }, [tabs.value.map((tab) => {
        return cloneElement(tab.node, {
          key: tab.key,
          prefixCls: pre,
          tabKey: tab.key,
          id,
          animated: tabPaneAnimated,
          active: tab.key === activeKey,
          destroyInactiveTabPane
        });
      })])]);
    };
  }
});
const genMotionStyle$2 = (token2) => {
  const {
    componentCls,
    motionDurationSlow
  } = token2;
  return [
    {
      [componentCls]: {
        [`${componentCls}-switch`]: {
          "&-appear, &-enter": {
            transition: "none",
            "&-start": {
              opacity: 0
            },
            "&-active": {
              opacity: 1,
              transition: `opacity ${motionDurationSlow}`
            }
          },
          "&-leave": {
            position: "absolute",
            transition: "none",
            inset: 0,
            "&-start": {
              opacity: 1
            },
            "&-active": {
              opacity: 0,
              transition: `opacity ${motionDurationSlow}`
            }
          }
        }
      }
    },
    // Follow code may reuse in other components
    [initSlideMotion(token2, "slide-up"), initSlideMotion(token2, "slide-down")]
  ];
};
const genCardStyle$1 = (token2) => {
  const {
    componentCls,
    tabsCardHorizontalPadding,
    tabsCardHeadBackground,
    tabsCardGutter,
    colorSplit
  } = token2;
  return {
    [`${componentCls}-card`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        [`${componentCls}-tab`]: {
          margin: 0,
          padding: tabsCardHorizontalPadding,
          background: tabsCardHeadBackground,
          border: `${token2.lineWidth}px ${token2.lineType} ${colorSplit}`,
          transition: `all ${token2.motionDurationSlow} ${token2.motionEaseInOut}`
        },
        [`${componentCls}-tab-active`]: {
          color: token2.colorPrimary,
          background: token2.colorBgContainer
        },
        [`${componentCls}-ink-bar`]: {
          visibility: "hidden"
        }
      },
      // ========================== Top & Bottom ==========================
      [`&${componentCls}-top, &${componentCls}-bottom`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab + ${componentCls}-tab`]: {
            marginLeft: {
              _skip_check_: true,
              value: `${tabsCardGutter}px`
            }
          }
        }
      },
      [`&${componentCls}-top`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            borderRadius: `${token2.borderRadiusLG}px ${token2.borderRadiusLG}px 0 0`
          },
          [`${componentCls}-tab-active`]: {
            borderBottomColor: token2.colorBgContainer
          }
        }
      },
      [`&${componentCls}-bottom`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            borderRadius: `0 0 ${token2.borderRadiusLG}px ${token2.borderRadiusLG}px`
          },
          [`${componentCls}-tab-active`]: {
            borderTopColor: token2.colorBgContainer
          }
        }
      },
      // ========================== Left & Right ==========================
      [`&${componentCls}-left, &${componentCls}-right`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab + ${componentCls}-tab`]: {
            marginTop: `${tabsCardGutter}px`
          }
        }
      },
      [`&${componentCls}-left`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            borderRadius: {
              _skip_check_: true,
              value: `${token2.borderRadiusLG}px 0 0 ${token2.borderRadiusLG}px`
            }
          },
          [`${componentCls}-tab-active`]: {
            borderRightColor: {
              _skip_check_: true,
              value: token2.colorBgContainer
            }
          }
        }
      },
      [`&${componentCls}-right`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            borderRadius: {
              _skip_check_: true,
              value: `0 ${token2.borderRadiusLG}px ${token2.borderRadiusLG}px 0`
            }
          },
          [`${componentCls}-tab-active`]: {
            borderLeftColor: {
              _skip_check_: true,
              value: token2.colorBgContainer
            }
          }
        }
      }
    }
  };
};
const genDropdownStyle = (token2) => {
  const {
    componentCls,
    tabsHoverColor,
    dropdownEdgeChildVerticalPadding
  } = token2;
  return {
    [`${componentCls}-dropdown`]: _extends$1(_extends$1({}, resetComponent(token2)), {
      position: "absolute",
      top: -9999,
      left: {
        _skip_check_: true,
        value: -9999
      },
      zIndex: token2.zIndexPopup,
      display: "block",
      "&-hidden": {
        display: "none"
      },
      [`${componentCls}-dropdown-menu`]: {
        maxHeight: token2.tabsDropdownHeight,
        margin: 0,
        padding: `${dropdownEdgeChildVerticalPadding}px 0`,
        overflowX: "hidden",
        overflowY: "auto",
        textAlign: {
          _skip_check_: true,
          value: "left"
        },
        listStyleType: "none",
        backgroundColor: token2.colorBgContainer,
        backgroundClip: "padding-box",
        borderRadius: token2.borderRadiusLG,
        outline: "none",
        boxShadow: token2.boxShadowSecondary,
        "&-item": _extends$1(_extends$1({}, textEllipsis), {
          display: "flex",
          alignItems: "center",
          minWidth: token2.tabsDropdownWidth,
          margin: 0,
          padding: `${token2.paddingXXS}px ${token2.paddingSM}px`,
          color: token2.colorText,
          fontWeight: "normal",
          fontSize: token2.fontSize,
          lineHeight: token2.lineHeight,
          cursor: "pointer",
          transition: `all ${token2.motionDurationSlow}`,
          "> span": {
            flex: 1,
            whiteSpace: "nowrap"
          },
          "&-remove": {
            flex: "none",
            marginLeft: {
              _skip_check_: true,
              value: token2.marginSM
            },
            color: token2.colorTextDescription,
            fontSize: token2.fontSizeSM,
            background: "transparent",
            border: 0,
            cursor: "pointer",
            "&:hover": {
              color: tabsHoverColor
            }
          },
          "&:hover": {
            background: token2.controlItemBgHover
          },
          "&-disabled": {
            "&, &:hover": {
              color: token2.colorTextDisabled,
              background: "transparent",
              cursor: "not-allowed"
            }
          }
        })
      }
    })
  };
};
const genPositionStyle = (token2) => {
  const {
    componentCls,
    margin,
    colorSplit
  } = token2;
  return {
    // ========================== Top & Bottom ==========================
    [`${componentCls}-top, ${componentCls}-bottom`]: {
      flexDirection: "column",
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        margin: `0 0 ${margin}px 0`,
        "&::before": {
          position: "absolute",
          right: {
            _skip_check_: true,
            value: 0
          },
          left: {
            _skip_check_: true,
            value: 0
          },
          borderBottom: `${token2.lineWidth}px ${token2.lineType} ${colorSplit}`,
          content: "''"
        },
        [`${componentCls}-ink-bar`]: {
          height: token2.lineWidthBold,
          "&-animated": {
            transition: `width ${token2.motionDurationSlow}, left ${token2.motionDurationSlow},
            right ${token2.motionDurationSlow}`
          }
        },
        [`${componentCls}-nav-wrap`]: {
          "&::before, &::after": {
            top: 0,
            bottom: 0,
            width: token2.controlHeight
          },
          "&::before": {
            left: {
              _skip_check_: true,
              value: 0
            },
            boxShadow: token2.boxShadowTabsOverflowLeft
          },
          "&::after": {
            right: {
              _skip_check_: true,
              value: 0
            },
            boxShadow: token2.boxShadowTabsOverflowRight
          },
          [`&${componentCls}-nav-wrap-ping-left::before`]: {
            opacity: 1
          },
          [`&${componentCls}-nav-wrap-ping-right::after`]: {
            opacity: 1
          }
        }
      }
    },
    [`${componentCls}-top`]: {
      [`> ${componentCls}-nav,
        > div > ${componentCls}-nav`]: {
        "&::before": {
          bottom: 0
        },
        [`${componentCls}-ink-bar`]: {
          bottom: 0
        }
      }
    },
    [`${componentCls}-bottom`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        order: 1,
        marginTop: `${margin}px`,
        marginBottom: 0,
        "&::before": {
          top: 0
        },
        [`${componentCls}-ink-bar`]: {
          top: 0
        }
      },
      [`> ${componentCls}-content-holder, > div > ${componentCls}-content-holder`]: {
        order: 0
      }
    },
    // ========================== Left & Right ==========================
    [`${componentCls}-left, ${componentCls}-right`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        flexDirection: "column",
        minWidth: token2.controlHeight * 1.25,
        // >>>>>>>>>>> Tab
        [`${componentCls}-tab`]: {
          padding: `${token2.paddingXS}px ${token2.paddingLG}px`,
          textAlign: "center"
        },
        [`${componentCls}-tab + ${componentCls}-tab`]: {
          margin: `${token2.margin}px 0 0 0`
        },
        // >>>>>>>>>>> Nav
        [`${componentCls}-nav-wrap`]: {
          flexDirection: "column",
          "&::before, &::after": {
            right: {
              _skip_check_: true,
              value: 0
            },
            left: {
              _skip_check_: true,
              value: 0
            },
            height: token2.controlHeight
          },
          "&::before": {
            top: 0,
            boxShadow: token2.boxShadowTabsOverflowTop
          },
          "&::after": {
            bottom: 0,
            boxShadow: token2.boxShadowTabsOverflowBottom
          },
          [`&${componentCls}-nav-wrap-ping-top::before`]: {
            opacity: 1
          },
          [`&${componentCls}-nav-wrap-ping-bottom::after`]: {
            opacity: 1
          }
        },
        // >>>>>>>>>>> Ink Bar
        [`${componentCls}-ink-bar`]: {
          width: token2.lineWidthBold,
          "&-animated": {
            transition: `height ${token2.motionDurationSlow}, top ${token2.motionDurationSlow}`
          }
        },
        [`${componentCls}-nav-list, ${componentCls}-nav-operations`]: {
          flex: "1 0 auto",
          flexDirection: "column"
        }
      }
    },
    [`${componentCls}-left`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        [`${componentCls}-ink-bar`]: {
          right: {
            _skip_check_: true,
            value: 0
          }
        }
      },
      [`> ${componentCls}-content-holder, > div > ${componentCls}-content-holder`]: {
        marginLeft: {
          _skip_check_: true,
          value: `-${token2.lineWidth}px`
        },
        borderLeft: {
          _skip_check_: true,
          value: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`
        },
        [`> ${componentCls}-content > ${componentCls}-tabpane`]: {
          paddingLeft: {
            _skip_check_: true,
            value: token2.paddingLG
          }
        }
      }
    },
    [`${componentCls}-right`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        order: 1,
        [`${componentCls}-ink-bar`]: {
          left: {
            _skip_check_: true,
            value: 0
          }
        }
      },
      [`> ${componentCls}-content-holder, > div > ${componentCls}-content-holder`]: {
        order: 0,
        marginRight: {
          _skip_check_: true,
          value: -token2.lineWidth
        },
        borderRight: {
          _skip_check_: true,
          value: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`
        },
        [`> ${componentCls}-content > ${componentCls}-tabpane`]: {
          paddingRight: {
            _skip_check_: true,
            value: token2.paddingLG
          }
        }
      }
    }
  };
};
const genSizeStyle$1 = (token2) => {
  const {
    componentCls,
    padding
  } = token2;
  return {
    [componentCls]: {
      "&-small": {
        [`> ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            padding: `${token2.paddingXS}px 0`,
            fontSize: token2.fontSize
          }
        }
      },
      "&-large": {
        [`> ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            padding: `${padding}px 0`,
            fontSize: token2.fontSizeLG
          }
        }
      }
    },
    [`${componentCls}-card`]: {
      [`&${componentCls}-small`]: {
        [`> ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            padding: `${token2.paddingXXS * 1.5}px ${padding}px`
          }
        },
        [`&${componentCls}-bottom`]: {
          [`> ${componentCls}-nav ${componentCls}-tab`]: {
            borderRadius: `0 0 ${token2.borderRadius}px ${token2.borderRadius}px`
          }
        },
        [`&${componentCls}-top`]: {
          [`> ${componentCls}-nav ${componentCls}-tab`]: {
            borderRadius: `${token2.borderRadius}px ${token2.borderRadius}px 0 0`
          }
        },
        [`&${componentCls}-right`]: {
          [`> ${componentCls}-nav ${componentCls}-tab`]: {
            borderRadius: {
              _skip_check_: true,
              value: `0 ${token2.borderRadius}px ${token2.borderRadius}px 0`
            }
          }
        },
        [`&${componentCls}-left`]: {
          [`> ${componentCls}-nav ${componentCls}-tab`]: {
            borderRadius: {
              _skip_check_: true,
              value: `${token2.borderRadius}px 0 0 ${token2.borderRadius}px`
            }
          }
        }
      },
      [`&${componentCls}-large`]: {
        [`> ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            padding: `${token2.paddingXS}px ${padding}px ${token2.paddingXXS * 1.5}px`
          }
        }
      }
    }
  };
};
const genTabStyle = (token2) => {
  const {
    componentCls,
    tabsActiveColor,
    tabsHoverColor,
    iconCls,
    tabsHorizontalGutter
  } = token2;
  const tabCls = `${componentCls}-tab`;
  return {
    [tabCls]: {
      position: "relative",
      display: "inline-flex",
      alignItems: "center",
      padding: `${token2.paddingSM}px 0`,
      fontSize: `${token2.fontSize}px`,
      background: "transparent",
      border: 0,
      outline: "none",
      cursor: "pointer",
      "&-btn, &-remove": _extends$1({
        "&:focus:not(:focus-visible), &:active": {
          color: tabsActiveColor
        }
      }, genFocusStyle(token2)),
      "&-btn": {
        outline: "none",
        transition: "all 0.3s"
      },
      "&-remove": {
        flex: "none",
        marginRight: {
          _skip_check_: true,
          value: -token2.marginXXS
        },
        marginLeft: {
          _skip_check_: true,
          value: token2.marginXS
        },
        color: token2.colorTextDescription,
        fontSize: token2.fontSizeSM,
        background: "transparent",
        border: "none",
        outline: "none",
        cursor: "pointer",
        transition: `all ${token2.motionDurationSlow}`,
        "&:hover": {
          color: token2.colorTextHeading
        }
      },
      "&:hover": {
        color: tabsHoverColor
      },
      [`&${tabCls}-active ${tabCls}-btn`]: {
        color: token2.colorPrimary,
        textShadow: token2.tabsActiveTextShadow
      },
      [`&${tabCls}-disabled`]: {
        color: token2.colorTextDisabled,
        cursor: "not-allowed"
      },
      [`&${tabCls}-disabled ${tabCls}-btn, &${tabCls}-disabled ${componentCls}-remove`]: {
        "&:focus, &:active": {
          color: token2.colorTextDisabled
        }
      },
      [`& ${tabCls}-remove ${iconCls}`]: {
        margin: 0
      },
      [iconCls]: {
        marginRight: {
          _skip_check_: true,
          value: token2.marginSM
        }
      }
    },
    [`${tabCls} + ${tabCls}`]: {
      margin: {
        _skip_check_: true,
        value: `0 0 0 ${tabsHorizontalGutter}px`
      }
    }
  };
};
const genRtlStyle$1 = (token2) => {
  const {
    componentCls,
    tabsHorizontalGutter,
    iconCls,
    tabsCardGutter
  } = token2;
  const rtlCls = `${componentCls}-rtl`;
  return {
    [rtlCls]: {
      direction: "rtl",
      [`${componentCls}-nav`]: {
        [`${componentCls}-tab`]: {
          margin: {
            _skip_check_: true,
            value: `0 0 0 ${tabsHorizontalGutter}px`
          },
          [`${componentCls}-tab:last-of-type`]: {
            marginLeft: {
              _skip_check_: true,
              value: 0
            }
          },
          [iconCls]: {
            marginRight: {
              _skip_check_: true,
              value: 0
            },
            marginLeft: {
              _skip_check_: true,
              value: `${token2.marginSM}px`
            }
          },
          [`${componentCls}-tab-remove`]: {
            marginRight: {
              _skip_check_: true,
              value: `${token2.marginXS}px`
            },
            marginLeft: {
              _skip_check_: true,
              value: `-${token2.marginXXS}px`
            },
            [iconCls]: {
              margin: 0
            }
          }
        }
      },
      [`&${componentCls}-left`]: {
        [`> ${componentCls}-nav`]: {
          order: 1
        },
        [`> ${componentCls}-content-holder`]: {
          order: 0
        }
      },
      [`&${componentCls}-right`]: {
        [`> ${componentCls}-nav`]: {
          order: 0
        },
        [`> ${componentCls}-content-holder`]: {
          order: 1
        }
      },
      // ====================== Card ======================
      [`&${componentCls}-card${componentCls}-top, &${componentCls}-card${componentCls}-bottom`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab + ${componentCls}-tab`]: {
            marginRight: {
              _skip_check_: true,
              value: `${tabsCardGutter}px`
            },
            marginLeft: {
              _skip_check_: true,
              value: 0
            }
          }
        }
      }
    },
    [`${componentCls}-dropdown-rtl`]: {
      direction: "rtl"
    },
    [`${componentCls}-menu-item`]: {
      [`${componentCls}-dropdown-rtl`]: {
        textAlign: {
          _skip_check_: true,
          value: "right"
        }
      }
    }
  };
};
const genTabsStyle = (token2) => {
  const {
    componentCls,
    tabsCardHorizontalPadding,
    tabsCardHeight,
    tabsCardGutter,
    tabsHoverColor,
    tabsActiveColor,
    colorSplit
  } = token2;
  return {
    [componentCls]: _extends$1(_extends$1(_extends$1(_extends$1({}, resetComponent(token2)), {
      display: "flex",
      // ========================== Navigation ==========================
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        position: "relative",
        display: "flex",
        flex: "none",
        alignItems: "center",
        [`${componentCls}-nav-wrap`]: {
          position: "relative",
          display: "flex",
          flex: "auto",
          alignSelf: "stretch",
          overflow: "hidden",
          whiteSpace: "nowrap",
          transform: "translate(0)",
          // >>>>> Ping shadow
          "&::before, &::after": {
            position: "absolute",
            zIndex: 1,
            opacity: 0,
            transition: `opacity ${token2.motionDurationSlow}`,
            content: "''",
            pointerEvents: "none"
          }
        },
        [`${componentCls}-nav-list`]: {
          position: "relative",
          display: "flex",
          transition: `opacity ${token2.motionDurationSlow}`
        },
        // >>>>>>>> Operations
        [`${componentCls}-nav-operations`]: {
          display: "flex",
          alignSelf: "stretch"
        },
        [`${componentCls}-nav-operations-hidden`]: {
          position: "absolute",
          visibility: "hidden",
          pointerEvents: "none"
        },
        [`${componentCls}-nav-more`]: {
          position: "relative",
          padding: tabsCardHorizontalPadding,
          background: "transparent",
          border: 0,
          "&::after": {
            position: "absolute",
            right: {
              _skip_check_: true,
              value: 0
            },
            bottom: 0,
            left: {
              _skip_check_: true,
              value: 0
            },
            height: token2.controlHeightLG / 8,
            transform: "translateY(100%)",
            content: "''"
          }
        },
        [`${componentCls}-nav-add`]: _extends$1({
          minWidth: `${tabsCardHeight}px`,
          marginLeft: {
            _skip_check_: true,
            value: `${tabsCardGutter}px`
          },
          padding: `0 ${token2.paddingXS}px`,
          background: "transparent",
          border: `${token2.lineWidth}px ${token2.lineType} ${colorSplit}`,
          borderRadius: `${token2.borderRadiusLG}px ${token2.borderRadiusLG}px 0 0`,
          outline: "none",
          cursor: "pointer",
          color: token2.colorText,
          transition: `all ${token2.motionDurationSlow} ${token2.motionEaseInOut}`,
          "&:hover": {
            color: tabsHoverColor
          },
          "&:active, &:focus:not(:focus-visible)": {
            color: tabsActiveColor
          }
        }, genFocusStyle(token2))
      },
      [`${componentCls}-extra-content`]: {
        flex: "none"
      },
      // ============================ InkBar ============================
      [`${componentCls}-ink-bar`]: {
        position: "absolute",
        background: token2.colorPrimary,
        pointerEvents: "none"
      }
    }), genTabStyle(token2)), {
      // =========================== TabPanes ===========================
      [`${componentCls}-content`]: {
        position: "relative",
        display: "flex",
        width: "100%",
        ["&-animated"]: {
          transition: "margin 0.3s"
        }
      },
      [`${componentCls}-content-holder`]: {
        flex: "auto",
        minWidth: 0,
        minHeight: 0
      },
      [`${componentCls}-tabpane`]: {
        outline: "none",
        flex: "none",
        width: "100%"
      }
    }),
    [`${componentCls}-centered`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        [`${componentCls}-nav-wrap`]: {
          [`&:not([class*='${componentCls}-nav-wrap-ping'])`]: {
            justifyContent: "center"
          }
        }
      }
    }
  };
};
const useStyle$t = genComponentStyleHook("Tabs", (token2) => {
  const tabsCardHeight = token2.controlHeightLG;
  const tabsToken = merge(token2, {
    tabsHoverColor: token2.colorPrimaryHover,
    tabsActiveColor: token2.colorPrimaryActive,
    tabsCardHorizontalPadding: `${(tabsCardHeight - Math.round(token2.fontSize * token2.lineHeight)) / 2 - token2.lineWidth}px ${token2.padding}px`,
    tabsCardHeight,
    tabsCardGutter: token2.marginXXS / 2,
    tabsHorizontalGutter: 32,
    tabsCardHeadBackground: token2.colorFillAlter,
    dropdownEdgeChildVerticalPadding: token2.paddingXXS,
    tabsActiveTextShadow: "0 0 0.25px currentcolor",
    tabsDropdownHeight: 200,
    tabsDropdownWidth: 120
  });
  return [genSizeStyle$1(tabsToken), genRtlStyle$1(tabsToken), genPositionStyle(tabsToken), genDropdownStyle(tabsToken), genCardStyle$1(tabsToken), genTabsStyle(tabsToken), genMotionStyle$2(tabsToken)];
}, (token2) => ({
  zIndexPopup: token2.zIndexPopupBase + 50
}));
let uuid$3 = 0;
const tabsProps = () => {
  return {
    prefixCls: {
      type: String
    },
    id: {
      type: String
    },
    popupClassName: String,
    getPopupContainer: functionType(),
    activeKey: {
      type: [String, Number]
    },
    defaultActiveKey: {
      type: [String, Number]
    },
    direction: stringType(),
    animated: someType([Boolean, Object]),
    renderTabBar: functionType(),
    tabBarGutter: {
      type: Number
    },
    tabBarStyle: objectType(),
    tabPosition: stringType(),
    destroyInactiveTabPane: booleanType(),
    hideAdd: Boolean,
    type: stringType(),
    size: stringType(),
    centered: Boolean,
    onEdit: functionType(),
    onChange: functionType(),
    onTabClick: functionType(),
    onTabScroll: functionType(),
    "onUpdate:activeKey": functionType(),
    // Accessibility
    locale: objectType(),
    onPrevClick: functionType(),
    onNextClick: functionType(),
    tabBarExtraContent: PropTypes.any
  };
};
function parseTabList(children) {
  return children.map((node2) => {
    if (isValidElement(node2)) {
      const props2 = _extends$1({}, node2.props || {});
      for (const [k2, v2] of Object.entries(props2)) {
        delete props2[k2];
        props2[camelize(k2)] = v2;
      }
      const slots = node2.children || {};
      const key2 = node2.key !== void 0 ? node2.key : void 0;
      const {
        tab = slots.tab,
        disabled,
        forceRender,
        closable,
        animated,
        active,
        destroyInactiveTabPane
      } = props2;
      return _extends$1(_extends$1({
        key: key2
      }, props2), {
        node: node2,
        closeIcon: slots.closeIcon,
        tab,
        disabled: disabled === "" || disabled,
        forceRender: forceRender === "" || forceRender,
        closable: closable === "" || closable,
        animated: animated === "" || animated,
        active: active === "" || active,
        destroyInactiveTabPane: destroyInactiveTabPane === "" || destroyInactiveTabPane
      });
    }
    return null;
  }).filter((tab) => tab);
}
const InternalTabs = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "InternalTabs",
  inheritAttrs: false,
  props: _extends$1(_extends$1({}, initDefaultProps(tabsProps(), {
    tabPosition: "top",
    animated: {
      inkBar: true,
      tabPane: false
    }
  })), {
    tabs: arrayType()
  }),
  slots: Object,
  // emits: ['tabClick', 'tabScroll', 'change', 'update:activeKey'],
  setup(props2, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    devWarning(!(props2.onPrevClick !== void 0) && !(props2.onNextClick !== void 0), "Tabs", "`onPrevClick / @prevClick` and `onNextClick / @nextClick` has been removed. Please use `onTabScroll / @tabScroll` instead.");
    devWarning(!(props2.tabBarExtraContent !== void 0), "Tabs", "`tabBarExtraContent` prop has been removed. Please use `rightExtra` slot instead.");
    devWarning(!(slots.tabBarExtraContent !== void 0), "Tabs", "`tabBarExtraContent` slot is deprecated. Please use `rightExtra` slot instead.");
    const {
      prefixCls,
      direction,
      size,
      rootPrefixCls,
      getPopupContainer
    } = useConfigInject("tabs", props2);
    const [wrapSSR, hashId] = useStyle$t(prefixCls);
    const rtl2 = computed(() => direction.value === "rtl");
    const mergedAnimated = computed(() => {
      const {
        animated,
        tabPosition
      } = props2;
      if (animated === false || ["left", "right"].includes(tabPosition)) {
        return {
          inkBar: false,
          tabPane: false
        };
      } else if (animated === true) {
        return {
          inkBar: true,
          tabPane: true
        };
      } else {
        return _extends$1({
          inkBar: true,
          tabPane: false
        }, typeof animated === "object" ? animated : {});
      }
    });
    const [mobile, setMobile] = useState(false);
    onMounted(() => {
      setMobile(isMobile());
    });
    const [mergedActiveKey, setMergedActiveKey] = useMergedState(() => {
      var _a2;
      return (_a2 = props2.tabs[0]) === null || _a2 === void 0 ? void 0 : _a2.key;
    }, {
      value: computed(() => props2.activeKey),
      defaultValue: props2.defaultActiveKey
    });
    const [activeIndex, setActiveIndex] = useState(() => props2.tabs.findIndex((tab) => tab.key === mergedActiveKey.value));
    watchEffect(() => {
      var _a2;
      let newActiveIndex = props2.tabs.findIndex((tab) => tab.key === mergedActiveKey.value);
      if (newActiveIndex === -1) {
        newActiveIndex = Math.max(0, Math.min(activeIndex.value, props2.tabs.length - 1));
        setMergedActiveKey((_a2 = props2.tabs[newActiveIndex]) === null || _a2 === void 0 ? void 0 : _a2.key);
      }
      setActiveIndex(newActiveIndex);
    });
    const [mergedId, setMergedId] = useMergedState(null, {
      value: computed(() => props2.id)
    });
    const mergedTabPosition = computed(() => {
      if (mobile.value && !["left", "right"].includes(props2.tabPosition)) {
        return "top";
      } else {
        return props2.tabPosition;
      }
    });
    onMounted(() => {
      if (!props2.id) {
        setMergedId(`rc-tabs-${uuid$3}`);
        uuid$3 += 1;
      }
    });
    const onInternalTabClick = (key2, e2) => {
      var _a2, _b;
      (_a2 = props2.onTabClick) === null || _a2 === void 0 ? void 0 : _a2.call(props2, key2, e2);
      const isActiveChanged = key2 !== mergedActiveKey.value;
      setMergedActiveKey(key2);
      if (isActiveChanged) {
        (_b = props2.onChange) === null || _b === void 0 ? void 0 : _b.call(props2, key2);
      }
    };
    useProvideTabs({
      tabs: computed(() => props2.tabs),
      prefixCls
    });
    return () => {
      const {
        id,
        type: type4,
        tabBarGutter,
        tabBarStyle,
        locale: locale2,
        destroyInactiveTabPane,
        renderTabBar = slots.renderTabBar,
        onTabScroll,
        hideAdd,
        centered
      } = props2;
      const sharedProps = {
        id: mergedId.value,
        activeKey: mergedActiveKey.value,
        animated: mergedAnimated.value,
        tabPosition: mergedTabPosition.value,
        rtl: rtl2.value,
        mobile: mobile.value
      };
      let editable;
      if (type4 === "editable-card") {
        editable = {
          onEdit: (editType, _ref2) => {
            let {
              key: key2,
              event
            } = _ref2;
            var _a2;
            (_a2 = props2.onEdit) === null || _a2 === void 0 ? void 0 : _a2.call(props2, editType === "add" ? event : key2, editType);
          },
          removeIcon: () => createVNode(CloseOutlined, null, null),
          addIcon: slots.addIcon ? slots.addIcon : () => createVNode(PlusOutlined, null, null),
          showAdd: hideAdd !== true
        };
      }
      let tabNavBar;
      const tabNavBarProps = _extends$1(_extends$1({}, sharedProps), {
        moreTransitionName: `${rootPrefixCls.value}-slide-up`,
        editable,
        locale: locale2,
        tabBarGutter,
        onTabClick: onInternalTabClick,
        onTabScroll,
        style: tabBarStyle,
        getPopupContainer: getPopupContainer.value,
        popupClassName: classNames(props2.popupClassName, hashId.value)
      });
      if (renderTabBar) {
        tabNavBar = renderTabBar(_extends$1(_extends$1({}, tabNavBarProps), {
          DefaultTabBar: TabNavList
        }));
      } else {
        tabNavBar = createVNode(TabNavList, tabNavBarProps, pick(slots, ["moreIcon", "leftExtra", "rightExtra", "tabBarExtraContent"]));
      }
      const pre = prefixCls.value;
      return wrapSSR(createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "id": id,
        "class": classNames(pre, `${pre}-${mergedTabPosition.value}`, {
          [hashId.value]: true,
          [`${pre}-${size.value}`]: size.value,
          [`${pre}-card`]: ["card", "editable-card"].includes(type4),
          [`${pre}-editable-card`]: type4 === "editable-card",
          [`${pre}-centered`]: centered,
          [`${pre}-mobile`]: mobile.value,
          [`${pre}-editable`]: type4 === "editable-card",
          [`${pre}-rtl`]: rtl2.value
        }, attrs.class)
      }), [tabNavBar, createVNode(TabPanelList, _objectSpread2$1(_objectSpread2$1({
        "destroyInactiveTabPane": destroyInactiveTabPane
      }, sharedProps), {}, {
        "animated": mergedAnimated.value
      }), null)]));
    };
  }
});
const Tabs = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ATabs",
  inheritAttrs: false,
  props: initDefaultProps(tabsProps(), {
    tabPosition: "top",
    animated: {
      inkBar: true,
      tabPane: false
    }
  }),
  slots: Object,
  // emits: ['tabClick', 'tabScroll', 'change', 'update:activeKey'],
  setup(props2, _ref3) {
    let {
      attrs,
      slots,
      emit
    } = _ref3;
    const handleChange = (key2) => {
      emit("update:activeKey", key2);
      emit("change", key2);
    };
    return () => {
      var _a2;
      const tabs = parseTabList(flattenChildren((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)));
      return createVNode(InternalTabs, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, omit$1(props2, ["onUpdate:activeKey"])), attrs), {}, {
        "onChange": handleChange,
        "tabs": tabs
      }), slots);
    };
  }
});
const tabPaneProps = () => ({
  tab: PropTypes.any,
  disabled: {
    type: Boolean
  },
  forceRender: {
    type: Boolean
  },
  closable: {
    type: Boolean
  },
  animated: {
    type: Boolean
  },
  active: {
    type: Boolean
  },
  destroyInactiveTabPane: {
    type: Boolean
  },
  // Pass by TabPaneList
  prefixCls: {
    type: String
  },
  tabKey: {
    type: [String, Number]
  },
  id: {
    type: String
  }
  // closeIcon: PropTypes.any,
});
const TabPane$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ATabPane",
  inheritAttrs: false,
  __ANT_TAB_PANE: true,
  props: tabPaneProps(),
  slots: Object,
  setup(props2, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const visited = ref(props2.forceRender);
    watch([() => props2.active, () => props2.destroyInactiveTabPane], () => {
      if (props2.active) {
        visited.value = true;
      } else if (props2.destroyInactiveTabPane) {
        visited.value = false;
      }
    }, {
      immediate: true
    });
    const mergedStyle = computed(() => {
      if (!props2.active) {
        if (props2.animated) {
          return {
            visibility: "hidden",
            height: 0,
            overflowY: "hidden"
          };
        } else {
          return {
            display: "none"
          };
        }
      }
      return {};
    });
    return () => {
      var _a2;
      const {
        prefixCls,
        forceRender,
        id,
        active,
        tabKey
      } = props2;
      return createVNode("div", {
        "id": id && `${id}-panel-${tabKey}`,
        "role": "tabpanel",
        "tabindex": active ? 0 : -1,
        "aria-labelledby": id && `${id}-tab-${tabKey}`,
        "aria-hidden": !active,
        "style": [mergedStyle.value, attrs.style],
        "class": [`${prefixCls}-tabpane`, active && `${prefixCls}-tabpane-active`, attrs.class]
      }, [(active || visited.value || forceRender) && ((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots))]);
    };
  }
});
Tabs.TabPane = TabPane$1;
Tabs.install = function(app) {
  app.component(Tabs.name, Tabs);
  app.component(TabPane$1.name, TabPane$1);
  return app;
};
const genCardHeadStyle = (token2) => {
  const {
    antCls,
    componentCls,
    cardHeadHeight,
    cardPaddingBase,
    cardHeadTabsMarginBottom
  } = token2;
  return _extends$1(_extends$1({
    display: "flex",
    justifyContent: "center",
    flexDirection: "column",
    minHeight: cardHeadHeight,
    marginBottom: -1,
    padding: `0 ${cardPaddingBase}px`,
    color: token2.colorTextHeading,
    fontWeight: token2.fontWeightStrong,
    fontSize: token2.fontSizeLG,
    background: "transparent",
    borderBottom: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorderSecondary}`,
    borderRadius: `${token2.borderRadiusLG}px ${token2.borderRadiusLG}px 0 0`
  }, clearFix()), {
    "&-wrapper": {
      width: "100%",
      display: "flex",
      alignItems: "center"
    },
    "&-title": _extends$1(_extends$1({
      display: "inline-block",
      flex: 1
    }, textEllipsis), {
      [`
          > ${componentCls}-typography,
          > ${componentCls}-typography-edit-content
        `]: {
        insetInlineStart: 0,
        marginTop: 0,
        marginBottom: 0
      }
    }),
    [`${antCls}-tabs-top`]: {
      clear: "both",
      marginBottom: cardHeadTabsMarginBottom,
      color: token2.colorText,
      fontWeight: "normal",
      fontSize: token2.fontSize,
      "&-bar": {
        borderBottom: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorderSecondary}`
      }
    }
  });
};
const genCardGridStyle = (token2) => {
  const {
    cardPaddingBase,
    colorBorderSecondary,
    cardShadow,
    lineWidth
  } = token2;
  return {
    width: "33.33%",
    padding: cardPaddingBase,
    border: 0,
    borderRadius: 0,
    boxShadow: `
      ${lineWidth}px 0 0 0 ${colorBorderSecondary},
      0 ${lineWidth}px 0 0 ${colorBorderSecondary},
      ${lineWidth}px ${lineWidth}px 0 0 ${colorBorderSecondary},
      ${lineWidth}px 0 0 0 ${colorBorderSecondary} inset,
      0 ${lineWidth}px 0 0 ${colorBorderSecondary} inset;
    `,
    transition: `all ${token2.motionDurationMid}`,
    "&-hoverable:hover": {
      position: "relative",
      zIndex: 1,
      boxShadow: cardShadow
    }
  };
};
const genCardActionsStyle = (token2) => {
  const {
    componentCls,
    iconCls,
    cardActionsLiMargin,
    cardActionsIconSize,
    colorBorderSecondary
  } = token2;
  return _extends$1(_extends$1({
    margin: 0,
    padding: 0,
    listStyle: "none",
    background: token2.colorBgContainer,
    borderTop: `${token2.lineWidth}px ${token2.lineType} ${colorBorderSecondary}`,
    display: "flex",
    borderRadius: `0 0 ${token2.borderRadiusLG}px ${token2.borderRadiusLG}px `
  }, clearFix()), {
    "& > li": {
      margin: cardActionsLiMargin,
      color: token2.colorTextDescription,
      textAlign: "center",
      "> span": {
        position: "relative",
        display: "block",
        minWidth: token2.cardActionsIconSize * 2,
        fontSize: token2.fontSize,
        lineHeight: token2.lineHeight,
        cursor: "pointer",
        "&:hover": {
          color: token2.colorPrimary,
          transition: `color ${token2.motionDurationMid}`
        },
        [`a:not(${componentCls}-btn), > ${iconCls}`]: {
          display: "inline-block",
          width: "100%",
          color: token2.colorTextDescription,
          lineHeight: `${token2.fontSize * token2.lineHeight}px`,
          transition: `color ${token2.motionDurationMid}`,
          "&:hover": {
            color: token2.colorPrimary
          }
        },
        [`> ${iconCls}`]: {
          fontSize: cardActionsIconSize,
          lineHeight: `${cardActionsIconSize * token2.lineHeight}px`
        }
      },
      "&:not(:last-child)": {
        borderInlineEnd: `${token2.lineWidth}px ${token2.lineType} ${colorBorderSecondary}`
      }
    }
  });
};
const genCardMetaStyle = (token2) => _extends$1(_extends$1({
  margin: `-${token2.marginXXS}px 0`,
  display: "flex"
}, clearFix()), {
  "&-avatar": {
    paddingInlineEnd: token2.padding
  },
  "&-detail": {
    overflow: "hidden",
    flex: 1,
    "> div:not(:last-child)": {
      marginBottom: token2.marginXS
    }
  },
  "&-title": _extends$1({
    color: token2.colorTextHeading,
    fontWeight: token2.fontWeightStrong,
    fontSize: token2.fontSizeLG
  }, textEllipsis),
  "&-description": {
    color: token2.colorTextDescription
  }
});
const genCardTypeInnerStyle = (token2) => {
  const {
    componentCls,
    cardPaddingBase,
    colorFillAlter
  } = token2;
  return {
    [`${componentCls}-head`]: {
      padding: `0 ${cardPaddingBase}px`,
      background: colorFillAlter,
      "&-title": {
        fontSize: token2.fontSize
      }
    },
    [`${componentCls}-body`]: {
      padding: `${token2.padding}px ${cardPaddingBase}px`
    }
  };
};
const genCardLoadingStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    overflow: "hidden",
    [`${componentCls}-body`]: {
      userSelect: "none"
    }
  };
};
const genCardStyle = (token2) => {
  const {
    componentCls,
    cardShadow,
    cardHeadPadding,
    colorBorderSecondary,
    boxShadow,
    cardPaddingBase
  } = token2;
  return {
    [componentCls]: _extends$1(_extends$1({}, resetComponent(token2)), {
      position: "relative",
      background: token2.colorBgContainer,
      borderRadius: token2.borderRadiusLG,
      [`&:not(${componentCls}-bordered)`]: {
        boxShadow
      },
      [`${componentCls}-head`]: genCardHeadStyle(token2),
      [`${componentCls}-extra`]: {
        // https://stackoverflow.com/a/22429853/3040605
        marginInlineStart: "auto",
        color: "",
        fontWeight: "normal",
        fontSize: token2.fontSize
      },
      [`${componentCls}-body`]: _extends$1({
        padding: cardPaddingBase,
        borderRadius: ` 0 0 ${token2.borderRadiusLG}px ${token2.borderRadiusLG}px`
      }, clearFix()),
      [`${componentCls}-grid`]: genCardGridStyle(token2),
      [`${componentCls}-cover`]: {
        "> *": {
          display: "block",
          width: "100%"
        },
        img: {
          borderRadius: `${token2.borderRadiusLG}px ${token2.borderRadiusLG}px 0 0`
        }
      },
      [`${componentCls}-actions`]: genCardActionsStyle(token2),
      [`${componentCls}-meta`]: genCardMetaStyle(token2)
    }),
    [`${componentCls}-bordered`]: {
      border: `${token2.lineWidth}px ${token2.lineType} ${colorBorderSecondary}`,
      [`${componentCls}-cover`]: {
        marginTop: -1,
        marginInlineStart: -1,
        marginInlineEnd: -1
      }
    },
    [`${componentCls}-hoverable`]: {
      cursor: "pointer",
      transition: `box-shadow ${token2.motionDurationMid}, border-color ${token2.motionDurationMid}`,
      "&:hover": {
        borderColor: "transparent",
        boxShadow: cardShadow
      }
    },
    [`${componentCls}-contain-grid`]: {
      [`${componentCls}-body`]: {
        display: "flex",
        flexWrap: "wrap"
      },
      [`&:not(${componentCls}-loading) ${componentCls}-body`]: {
        marginBlockStart: -token2.lineWidth,
        marginInlineStart: -token2.lineWidth,
        padding: 0
      }
    },
    [`${componentCls}-contain-tabs`]: {
      [`> ${componentCls}-head`]: {
        [`${componentCls}-head-title, ${componentCls}-extra`]: {
          paddingTop: cardHeadPadding
        }
      }
    },
    [`${componentCls}-type-inner`]: genCardTypeInnerStyle(token2),
    [`${componentCls}-loading`]: genCardLoadingStyle(token2),
    [`${componentCls}-rtl`]: {
      direction: "rtl"
    }
  };
};
const genCardSizeStyle = (token2) => {
  const {
    componentCls,
    cardPaddingSM,
    cardHeadHeightSM
  } = token2;
  return {
    [`${componentCls}-small`]: {
      [`> ${componentCls}-head`]: {
        minHeight: cardHeadHeightSM,
        padding: `0 ${cardPaddingSM}px`,
        fontSize: token2.fontSize,
        [`> ${componentCls}-head-wrapper`]: {
          [`> ${componentCls}-extra`]: {
            fontSize: token2.fontSize
          }
        }
      },
      [`> ${componentCls}-body`]: {
        padding: cardPaddingSM
      }
    },
    [`${componentCls}-small${componentCls}-contain-tabs`]: {
      [`> ${componentCls}-head`]: {
        [`${componentCls}-head-title, ${componentCls}-extra`]: {
          minHeight: cardHeadHeightSM,
          paddingTop: 0,
          display: "flex",
          alignItems: "center"
        }
      }
    }
  };
};
const useStyle$s = genComponentStyleHook("Card", (token2) => {
  const cardToken = merge(token2, {
    cardShadow: token2.boxShadowCard,
    cardHeadHeight: token2.fontSizeLG * token2.lineHeightLG + token2.padding * 2,
    cardHeadHeightSM: token2.fontSize * token2.lineHeight + token2.paddingXS * 2,
    cardHeadPadding: token2.padding,
    cardPaddingBase: token2.paddingLG,
    cardHeadTabsMarginBottom: -token2.padding - token2.lineWidth,
    cardActionsLiMargin: `${token2.paddingSM}px 0`,
    cardActionsIconSize: token2.fontSize,
    cardPaddingSM: 12
    // Fixed padding.
  });
  return [
    // Style
    genCardStyle(cardToken),
    // Size
    genCardSizeStyle(cardToken)
  ];
});
const skeletonTitleProps = () => ({
  prefixCls: String,
  width: {
    type: [Number, String]
  }
});
const SkeletonTitle = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "SkeletonTitle",
  props: skeletonTitleProps(),
  setup(props2) {
    return () => {
      const {
        prefixCls,
        width
      } = props2;
      const zWidth = typeof width === "number" ? `${width}px` : width;
      return createVNode("h3", {
        "class": prefixCls,
        "style": {
          width: zWidth
        }
      }, null);
    };
  }
});
const skeletonParagraphProps = () => ({
  prefixCls: String,
  width: {
    type: [Number, String, Array]
  },
  rows: Number
});
const SkeletonParagraph = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "SkeletonParagraph",
  props: skeletonParagraphProps(),
  setup(props2) {
    const getWidth = (index2) => {
      const {
        width,
        rows = 2
      } = props2;
      if (Array.isArray(width)) {
        return width[index2];
      }
      if (rows - 1 === index2) {
        return width;
      }
      return void 0;
    };
    return () => {
      const {
        prefixCls,
        rows
      } = props2;
      const rowList = [...Array(rows)].map((_2, index2) => {
        const width = getWidth(index2);
        return createVNode("li", {
          "key": index2,
          "style": {
            width: typeof width === "number" ? `${width}px` : width
          }
        }, null);
      });
      return createVNode("ul", {
        "class": prefixCls
      }, [rowList]);
    };
  }
});
const skeletonElementProps = () => ({
  prefixCls: String,
  size: [String, Number],
  shape: String,
  active: {
    type: Boolean,
    default: void 0
  }
});
const Element$1 = (props2) => {
  const {
    prefixCls,
    size,
    shape
  } = props2;
  const sizeCls = classNames({
    [`${prefixCls}-lg`]: size === "large",
    [`${prefixCls}-sm`]: size === "small"
  });
  const shapeCls = classNames({
    [`${prefixCls}-circle`]: shape === "circle",
    [`${prefixCls}-square`]: shape === "square",
    [`${prefixCls}-round`]: shape === "round"
  });
  const sizeStyle = typeof size === "number" ? {
    width: `${size}px`,
    height: `${size}px`,
    lineHeight: `${size}px`
  } : {};
  return createVNode("span", {
    "class": classNames(prefixCls, sizeCls, shapeCls),
    "style": sizeStyle
  }, null);
};
Element$1.displayName = "SkeletonElement";
const skeletonClsLoading = new Keyframe(`ant-skeleton-loading`, {
  "0%": {
    transform: "translateX(-37.5%)"
  },
  "100%": {
    transform: "translateX(37.5%)"
  }
});
const genSkeletonElementCommonSize = (size) => ({
  height: size,
  lineHeight: `${size}px`
});
const genSkeletonElementAvatarSize = (size) => _extends$1({
  width: size
}, genSkeletonElementCommonSize(size));
const genSkeletonColor = (token2) => ({
  position: "relative",
  // fix https://github.com/ant-design/ant-design/issues/36444
  // https://monshin.github.io/202109/css/safari-border-radius-overflow-hidden/
  /* stylelint-disable-next-line property-no-vendor-prefix,value-no-vendor-prefix */
  zIndex: 0,
  overflow: "hidden",
  background: "transparent",
  "&::after": {
    position: "absolute",
    top: 0,
    insetInlineEnd: "-150%",
    bottom: 0,
    insetInlineStart: "-150%",
    background: token2.skeletonLoadingBackground,
    animationName: skeletonClsLoading,
    animationDuration: token2.skeletonLoadingMotionDuration,
    animationTimingFunction: "ease",
    animationIterationCount: "infinite",
    content: '""'
  }
});
const genSkeletonElementInputSize = (size) => _extends$1({
  width: size * 5,
  minWidth: size * 5
}, genSkeletonElementCommonSize(size));
const genSkeletonElementAvatar = (token2) => {
  const {
    skeletonAvatarCls,
    color,
    controlHeight,
    controlHeightLG,
    controlHeightSM
  } = token2;
  return {
    [`${skeletonAvatarCls}`]: _extends$1({
      display: "inline-block",
      verticalAlign: "top",
      background: color
    }, genSkeletonElementAvatarSize(controlHeight)),
    [`${skeletonAvatarCls}${skeletonAvatarCls}-circle`]: {
      borderRadius: "50%"
    },
    [`${skeletonAvatarCls}${skeletonAvatarCls}-lg`]: _extends$1({}, genSkeletonElementAvatarSize(controlHeightLG)),
    [`${skeletonAvatarCls}${skeletonAvatarCls}-sm`]: _extends$1({}, genSkeletonElementAvatarSize(controlHeightSM))
  };
};
const genSkeletonElementInput = (token2) => {
  const {
    controlHeight,
    borderRadiusSM,
    skeletonInputCls,
    controlHeightLG,
    controlHeightSM,
    color
  } = token2;
  return {
    [`${skeletonInputCls}`]: _extends$1({
      display: "inline-block",
      verticalAlign: "top",
      background: color,
      borderRadius: borderRadiusSM
    }, genSkeletonElementInputSize(controlHeight)),
    [`${skeletonInputCls}-lg`]: _extends$1({}, genSkeletonElementInputSize(controlHeightLG)),
    [`${skeletonInputCls}-sm`]: _extends$1({}, genSkeletonElementInputSize(controlHeightSM))
  };
};
const genSkeletonElementImageSize = (size) => _extends$1({
  width: size
}, genSkeletonElementCommonSize(size));
const genSkeletonElementImage = (token2) => {
  const {
    skeletonImageCls,
    imageSizeBase,
    color,
    borderRadiusSM
  } = token2;
  return {
    [`${skeletonImageCls}`]: _extends$1(_extends$1({
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      verticalAlign: "top",
      background: color,
      borderRadius: borderRadiusSM
    }, genSkeletonElementImageSize(imageSizeBase * 2)), {
      [`${skeletonImageCls}-path`]: {
        fill: "#bfbfbf"
      },
      [`${skeletonImageCls}-svg`]: _extends$1(_extends$1({}, genSkeletonElementImageSize(imageSizeBase)), {
        maxWidth: imageSizeBase * 4,
        maxHeight: imageSizeBase * 4
      }),
      [`${skeletonImageCls}-svg${skeletonImageCls}-svg-circle`]: {
        borderRadius: "50%"
      }
    }),
    [`${skeletonImageCls}${skeletonImageCls}-circle`]: {
      borderRadius: "50%"
    }
  };
};
const genSkeletonElementButtonShape = (token2, size, buttonCls) => {
  const {
    skeletonButtonCls
  } = token2;
  return {
    [`${buttonCls}${skeletonButtonCls}-circle`]: {
      width: size,
      minWidth: size,
      borderRadius: "50%"
    },
    [`${buttonCls}${skeletonButtonCls}-round`]: {
      borderRadius: size
    }
  };
};
const genSkeletonElementButtonSize = (size) => _extends$1({
  width: size * 2,
  minWidth: size * 2
}, genSkeletonElementCommonSize(size));
const genSkeletonElementButton = (token2) => {
  const {
    borderRadiusSM,
    skeletonButtonCls,
    controlHeight,
    controlHeightLG,
    controlHeightSM,
    color
  } = token2;
  return _extends$1(_extends$1(_extends$1(_extends$1(_extends$1({
    [`${skeletonButtonCls}`]: _extends$1({
      display: "inline-block",
      verticalAlign: "top",
      background: color,
      borderRadius: borderRadiusSM,
      width: controlHeight * 2,
      minWidth: controlHeight * 2
    }, genSkeletonElementButtonSize(controlHeight))
  }, genSkeletonElementButtonShape(token2, controlHeight, skeletonButtonCls)), {
    [`${skeletonButtonCls}-lg`]: _extends$1({}, genSkeletonElementButtonSize(controlHeightLG))
  }), genSkeletonElementButtonShape(token2, controlHeightLG, `${skeletonButtonCls}-lg`)), {
    [`${skeletonButtonCls}-sm`]: _extends$1({}, genSkeletonElementButtonSize(controlHeightSM))
  }), genSkeletonElementButtonShape(token2, controlHeightSM, `${skeletonButtonCls}-sm`));
};
const genBaseStyle$a = (token2) => {
  const {
    componentCls,
    skeletonAvatarCls,
    skeletonTitleCls,
    skeletonParagraphCls,
    skeletonButtonCls,
    skeletonInputCls,
    skeletonImageCls,
    controlHeight,
    controlHeightLG,
    controlHeightSM,
    color,
    padding,
    marginSM,
    borderRadius,
    skeletonTitleHeight,
    skeletonBlockRadius,
    skeletonParagraphLineHeight,
    controlHeightXS,
    skeletonParagraphMarginTop
  } = token2;
  return {
    [`${componentCls}`]: {
      display: "table",
      width: "100%",
      [`${componentCls}-header`]: {
        display: "table-cell",
        paddingInlineEnd: padding,
        verticalAlign: "top",
        // Avatar
        [`${skeletonAvatarCls}`]: _extends$1({
          display: "inline-block",
          verticalAlign: "top",
          background: color
        }, genSkeletonElementAvatarSize(controlHeight)),
        [`${skeletonAvatarCls}-circle`]: {
          borderRadius: "50%"
        },
        [`${skeletonAvatarCls}-lg`]: _extends$1({}, genSkeletonElementAvatarSize(controlHeightLG)),
        [`${skeletonAvatarCls}-sm`]: _extends$1({}, genSkeletonElementAvatarSize(controlHeightSM))
      },
      [`${componentCls}-content`]: {
        display: "table-cell",
        width: "100%",
        verticalAlign: "top",
        // Title
        [`${skeletonTitleCls}`]: {
          width: "100%",
          height: skeletonTitleHeight,
          background: color,
          borderRadius: skeletonBlockRadius,
          [`+ ${skeletonParagraphCls}`]: {
            marginBlockStart: controlHeightSM
          }
        },
        // paragraph
        [`${skeletonParagraphCls}`]: {
          padding: 0,
          "> li": {
            width: "100%",
            height: skeletonParagraphLineHeight,
            listStyle: "none",
            background: color,
            borderRadius: skeletonBlockRadius,
            "+ li": {
              marginBlockStart: controlHeightXS
            }
          }
        },
        [`${skeletonParagraphCls}> li:last-child:not(:first-child):not(:nth-child(2))`]: {
          width: "61%"
        }
      },
      [`&-round ${componentCls}-content`]: {
        [`${skeletonTitleCls}, ${skeletonParagraphCls} > li`]: {
          borderRadius
        }
      }
    },
    [`${componentCls}-with-avatar ${componentCls}-content`]: {
      // Title
      [`${skeletonTitleCls}`]: {
        marginBlockStart: marginSM,
        [`+ ${skeletonParagraphCls}`]: {
          marginBlockStart: skeletonParagraphMarginTop
        }
      }
    },
    // Skeleton element
    [`${componentCls}${componentCls}-element`]: _extends$1(_extends$1(_extends$1(_extends$1({
      display: "inline-block",
      width: "auto"
    }, genSkeletonElementButton(token2)), genSkeletonElementAvatar(token2)), genSkeletonElementInput(token2)), genSkeletonElementImage(token2)),
    // Skeleton Block Button, Input
    [`${componentCls}${componentCls}-block`]: {
      width: "100%",
      [`${skeletonButtonCls}`]: {
        width: "100%"
      },
      [`${skeletonInputCls}`]: {
        width: "100%"
      }
    },
    // With active animation
    [`${componentCls}${componentCls}-active`]: {
      [`
        ${skeletonTitleCls},
        ${skeletonParagraphCls} > li,
        ${skeletonAvatarCls},
        ${skeletonButtonCls},
        ${skeletonInputCls},
        ${skeletonImageCls}
      `]: _extends$1({}, genSkeletonColor(token2))
    }
  };
};
const useStyle$r = genComponentStyleHook("Skeleton", (token2) => {
  const {
    componentCls
  } = token2;
  const skeletonToken = merge(token2, {
    skeletonAvatarCls: `${componentCls}-avatar`,
    skeletonTitleCls: `${componentCls}-title`,
    skeletonParagraphCls: `${componentCls}-paragraph`,
    skeletonButtonCls: `${componentCls}-button`,
    skeletonInputCls: `${componentCls}-input`,
    skeletonImageCls: `${componentCls}-image`,
    imageSizeBase: token2.controlHeight * 1.5,
    skeletonTitleHeight: token2.controlHeight / 2,
    skeletonBlockRadius: token2.borderRadiusSM,
    skeletonParagraphLineHeight: token2.controlHeight / 2,
    skeletonParagraphMarginTop: token2.marginLG + token2.marginXXS,
    borderRadius: 100,
    skeletonLoadingBackground: `linear-gradient(90deg, ${token2.color} 25%, ${token2.colorGradientEnd} 37%, ${token2.color} 63%)`,
    skeletonLoadingMotionDuration: "1.4s"
  });
  return [genBaseStyle$a(skeletonToken)];
}, (token2) => {
  const {
    colorFillContent,
    colorFill
  } = token2;
  return {
    color: colorFillContent,
    colorGradientEnd: colorFill
  };
});
const skeletonProps = () => ({
  active: {
    type: Boolean,
    default: void 0
  },
  loading: {
    type: Boolean,
    default: void 0
  },
  prefixCls: String,
  avatar: {
    type: [Boolean, Object],
    default: void 0
  },
  title: {
    type: [Boolean, Object],
    default: void 0
  },
  paragraph: {
    type: [Boolean, Object],
    default: void 0
  },
  round: {
    type: Boolean,
    default: void 0
  }
});
function getComponentProps(prop) {
  if (prop && typeof prop === "object") {
    return prop;
  }
  return {};
}
function getAvatarBasicProps(hasTitle, hasParagraph) {
  if (hasTitle && !hasParagraph) {
    return {
      size: "large",
      shape: "square"
    };
  }
  return {
    size: "large",
    shape: "circle"
  };
}
function getTitleBasicProps(hasAvatar, hasParagraph) {
  if (!hasAvatar && hasParagraph) {
    return {
      width: "38%"
    };
  }
  if (hasAvatar && hasParagraph) {
    return {
      width: "50%"
    };
  }
  return {};
}
function getParagraphBasicProps(hasAvatar, hasTitle) {
  const basicProps2 = {};
  if (!hasAvatar || !hasTitle) {
    basicProps2.width = "61%";
  }
  if (!hasAvatar && hasTitle) {
    basicProps2.rows = 3;
  } else {
    basicProps2.rows = 2;
  }
  return basicProps2;
}
const Skeleton = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ASkeleton",
  props: initDefaultProps(skeletonProps(), {
    avatar: false,
    title: true,
    paragraph: true
  }),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      prefixCls,
      direction
    } = useConfigInject("skeleton", props2);
    const [wrapSSR, hashId] = useStyle$r(prefixCls);
    return () => {
      var _a2;
      const {
        loading,
        avatar,
        title,
        paragraph,
        active,
        round
      } = props2;
      const pre = prefixCls.value;
      if (loading || props2.loading === void 0) {
        const hasAvatar = !!avatar || avatar === "";
        const hasTitle = !!title || title === "";
        const hasParagraph = !!paragraph || paragraph === "";
        let avatarNode;
        if (hasAvatar) {
          const avatarProps2 = _extends$1(_extends$1({
            prefixCls: `${pre}-avatar`
          }, getAvatarBasicProps(hasTitle, hasParagraph)), getComponentProps(avatar));
          avatarNode = createVNode("div", {
            "class": `${pre}-header`
          }, [createVNode(Element$1, avatarProps2, null)]);
        }
        let contentNode;
        if (hasTitle || hasParagraph) {
          let $title;
          if (hasTitle) {
            const titleProps2 = _extends$1(_extends$1({
              prefixCls: `${pre}-title`
            }, getTitleBasicProps(hasAvatar, hasParagraph)), getComponentProps(title));
            $title = createVNode(SkeletonTitle, titleProps2, null);
          }
          let paragraphNode;
          if (hasParagraph) {
            const paragraphProps2 = _extends$1(_extends$1({
              prefixCls: `${pre}-paragraph`
            }, getParagraphBasicProps(hasAvatar, hasTitle)), getComponentProps(paragraph));
            paragraphNode = createVNode(SkeletonParagraph, paragraphProps2, null);
          }
          contentNode = createVNode("div", {
            "class": `${pre}-content`
          }, [$title, paragraphNode]);
        }
        const cls = classNames(pre, {
          [`${pre}-with-avatar`]: hasAvatar,
          [`${pre}-active`]: active,
          [`${pre}-rtl`]: direction.value === "rtl",
          [`${pre}-round`]: round,
          [hashId.value]: true
        });
        return wrapSSR(createVNode("div", {
          "class": cls
        }, [avatarNode, contentNode]));
      }
      return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
    };
  }
});
const skeletonButtonProps = () => {
  return _extends$1(_extends$1({}, skeletonElementProps()), {
    size: String,
    block: Boolean
  });
};
const SkeletonButton = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ASkeletonButton",
  props: initDefaultProps(skeletonButtonProps(), {
    size: "default"
  }),
  setup(props2) {
    const {
      prefixCls
    } = useConfigInject("skeleton", props2);
    const [wrapSSR, hashId] = useStyle$r(prefixCls);
    const cls = computed(() => classNames(prefixCls.value, `${prefixCls.value}-element`, {
      [`${prefixCls.value}-active`]: props2.active,
      [`${prefixCls.value}-block`]: props2.block
    }, hashId.value));
    return () => {
      return wrapSSR(createVNode("div", {
        "class": cls.value
      }, [createVNode(Element$1, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
        "prefixCls": `${prefixCls.value}-button`
      }), null)]));
    };
  }
});
const SkeletonInput = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ASkeletonInput",
  props: _extends$1(_extends$1({}, omit$1(skeletonElementProps(), ["shape"])), {
    size: String,
    block: Boolean
  }),
  setup(props2) {
    const {
      prefixCls
    } = useConfigInject("skeleton", props2);
    const [wrapSSR, hashId] = useStyle$r(prefixCls);
    const cls = computed(() => classNames(prefixCls.value, `${prefixCls.value}-element`, {
      [`${prefixCls.value}-active`]: props2.active,
      [`${prefixCls.value}-block`]: props2.block
    }, hashId.value));
    return () => {
      return wrapSSR(createVNode("div", {
        "class": cls.value
      }, [createVNode(Element$1, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
        "prefixCls": `${prefixCls.value}-input`
      }), null)]));
    };
  }
});
const path = "M365.714286 329.142857q0 45.714286-32.036571 77.677714t-77.677714 32.036571-77.677714-32.036571-32.036571-77.677714 32.036571-77.677714 77.677714-32.036571 77.677714 32.036571 32.036571 77.677714zM950.857143 548.571429l0 256-804.571429 0 0-109.714286 182.857143-182.857143 91.428571 91.428571 292.571429-292.571429zM1005.714286 146.285714l-914.285714 0q-7.460571 0-12.873143 5.412571t-5.412571 12.873143l0 694.857143q0 7.460571 5.412571 12.873143t12.873143 5.412571l914.285714 0q7.460571 0 12.873143-5.412571t5.412571-12.873143l0-694.857143q0-7.460571-5.412571-12.873143t-12.873143-5.412571zM1097.142857 164.571429l0 694.857143q0 37.741714-26.843429 64.585143t-64.585143 26.843429l-914.285714 0q-37.741714 0-64.585143-26.843429t-26.843429-64.585143l0-694.857143q0-37.741714 26.843429-64.585143t64.585143-26.843429l914.285714 0q37.741714 0 64.585143 26.843429t26.843429 64.585143z";
const SkeletonImage = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ASkeletonImage",
  props: omit$1(skeletonElementProps(), ["size", "shape", "active"]),
  setup(props2) {
    const {
      prefixCls
    } = useConfigInject("skeleton", props2);
    const [wrapSSR, hashId] = useStyle$r(prefixCls);
    const cls = computed(() => classNames(prefixCls.value, `${prefixCls.value}-element`, hashId.value));
    return () => {
      return wrapSSR(createVNode("div", {
        "class": cls.value
      }, [createVNode("div", {
        "class": `${prefixCls.value}-image`
      }, [createVNode("svg", {
        "viewBox": "0 0 1098 1024",
        "xmlns": "http://www.w3.org/2000/svg",
        "class": `${prefixCls.value}-image-svg`
      }, [createVNode("path", {
        "d": path,
        "class": `${prefixCls.value}-image-path`
      }, null)])])]));
    };
  }
});
const avatarProps = () => {
  return _extends$1(_extends$1({}, skeletonElementProps()), {
    shape: String
  });
};
const SkeletonAvatar = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ASkeletonAvatar",
  props: initDefaultProps(avatarProps(), {
    size: "default",
    shape: "circle"
  }),
  setup(props2) {
    const {
      prefixCls
    } = useConfigInject("skeleton", props2);
    const [wrapSSR, hashId] = useStyle$r(prefixCls);
    const cls = computed(() => classNames(prefixCls.value, `${prefixCls.value}-element`, {
      [`${prefixCls.value}-active`]: props2.active
    }, hashId.value));
    return () => {
      return wrapSSR(createVNode("div", {
        "class": cls.value
      }, [createVNode(Element$1, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
        "prefixCls": `${prefixCls.value}-avatar`
      }), null)]));
    };
  }
});
Skeleton.Button = SkeletonButton;
Skeleton.Avatar = SkeletonAvatar;
Skeleton.Input = SkeletonInput;
Skeleton.Image = SkeletonImage;
Skeleton.Title = SkeletonTitle;
Skeleton.install = function(app) {
  app.component(Skeleton.name, Skeleton);
  app.component(Skeleton.Button.name, SkeletonButton);
  app.component(Skeleton.Avatar.name, SkeletonAvatar);
  app.component(Skeleton.Input.name, SkeletonInput);
  app.component(Skeleton.Image.name, SkeletonImage);
  app.component(Skeleton.Title.name, SkeletonTitle);
  return app;
};
const {
  TabPane
} = Tabs;
const cardProps = () => ({
  prefixCls: String,
  title: PropTypes.any,
  extra: PropTypes.any,
  bordered: {
    type: Boolean,
    default: true
  },
  bodyStyle: {
    type: Object,
    default: void 0
  },
  headStyle: {
    type: Object,
    default: void 0
  },
  loading: {
    type: Boolean,
    default: false
  },
  hoverable: {
    type: Boolean,
    default: false
  },
  type: {
    type: String
  },
  size: {
    type: String
  },
  actions: PropTypes.any,
  tabList: {
    type: Array
  },
  tabBarExtraContent: PropTypes.any,
  activeTabKey: String,
  defaultActiveTabKey: String,
  cover: PropTypes.any,
  onTabChange: {
    type: Function
  }
});
const Card = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ACard",
  inheritAttrs: false,
  props: cardProps(),
  slots: Object,
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const {
      prefixCls,
      direction,
      size
    } = useConfigInject("card", props2);
    const [wrapSSR, hashId] = useStyle$s(prefixCls);
    const getAction = (actions) => {
      const actionList = actions.map((action, index2) => isVNode(action) && !isEmptyElement(action) || !isVNode(action) ? createVNode("li", {
        "style": {
          width: `${100 / actions.length}%`
        },
        "key": `action-${index2}`
      }, [createVNode("span", null, [action])]) : null);
      return actionList;
    };
    const triggerTabChange = (key2) => {
      var _a2;
      (_a2 = props2.onTabChange) === null || _a2 === void 0 ? void 0 : _a2.call(props2, key2);
    };
    const isContainGrid = function() {
      let obj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      let containGrid;
      obj.forEach((element) => {
        if (element && isPlainObject(element.type) && element.type.__ANT_CARD_GRID) {
          containGrid = true;
        }
      });
      return containGrid;
    };
    return () => {
      var _a2, _b, _c, _d, _e, _f;
      const {
        headStyle = {},
        bodyStyle = {},
        loading,
        bordered = true,
        type: type4,
        tabList,
        hoverable,
        activeTabKey,
        defaultActiveTabKey,
        tabBarExtraContent = filterEmptyWithUndefined((_a2 = slots.tabBarExtraContent) === null || _a2 === void 0 ? void 0 : _a2.call(slots)),
        title = filterEmptyWithUndefined((_b = slots.title) === null || _b === void 0 ? void 0 : _b.call(slots)),
        extra = filterEmptyWithUndefined((_c = slots.extra) === null || _c === void 0 ? void 0 : _c.call(slots)),
        actions = filterEmptyWithUndefined((_d = slots.actions) === null || _d === void 0 ? void 0 : _d.call(slots)),
        cover = filterEmptyWithUndefined((_e = slots.cover) === null || _e === void 0 ? void 0 : _e.call(slots))
      } = props2;
      const children = flattenChildren((_f = slots.default) === null || _f === void 0 ? void 0 : _f.call(slots));
      const pre = prefixCls.value;
      const classString = {
        [`${pre}`]: true,
        [hashId.value]: true,
        [`${pre}-loading`]: loading,
        [`${pre}-bordered`]: bordered,
        [`${pre}-hoverable`]: !!hoverable,
        [`${pre}-contain-grid`]: isContainGrid(children),
        [`${pre}-contain-tabs`]: tabList && tabList.length,
        [`${pre}-${size.value}`]: size.value,
        [`${pre}-type-${type4}`]: !!type4,
        [`${pre}-rtl`]: direction.value === "rtl"
      };
      const loadingBlock = createVNode(Skeleton, {
        "loading": true,
        "active": true,
        "paragraph": {
          rows: 4
        },
        "title": false
      }, {
        default: () => [children]
      });
      const hasActiveTabKey = activeTabKey !== void 0;
      const tabsProps2 = {
        size: "large",
        [hasActiveTabKey ? "activeKey" : "defaultActiveKey"]: hasActiveTabKey ? activeTabKey : defaultActiveTabKey,
        onChange: triggerTabChange,
        class: `${pre}-head-tabs`
      };
      let head;
      const tabs = tabList && tabList.length ? createVNode(Tabs, tabsProps2, {
        default: () => [tabList.map((item) => {
          const {
            tab: temp,
            slots: itemSlots
          } = item;
          const name = itemSlots === null || itemSlots === void 0 ? void 0 : itemSlots.tab;
          devWarning(!itemSlots, "Card", `tabList slots is deprecated, Please use \`customTab\` instead.`);
          let tab = temp !== void 0 ? temp : slots[name] ? slots[name](item) : null;
          tab = customRenderSlot(slots, "customTab", item, () => [tab]);
          return createVNode(TabPane, {
            "tab": tab,
            "key": item.key,
            "disabled": item.disabled
          }, null);
        })],
        rightExtra: tabBarExtraContent ? () => tabBarExtraContent : null
      }) : null;
      if (title || extra || tabs) {
        head = createVNode("div", {
          "class": `${pre}-head`,
          "style": headStyle
        }, [createVNode("div", {
          "class": `${pre}-head-wrapper`
        }, [title && createVNode("div", {
          "class": `${pre}-head-title`
        }, [title]), extra && createVNode("div", {
          "class": `${pre}-extra`
        }, [extra])]), tabs]);
      }
      const coverDom = cover ? createVNode("div", {
        "class": `${pre}-cover`
      }, [cover]) : null;
      const body = createVNode("div", {
        "class": `${pre}-body`,
        "style": bodyStyle
      }, [loading ? loadingBlock : children]);
      const actionDom = actions && actions.length ? createVNode("ul", {
        "class": `${pre}-actions`
      }, [getAction(actions)]) : null;
      return wrapSSR(createVNode("div", _objectSpread2$1(_objectSpread2$1({
        "ref": "cardContainerRef"
      }, attrs), {}, {
        "class": [classString, attrs.class]
      }), [head, coverDom, children.length ? body : null, actionDom]));
    };
  }
});
const cardMetaProps = () => ({
  prefixCls: String,
  title: vNodeType(),
  description: vNodeType(),
  avatar: vNodeType()
});
const Meta = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ACardMeta",
  props: cardMetaProps(),
  slots: Object,
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      prefixCls
    } = useConfigInject("card", props2);
    return () => {
      const classString = {
        [`${prefixCls.value}-meta`]: true
      };
      const avatar = getPropsSlot(slots, props2, "avatar");
      const title = getPropsSlot(slots, props2, "title");
      const description = getPropsSlot(slots, props2, "description");
      const avatarDom = avatar ? createVNode("div", {
        "class": `${prefixCls.value}-meta-avatar`
      }, [avatar]) : null;
      const titleDom = title ? createVNode("div", {
        "class": `${prefixCls.value}-meta-title`
      }, [title]) : null;
      const descriptionDom = description ? createVNode("div", {
        "class": `${prefixCls.value}-meta-description`
      }, [description]) : null;
      const MetaDetail = titleDom || descriptionDom ? createVNode("div", {
        "class": `${prefixCls.value}-meta-detail`
      }, [titleDom, descriptionDom]) : null;
      return createVNode("div", {
        "class": classString
      }, [avatarDom, MetaDetail]);
    };
  }
});
const cardGridProps = () => ({
  prefixCls: String,
  hoverable: {
    type: Boolean,
    default: true
  }
});
const Grid = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ACardGrid",
  __ANT_CARD_GRID: true,
  props: cardGridProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      prefixCls
    } = useConfigInject("card", props2);
    const classNames2 = computed(() => {
      return {
        [`${prefixCls.value}-grid`]: true,
        [`${prefixCls.value}-grid-hoverable`]: props2.hoverable
      };
    });
    return () => {
      var _a2;
      return createVNode("div", {
        "class": classNames2.value
      }, [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]);
    };
  }
});
Card.Meta = Meta;
Card.Grid = Grid;
Card.install = function(app) {
  app.component(Card.name, Card);
  app.component(Meta.name, Meta);
  app.component(Grid.name, Grid);
  return app;
};
const VALUE_SPLIT = "__RC_CASCADER_SPLIT__";
const SHOW_PARENT = "SHOW_PARENT";
const SHOW_CHILD = "SHOW_CHILD";
function toPathKey(value) {
  return value.join(VALUE_SPLIT);
}
function toPathKeys(value) {
  return value.map(toPathKey);
}
function toPathValueStr(pathKey) {
  return pathKey.split(VALUE_SPLIT);
}
function fillFieldNames$1(fieldNames) {
  const {
    label,
    value,
    children
  } = fieldNames || {};
  const val = value || "value";
  return {
    label: label || "label",
    value: val,
    key: val,
    children: children || "children"
  };
}
function isLeaf(option, fieldNames) {
  var _a2, _b;
  return (_a2 = option.isLeaf) !== null && _a2 !== void 0 ? _a2 : !((_b = option[fieldNames.children]) === null || _b === void 0 ? void 0 : _b.length);
}
function scrollIntoParentView(element) {
  const parent2 = element.parentElement;
  if (!parent2) {
    return;
  }
  const elementToParent = element.offsetTop - parent2.offsetTop;
  if (elementToParent - parent2.scrollTop < 0) {
    parent2.scrollTo({
      top: elementToParent
    });
  } else if (elementToParent + element.offsetHeight - parent2.scrollTop > parent2.offsetHeight) {
    parent2.scrollTo({
      top: elementToParent + element.offsetHeight - parent2.offsetHeight
    });
  }
}
const TreeContextKey = Symbol("TreeContextKey");
const TreeContext = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "TreeContext",
  props: {
    value: {
      type: Object
    }
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    provide(TreeContextKey, computed(() => props2.value));
    return () => {
      var _a2;
      return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
    };
  }
});
const useInjectTreeContext = () => {
  return inject(TreeContextKey, computed(() => ({})));
};
const KeysStateKey = Symbol("KeysStateKey");
const useProvideKeysState = (state) => {
  provide(KeysStateKey, state);
};
const useInjectKeysState = () => {
  return inject(KeysStateKey, {
    expandedKeys: shallowRef([]),
    selectedKeys: shallowRef([]),
    loadedKeys: shallowRef([]),
    loadingKeys: shallowRef([]),
    checkedKeys: shallowRef([]),
    halfCheckedKeys: shallowRef([]),
    expandedKeysSet: computed(() => /* @__PURE__ */ new Set()),
    selectedKeysSet: computed(() => /* @__PURE__ */ new Set()),
    loadedKeysSet: computed(() => /* @__PURE__ */ new Set()),
    loadingKeysSet: computed(() => /* @__PURE__ */ new Set()),
    checkedKeysSet: computed(() => /* @__PURE__ */ new Set()),
    halfCheckedKeysSet: computed(() => /* @__PURE__ */ new Set()),
    flattenNodes: shallowRef([])
  });
};
const Indent = (_ref) => {
  let {
    prefixCls,
    level,
    isStart,
    isEnd
  } = _ref;
  const baseClassName = `${prefixCls}-indent-unit`;
  const list = [];
  for (let i2 = 0; i2 < level; i2 += 1) {
    list.push(createVNode("span", {
      "key": i2,
      "class": {
        [baseClassName]: true,
        [`${baseClassName}-start`]: isStart[i2],
        [`${baseClassName}-end`]: isEnd[i2]
      }
    }, null));
  }
  return createVNode("span", {
    "aria-hidden": "true",
    "class": `${prefixCls}-indent`
  }, [list]);
};
const treeNodeProps = {
  eventKey: [String, Number],
  prefixCls: String,
  // By parent
  // expanded: { type: Boolean, default: undefined },
  // selected: { type: Boolean, default: undefined },
  // checked: { type: Boolean, default: undefined },
  // loaded: { type: Boolean, default: undefined },
  // loading: { type: Boolean, default: undefined },
  // halfChecked: { type: Boolean, default: undefined },
  // dragOver: { type: Boolean, default: undefined },
  // dragOverGapTop: { type: Boolean, default: undefined },
  // dragOverGapBottom: { type: Boolean, default: undefined },
  // pos: String,
  title: PropTypes.any,
  /** New added in Tree for easy data access */
  data: {
    type: Object,
    default: void 0
  },
  parent: {
    type: Object,
    default: void 0
  },
  isStart: {
    type: Array
  },
  isEnd: {
    type: Array
  },
  active: {
    type: Boolean,
    default: void 0
  },
  onMousemove: {
    type: Function
  },
  // By user
  isLeaf: {
    type: Boolean,
    default: void 0
  },
  checkable: {
    type: Boolean,
    default: void 0
  },
  selectable: {
    type: Boolean,
    default: void 0
  },
  disabled: {
    type: Boolean,
    default: void 0
  },
  disableCheckbox: {
    type: Boolean,
    default: void 0
  },
  icon: PropTypes.any,
  switcherIcon: PropTypes.any,
  domRef: {
    type: Function
  }
};
const nodeListProps = {
  prefixCls: {
    type: String
  },
  // data: { type: Array as PropType<FlattenNode[]> },
  motion: {
    type: Object
  },
  focusable: {
    type: Boolean
  },
  activeItem: {
    type: Object
  },
  focused: {
    type: Boolean
  },
  tabindex: {
    type: Number
  },
  checkable: {
    type: Boolean
  },
  selectable: {
    type: Boolean
  },
  disabled: {
    type: Boolean
  },
  // expandedKeys: { type: Array as PropType<Key[]> },
  // selectedKeys: { type: Array as PropType<Key[]> },
  // checkedKeys: { type: Array as PropType<Key[]> },
  // loadedKeys: { type: Array as PropType<Key[]> },
  // loadingKeys: { type: Array as PropType<Key[]> },
  // halfCheckedKeys: { type: Array as PropType<Key[]> },
  // keyEntities: { type: Object as PropType<Record<Key, DataEntity<DataNode>>> },
  // dragging: { type: Boolean as PropType<boolean> },
  // dragOverNodeKey: { type: [String, Number] as PropType<Key> },
  // dropPosition: { type: Number as PropType<number> },
  // Virtual list
  height: {
    type: Number
  },
  itemHeight: {
    type: Number
  },
  virtual: {
    type: Boolean
  },
  onScroll: {
    type: Function
  },
  onKeydown: {
    type: Function
  },
  onFocus: {
    type: Function
  },
  onBlur: {
    type: Function
  },
  onActiveChange: {
    type: Function
  },
  onContextmenu: {
    type: Function
  },
  onListChangeStart: {
    type: Function
  },
  onListChangeEnd: {
    type: Function
  }
};
const treeProps$1 = () => ({
  prefixCls: String,
  focusable: {
    type: Boolean,
    default: void 0
  },
  activeKey: [Number, String],
  tabindex: Number,
  children: PropTypes.any,
  treeData: {
    type: Array
  },
  fieldNames: {
    type: Object
  },
  showLine: {
    type: [Boolean, Object],
    default: void 0
  },
  showIcon: {
    type: Boolean,
    default: void 0
  },
  icon: PropTypes.any,
  selectable: {
    type: Boolean,
    default: void 0
  },
  expandAction: [String, Boolean],
  disabled: {
    type: Boolean,
    default: void 0
  },
  multiple: {
    type: Boolean,
    default: void 0
  },
  checkable: {
    type: Boolean,
    default: void 0
  },
  checkStrictly: {
    type: Boolean,
    default: void 0
  },
  draggable: {
    type: [Function, Boolean]
  },
  defaultExpandParent: {
    type: Boolean,
    default: void 0
  },
  autoExpandParent: {
    type: Boolean,
    default: void 0
  },
  defaultExpandAll: {
    type: Boolean,
    default: void 0
  },
  defaultExpandedKeys: {
    type: Array
  },
  expandedKeys: {
    type: Array
  },
  defaultCheckedKeys: {
    type: Array
  },
  checkedKeys: {
    type: [Object, Array]
  },
  defaultSelectedKeys: {
    type: Array
  },
  selectedKeys: {
    type: Array
  },
  allowDrop: {
    type: Function
  },
  dropIndicatorRender: {
    type: Function
  },
  onFocus: {
    type: Function
  },
  onBlur: {
    type: Function
  },
  onKeydown: {
    type: Function
  },
  onContextmenu: {
    type: Function
  },
  onClick: {
    type: Function
  },
  onDblclick: {
    type: Function
  },
  onScroll: {
    type: Function
  },
  onExpand: {
    type: Function
  },
  onCheck: {
    type: Function
  },
  onSelect: {
    type: Function
  },
  onLoad: {
    type: Function
  },
  loadData: {
    type: Function
  },
  loadedKeys: {
    type: Array
  },
  onMouseenter: {
    type: Function
  },
  onMouseleave: {
    type: Function
  },
  onRightClick: {
    type: Function
  },
  onDragstart: {
    type: Function
  },
  onDragenter: {
    type: Function
  },
  onDragover: {
    type: Function
  },
  onDragleave: {
    type: Function
  },
  onDragend: {
    type: Function
  },
  onDrop: {
    type: Function
  },
  /**
   * Used for `rc-tree-select` only.
   * Do not use in your production code directly since this will be refactor.
   */
  onActiveChange: {
    type: Function
  },
  filterTreeNode: {
    type: Function
  },
  motion: PropTypes.any,
  switcherIcon: PropTypes.any,
  // Virtual List
  height: Number,
  itemHeight: Number,
  virtual: {
    type: Boolean,
    default: void 0
  },
  // direction for drag logic
  direction: {
    type: String
  },
  rootClassName: String,
  rootStyle: Object
});
var __rest$N = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const ICON_OPEN = "open";
const ICON_CLOSE = "close";
const defaultTitle = "---";
const VcTreeNode = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ATreeNode",
  inheritAttrs: false,
  props: treeNodeProps,
  isTreeNode: 1,
  setup(props2, _ref) {
    let {
      attrs,
      slots,
      expose
    } = _ref;
    warning$2(!("slots" in props2.data), `treeData slots is deprecated, please use ${Object.keys(props2.data.slots || {}).map((key2) => "`v-slot:" + key2 + "` ")}instead`);
    const dragNodeHighlight = shallowRef(false);
    const context2 = useInjectTreeContext();
    const {
      expandedKeysSet,
      selectedKeysSet,
      loadedKeysSet,
      loadingKeysSet,
      checkedKeysSet,
      halfCheckedKeysSet
    } = useInjectKeysState();
    const {
      dragOverNodeKey,
      dropPosition,
      keyEntities
    } = context2.value;
    const mergedTreeNodeProps = computed(() => {
      return getTreeNodeProps(props2.eventKey, {
        expandedKeysSet: expandedKeysSet.value,
        selectedKeysSet: selectedKeysSet.value,
        loadedKeysSet: loadedKeysSet.value,
        loadingKeysSet: loadingKeysSet.value,
        checkedKeysSet: checkedKeysSet.value,
        halfCheckedKeysSet: halfCheckedKeysSet.value,
        dragOverNodeKey,
        dropPosition,
        keyEntities
      });
    });
    const expanded = eagerComputed(() => mergedTreeNodeProps.value.expanded);
    const selected = eagerComputed(() => mergedTreeNodeProps.value.selected);
    const checked = eagerComputed(() => mergedTreeNodeProps.value.checked);
    const loaded = eagerComputed(() => mergedTreeNodeProps.value.loaded);
    const loading = eagerComputed(() => mergedTreeNodeProps.value.loading);
    const halfChecked = eagerComputed(() => mergedTreeNodeProps.value.halfChecked);
    const dragOver = eagerComputed(() => mergedTreeNodeProps.value.dragOver);
    const dragOverGapTop = eagerComputed(() => mergedTreeNodeProps.value.dragOverGapTop);
    const dragOverGapBottom = eagerComputed(() => mergedTreeNodeProps.value.dragOverGapBottom);
    const pos = eagerComputed(() => mergedTreeNodeProps.value.pos);
    const selectHandle = shallowRef();
    const hasChildren = computed(() => {
      const {
        eventKey
      } = props2;
      const {
        keyEntities: keyEntities2
      } = context2.value;
      const {
        children
      } = keyEntities2[eventKey] || {};
      return !!(children || []).length;
    });
    const isLeaf2 = computed(() => {
      const {
        isLeaf: isLeaf3
      } = props2;
      const {
        loadData
      } = context2.value;
      const has = hasChildren.value;
      if (isLeaf3 === false) {
        return false;
      }
      return isLeaf3 || !loadData && !has || loadData && loaded.value && !has;
    });
    const nodeState = computed(() => {
      if (isLeaf2.value) {
        return null;
      }
      return expanded.value ? ICON_OPEN : ICON_CLOSE;
    });
    const isDisabled = computed(() => {
      const {
        disabled
      } = props2;
      const {
        disabled: treeDisabled
      } = context2.value;
      return !!(treeDisabled || disabled);
    });
    const isCheckable = computed(() => {
      const {
        checkable
      } = props2;
      const {
        checkable: treeCheckable
      } = context2.value;
      if (!treeCheckable || checkable === false) return false;
      return treeCheckable;
    });
    const isSelectable = computed(() => {
      const {
        selectable
      } = props2;
      const {
        selectable: treeSelectable
      } = context2.value;
      if (typeof selectable === "boolean") {
        return selectable;
      }
      return treeSelectable;
    });
    const renderArgsData = computed(() => {
      const {
        data,
        active,
        checkable,
        disableCheckbox,
        disabled,
        selectable
      } = props2;
      return _extends$1(_extends$1({
        active,
        checkable,
        disableCheckbox,
        disabled,
        selectable
      }, data), {
        dataRef: data,
        data,
        isLeaf: isLeaf2.value,
        checked: checked.value,
        expanded: expanded.value,
        loading: loading.value,
        selected: selected.value,
        halfChecked: halfChecked.value
      });
    });
    const instance = getCurrentInstance();
    const eventData = computed(() => {
      const {
        eventKey
      } = props2;
      const {
        keyEntities: keyEntities2
      } = context2.value;
      const {
        parent: parent2
      } = keyEntities2[eventKey] || {};
      return _extends$1(_extends$1({}, convertNodePropsToEventData(_extends$1({}, props2, mergedTreeNodeProps.value))), {
        parent: parent2
      });
    });
    const dragNodeEvent = reactive({
      eventData,
      eventKey: computed(() => props2.eventKey),
      selectHandle,
      pos,
      key: instance.vnode.key
    });
    expose(dragNodeEvent);
    const onSelectorDoubleClick = (e2) => {
      const {
        onNodeDoubleClick
      } = context2.value;
      onNodeDoubleClick(e2, eventData.value);
    };
    const onSelect = (e2) => {
      if (isDisabled.value) return;
      const {
        onNodeSelect
      } = context2.value;
      e2.preventDefault();
      onNodeSelect(e2, eventData.value);
    };
    const onCheck = (e2) => {
      if (isDisabled.value) return;
      const {
        disableCheckbox
      } = props2;
      const {
        onNodeCheck
      } = context2.value;
      if (!isCheckable.value || disableCheckbox) return;
      e2.preventDefault();
      const targetChecked = !checked.value;
      onNodeCheck(e2, eventData.value, targetChecked);
    };
    const onSelectorClick = (e2) => {
      const {
        onNodeClick
      } = context2.value;
      onNodeClick(e2, eventData.value);
      if (isSelectable.value) {
        onSelect(e2);
      } else {
        onCheck(e2);
      }
    };
    const onMouseEnter = (e2) => {
      const {
        onNodeMouseEnter
      } = context2.value;
      onNodeMouseEnter(e2, eventData.value);
    };
    const onMouseLeave = (e2) => {
      const {
        onNodeMouseLeave
      } = context2.value;
      onNodeMouseLeave(e2, eventData.value);
    };
    const onContextmenu = (e2) => {
      const {
        onNodeContextMenu
      } = context2.value;
      onNodeContextMenu(e2, eventData.value);
    };
    const onDragStart = (e2) => {
      const {
        onNodeDragStart
      } = context2.value;
      e2.stopPropagation();
      dragNodeHighlight.value = true;
      onNodeDragStart(e2, dragNodeEvent);
      try {
        e2.dataTransfer.setData("text/plain", "");
      } catch (error) {
      }
    };
    const onDragEnter = (e2) => {
      const {
        onNodeDragEnter
      } = context2.value;
      e2.preventDefault();
      e2.stopPropagation();
      onNodeDragEnter(e2, dragNodeEvent);
    };
    const onDragOver = (e2) => {
      const {
        onNodeDragOver
      } = context2.value;
      e2.preventDefault();
      e2.stopPropagation();
      onNodeDragOver(e2, dragNodeEvent);
    };
    const onDragLeave = (e2) => {
      const {
        onNodeDragLeave
      } = context2.value;
      e2.stopPropagation();
      onNodeDragLeave(e2, dragNodeEvent);
    };
    const onDragEnd = (e2) => {
      const {
        onNodeDragEnd
      } = context2.value;
      e2.stopPropagation();
      dragNodeHighlight.value = false;
      onNodeDragEnd(e2, dragNodeEvent);
    };
    const onDrop = (e2) => {
      const {
        onNodeDrop
      } = context2.value;
      e2.preventDefault();
      e2.stopPropagation();
      dragNodeHighlight.value = false;
      onNodeDrop(e2, dragNodeEvent);
    };
    const onExpand = (e2) => {
      const {
        onNodeExpand
      } = context2.value;
      if (loading.value) return;
      onNodeExpand(e2, eventData.value);
    };
    const isDraggable = () => {
      const {
        data
      } = props2;
      const {
        draggable
      } = context2.value;
      return !!(draggable && (!draggable.nodeDraggable || draggable.nodeDraggable(data)));
    };
    const renderDragHandler = () => {
      const {
        draggable,
        prefixCls
      } = context2.value;
      return draggable && (draggable === null || draggable === void 0 ? void 0 : draggable.icon) ? createVNode("span", {
        "class": `${prefixCls}-draggable-icon`
      }, [draggable.icon]) : null;
    };
    const renderSwitcherIconDom = () => {
      var _a2, _b, _c;
      const {
        switcherIcon: switcherIconFromProps = slots.switcherIcon || ((_a2 = context2.value.slots) === null || _a2 === void 0 ? void 0 : _a2[(_c = (_b = props2.data) === null || _b === void 0 ? void 0 : _b.slots) === null || _c === void 0 ? void 0 : _c.switcherIcon])
      } = props2;
      const {
        switcherIcon: switcherIconFromCtx
      } = context2.value;
      const switcherIcon = switcherIconFromProps || switcherIconFromCtx;
      if (typeof switcherIcon === "function") {
        return switcherIcon(renderArgsData.value);
      }
      return switcherIcon;
    };
    const syncLoadData = () => {
      const {
        loadData,
        onNodeLoad
      } = context2.value;
      if (loading.value) {
        return;
      }
      if (loadData && expanded.value && !isLeaf2.value) {
        if (!hasChildren.value && !loaded.value) {
          onNodeLoad(eventData.value);
        }
      }
    };
    onMounted(() => {
      syncLoadData();
    });
    onUpdated(() => {
      syncLoadData();
    });
    const renderSwitcher = () => {
      const {
        prefixCls
      } = context2.value;
      const switcherIconDom = renderSwitcherIconDom();
      if (isLeaf2.value) {
        return switcherIconDom !== false ? createVNode("span", {
          "class": classNames(`${prefixCls}-switcher`, `${prefixCls}-switcher-noop`)
        }, [switcherIconDom]) : null;
      }
      const switcherCls = classNames(`${prefixCls}-switcher`, `${prefixCls}-switcher_${expanded.value ? ICON_OPEN : ICON_CLOSE}`);
      return switcherIconDom !== false ? createVNode("span", {
        "onClick": onExpand,
        "class": switcherCls
      }, [switcherIconDom]) : null;
    };
    const renderCheckbox = () => {
      var _a2, _b;
      const {
        disableCheckbox
      } = props2;
      const {
        prefixCls
      } = context2.value;
      const disabled = isDisabled.value;
      const checkable = isCheckable.value;
      if (!checkable) return null;
      return createVNode("span", {
        "class": classNames(`${prefixCls}-checkbox`, checked.value && `${prefixCls}-checkbox-checked`, !checked.value && halfChecked.value && `${prefixCls}-checkbox-indeterminate`, (disabled || disableCheckbox) && `${prefixCls}-checkbox-disabled`),
        "onClick": onCheck
      }, [(_b = (_a2 = context2.value).customCheckable) === null || _b === void 0 ? void 0 : _b.call(_a2)]);
    };
    const renderIcon2 = () => {
      const {
        prefixCls
      } = context2.value;
      return createVNode("span", {
        "class": classNames(`${prefixCls}-iconEle`, `${prefixCls}-icon__${nodeState.value || "docu"}`, loading.value && `${prefixCls}-icon_loading`)
      }, null);
    };
    const renderDropIndicator = () => {
      const {
        disabled,
        eventKey
      } = props2;
      const {
        draggable,
        dropLevelOffset,
        dropPosition: dropPosition2,
        prefixCls,
        indent,
        dropIndicatorRender: dropIndicatorRender2,
        dragOverNodeKey: dragOverNodeKey2,
        direction
      } = context2.value;
      const rootDraggable = draggable !== false;
      const showIndicator = !disabled && rootDraggable && dragOverNodeKey2 === eventKey;
      return showIndicator ? dropIndicatorRender2({
        dropPosition: dropPosition2,
        dropLevelOffset,
        indent,
        prefixCls,
        direction
      }) : null;
    };
    const renderSelector = () => {
      var _a2, _b, _c, _d, _e, _f;
      const {
        // title = slots.title ||
        //   context.value.slots?.[props.data?.slots?.title] ||
        //   context.value.slots?.title,
        // selected,
        icon = slots.icon,
        // loading,
        data
      } = props2;
      const title = slots.title || ((_a2 = context2.value.slots) === null || _a2 === void 0 ? void 0 : _a2[(_c = (_b = props2.data) === null || _b === void 0 ? void 0 : _b.slots) === null || _c === void 0 ? void 0 : _c.title]) || ((_d = context2.value.slots) === null || _d === void 0 ? void 0 : _d.title) || props2.title;
      const {
        prefixCls,
        showIcon,
        icon: treeIcon,
        loadData
        // slots: contextSlots,
      } = context2.value;
      const disabled = isDisabled.value;
      const wrapClass = `${prefixCls}-node-content-wrapper`;
      let $icon;
      if (showIcon) {
        const currentIcon = icon || ((_e = context2.value.slots) === null || _e === void 0 ? void 0 : _e[(_f = data === null || data === void 0 ? void 0 : data.slots) === null || _f === void 0 ? void 0 : _f.icon]) || treeIcon;
        $icon = currentIcon ? createVNode("span", {
          "class": classNames(`${prefixCls}-iconEle`, `${prefixCls}-icon__customize`)
        }, [typeof currentIcon === "function" ? currentIcon(renderArgsData.value) : currentIcon]) : renderIcon2();
      } else if (loadData && loading.value) {
        $icon = renderIcon2();
      }
      let titleNode;
      if (typeof title === "function") {
        titleNode = title(renderArgsData.value);
      } else {
        titleNode = title;
      }
      titleNode = titleNode === void 0 ? defaultTitle : titleNode;
      const $title = createVNode("span", {
        "class": `${prefixCls}-title`
      }, [titleNode]);
      return createVNode("span", {
        "ref": selectHandle,
        "title": typeof title === "string" ? title : "",
        "class": classNames(`${wrapClass}`, `${wrapClass}-${nodeState.value || "normal"}`, !disabled && (selected.value || dragNodeHighlight.value) && `${prefixCls}-node-selected`),
        "onMouseenter": onMouseEnter,
        "onMouseleave": onMouseLeave,
        "onContextmenu": onContextmenu,
        "onClick": onSelectorClick,
        "onDblclick": onSelectorDoubleClick
      }, [$icon, $title, renderDropIndicator()]);
    };
    return () => {
      const _a2 = _extends$1(_extends$1({}, props2), attrs), {
        eventKey,
        isLeaf: isLeaf3,
        isStart,
        isEnd,
        domRef,
        active,
        data,
        onMousemove,
        selectable
      } = _a2, otherProps = __rest$N(_a2, ["eventKey", "isLeaf", "isStart", "isEnd", "domRef", "active", "data", "onMousemove", "selectable"]);
      const {
        prefixCls,
        filterTreeNode,
        keyEntities: keyEntities2,
        dropContainerKey,
        dropTargetKey,
        draggingNodeKey
      } = context2.value;
      const disabled = isDisabled.value;
      const dataOrAriaAttributeProps = pickAttrs(otherProps, {
        aria: true,
        data: true
      });
      const {
        level
      } = keyEntities2[eventKey] || {};
      const isEndNode = isEnd[isEnd.length - 1];
      const mergedDraggable = isDraggable();
      const draggableWithoutDisabled = !disabled && mergedDraggable;
      const dragging = draggingNodeKey === eventKey;
      const ariaSelected = selectable !== void 0 ? {
        "aria-selected": !!selectable
      } : void 0;
      return createVNode("div", _objectSpread2$1(_objectSpread2$1({
        "ref": domRef,
        "class": classNames(attrs.class, `${prefixCls}-treenode`, {
          [`${prefixCls}-treenode-disabled`]: disabled,
          [`${prefixCls}-treenode-switcher-${expanded.value ? "open" : "close"}`]: !isLeaf3,
          [`${prefixCls}-treenode-checkbox-checked`]: checked.value,
          [`${prefixCls}-treenode-checkbox-indeterminate`]: halfChecked.value,
          [`${prefixCls}-treenode-selected`]: selected.value,
          [`${prefixCls}-treenode-loading`]: loading.value,
          [`${prefixCls}-treenode-active`]: active,
          [`${prefixCls}-treenode-leaf-last`]: isEndNode,
          [`${prefixCls}-treenode-draggable`]: draggableWithoutDisabled,
          dragging,
          "drop-target": dropTargetKey === eventKey,
          "drop-container": dropContainerKey === eventKey,
          "drag-over": !disabled && dragOver.value,
          "drag-over-gap-top": !disabled && dragOverGapTop.value,
          "drag-over-gap-bottom": !disabled && dragOverGapBottom.value,
          "filter-node": filterTreeNode && filterTreeNode(eventData.value)
        }),
        "style": attrs.style,
        "draggable": draggableWithoutDisabled,
        "aria-grabbed": dragging,
        "onDragstart": draggableWithoutDisabled ? onDragStart : void 0,
        "onDragenter": mergedDraggable ? onDragEnter : void 0,
        "onDragover": mergedDraggable ? onDragOver : void 0,
        "onDragleave": mergedDraggable ? onDragLeave : void 0,
        "onDrop": mergedDraggable ? onDrop : void 0,
        "onDragend": mergedDraggable ? onDragEnd : void 0,
        "onMousemove": onMousemove
      }, ariaSelected), dataOrAriaAttributeProps), [createVNode(Indent, {
        "prefixCls": prefixCls,
        "level": level,
        "isStart": isStart,
        "isEnd": isEnd
      }, null), renderDragHandler(), renderSwitcher(), renderCheckbox(), renderSelector()]);
    };
  }
});
(function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
});
function arrDel(list, value) {
  if (!list) return [];
  const clone2 = list.slice();
  const index2 = clone2.indexOf(value);
  if (index2 >= 0) {
    clone2.splice(index2, 1);
  }
  return clone2;
}
function arrAdd(list, value) {
  const clone2 = (list || []).slice();
  if (clone2.indexOf(value) === -1) {
    clone2.push(value);
  }
  return clone2;
}
function posToArr(pos) {
  return pos.split("-");
}
function getPosition(level, index2) {
  return `${level}-${index2}`;
}
function isTreeNode(node2) {
  return node2 && node2.type && node2.type.isTreeNode;
}
function getDragChildrenKeys(dragNodeKey, keyEntities) {
  const dragChildrenKeys = [];
  const entity = keyEntities[dragNodeKey];
  function dig() {
    let list = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    list.forEach((_ref) => {
      let {
        key: key2,
        children
      } = _ref;
      dragChildrenKeys.push(key2);
      dig(children);
    });
  }
  dig(entity.children);
  return dragChildrenKeys;
}
function isLastChild(treeNodeEntity) {
  if (treeNodeEntity.parent) {
    const posArr = posToArr(treeNodeEntity.pos);
    return Number(posArr[posArr.length - 1]) === treeNodeEntity.parent.children.length - 1;
  }
  return false;
}
function isFirstChild(treeNodeEntity) {
  const posArr = posToArr(treeNodeEntity.pos);
  return Number(posArr[posArr.length - 1]) === 0;
}
function calcDropPosition(event, dragNode, targetNode, indent, startMousePosition, allowDrop, flattenedNodes, keyEntities, expandKeysSet, direction) {
  var _a2;
  const {
    clientX,
    clientY
  } = event;
  const {
    top,
    height
  } = event.target.getBoundingClientRect();
  const horizontalMouseOffset = (direction === "rtl" ? -1 : 1) * (((startMousePosition === null || startMousePosition === void 0 ? void 0 : startMousePosition.x) || 0) - clientX);
  const rawDropLevelOffset = (horizontalMouseOffset - 12) / indent;
  let abstractDropNodeEntity = keyEntities[targetNode.eventKey];
  if (clientY < top + height / 2) {
    const nodeIndex = flattenedNodes.findIndex((flattenedNode) => flattenedNode.key === abstractDropNodeEntity.key);
    const prevNodeIndex = nodeIndex <= 0 ? 0 : nodeIndex - 1;
    const prevNodeKey = flattenedNodes[prevNodeIndex].key;
    abstractDropNodeEntity = keyEntities[prevNodeKey];
  }
  const initialAbstractDropNodeKey = abstractDropNodeEntity.key;
  const abstractDragOverEntity = abstractDropNodeEntity;
  const dragOverNodeKey = abstractDropNodeEntity.key;
  let dropPosition = 0;
  let dropLevelOffset = 0;
  if (!expandKeysSet.has(initialAbstractDropNodeKey)) {
    for (let i2 = 0; i2 < rawDropLevelOffset; i2 += 1) {
      if (isLastChild(abstractDropNodeEntity)) {
        abstractDropNodeEntity = abstractDropNodeEntity.parent;
        dropLevelOffset += 1;
      } else {
        break;
      }
    }
  }
  const abstractDragDataNode = dragNode.eventData;
  const abstractDropDataNode = abstractDropNodeEntity.node;
  let dropAllowed = true;
  if (isFirstChild(abstractDropNodeEntity) && abstractDropNodeEntity.level === 0 && clientY < top + height / 2 && allowDrop({
    dragNode: abstractDragDataNode,
    dropNode: abstractDropDataNode,
    dropPosition: -1
  }) && abstractDropNodeEntity.key === targetNode.eventKey) {
    dropPosition = -1;
  } else if ((abstractDragOverEntity.children || []).length && expandKeysSet.has(dragOverNodeKey)) {
    if (allowDrop({
      dragNode: abstractDragDataNode,
      dropNode: abstractDropDataNode,
      dropPosition: 0
    })) {
      dropPosition = 0;
    } else {
      dropAllowed = false;
    }
  } else if (dropLevelOffset === 0) {
    if (rawDropLevelOffset > -1.5) {
      if (allowDrop({
        dragNode: abstractDragDataNode,
        dropNode: abstractDropDataNode,
        dropPosition: 1
      })) {
        dropPosition = 1;
      } else {
        dropAllowed = false;
      }
    } else {
      if (allowDrop({
        dragNode: abstractDragDataNode,
        dropNode: abstractDropDataNode,
        dropPosition: 0
      })) {
        dropPosition = 0;
      } else if (allowDrop({
        dragNode: abstractDragDataNode,
        dropNode: abstractDropDataNode,
        dropPosition: 1
      })) {
        dropPosition = 1;
      } else {
        dropAllowed = false;
      }
    }
  } else {
    if (allowDrop({
      dragNode: abstractDragDataNode,
      dropNode: abstractDropDataNode,
      dropPosition: 1
    })) {
      dropPosition = 1;
    } else {
      dropAllowed = false;
    }
  }
  return {
    dropPosition,
    dropLevelOffset,
    dropTargetKey: abstractDropNodeEntity.key,
    dropTargetPos: abstractDropNodeEntity.pos,
    dragOverNodeKey,
    dropContainerKey: dropPosition === 0 ? null : ((_a2 = abstractDropNodeEntity.parent) === null || _a2 === void 0 ? void 0 : _a2.key) || null,
    dropAllowed
  };
}
function calcSelectedKeys(selectedKeys, props2) {
  if (!selectedKeys) return void 0;
  const {
    multiple
  } = props2;
  if (multiple) {
    return selectedKeys.slice();
  }
  if (selectedKeys.length) {
    return [selectedKeys[0]];
  }
  return selectedKeys;
}
function parseCheckedKeys(keys2) {
  if (!keys2) {
    return null;
  }
  let keyProps;
  if (Array.isArray(keys2)) {
    keyProps = {
      checkedKeys: keys2,
      halfCheckedKeys: void 0
    };
  } else if (typeof keys2 === "object") {
    keyProps = {
      checkedKeys: keys2.checked || void 0,
      halfCheckedKeys: keys2.halfChecked || void 0
    };
  } else {
    return null;
  }
  return keyProps;
}
function conductExpandParent(keyList, keyEntities) {
  const expandedKeys = /* @__PURE__ */ new Set();
  function conductUp(key2) {
    if (expandedKeys.has(key2)) return;
    const entity = keyEntities[key2];
    if (!entity) return;
    expandedKeys.add(key2);
    const {
      parent: parent2,
      node: node2
    } = entity;
    if (node2.disabled) return;
    if (parent2) {
      conductUp(parent2.key);
    }
  }
  (keyList || []).forEach((key2) => {
    conductUp(key2);
  });
  return [...expandedKeys];
}
var __rest$M = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
function getKey(key2, pos) {
  if (key2 !== null && key2 !== void 0) {
    return key2;
  }
  return pos;
}
function fillFieldNames(fieldNames) {
  const {
    title,
    _title,
    key: key2,
    children
  } = fieldNames || {};
  const mergedTitle = title || "title";
  return {
    title: mergedTitle,
    _title: _title || [mergedTitle],
    key: key2 || "key",
    children: children || "children"
  };
}
function convertTreeToData(rootNodes) {
  function dig() {
    let node2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const treeNodes = filterEmpty(node2);
    return treeNodes.map((treeNode) => {
      var _a2, _b, _c, _d;
      if (!isTreeNode(treeNode)) {
        return null;
      }
      const slots = treeNode.children || {};
      const key2 = treeNode.key;
      const props2 = {};
      for (const [k2, v2] of Object.entries(treeNode.props)) {
        props2[camelize(k2)] = v2;
      }
      const {
        isLeaf: isLeaf2,
        checkable,
        selectable,
        disabled,
        disableCheckbox
      } = props2;
      const newProps = {
        isLeaf: isLeaf2 || isLeaf2 === "" || void 0,
        checkable: checkable || checkable === "" || void 0,
        selectable: selectable || selectable === "" || void 0,
        disabled: disabled || disabled === "" || void 0,
        disableCheckbox: disableCheckbox || disableCheckbox === "" || void 0
      };
      const slotsProps = _extends$1(_extends$1({}, props2), newProps);
      const {
        title = (_a2 = slots.title) === null || _a2 === void 0 ? void 0 : _a2.call(slots, slotsProps),
        icon = (_b = slots.icon) === null || _b === void 0 ? void 0 : _b.call(slots, slotsProps),
        switcherIcon = (_c = slots.switcherIcon) === null || _c === void 0 ? void 0 : _c.call(slots, slotsProps)
      } = props2, rest = __rest$M(props2, ["title", "icon", "switcherIcon"]);
      const children = (_d = slots.default) === null || _d === void 0 ? void 0 : _d.call(slots);
      const dataNode = _extends$1(_extends$1(_extends$1({}, rest), {
        title,
        icon,
        switcherIcon,
        key: key2,
        isLeaf: isLeaf2
      }), newProps);
      const parsedChildren = dig(children);
      if (parsedChildren.length) {
        dataNode.children = parsedChildren;
      }
      return dataNode;
    });
  }
  return dig(rootNodes);
}
function flattenTreeData(treeNodeList, expandedKeys, fieldNames) {
  const {
    _title: fieldTitles,
    key: fieldKey,
    children: fieldChildren
  } = fillFieldNames(fieldNames);
  const expandedKeySet = new Set(expandedKeys === true ? [] : expandedKeys);
  const flattenList = [];
  function dig(list) {
    let parent2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    return list.map((treeNode, index2) => {
      const pos = getPosition(parent2 ? parent2.pos : "0", index2);
      const mergedKey = getKey(treeNode[fieldKey], pos);
      let mergedTitle;
      for (let i2 = 0; i2 < fieldTitles.length; i2 += 1) {
        const fieldTitle = fieldTitles[i2];
        if (treeNode[fieldTitle] !== void 0) {
          mergedTitle = treeNode[fieldTitle];
          break;
        }
      }
      const flattenNode = _extends$1(_extends$1({}, omit$1(treeNode, [...fieldTitles, fieldKey, fieldChildren])), {
        title: mergedTitle,
        key: mergedKey,
        parent: parent2,
        pos,
        children: null,
        data: treeNode,
        isStart: [...parent2 ? parent2.isStart : [], index2 === 0],
        isEnd: [...parent2 ? parent2.isEnd : [], index2 === list.length - 1]
      });
      flattenList.push(flattenNode);
      if (expandedKeys === true || expandedKeySet.has(mergedKey)) {
        flattenNode.children = dig(treeNode[fieldChildren] || [], flattenNode);
      } else {
        flattenNode.children = [];
      }
      return flattenNode;
    });
  }
  dig(treeNodeList);
  return flattenList;
}
function traverseDataNodes(dataNodes, callback, config) {
  let mergedConfig = {};
  if (typeof config === "object") {
    mergedConfig = config;
  } else {
    mergedConfig = {
      externalGetKey: config
    };
  }
  mergedConfig = mergedConfig || {};
  const {
    childrenPropName,
    externalGetKey,
    fieldNames
  } = mergedConfig;
  const {
    key: fieldKey,
    children: fieldChildren
  } = fillFieldNames(fieldNames);
  const mergeChildrenPropName = childrenPropName || fieldChildren;
  let syntheticGetKey;
  if (externalGetKey) {
    if (typeof externalGetKey === "string") {
      syntheticGetKey = (node2) => node2[externalGetKey];
    } else if (typeof externalGetKey === "function") {
      syntheticGetKey = (node2) => externalGetKey(node2);
    }
  } else {
    syntheticGetKey = (node2, pos) => getKey(node2[fieldKey], pos);
  }
  function processNode(node2, index2, parent2, pathNodes) {
    const children = node2 ? node2[mergeChildrenPropName] : dataNodes;
    const pos = node2 ? getPosition(parent2.pos, index2) : "0";
    const connectNodes = node2 ? [...pathNodes, node2] : [];
    if (node2) {
      const key2 = syntheticGetKey(node2, pos);
      const data = {
        node: node2,
        index: index2,
        pos,
        key: key2,
        parentPos: parent2.node ? parent2.pos : null,
        level: parent2.level + 1,
        nodes: connectNodes
      };
      callback(data);
    }
    if (children) {
      children.forEach((subNode, subIndex) => {
        processNode(subNode, subIndex, {
          node: node2,
          pos,
          level: parent2 ? parent2.level + 1 : -1
        }, connectNodes);
      });
    }
  }
  processNode(null);
}
function convertDataToEntities(dataNodes) {
  let {
    initWrapper,
    processEntity,
    onProcessFinished,
    externalGetKey,
    childrenPropName,
    fieldNames
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  let legacyExternalGetKey = arguments.length > 2 ? arguments[2] : void 0;
  const mergedExternalGetKey = externalGetKey || legacyExternalGetKey;
  const posEntities = {};
  const keyEntities = {};
  let wrapper = {
    posEntities,
    keyEntities
  };
  if (initWrapper) {
    wrapper = initWrapper(wrapper) || wrapper;
  }
  traverseDataNodes(dataNodes, (item) => {
    const {
      node: node2,
      index: index2,
      pos,
      key: key2,
      parentPos,
      level,
      nodes
    } = item;
    const entity = {
      node: node2,
      nodes,
      index: index2,
      key: key2,
      pos,
      level
    };
    const mergedKey = getKey(key2, pos);
    posEntities[pos] = entity;
    keyEntities[mergedKey] = entity;
    entity.parent = posEntities[parentPos];
    if (entity.parent) {
      entity.parent.children = entity.parent.children || [];
      entity.parent.children.push(entity);
    }
    if (processEntity) {
      processEntity(entity, wrapper);
    }
  }, {
    externalGetKey: mergedExternalGetKey,
    childrenPropName,
    fieldNames
  });
  if (onProcessFinished) {
    onProcessFinished(wrapper);
  }
  return wrapper;
}
function getTreeNodeProps(key2, _ref) {
  let {
    expandedKeysSet,
    selectedKeysSet,
    loadedKeysSet,
    loadingKeysSet,
    checkedKeysSet,
    halfCheckedKeysSet,
    dragOverNodeKey,
    dropPosition,
    keyEntities
  } = _ref;
  const entity = keyEntities[key2];
  const treeNodeProps2 = {
    eventKey: key2,
    expanded: expandedKeysSet.has(key2),
    selected: selectedKeysSet.has(key2),
    loaded: loadedKeysSet.has(key2),
    loading: loadingKeysSet.has(key2),
    checked: checkedKeysSet.has(key2),
    halfChecked: halfCheckedKeysSet.has(key2),
    pos: String(entity ? entity.pos : ""),
    parent: entity.parent,
    // [Legacy] Drag props
    // Since the interaction of drag is changed, the semantic of the props are
    // not accuracy, I think it should be finally removed
    dragOver: dragOverNodeKey === key2 && dropPosition === 0,
    dragOverGapTop: dragOverNodeKey === key2 && dropPosition === -1,
    dragOverGapBottom: dragOverNodeKey === key2 && dropPosition === 1
  };
  return treeNodeProps2;
}
function convertNodePropsToEventData(props2) {
  const {
    data,
    expanded,
    selected,
    checked,
    loaded,
    loading,
    halfChecked,
    dragOver,
    dragOverGapTop,
    dragOverGapBottom,
    pos,
    active,
    eventKey
  } = props2;
  const eventData = _extends$1(_extends$1({
    dataRef: data
  }, data), {
    expanded,
    selected,
    checked,
    loaded,
    loading,
    halfChecked,
    dragOver,
    dragOverGapTop,
    dragOverGapBottom,
    pos,
    active,
    eventKey,
    key: eventKey
  });
  if (!("props" in eventData)) {
    Object.defineProperty(eventData, "props", {
      get() {
        return props2;
      }
    });
  }
  return eventData;
}
const useEntities = (options, fieldNames) => {
  const entities = computed(() => {
    return convertDataToEntities(options.value, {
      fieldNames: fieldNames.value,
      initWrapper: (wrapper) => _extends$1(_extends$1({}, wrapper), {
        pathKeyEntities: {}
      }),
      processEntity: (entity, wrapper) => {
        const pathKey = entity.nodes.map((node2) => node2[fieldNames.value.value]).join(VALUE_SPLIT);
        wrapper.pathKeyEntities[pathKey] = entity;
        entity.key = pathKey;
      }
    }).pathKeyEntities;
  });
  return entities;
};
function useSearchConfig(showSearch) {
  const mergedShowSearch = shallowRef(false);
  const mergedSearchConfig = ref({});
  watchEffect(() => {
    if (!showSearch.value) {
      mergedShowSearch.value = false;
      mergedSearchConfig.value = {};
      return;
    }
    let searchConfig = {
      matchInputWidth: true,
      limit: 50
    };
    if (showSearch.value && typeof showSearch.value === "object") {
      searchConfig = _extends$1(_extends$1({}, searchConfig), showSearch.value);
    }
    if (searchConfig.limit <= 0) {
      delete searchConfig.limit;
    }
    mergedShowSearch.value = true;
    mergedSearchConfig.value = searchConfig;
    return;
  });
  return {
    showSearch: mergedShowSearch,
    searchConfig: mergedSearchConfig
  };
}
const SEARCH_MARK = "__rc_cascader_search_mark__";
const defaultFilter = (search, options, _ref) => {
  let {
    label
  } = _ref;
  return options.some((opt) => String(opt[label]).toLowerCase().includes(search.toLowerCase()));
};
const defaultRender = (_ref2) => {
  let {
    path: path2,
    fieldNames
  } = _ref2;
  return path2.map((opt) => opt[fieldNames.label]).join(" / ");
};
const useSearchOptions = (search, options, fieldNames, prefixCls, config, changeOnSelect) => {
  return computed(() => {
    const {
      filter = defaultFilter,
      render: render8 = defaultRender,
      limit = 50,
      sort
    } = config.value;
    const filteredOptions = [];
    if (!search.value) {
      return [];
    }
    function dig(list, pathOptions) {
      list.forEach((option) => {
        if (!sort && limit > 0 && filteredOptions.length >= limit) {
          return;
        }
        const connectedPathOptions = [...pathOptions, option];
        const children = option[fieldNames.value.children];
        if (
          // If is leaf option
          !children || children.length === 0 || // If is changeOnSelect
          changeOnSelect.value
        ) {
          if (filter(search.value, connectedPathOptions, {
            label: fieldNames.value.label
          })) {
            filteredOptions.push(_extends$1(_extends$1({}, option), {
              [fieldNames.value.label]: render8({
                inputValue: search.value,
                path: connectedPathOptions,
                prefixCls: prefixCls.value,
                fieldNames: fieldNames.value
              }),
              [SEARCH_MARK]: connectedPathOptions
            }));
          }
        }
        if (children) {
          dig(option[fieldNames.value.children], connectedPathOptions);
        }
      });
    }
    dig(options.value, []);
    if (sort) {
      filteredOptions.sort((a2, b2) => {
        return sort(a2[SEARCH_MARK], b2[SEARCH_MARK], search.value, fieldNames.value);
      });
    }
    return limit > 0 ? filteredOptions.slice(0, limit) : filteredOptions;
  });
};
function formatStrategyValues(pathKeys, keyPathEntities, showCheckedStrategy) {
  const valueSet = new Set(pathKeys);
  return pathKeys.filter((key2) => {
    const entity = keyPathEntities[key2];
    const parent2 = entity ? entity.parent : null;
    const children = entity ? entity.children : null;
    return showCheckedStrategy === SHOW_CHILD ? !(children && children.some((child) => child.key && valueSet.has(child.key))) : !(parent2 && !parent2.node.disabled && valueSet.has(parent2.key));
  });
}
function toPathOptions(valueCells, options, fieldNames) {
  let stringMode = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  var _a2;
  let currentList = options;
  const valueOptions = [];
  for (let i2 = 0; i2 < valueCells.length; i2 += 1) {
    const valueCell = valueCells[i2];
    const foundIndex = currentList === null || currentList === void 0 ? void 0 : currentList.findIndex((option) => {
      const val = option[fieldNames.value];
      return stringMode ? String(val) === String(valueCell) : val === valueCell;
    });
    const foundOption = foundIndex !== -1 ? currentList === null || currentList === void 0 ? void 0 : currentList[foundIndex] : null;
    valueOptions.push({
      value: (_a2 = foundOption === null || foundOption === void 0 ? void 0 : foundOption[fieldNames.value]) !== null && _a2 !== void 0 ? _a2 : valueCell,
      index: foundIndex,
      option: foundOption
    });
    currentList = foundOption === null || foundOption === void 0 ? void 0 : foundOption[fieldNames.children];
  }
  return valueOptions;
}
const useMissingValues = (options, fieldNames, rawValues) => {
  return computed(() => {
    const missingValues = [];
    const existsValues = [];
    rawValues.value.forEach((valueCell) => {
      const pathOptions = toPathOptions(valueCell, options.value, fieldNames.value);
      if (pathOptions.every((opt) => opt.option)) {
        existsValues.push(valueCell);
      } else {
        missingValues.push(valueCell);
      }
    });
    return [existsValues, missingValues];
  });
};
function removeFromCheckedKeys(halfCheckedKeys, checkedKeys) {
  const filteredKeys = /* @__PURE__ */ new Set();
  halfCheckedKeys.forEach((key2) => {
    if (!checkedKeys.has(key2)) {
      filteredKeys.add(key2);
    }
  });
  return filteredKeys;
}
function isCheckDisabled(node2) {
  const {
    disabled,
    disableCheckbox,
    checkable
  } = node2 || {};
  return !!(disabled || disableCheckbox) || checkable === false;
}
function fillConductCheck(keys2, levelEntities, maxLevel, syntheticGetCheckDisabled) {
  const checkedKeys = new Set(keys2);
  const halfCheckedKeys = /* @__PURE__ */ new Set();
  for (let level = 0; level <= maxLevel; level += 1) {
    const entities = levelEntities.get(level) || /* @__PURE__ */ new Set();
    entities.forEach((entity) => {
      const {
        key: key2,
        node: node2,
        children = []
      } = entity;
      if (checkedKeys.has(key2) && !syntheticGetCheckDisabled(node2)) {
        children.filter((childEntity) => !syntheticGetCheckDisabled(childEntity.node)).forEach((childEntity) => {
          checkedKeys.add(childEntity.key);
        });
      }
    });
  }
  const visitedKeys = /* @__PURE__ */ new Set();
  for (let level = maxLevel; level >= 0; level -= 1) {
    const entities = levelEntities.get(level) || /* @__PURE__ */ new Set();
    entities.forEach((entity) => {
      const {
        parent: parent2,
        node: node2
      } = entity;
      if (syntheticGetCheckDisabled(node2) || !entity.parent || visitedKeys.has(entity.parent.key)) {
        return;
      }
      if (syntheticGetCheckDisabled(entity.parent.node)) {
        visitedKeys.add(parent2.key);
        return;
      }
      let allChecked = true;
      let partialChecked = false;
      (parent2.children || []).filter((childEntity) => !syntheticGetCheckDisabled(childEntity.node)).forEach((_ref) => {
        let {
          key: key2
        } = _ref;
        const checked = checkedKeys.has(key2);
        if (allChecked && !checked) {
          allChecked = false;
        }
        if (!partialChecked && (checked || halfCheckedKeys.has(key2))) {
          partialChecked = true;
        }
      });
      if (allChecked) {
        checkedKeys.add(parent2.key);
      }
      if (partialChecked) {
        halfCheckedKeys.add(parent2.key);
      }
      visitedKeys.add(parent2.key);
    });
  }
  return {
    checkedKeys: Array.from(checkedKeys),
    halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))
  };
}
function cleanConductCheck(keys2, halfKeys, levelEntities, maxLevel, syntheticGetCheckDisabled) {
  const checkedKeys = new Set(keys2);
  let halfCheckedKeys = new Set(halfKeys);
  for (let level = 0; level <= maxLevel; level += 1) {
    const entities = levelEntities.get(level) || /* @__PURE__ */ new Set();
    entities.forEach((entity) => {
      const {
        key: key2,
        node: node2,
        children = []
      } = entity;
      if (!checkedKeys.has(key2) && !halfCheckedKeys.has(key2) && !syntheticGetCheckDisabled(node2)) {
        children.filter((childEntity) => !syntheticGetCheckDisabled(childEntity.node)).forEach((childEntity) => {
          checkedKeys.delete(childEntity.key);
        });
      }
    });
  }
  halfCheckedKeys = /* @__PURE__ */ new Set();
  const visitedKeys = /* @__PURE__ */ new Set();
  for (let level = maxLevel; level >= 0; level -= 1) {
    const entities = levelEntities.get(level) || /* @__PURE__ */ new Set();
    entities.forEach((entity) => {
      const {
        parent: parent2,
        node: node2
      } = entity;
      if (syntheticGetCheckDisabled(node2) || !entity.parent || visitedKeys.has(entity.parent.key)) {
        return;
      }
      if (syntheticGetCheckDisabled(entity.parent.node)) {
        visitedKeys.add(parent2.key);
        return;
      }
      let allChecked = true;
      let partialChecked = false;
      (parent2.children || []).filter((childEntity) => !syntheticGetCheckDisabled(childEntity.node)).forEach((_ref2) => {
        let {
          key: key2
        } = _ref2;
        const checked = checkedKeys.has(key2);
        if (allChecked && !checked) {
          allChecked = false;
        }
        if (!partialChecked && (checked || halfCheckedKeys.has(key2))) {
          partialChecked = true;
        }
      });
      if (!allChecked) {
        checkedKeys.delete(parent2.key);
      }
      if (partialChecked) {
        halfCheckedKeys.add(parent2.key);
      }
      visitedKeys.add(parent2.key);
    });
  }
  return {
    checkedKeys: Array.from(checkedKeys),
    halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))
  };
}
function conductCheck(keyList, checked, keyEntities, maxLevel, levelEntities, getCheckDisabled) {
  let syntheticGetCheckDisabled;
  if (getCheckDisabled) {
    syntheticGetCheckDisabled = getCheckDisabled;
  } else {
    syntheticGetCheckDisabled = isCheckDisabled;
  }
  const keys2 = new Set(keyList.filter((key2) => {
    const hasEntity = !!keyEntities[key2];
    return hasEntity;
  }));
  let result;
  if (checked === true) {
    result = fillConductCheck(keys2, levelEntities, maxLevel, syntheticGetCheckDisabled);
  } else {
    result = cleanConductCheck(keys2, checked.halfCheckedKeys, levelEntities, maxLevel, syntheticGetCheckDisabled);
  }
  return result;
}
const useDisplayValues = (rawValues, options, fieldNames, multiple, displayRender) => {
  return computed(() => {
    const mergedDisplayRender = displayRender.value || // Default displayRender
    ((_ref) => {
      let {
        labels
      } = _ref;
      const mergedLabels = multiple.value ? labels.slice(-1) : labels;
      const SPLIT2 = " / ";
      if (mergedLabels.every((label) => ["string", "number"].includes(typeof label))) {
        return mergedLabels.join(SPLIT2);
      }
      return mergedLabels.reduce((list, label, index2) => {
        const keyedLabel = isValidElement(label) ? cloneElement(label, {
          key: index2
        }) : label;
        if (index2 === 0) {
          return [keyedLabel];
        }
        return [...list, SPLIT2, keyedLabel];
      }, []);
    });
    return rawValues.value.map((valueCells) => {
      const valueOptions = toPathOptions(valueCells, options.value, fieldNames.value);
      const label = mergedDisplayRender({
        labels: valueOptions.map((_ref2) => {
          let {
            option,
            value: value2
          } = _ref2;
          var _a2;
          return (_a2 = option === null || option === void 0 ? void 0 : option[fieldNames.value.label]) !== null && _a2 !== void 0 ? _a2 : value2;
        }),
        selectedOptions: valueOptions.map((_ref3) => {
          let {
            option
          } = _ref3;
          return option;
        })
      });
      const value = toPathKey(valueCells);
      return {
        label,
        value,
        key: value,
        valueCells
      };
    });
  });
};
const CascaderContextKey = Symbol("CascaderContextKey");
const useProvideCascader = (props2) => {
  provide(CascaderContextKey, props2);
};
const useInjectCascader = () => {
  return inject(CascaderContextKey);
};
const useActive = () => {
  const baseProps2 = useBaseProps();
  const {
    values
  } = useInjectCascader();
  const [activeValueCells, setActiveValueCells] = useState([]);
  watch(() => baseProps2.open, () => {
    if (baseProps2.open && !baseProps2.multiple) {
      const firstValueCells = values.value[0];
      setActiveValueCells(firstValueCells || []);
    }
  }, {
    immediate: true
  });
  return [activeValueCells, setActiveValueCells];
};
const useKeyboard = (context2, options, fieldNames, activeValueCells, setActiveValueCells, onKeyBoardSelect) => {
  const baseProps2 = useBaseProps();
  const rtl2 = computed(() => baseProps2.direction === "rtl");
  const [validActiveValueCells, lastActiveIndex, lastActiveOptions] = [ref([]), ref(), ref([])];
  watchEffect(() => {
    let activeIndex = -1;
    let currentOptions = options.value;
    const mergedActiveIndexes = [];
    const mergedActiveValueCells = [];
    const len = activeValueCells.value.length;
    for (let i2 = 0; i2 < len && currentOptions; i2 += 1) {
      const nextActiveIndex = currentOptions.findIndex((option) => option[fieldNames.value.value] === activeValueCells.value[i2]);
      if (nextActiveIndex === -1) {
        break;
      }
      activeIndex = nextActiveIndex;
      mergedActiveIndexes.push(activeIndex);
      mergedActiveValueCells.push(activeValueCells.value[i2]);
      currentOptions = currentOptions[activeIndex][fieldNames.value.children];
    }
    let activeOptions = options.value;
    for (let i2 = 0; i2 < mergedActiveIndexes.length - 1; i2 += 1) {
      activeOptions = activeOptions[mergedActiveIndexes[i2]][fieldNames.value.children];
    }
    [validActiveValueCells.value, lastActiveIndex.value, lastActiveOptions.value] = [mergedActiveValueCells, activeIndex, activeOptions];
  });
  const internalSetActiveValueCells = (next2) => {
    setActiveValueCells(next2);
  };
  const offsetActiveOption = (offset3) => {
    const len = lastActiveOptions.value.length;
    let currentIndex = lastActiveIndex.value;
    if (currentIndex === -1 && offset3 < 0) {
      currentIndex = len;
    }
    for (let i2 = 0; i2 < len; i2 += 1) {
      currentIndex = (currentIndex + offset3 + len) % len;
      const option = lastActiveOptions.value[currentIndex];
      if (option && !option.disabled) {
        const value = option[fieldNames.value.value];
        const nextActiveCells = validActiveValueCells.value.slice(0, -1).concat(value);
        internalSetActiveValueCells(nextActiveCells);
        return;
      }
    }
  };
  const prevColumn = () => {
    if (validActiveValueCells.value.length > 1) {
      const nextActiveCells = validActiveValueCells.value.slice(0, -1);
      internalSetActiveValueCells(nextActiveCells);
    } else {
      baseProps2.toggleOpen(false);
    }
  };
  const nextColumn = () => {
    var _a2;
    const nextOptions = ((_a2 = lastActiveOptions.value[lastActiveIndex.value]) === null || _a2 === void 0 ? void 0 : _a2[fieldNames.value.children]) || [];
    const nextOption = nextOptions.find((option) => !option.disabled);
    if (nextOption) {
      const nextActiveCells = [...validActiveValueCells.value, nextOption[fieldNames.value.value]];
      internalSetActiveValueCells(nextActiveCells);
    }
  };
  context2.expose({
    // scrollTo: treeRef.current?.scrollTo,
    onKeydown: (event) => {
      const {
        which
      } = event;
      switch (which) {
        // >>> Arrow keys
        case KeyCode.UP:
        case KeyCode.DOWN: {
          let offset3 = 0;
          if (which === KeyCode.UP) {
            offset3 = -1;
          } else if (which === KeyCode.DOWN) {
            offset3 = 1;
          }
          if (offset3 !== 0) {
            offsetActiveOption(offset3);
          }
          break;
        }
        case KeyCode.LEFT: {
          if (rtl2.value) {
            nextColumn();
          } else {
            prevColumn();
          }
          break;
        }
        case KeyCode.RIGHT: {
          if (rtl2.value) {
            prevColumn();
          } else {
            nextColumn();
          }
          break;
        }
        case KeyCode.BACKSPACE: {
          if (!baseProps2.searchValue) {
            prevColumn();
          }
          break;
        }
        // >>> Select
        case KeyCode.ENTER: {
          if (validActiveValueCells.value.length) {
            const option = lastActiveOptions.value[lastActiveIndex.value];
            const originOptions = (option === null || option === void 0 ? void 0 : option[SEARCH_MARK]) || [];
            if (originOptions.length) {
              onKeyBoardSelect(originOptions.map((opt) => opt[fieldNames.value.value]), originOptions[originOptions.length - 1]);
            } else {
              onKeyBoardSelect(validActiveValueCells.value, option);
            }
          }
          break;
        }
        // >>> Close
        case KeyCode.ESC: {
          baseProps2.toggleOpen(false);
          if (open) {
            event.stopPropagation();
          }
        }
      }
    },
    onKeyup: () => {
    }
  });
};
function Checkbox$1(_ref) {
  let {
    prefixCls,
    checked,
    halfChecked,
    disabled,
    onClick
  } = _ref;
  const {
    customSlots,
    checkable
  } = useInjectCascader();
  const mergedCheckable = checkable.value !== false ? customSlots.value.checkable : checkable.value;
  const customCheckbox = typeof mergedCheckable === "function" ? mergedCheckable() : typeof mergedCheckable === "boolean" ? null : mergedCheckable;
  return createVNode("span", {
    "class": {
      [prefixCls]: true,
      [`${prefixCls}-checked`]: checked,
      [`${prefixCls}-indeterminate`]: !checked && halfChecked,
      [`${prefixCls}-disabled`]: disabled
    },
    "onClick": onClick
  }, [customCheckbox]);
}
Checkbox$1.props = ["prefixCls", "checked", "halfChecked", "disabled", "onClick"];
Checkbox$1.displayName = "Checkbox";
Checkbox$1.inheritAttrs = false;
const FIX_LABEL = "__cascader_fix_label__";
function Column$1(_ref) {
  let {
    prefixCls,
    multiple,
    options,
    activeValue,
    prevValuePath,
    onToggleOpen,
    onSelect,
    onActive,
    checkedSet,
    halfCheckedSet,
    loadingKeys,
    isSelectable
  } = _ref;
  var _a2, _b, _c, _d, _e, _f;
  const menuPrefixCls = `${prefixCls}-menu`;
  const menuItemPrefixCls = `${prefixCls}-menu-item`;
  const {
    fieldNames,
    changeOnSelect,
    expandTrigger,
    expandIcon: expandIconRef,
    loadingIcon: loadingIconRef,
    dropdownMenuColumnStyle,
    customSlots
  } = useInjectCascader();
  const expandIcon = (_a2 = expandIconRef.value) !== null && _a2 !== void 0 ? _a2 : (_c = (_b = customSlots.value).expandIcon) === null || _c === void 0 ? void 0 : _c.call(_b);
  const loadingIcon = (_d = loadingIconRef.value) !== null && _d !== void 0 ? _d : (_f = (_e = customSlots.value).loadingIcon) === null || _f === void 0 ? void 0 : _f.call(_e);
  const hoverOpen = expandTrigger.value === "hover";
  return createVNode("ul", {
    "class": menuPrefixCls,
    "role": "menu"
  }, [options.map((option) => {
    var _a3;
    const {
      disabled
    } = option;
    const searchOptions = option[SEARCH_MARK];
    const label = (_a3 = option[FIX_LABEL]) !== null && _a3 !== void 0 ? _a3 : option[fieldNames.value.label];
    const value = option[fieldNames.value.value];
    const isMergedLeaf = isLeaf(option, fieldNames.value);
    const fullPath = searchOptions ? searchOptions.map((opt) => opt[fieldNames.value.value]) : [...prevValuePath, value];
    const fullPathKey = toPathKey(fullPath);
    const isLoading = loadingKeys.includes(fullPathKey);
    const checked = checkedSet.has(fullPathKey);
    const halfChecked = halfCheckedSet.has(fullPathKey);
    const triggerOpenPath = () => {
      if (!disabled && (!hoverOpen || !isMergedLeaf)) {
        onActive(fullPath);
      }
    };
    const triggerSelect = () => {
      if (isSelectable(option)) {
        onSelect(fullPath, isMergedLeaf);
      }
    };
    let title;
    if (typeof option.title === "string") {
      title = option.title;
    } else if (typeof label === "string") {
      title = label;
    }
    return createVNode("li", {
      "key": fullPathKey,
      "class": [menuItemPrefixCls, {
        [`${menuItemPrefixCls}-expand`]: !isMergedLeaf,
        [`${menuItemPrefixCls}-active`]: activeValue === value,
        [`${menuItemPrefixCls}-disabled`]: disabled,
        [`${menuItemPrefixCls}-loading`]: isLoading
      }],
      "style": dropdownMenuColumnStyle.value,
      "role": "menuitemcheckbox",
      "title": title,
      "aria-checked": checked,
      "data-path-key": fullPathKey,
      "onClick": () => {
        triggerOpenPath();
        if (!multiple || isMergedLeaf) {
          triggerSelect();
        }
      },
      "onDblclick": () => {
        if (changeOnSelect.value) {
          onToggleOpen(false);
        }
      },
      "onMouseenter": () => {
        if (hoverOpen) {
          triggerOpenPath();
        }
      },
      "onMousedown": (e2) => {
        e2.preventDefault();
      }
    }, [multiple && createVNode(Checkbox$1, {
      "prefixCls": `${prefixCls}-checkbox`,
      "checked": checked,
      "halfChecked": halfChecked,
      "disabled": disabled,
      "onClick": (e2) => {
        e2.stopPropagation();
        triggerSelect();
      }
    }, null), createVNode("div", {
      "class": `${menuItemPrefixCls}-content`
    }, [label]), !isLoading && expandIcon && !isMergedLeaf && createVNode("div", {
      "class": `${menuItemPrefixCls}-expand-icon`
    }, [cloneElement(expandIcon)]), isLoading && loadingIcon && createVNode("div", {
      "class": `${menuItemPrefixCls}-loading-icon`
    }, [cloneElement(loadingIcon)])]);
  })]);
}
Column$1.props = ["prefixCls", "multiple", "options", "activeValue", "prevValuePath", "onToggleOpen", "onSelect", "onActive", "checkedSet", "halfCheckedSet", "loadingKeys", "isSelectable"];
Column$1.displayName = "Column";
Column$1.inheritAttrs = false;
const OptionList = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "OptionList",
  inheritAttrs: false,
  setup(_props, context2) {
    const {
      attrs,
      slots
    } = context2;
    const baseProps2 = useBaseProps();
    const containerRef = ref();
    const rtl2 = computed(() => baseProps2.direction === "rtl");
    const {
      options,
      values,
      halfValues,
      fieldNames,
      changeOnSelect,
      onSelect,
      searchOptions,
      dropdownPrefixCls,
      loadData,
      expandTrigger,
      customSlots
    } = useInjectCascader();
    const mergedPrefixCls = computed(() => dropdownPrefixCls.value || baseProps2.prefixCls);
    const loadingKeys = shallowRef([]);
    const internalLoadData = (valueCells) => {
      if (!loadData.value || baseProps2.searchValue) {
        return;
      }
      const optionList = toPathOptions(valueCells, options.value, fieldNames.value);
      const rawOptions = optionList.map((_ref) => {
        let {
          option
        } = _ref;
        return option;
      });
      const lastOption = rawOptions[rawOptions.length - 1];
      if (lastOption && !isLeaf(lastOption, fieldNames.value)) {
        const pathKey = toPathKey(valueCells);
        loadingKeys.value = [...loadingKeys.value, pathKey];
        loadData.value(rawOptions);
      }
    };
    watchEffect(() => {
      if (loadingKeys.value.length) {
        loadingKeys.value.forEach((loadingKey) => {
          const valueStrCells = toPathValueStr(loadingKey);
          const optionList = toPathOptions(valueStrCells, options.value, fieldNames.value, true).map((_ref2) => {
            let {
              option
            } = _ref2;
            return option;
          });
          const lastOption = optionList[optionList.length - 1];
          if (!lastOption || lastOption[fieldNames.value.children] || isLeaf(lastOption, fieldNames.value)) {
            loadingKeys.value = loadingKeys.value.filter((key2) => key2 !== loadingKey);
          }
        });
      }
    });
    const checkedSet = computed(() => new Set(toPathKeys(values.value)));
    const halfCheckedSet = computed(() => new Set(toPathKeys(halfValues.value)));
    const [activeValueCells, setActiveValueCells] = useActive();
    const onPathOpen = (nextValueCells) => {
      setActiveValueCells(nextValueCells);
      internalLoadData(nextValueCells);
    };
    const isSelectable = (option) => {
      const {
        disabled
      } = option;
      const isMergedLeaf = isLeaf(option, fieldNames.value);
      return !disabled && (isMergedLeaf || changeOnSelect.value || baseProps2.multiple);
    };
    const onPathSelect = function(valuePath, leaf) {
      let fromKeyboard = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      onSelect(valuePath);
      if (!baseProps2.multiple && (leaf || changeOnSelect.value && (expandTrigger.value === "hover" || fromKeyboard))) {
        baseProps2.toggleOpen(false);
      }
    };
    const mergedOptions = computed(() => {
      if (baseProps2.searchValue) {
        return searchOptions.value;
      }
      return options.value;
    });
    const optionColumns = computed(() => {
      const optionList = [{
        options: mergedOptions.value
      }];
      let currentList = mergedOptions.value;
      for (let i2 = 0; i2 < activeValueCells.value.length; i2 += 1) {
        const activeValueCell = activeValueCells.value[i2];
        const currentOption = currentList.find((option) => option[fieldNames.value.value] === activeValueCell);
        const subOptions = currentOption === null || currentOption === void 0 ? void 0 : currentOption[fieldNames.value.children];
        if (!(subOptions === null || subOptions === void 0 ? void 0 : subOptions.length)) {
          break;
        }
        currentList = subOptions;
        optionList.push({
          options: subOptions
        });
      }
      return optionList;
    });
    const onKeyboardSelect = (selectValueCells, option) => {
      if (isSelectable(option)) {
        onPathSelect(selectValueCells, isLeaf(option, fieldNames.value), true);
      }
    };
    useKeyboard(context2, mergedOptions, fieldNames, activeValueCells, onPathOpen, onKeyboardSelect);
    const onListMouseDown = (event) => {
      event.preventDefault();
    };
    onMounted(() => {
      watch(activeValueCells, (cells) => {
        var _a2;
        for (let i2 = 0; i2 < cells.length; i2 += 1) {
          const cellPath = cells.slice(0, i2 + 1);
          const cellKeyPath = toPathKey(cellPath);
          const ele = (_a2 = containerRef.value) === null || _a2 === void 0 ? void 0 : _a2.querySelector(`li[data-path-key="${cellKeyPath.replace(/\\{0,2}"/g, '\\"')}"]`);
          if (ele) {
            scrollIntoParentView(ele);
          }
        }
      }, {
        flush: "post",
        immediate: true
      });
    });
    return () => {
      var _a2, _b, _c, _d, _e;
      const {
        notFoundContent = ((_a2 = slots.notFoundContent) === null || _a2 === void 0 ? void 0 : _a2.call(slots)) || ((_c = (_b = customSlots.value).notFoundContent) === null || _c === void 0 ? void 0 : _c.call(_b)),
        multiple,
        toggleOpen
      } = baseProps2;
      const isEmpty2 = !((_e = (_d = optionColumns.value[0]) === null || _d === void 0 ? void 0 : _d.options) === null || _e === void 0 ? void 0 : _e.length);
      const emptyList = [{
        [fieldNames.value.value]: "__EMPTY__",
        [FIX_LABEL]: notFoundContent,
        disabled: true
      }];
      const columnProps = _extends$1(_extends$1({}, attrs), {
        multiple: !isEmpty2 && multiple,
        onSelect: onPathSelect,
        onActive: onPathOpen,
        onToggleOpen: toggleOpen,
        checkedSet: checkedSet.value,
        halfCheckedSet: halfCheckedSet.value,
        loadingKeys: loadingKeys.value,
        isSelectable
      });
      const mergedOptionColumns = isEmpty2 ? [{
        options: emptyList
      }] : optionColumns.value;
      const columnNodes = mergedOptionColumns.map((col, index2) => {
        const prevValuePath = activeValueCells.value.slice(0, index2);
        const activeValue = activeValueCells.value[index2];
        return createVNode(Column$1, _objectSpread2$1(_objectSpread2$1({
          "key": index2
        }, columnProps), {}, {
          "prefixCls": mergedPrefixCls.value,
          "options": col.options,
          "prevValuePath": prevValuePath,
          "activeValue": activeValue
        }), null);
      });
      return createVNode("div", {
        "class": [`${mergedPrefixCls.value}-menus`, {
          [`${mergedPrefixCls.value}-menu-empty`]: isEmpty2,
          [`${mergedPrefixCls.value}-rtl`]: rtl2.value
        }],
        "onMousedown": onListMouseDown,
        "ref": containerRef
      }, [columnNodes]);
    };
  }
});
function useMaxLevel(keyEntities) {
  const maxLevel = ref(0);
  const levelEntities = shallowRef();
  watchEffect(() => {
    const newLevelEntities = /* @__PURE__ */ new Map();
    let newMaxLevel = 0;
    const keyEntitiesValue = keyEntities.value || {};
    for (const key2 in keyEntitiesValue) {
      if (Object.prototype.hasOwnProperty.call(keyEntitiesValue, key2)) {
        const entity = keyEntitiesValue[key2];
        const {
          level
        } = entity;
        let levelSet = newLevelEntities.get(level);
        if (!levelSet) {
          levelSet = /* @__PURE__ */ new Set();
          newLevelEntities.set(level, levelSet);
        }
        levelSet.add(entity);
        newMaxLevel = Math.max(newMaxLevel, level);
      }
    }
    maxLevel.value = newMaxLevel;
    levelEntities.value = newLevelEntities;
  });
  return {
    maxLevel,
    levelEntities
  };
}
function baseCascaderProps() {
  return _extends$1(_extends$1({}, omit$1(baseSelectPropsWithoutPrivate(), ["tokenSeparators", "mode", "showSearch"])), {
    // MISC
    id: String,
    prefixCls: String,
    fieldNames: objectType(),
    children: Array,
    // Value
    value: {
      type: [String, Number, Array]
    },
    defaultValue: {
      type: [String, Number, Array]
    },
    changeOnSelect: {
      type: Boolean,
      default: void 0
    },
    displayRender: Function,
    checkable: {
      type: Boolean,
      default: void 0
    },
    showCheckedStrategy: {
      type: String,
      default: SHOW_PARENT
    },
    // Search
    showSearch: {
      type: [Boolean, Object],
      default: void 0
    },
    searchValue: String,
    onSearch: Function,
    // Trigger
    expandTrigger: String,
    // Options
    options: Array,
    /** @private Internal usage. Do not use in your production. */
    dropdownPrefixCls: String,
    loadData: Function,
    // Open
    /** @deprecated Use `open` instead */
    popupVisible: {
      type: Boolean,
      default: void 0
    },
    dropdownClassName: String,
    dropdownMenuColumnStyle: {
      type: Object,
      default: void 0
    },
    /** @deprecated Use `dropdownStyle` instead */
    popupStyle: {
      type: Object,
      default: void 0
    },
    dropdownStyle: {
      type: Object,
      default: void 0
    },
    /** @deprecated Use `placement` instead */
    popupPlacement: String,
    placement: String,
    /** @deprecated Use `onDropdownVisibleChange` instead */
    onPopupVisibleChange: Function,
    onDropdownVisibleChange: Function,
    // Icon
    expandIcon: PropTypes.any,
    loadingIcon: PropTypes.any
  });
}
function internalCascaderProps() {
  return _extends$1(_extends$1({}, baseCascaderProps()), {
    onChange: Function,
    customSlots: Object
  });
}
function isMultipleValue(value) {
  return Array.isArray(value) && Array.isArray(value[0]);
}
function toRawValues(value) {
  if (!value) {
    return [];
  }
  if (isMultipleValue(value)) {
    return value;
  }
  return (value.length === 0 ? [] : [value]).map((val) => Array.isArray(val) ? val : [val]);
}
const Cascader$2 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Cascader",
  inheritAttrs: false,
  props: initDefaultProps(internalCascaderProps(), {}),
  setup(props2, _ref) {
    let {
      attrs,
      expose,
      slots
    } = _ref;
    const mergedId = useId(toRef(props2, "id"));
    const multiple = computed(() => !!props2.checkable);
    const [rawValues, setRawValues] = useMergedState(props2.defaultValue, {
      value: computed(() => props2.value),
      postState: toRawValues
    });
    const mergedFieldNames = computed(() => fillFieldNames$1(props2.fieldNames));
    const mergedOptions = computed(() => props2.options || []);
    const pathKeyEntities = useEntities(mergedOptions, mergedFieldNames);
    const getValueByKeyPath = (pathKeys) => {
      const keyPathEntities = pathKeyEntities.value;
      return pathKeys.map((pathKey) => {
        const {
          nodes
        } = keyPathEntities[pathKey];
        return nodes.map((node2) => node2[mergedFieldNames.value.value]);
      });
    };
    const [mergedSearchValue, setSearchValue] = useMergedState("", {
      value: computed(() => props2.searchValue),
      postState: (search) => search || ""
    });
    const onInternalSearch = (searchText, info) => {
      setSearchValue(searchText);
      if (info.source !== "blur" && props2.onSearch) {
        props2.onSearch(searchText);
      }
    };
    const {
      showSearch: mergedShowSearch,
      searchConfig: mergedSearchConfig
    } = useSearchConfig(toRef(props2, "showSearch"));
    const searchOptions = useSearchOptions(mergedSearchValue, mergedOptions, mergedFieldNames, computed(() => props2.dropdownPrefixCls || props2.prefixCls), mergedSearchConfig, toRef(props2, "changeOnSelect"));
    const missingValuesInfo = useMissingValues(mergedOptions, mergedFieldNames, rawValues);
    const [checkedValues, halfCheckedValues, missingCheckedValues] = [ref([]), ref([]), ref([])];
    const {
      maxLevel,
      levelEntities
    } = useMaxLevel(pathKeyEntities);
    watchEffect(() => {
      const [existValues, missingValues] = missingValuesInfo.value;
      if (!multiple.value || !rawValues.value.length) {
        [checkedValues.value, halfCheckedValues.value, missingCheckedValues.value] = [existValues, [], missingValues];
        return;
      }
      const keyPathValues = toPathKeys(existValues);
      const keyPathEntities = pathKeyEntities.value;
      const {
        checkedKeys,
        halfCheckedKeys
      } = conductCheck(keyPathValues, true, keyPathEntities, maxLevel.value, levelEntities.value);
      [checkedValues.value, halfCheckedValues.value, missingCheckedValues.value] = [getValueByKeyPath(checkedKeys), getValueByKeyPath(halfCheckedKeys), missingValues];
    });
    const deDuplicatedValues = computed(() => {
      const checkedKeys = toPathKeys(checkedValues.value);
      const deduplicateKeys = formatStrategyValues(checkedKeys, pathKeyEntities.value, props2.showCheckedStrategy);
      return [...missingCheckedValues.value, ...getValueByKeyPath(deduplicateKeys)];
    });
    const displayValues = useDisplayValues(deDuplicatedValues, mergedOptions, mergedFieldNames, multiple, toRef(props2, "displayRender"));
    const triggerChange = (nextValues) => {
      setRawValues(nextValues);
      if (props2.onChange) {
        const nextRawValues = toRawValues(nextValues);
        const valueOptions = nextRawValues.map((valueCells) => toPathOptions(valueCells, mergedOptions.value, mergedFieldNames.value).map((valueOpt) => valueOpt.option));
        const triggerValues = multiple.value ? nextRawValues : nextRawValues[0];
        const triggerOptions = multiple.value ? valueOptions : valueOptions[0];
        props2.onChange(triggerValues, triggerOptions);
      }
    };
    const onInternalSelect = (valuePath) => {
      setSearchValue("");
      if (!multiple.value) {
        triggerChange(valuePath);
      } else {
        const pathKey = toPathKey(valuePath);
        const checkedPathKeys = toPathKeys(checkedValues.value);
        const halfCheckedPathKeys = toPathKeys(halfCheckedValues.value);
        const existInChecked = checkedPathKeys.includes(pathKey);
        const existInMissing = missingCheckedValues.value.some((valueCells) => toPathKey(valueCells) === pathKey);
        let nextCheckedValues = checkedValues.value;
        let nextMissingValues = missingCheckedValues.value;
        if (existInMissing && !existInChecked) {
          nextMissingValues = missingCheckedValues.value.filter((valueCells) => toPathKey(valueCells) !== pathKey);
        } else {
          const nextRawCheckedKeys = existInChecked ? checkedPathKeys.filter((key2) => key2 !== pathKey) : [...checkedPathKeys, pathKey];
          let checkedKeys;
          if (existInChecked) {
            ({
              checkedKeys
            } = conductCheck(nextRawCheckedKeys, {
              checked: false,
              halfCheckedKeys: halfCheckedPathKeys
            }, pathKeyEntities.value, maxLevel.value, levelEntities.value));
          } else {
            ({
              checkedKeys
            } = conductCheck(nextRawCheckedKeys, true, pathKeyEntities.value, maxLevel.value, levelEntities.value));
          }
          const deDuplicatedKeys = formatStrategyValues(checkedKeys, pathKeyEntities.value, props2.showCheckedStrategy);
          nextCheckedValues = getValueByKeyPath(deDuplicatedKeys);
        }
        triggerChange([...nextMissingValues, ...nextCheckedValues]);
      }
    };
    const onDisplayValuesChange = (_2, info) => {
      if (info.type === "clear") {
        triggerChange([]);
        return;
      }
      const {
        valueCells
      } = info.values[0];
      onInternalSelect(valueCells);
    };
    const mergedOpen = computed(() => props2.open !== void 0 ? props2.open : props2.popupVisible);
    const mergedDropdownStyle = computed(() => props2.dropdownStyle || props2.popupStyle || {});
    const mergedPlacement = computed(() => props2.placement || props2.popupPlacement);
    const onInternalDropdownVisibleChange = (nextVisible) => {
      var _a2, _b;
      (_a2 = props2.onDropdownVisibleChange) === null || _a2 === void 0 ? void 0 : _a2.call(props2, nextVisible);
      (_b = props2.onPopupVisibleChange) === null || _b === void 0 ? void 0 : _b.call(props2, nextVisible);
    };
    const {
      changeOnSelect,
      checkable,
      dropdownPrefixCls,
      loadData,
      expandTrigger,
      expandIcon,
      loadingIcon,
      dropdownMenuColumnStyle,
      customSlots,
      dropdownClassName
    } = toRefs(props2);
    useProvideCascader({
      options: mergedOptions,
      fieldNames: mergedFieldNames,
      values: checkedValues,
      halfValues: halfCheckedValues,
      changeOnSelect,
      onSelect: onInternalSelect,
      checkable,
      searchOptions,
      dropdownPrefixCls,
      loadData,
      expandTrigger,
      expandIcon,
      loadingIcon,
      dropdownMenuColumnStyle,
      customSlots
    });
    const selectRef = ref();
    expose({
      focus() {
        var _a2;
        (_a2 = selectRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
      },
      blur() {
        var _a2;
        (_a2 = selectRef.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
      },
      scrollTo(arg) {
        var _a2;
        (_a2 = selectRef.value) === null || _a2 === void 0 ? void 0 : _a2.scrollTo(arg);
      }
    });
    const pickProps = computed(() => {
      return omit$1(props2, [
        "id",
        "prefixCls",
        "fieldNames",
        // Value
        "defaultValue",
        "value",
        "changeOnSelect",
        "onChange",
        "displayRender",
        "checkable",
        // Search
        "searchValue",
        "onSearch",
        "showSearch",
        // Trigger
        "expandTrigger",
        // Options
        "options",
        "dropdownPrefixCls",
        "loadData",
        // Open
        "popupVisible",
        "open",
        "dropdownClassName",
        "dropdownMenuColumnStyle",
        "popupPlacement",
        "placement",
        "onDropdownVisibleChange",
        "onPopupVisibleChange",
        // Icon
        "expandIcon",
        "loadingIcon",
        "customSlots",
        "showCheckedStrategy",
        // Children
        "children"
      ]);
    });
    return () => {
      const emptyOptions = !(mergedSearchValue.value ? searchOptions.value : mergedOptions.value).length;
      const {
        dropdownMatchSelectWidth = false
      } = props2;
      const dropdownStyle = (
        // Search to match width
        mergedSearchValue.value && mergedSearchConfig.value.matchInputWidth || // Empty keep the width
        emptyOptions ? {} : {
          minWidth: "auto"
        }
      );
      return createVNode(BaseSelect, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, pickProps.value), attrs), {}, {
        "ref": selectRef,
        "id": mergedId,
        "prefixCls": props2.prefixCls,
        "dropdownMatchSelectWidth": dropdownMatchSelectWidth,
        "dropdownStyle": _extends$1(_extends$1({}, mergedDropdownStyle.value), dropdownStyle),
        "displayValues": displayValues.value,
        "onDisplayValuesChange": onDisplayValuesChange,
        "mode": multiple.value ? "multiple" : void 0,
        "searchValue": mergedSearchValue.value,
        "onSearch": onInternalSearch,
        "showSearch": mergedShowSearch.value,
        "OptionList": OptionList,
        "emptyOptions": emptyOptions,
        "open": mergedOpen.value,
        "dropdownClassName": dropdownClassName.value,
        "placement": mergedPlacement.value,
        "onDropdownVisibleChange": onInternalDropdownVisibleChange,
        "getRawInputElement": () => {
          var _a2;
          return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
        }
      }), slots);
    };
  }
});
const canUseDocElement = () => canUseDom() && window.document.documentElement;
const isStyleNameSupport = (styleName) => {
  if (canUseDom() && window.document.documentElement) {
    const styleNameList = Array.isArray(styleName) ? styleName : [styleName];
    const {
      documentElement
    } = window.document;
    return styleNameList.some((name) => name in documentElement.style);
  }
  return false;
};
const isStyleValueSupport = (styleName, value) => {
  if (!isStyleNameSupport(styleName)) {
    return false;
  }
  const ele = document.createElement("div");
  const origin = ele.style[styleName];
  ele.style[styleName] = value;
  return ele.style[styleName] !== origin;
};
function isStyleSupport(styleName, styleValue) {
  if (!Array.isArray(styleName) && styleValue !== void 0) {
    return isStyleValueSupport(styleName, styleValue);
  }
  return isStyleNameSupport(styleName);
}
let flexGapSupported;
const detectFlexGapSupported = () => {
  if (!canUseDocElement()) {
    return false;
  }
  if (flexGapSupported !== void 0) {
    return flexGapSupported;
  }
  const flex = document.createElement("div");
  flex.style.display = "flex";
  flex.style.flexDirection = "column";
  flex.style.rowGap = "1px";
  flex.appendChild(document.createElement("div"));
  flex.appendChild(document.createElement("div"));
  document.body.appendChild(flex);
  flexGapSupported = flex.scrollHeight === 1;
  document.body.removeChild(flex);
  return flexGapSupported;
};
const useFlexGapSupport = () => {
  const flexible = shallowRef(false);
  onMounted(() => {
    flexible.value = detectFlexGapSupported();
  });
  return flexible;
};
const RowContextKey = Symbol("rowContextKey");
const useProvideRow = (state) => {
  provide(RowContextKey, state);
};
const useInjectRow = () => {
  return inject(RowContextKey, {
    gutter: computed(() => void 0),
    wrap: computed(() => void 0),
    supportFlexGap: computed(() => void 0)
  });
};
const genGridRowStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    // Grid system
    [componentCls]: {
      display: "flex",
      flexFlow: "row wrap",
      minWidth: 0,
      "&::before, &::after": {
        display: "flex"
      },
      "&-no-wrap": {
        flexWrap: "nowrap"
      },
      // The origin of the X-axis
      "&-start": {
        justifyContent: "flex-start"
      },
      // The center of the X-axis
      "&-center": {
        justifyContent: "center"
      },
      // The opposite of the X-axis
      "&-end": {
        justifyContent: "flex-end"
      },
      "&-space-between": {
        justifyContent: "space-between"
      },
      "&-space-around ": {
        justifyContent: "space-around"
      },
      "&-space-evenly ": {
        justifyContent: "space-evenly"
      },
      // Align at the top
      "&-top": {
        alignItems: "flex-start"
      },
      // Align at the center
      "&-middle": {
        alignItems: "center"
      },
      "&-bottom": {
        alignItems: "flex-end"
      }
    }
  };
};
const genGridColStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    // Grid system
    [componentCls]: {
      position: "relative",
      maxWidth: "100%",
      // Prevent columns from collapsing when empty
      minHeight: 1
    }
  };
};
const genLoopGridColumnsStyle = (token2, sizeCls) => {
  const {
    componentCls,
    gridColumns
  } = token2;
  const gridColumnsStyle = {};
  for (let i2 = gridColumns; i2 >= 0; i2--) {
    if (i2 === 0) {
      gridColumnsStyle[`${componentCls}${sizeCls}-${i2}`] = {
        display: "none"
      };
      gridColumnsStyle[`${componentCls}-push-${i2}`] = {
        insetInlineStart: "auto"
      };
      gridColumnsStyle[`${componentCls}-pull-${i2}`] = {
        insetInlineEnd: "auto"
      };
      gridColumnsStyle[`${componentCls}${sizeCls}-push-${i2}`] = {
        insetInlineStart: "auto"
      };
      gridColumnsStyle[`${componentCls}${sizeCls}-pull-${i2}`] = {
        insetInlineEnd: "auto"
      };
      gridColumnsStyle[`${componentCls}${sizeCls}-offset-${i2}`] = {
        marginInlineEnd: 0
      };
      gridColumnsStyle[`${componentCls}${sizeCls}-order-${i2}`] = {
        order: 0
      };
    } else {
      gridColumnsStyle[`${componentCls}${sizeCls}-${i2}`] = {
        display: "block",
        flex: `0 0 ${i2 / gridColumns * 100}%`,
        maxWidth: `${i2 / gridColumns * 100}%`
      };
      gridColumnsStyle[`${componentCls}${sizeCls}-push-${i2}`] = {
        insetInlineStart: `${i2 / gridColumns * 100}%`
      };
      gridColumnsStyle[`${componentCls}${sizeCls}-pull-${i2}`] = {
        insetInlineEnd: `${i2 / gridColumns * 100}%`
      };
      gridColumnsStyle[`${componentCls}${sizeCls}-offset-${i2}`] = {
        marginInlineStart: `${i2 / gridColumns * 100}%`
      };
      gridColumnsStyle[`${componentCls}${sizeCls}-order-${i2}`] = {
        order: i2
      };
    }
  }
  return gridColumnsStyle;
};
const genGridStyle = (token2, sizeCls) => genLoopGridColumnsStyle(token2, sizeCls);
const genGridMediaStyle = (token2, screenSize, sizeCls) => ({
  [`@media (min-width: ${screenSize}px)`]: _extends$1({}, genGridStyle(token2, sizeCls))
});
const useRowStyle = genComponentStyleHook("Grid", (token2) => [genGridRowStyle(token2)]);
const useColStyle = genComponentStyleHook("Grid", (token2) => {
  const gridToken = merge(token2, {
    gridColumns: 24
    // Row is divided into 24 parts in Grid
  });
  const gridMediaSizesMap = {
    "-sm": gridToken.screenSMMin,
    "-md": gridToken.screenMDMin,
    "-lg": gridToken.screenLGMin,
    "-xl": gridToken.screenXLMin,
    "-xxl": gridToken.screenXXLMin
  };
  return [genGridColStyle(gridToken), genGridStyle(gridToken, ""), genGridStyle(gridToken, "-xs"), Object.keys(gridMediaSizesMap).map((key2) => genGridMediaStyle(gridToken, gridMediaSizesMap[key2], key2)).reduce((pre, cur) => _extends$1(_extends$1({}, pre), cur), {})];
});
const rowProps = () => ({
  align: someType([String, Object]),
  justify: someType([String, Object]),
  prefixCls: String,
  gutter: someType([Number, Array, Object], 0),
  wrap: {
    type: Boolean,
    default: void 0
  }
});
const ARow = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ARow",
  inheritAttrs: false,
  props: rowProps(),
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const {
      prefixCls,
      direction
    } = useConfigInject("row", props2);
    const [wrapSSR, hashId] = useRowStyle(prefixCls);
    let token2;
    const responsiveObserve = useResponsiveObserver();
    const screens = ref({
      xs: true,
      sm: true,
      md: true,
      lg: true,
      xl: true,
      xxl: true
    });
    const curScreens = ref({
      xs: false,
      sm: false,
      md: false,
      lg: false,
      xl: false,
      xxl: false
    });
    const mergePropsByScreen = (oriProp) => {
      return computed(() => {
        if (typeof props2[oriProp] === "string") {
          return props2[oriProp];
        }
        if (typeof props2[oriProp] !== "object") {
          return "";
        }
        for (let i2 = 0; i2 < responsiveArray.length; i2++) {
          const breakpoint = responsiveArray[i2];
          if (!curScreens.value[breakpoint]) continue;
          const curVal = props2[oriProp][breakpoint];
          if (curVal !== void 0) {
            return curVal;
          }
        }
        return "";
      });
    };
    const mergeAlign = mergePropsByScreen("align");
    const mergeJustify = mergePropsByScreen("justify");
    const supportFlexGap = useFlexGapSupport();
    onMounted(() => {
      token2 = responsiveObserve.value.subscribe((screen) => {
        curScreens.value = screen;
        const currentGutter = props2.gutter || 0;
        if (!Array.isArray(currentGutter) && typeof currentGutter === "object" || Array.isArray(currentGutter) && (typeof currentGutter[0] === "object" || typeof currentGutter[1] === "object")) {
          screens.value = screen;
        }
      });
    });
    onBeforeUnmount(() => {
      responsiveObserve.value.unsubscribe(token2);
    });
    const gutter = computed(() => {
      const results = [void 0, void 0];
      const {
        gutter: gutter2 = 0
      } = props2;
      const normalizedGutter = Array.isArray(gutter2) ? gutter2 : [gutter2, void 0];
      normalizedGutter.forEach((g2, index2) => {
        if (typeof g2 === "object") {
          for (let i2 = 0; i2 < responsiveArray.length; i2++) {
            const breakpoint = responsiveArray[i2];
            if (screens.value[breakpoint] && g2[breakpoint] !== void 0) {
              results[index2] = g2[breakpoint];
              break;
            }
          }
        } else {
          results[index2] = g2;
        }
      });
      return results;
    });
    useProvideRow({
      gutter,
      supportFlexGap,
      wrap: computed(() => props2.wrap)
    });
    const classes = computed(() => classNames(prefixCls.value, {
      [`${prefixCls.value}-no-wrap`]: props2.wrap === false,
      [`${prefixCls.value}-${mergeJustify.value}`]: mergeJustify.value,
      [`${prefixCls.value}-${mergeAlign.value}`]: mergeAlign.value,
      [`${prefixCls.value}-rtl`]: direction.value === "rtl"
    }, attrs.class, hashId.value));
    const rowStyle = computed(() => {
      const gt = gutter.value;
      const style = {};
      const horizontalGutter = gt[0] != null && gt[0] > 0 ? `${gt[0] / -2}px` : void 0;
      const verticalGutter = gt[1] != null && gt[1] > 0 ? `${gt[1] / -2}px` : void 0;
      if (horizontalGutter) {
        style.marginLeft = horizontalGutter;
        style.marginRight = horizontalGutter;
      }
      if (supportFlexGap.value) {
        style.rowGap = `${gt[1]}px`;
      } else if (verticalGutter) {
        style.marginTop = verticalGutter;
        style.marginBottom = verticalGutter;
      }
      return style;
    });
    return () => {
      var _a2;
      return wrapSSR(createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "class": classes.value,
        "style": _extends$1(_extends$1({}, rowStyle.value), attrs.style)
      }), [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]));
    };
  }
});
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o2) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o22) {
    return o22.__proto__ || Object.getPrototypeOf(o22);
  };
  return _getPrototypeOf(o2);
}
function _setPrototypeOf(o2, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o22, p2) {
    o22.__proto__ = p2;
    return o22;
  };
  return _setPrototypeOf(o2, p);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a2 = [null];
      a2.push.apply(a2, args2);
      var Constructor = Function.bind.apply(Parent2, a2);
      var instance = new Constructor();
      if (Class2) _setPrototypeOf(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2)) return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2)) return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
var formatRegExp = /%[sdj%]/g;
var warning = function warning2() {
};
function convertFieldsError(errors) {
  if (!errors || !errors.length) return null;
  var fields = {};
  errors.forEach(function(error) {
    var field = error.field;
    fields[field] = fields[field] || [];
    fields[field].push(error);
  });
  return fields;
}
function format$1(template) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  var i2 = 0;
  var len = args.length;
  if (typeof template === "function") {
    return template.apply(null, args);
  }
  if (typeof template === "string") {
    var str = template.replace(formatRegExp, function(x2) {
      if (x2 === "%%") {
        return "%";
      }
      if (i2 >= len) {
        return x2;
      }
      switch (x2) {
        case "%s":
          return String(args[i2++]);
        case "%d":
          return Number(args[i2++]);
        case "%j":
          try {
            return JSON.stringify(args[i2++]);
          } catch (_2) {
            return "[Circular]";
          }
          break;
        default:
          return x2;
      }
    });
    return str;
  }
  return template;
}
function isNativeStringType(type4) {
  return type4 === "string" || type4 === "url" || type4 === "hex" || type4 === "email" || type4 === "date" || type4 === "pattern";
}
function isEmptyValue(value, type4) {
  if (value === void 0 || value === null) {
    return true;
  }
  if (type4 === "array" && Array.isArray(value) && !value.length) {
    return true;
  }
  if (isNativeStringType(type4) && typeof value === "string" && !value) {
    return true;
  }
  return false;
}
function asyncParallelArray(arr, func, callback) {
  var results = [];
  var total = 0;
  var arrLength = arr.length;
  function count(errors) {
    results.push.apply(results, errors || []);
    total++;
    if (total === arrLength) {
      callback(results);
    }
  }
  arr.forEach(function(a2) {
    func(a2, count);
  });
}
function asyncSerialArray(arr, func, callback) {
  var index2 = 0;
  var arrLength = arr.length;
  function next2(errors) {
    if (errors && errors.length) {
      callback(errors);
      return;
    }
    var original = index2;
    index2 = index2 + 1;
    if (original < arrLength) {
      func(arr[original], next2);
    } else {
      callback([]);
    }
  }
  next2([]);
}
function flattenObjArr(objArr) {
  var ret = [];
  Object.keys(objArr).forEach(function(k2) {
    ret.push.apply(ret, objArr[k2] || []);
  });
  return ret;
}
var AsyncValidationError = /* @__PURE__ */ function(_Error) {
  _inheritsLoose(AsyncValidationError2, _Error);
  function AsyncValidationError2(errors, fields) {
    var _this;
    _this = _Error.call(this, "Async Validation Error") || this;
    _this.errors = errors;
    _this.fields = fields;
    return _this;
  }
  return AsyncValidationError2;
}(/* @__PURE__ */ _wrapNativeSuper(Error));
function asyncMap(objArr, option, func, callback, source) {
  if (option.first) {
    var _pending = new Promise(function(resolve, reject) {
      var next2 = function next22(errors) {
        callback(errors);
        return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);
      };
      var flattenArr = flattenObjArr(objArr);
      asyncSerialArray(flattenArr, func, next2);
    });
    _pending["catch"](function(e2) {
      return e2;
    });
    return _pending;
  }
  var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
  var objArrKeys = Object.keys(objArr);
  var objArrLength = objArrKeys.length;
  var total = 0;
  var results = [];
  var pending = new Promise(function(resolve, reject) {
    var next2 = function next22(errors) {
      results.push.apply(results, errors);
      total++;
      if (total === objArrLength) {
        callback(results);
        return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);
      }
    };
    if (!objArrKeys.length) {
      callback(results);
      resolve(source);
    }
    objArrKeys.forEach(function(key2) {
      var arr = objArr[key2];
      if (firstFields.indexOf(key2) !== -1) {
        asyncSerialArray(arr, func, next2);
      } else {
        asyncParallelArray(arr, func, next2);
      }
    });
  });
  pending["catch"](function(e2) {
    return e2;
  });
  return pending;
}
function isErrorObj(obj) {
  return !!(obj && obj.message !== void 0);
}
function getValue$1(value, path2) {
  var v2 = value;
  for (var i2 = 0; i2 < path2.length; i2++) {
    if (v2 == void 0) {
      return v2;
    }
    v2 = v2[path2[i2]];
  }
  return v2;
}
function complementError(rule, source) {
  return function(oe) {
    var fieldValue;
    if (rule.fullFields) {
      fieldValue = getValue$1(source, rule.fullFields);
    } else {
      fieldValue = source[oe.field || rule.fullField];
    }
    if (isErrorObj(oe)) {
      oe.field = oe.field || rule.fullField;
      oe.fieldValue = fieldValue;
      return oe;
    }
    return {
      message: typeof oe === "function" ? oe() : oe,
      fieldValue,
      field: oe.field || rule.fullField
    };
  };
}
function deepMerge(target, source) {
  if (source) {
    for (var s2 in source) {
      if (source.hasOwnProperty(s2)) {
        var value = source[s2];
        if (typeof value === "object" && typeof target[s2] === "object") {
          target[s2] = _extends({}, target[s2], value);
        } else {
          target[s2] = value;
        }
      }
    }
  }
  return target;
}
var required$1 = function required(rule, value, source, errors, options, type4) {
  if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type4 || rule.type))) {
    errors.push(format$1(options.messages.required, rule.fullField));
  }
};
var whitespace = function whitespace2(rule, value, source, errors, options) {
  if (/^\s+$/.test(value) || value === "") {
    errors.push(format$1(options.messages.whitespace, rule.fullField));
  }
};
var urlReg;
var getUrlRegex = function() {
  if (urlReg) {
    return urlReg;
  }
  var word = "[a-fA-F\\d:]";
  var b2 = function b22(options) {
    return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=" + word + ")|(?<=" + word + ")(?=\\s|$))" : "";
  };
  var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
  var v6seg = "[a-fA-F\\d]{1,4}";
  var v6 = ("\n(?:\n(?:" + v6seg + ":){7}(?:" + v6seg + "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:" + v6seg + ":){6}(?:" + v4 + "|:" + v6seg + "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:" + v6seg + ":){5}(?::" + v4 + "|(?::" + v6seg + "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:" + v6seg + ":){4}(?:(?::" + v6seg + "){0,1}:" + v4 + "|(?::" + v6seg + "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:" + v6seg + ":){3}(?:(?::" + v6seg + "){0,2}:" + v4 + "|(?::" + v6seg + "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:" + v6seg + ":){2}(?:(?::" + v6seg + "){0,3}:" + v4 + "|(?::" + v6seg + "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:" + v6seg + ":){1}(?:(?::" + v6seg + "){0,4}:" + v4 + "|(?::" + v6seg + "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::" + v6seg + "){0,5}:" + v4 + "|(?::" + v6seg + "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
  var v46Exact = new RegExp("(?:^" + v4 + "$)|(?:^" + v6 + "$)");
  var v4exact = new RegExp("^" + v4 + "$");
  var v6exact = new RegExp("^" + v6 + "$");
  var ip = function ip2(options) {
    return options && options.exact ? v46Exact : new RegExp("(?:" + b2(options) + v4 + b2(options) + ")|(?:" + b2(options) + v6 + b2(options) + ")", "g");
  };
  ip.v4 = function(options) {
    return options && options.exact ? v4exact : new RegExp("" + b2(options) + v4 + b2(options), "g");
  };
  ip.v6 = function(options) {
    return options && options.exact ? v6exact : new RegExp("" + b2(options) + v6 + b2(options), "g");
  };
  var protocol = "(?:(?:[a-z]+:)?//)";
  var auth = "(?:\\S+(?::\\S*)?@)?";
  var ipv4 = ip.v4().source;
  var ipv6 = ip.v6().source;
  var host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
  var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
  var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
  var port = "(?::\\d{2,5})?";
  var path2 = '(?:[/?#][^\\s"]*)?';
  var regex = "(?:" + protocol + "|www\\.)" + auth + "(?:localhost|" + ipv4 + "|" + ipv6 + "|" + host + domain + tld + ")" + port + path2;
  urlReg = new RegExp("(?:^" + regex + "$)", "i");
  return urlReg;
};
var pattern$2 = {
  // http://emailregex.com/
  email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
  // url: new RegExp(
  //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
  //   'i',
  // ),
  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
};
var types = {
  integer: function integer(value) {
    return types.number(value) && parseInt(value, 10) === value;
  },
  "float": function float(value) {
    return types.number(value) && !types.integer(value);
  },
  array: function array(value) {
    return Array.isArray(value);
  },
  regexp: function regexp(value) {
    if (value instanceof RegExp) {
      return true;
    }
    try {
      return !!new RegExp(value);
    } catch (e2) {
      return false;
    }
  },
  date: function date(value) {
    return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
  },
  number: function number(value) {
    if (isNaN(value)) {
      return false;
    }
    return typeof value === "number";
  },
  object: function object(value) {
    return typeof value === "object" && !types.array(value);
  },
  method: function method(value) {
    return typeof value === "function";
  },
  email: function email(value) {
    return typeof value === "string" && value.length <= 320 && !!value.match(pattern$2.email);
  },
  url: function url(value) {
    return typeof value === "string" && value.length <= 2048 && !!value.match(getUrlRegex());
  },
  hex: function hex(value) {
    return typeof value === "string" && !!value.match(pattern$2.hex);
  }
};
var type$1 = function type(rule, value, source, errors, options) {
  if (rule.required && value === void 0) {
    required$1(rule, value, source, errors, options);
    return;
  }
  var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
  var ruleType = rule.type;
  if (custom.indexOf(ruleType) > -1) {
    if (!types[ruleType](value)) {
      errors.push(format$1(options.messages.types[ruleType], rule.fullField, rule.type));
    }
  } else if (ruleType && typeof value !== rule.type) {
    errors.push(format$1(options.messages.types[ruleType], rule.fullField, rule.type));
  }
};
var range = function range2(rule, value, source, errors, options) {
  var len = typeof rule.len === "number";
  var min = typeof rule.min === "number";
  var max = typeof rule.max === "number";
  var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
  var val = value;
  var key2 = null;
  var num = typeof value === "number";
  var str = typeof value === "string";
  var arr = Array.isArray(value);
  if (num) {
    key2 = "number";
  } else if (str) {
    key2 = "string";
  } else if (arr) {
    key2 = "array";
  }
  if (!key2) {
    return false;
  }
  if (arr) {
    val = value.length;
  }
  if (str) {
    val = value.replace(spRegexp, "_").length;
  }
  if (len) {
    if (val !== rule.len) {
      errors.push(format$1(options.messages[key2].len, rule.fullField, rule.len));
    }
  } else if (min && !max && val < rule.min) {
    errors.push(format$1(options.messages[key2].min, rule.fullField, rule.min));
  } else if (max && !min && val > rule.max) {
    errors.push(format$1(options.messages[key2].max, rule.fullField, rule.max));
  } else if (min && max && (val < rule.min || val > rule.max)) {
    errors.push(format$1(options.messages[key2].range, rule.fullField, rule.min, rule.max));
  }
};
var ENUM$1 = "enum";
var enumerable$1 = function enumerable(rule, value, source, errors, options) {
  rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
  if (rule[ENUM$1].indexOf(value) === -1) {
    errors.push(format$1(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
  }
};
var pattern$1 = function pattern(rule, value, source, errors, options) {
  if (rule.pattern) {
    if (rule.pattern instanceof RegExp) {
      rule.pattern.lastIndex = 0;
      if (!rule.pattern.test(value)) {
        errors.push(format$1(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
      }
    } else if (typeof rule.pattern === "string") {
      var _pattern = new RegExp(rule.pattern);
      if (!_pattern.test(value)) {
        errors.push(format$1(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
      }
    }
  }
};
var rules = {
  required: required$1,
  whitespace,
  type: type$1,
  range,
  "enum": enumerable$1,
  pattern: pattern$1
};
var string = function string2(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, "string") && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options, "string");
    if (!isEmptyValue(value, "string")) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
      rules.pattern(rule, value, source, errors, options);
      if (rule.whitespace === true) {
        rules.whitespace(rule, value, source, errors, options);
      }
    }
  }
  callback(errors);
};
var method2 = function method3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var number2 = function number3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (value === "") {
      value = void 0;
    }
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var _boolean = function _boolean2(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var regexp2 = function regexp3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (!isEmptyValue(value)) {
      rules.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var integer2 = function integer3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var floatFn = function floatFn2(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var array2 = function array3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if ((value === void 0 || value === null) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options, "array");
    if (value !== void 0 && value !== null) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var object2 = function object3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var ENUM = "enum";
var enumerable2 = function enumerable3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules[ENUM](rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var pattern2 = function pattern3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, "string") && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (!isEmptyValue(value, "string")) {
      rules.pattern(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var date2 = function date3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, "date") && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (!isEmptyValue(value, "date")) {
      var dateObject;
      if (value instanceof Date) {
        dateObject = value;
      } else {
        dateObject = new Date(value);
      }
      rules.type(rule, dateObject, source, errors, options);
      if (dateObject) {
        rules.range(rule, dateObject.getTime(), source, errors, options);
      }
    }
  }
  callback(errors);
};
var required2 = function required3(rule, value, callback, source, options) {
  var errors = [];
  var type4 = Array.isArray(value) ? "array" : typeof value;
  rules.required(rule, value, source, errors, options, type4);
  callback(errors);
};
var type2 = function type3(rule, value, callback, source, options) {
  var ruleType = rule.type;
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, ruleType) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options, ruleType);
    if (!isEmptyValue(value, ruleType)) {
      rules.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var any = function any2(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
  }
  callback(errors);
};
var validators = {
  string,
  method: method2,
  number: number2,
  "boolean": _boolean,
  regexp: regexp2,
  integer: integer2,
  "float": floatFn,
  array: array2,
  object: object2,
  "enum": enumerable2,
  pattern: pattern2,
  date: date2,
  url: type2,
  hex: type2,
  email: type2,
  required: required2,
  any
};
function newMessages() {
  return {
    "default": "Validation error on field %s",
    required: "%s is required",
    "enum": "%s must be one of %s",
    whitespace: "%s cannot be empty",
    date: {
      format: "%s date %s is invalid for format %s",
      parse: "%s date could not be parsed, %s is invalid ",
      invalid: "%s date %s is invalid"
    },
    types: {
      string: "%s is not a %s",
      method: "%s is not a %s (function)",
      array: "%s is not an %s",
      object: "%s is not an %s",
      number: "%s is not a %s",
      date: "%s is not a %s",
      "boolean": "%s is not a %s",
      integer: "%s is not an %s",
      "float": "%s is not a %s",
      regexp: "%s is not a valid %s",
      email: "%s is not a valid %s",
      url: "%s is not a valid %s",
      hex: "%s is not a valid %s"
    },
    string: {
      len: "%s must be exactly %s characters",
      min: "%s must be at least %s characters",
      max: "%s cannot be longer than %s characters",
      range: "%s must be between %s and %s characters"
    },
    number: {
      len: "%s must equal %s",
      min: "%s cannot be less than %s",
      max: "%s cannot be greater than %s",
      range: "%s must be between %s and %s"
    },
    array: {
      len: "%s must be exactly %s in length",
      min: "%s cannot be less than %s in length",
      max: "%s cannot be greater than %s in length",
      range: "%s must be between %s and %s in length"
    },
    pattern: {
      mismatch: "%s value %s does not match pattern %s"
    },
    clone: function clone2() {
      var cloned = JSON.parse(JSON.stringify(this));
      cloned.clone = this.clone;
      return cloned;
    }
  };
}
var messages = newMessages();
var Schema = /* @__PURE__ */ function() {
  function Schema2(descriptor) {
    this.rules = null;
    this._messages = messages;
    this.define(descriptor);
  }
  var _proto = Schema2.prototype;
  _proto.define = function define(rules2) {
    var _this = this;
    if (!rules2) {
      throw new Error("Cannot configure a schema with no rules");
    }
    if (typeof rules2 !== "object" || Array.isArray(rules2)) {
      throw new Error("Rules must be an object");
    }
    this.rules = {};
    Object.keys(rules2).forEach(function(name) {
      var item = rules2[name];
      _this.rules[name] = Array.isArray(item) ? item : [item];
    });
  };
  _proto.messages = function messages2(_messages) {
    if (_messages) {
      this._messages = deepMerge(newMessages(), _messages);
    }
    return this._messages;
  };
  _proto.validate = function validate(source_, o2, oc) {
    var _this2 = this;
    if (o2 === void 0) {
      o2 = {};
    }
    if (oc === void 0) {
      oc = function oc2() {
      };
    }
    var source = source_;
    var options = o2;
    var callback = oc;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    if (!this.rules || Object.keys(this.rules).length === 0) {
      if (callback) {
        callback(null, source);
      }
      return Promise.resolve(source);
    }
    function complete(results) {
      var errors = [];
      var fields = {};
      function add(e2) {
        if (Array.isArray(e2)) {
          var _errors;
          errors = (_errors = errors).concat.apply(_errors, e2);
        } else {
          errors.push(e2);
        }
      }
      for (var i2 = 0; i2 < results.length; i2++) {
        add(results[i2]);
      }
      if (!errors.length) {
        callback(null, source);
      } else {
        fields = convertFieldsError(errors);
        callback(errors, fields);
      }
    }
    if (options.messages) {
      var messages$1 = this.messages();
      if (messages$1 === messages) {
        messages$1 = newMessages();
      }
      deepMerge(messages$1, options.messages);
      options.messages = messages$1;
    } else {
      options.messages = this.messages();
    }
    var series = {};
    var keys2 = options.keys || Object.keys(this.rules);
    keys2.forEach(function(z2) {
      var arr = _this2.rules[z2];
      var value = source[z2];
      arr.forEach(function(r2) {
        var rule = r2;
        if (typeof rule.transform === "function") {
          if (source === source_) {
            source = _extends({}, source);
          }
          value = source[z2] = rule.transform(value);
        }
        if (typeof rule === "function") {
          rule = {
            validator: rule
          };
        } else {
          rule = _extends({}, rule);
        }
        rule.validator = _this2.getValidationMethod(rule);
        if (!rule.validator) {
          return;
        }
        rule.field = z2;
        rule.fullField = rule.fullField || z2;
        rule.type = _this2.getType(rule);
        series[z2] = series[z2] || [];
        series[z2].push({
          rule,
          value,
          source,
          field: z2
        });
      });
    });
    var errorFields = {};
    return asyncMap(series, options, function(data, doIt) {
      var rule = data.rule;
      var deep = (rule.type === "object" || rule.type === "array") && (typeof rule.fields === "object" || typeof rule.defaultField === "object");
      deep = deep && (rule.required || !rule.required && data.value);
      rule.field = data.field;
      function addFullField(key2, schema) {
        return _extends({}, schema, {
          fullField: rule.fullField + "." + key2,
          fullFields: rule.fullFields ? [].concat(rule.fullFields, [key2]) : [key2]
        });
      }
      function cb(e2) {
        if (e2 === void 0) {
          e2 = [];
        }
        var errorList = Array.isArray(e2) ? e2 : [e2];
        if (!options.suppressWarning && errorList.length) {
          Schema2.warning("async-validator:", errorList);
        }
        if (errorList.length && rule.message !== void 0) {
          errorList = [].concat(rule.message);
        }
        var filledErrors = errorList.map(complementError(rule, source));
        if (options.first && filledErrors.length) {
          errorFields[rule.field] = 1;
          return doIt(filledErrors);
        }
        if (!deep) {
          doIt(filledErrors);
        } else {
          if (rule.required && !data.value) {
            if (rule.message !== void 0) {
              filledErrors = [].concat(rule.message).map(complementError(rule, source));
            } else if (options.error) {
              filledErrors = [options.error(rule, format$1(options.messages.required, rule.field))];
            }
            return doIt(filledErrors);
          }
          var fieldsSchema = {};
          if (rule.defaultField) {
            Object.keys(data.value).map(function(key2) {
              fieldsSchema[key2] = rule.defaultField;
            });
          }
          fieldsSchema = _extends({}, fieldsSchema, data.rule.fields);
          var paredFieldsSchema = {};
          Object.keys(fieldsSchema).forEach(function(field) {
            var fieldSchema = fieldsSchema[field];
            var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
            paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
          });
          var schema = new Schema2(paredFieldsSchema);
          schema.messages(options.messages);
          if (data.rule.options) {
            data.rule.options.messages = options.messages;
            data.rule.options.error = options.error;
          }
          schema.validate(data.value, data.rule.options || options, function(errs) {
            var finalErrors = [];
            if (filledErrors && filledErrors.length) {
              finalErrors.push.apply(finalErrors, filledErrors);
            }
            if (errs && errs.length) {
              finalErrors.push.apply(finalErrors, errs);
            }
            doIt(finalErrors.length ? finalErrors : null);
          });
        }
      }
      var res;
      if (rule.asyncValidator) {
        res = rule.asyncValidator(rule, data.value, cb, data.source, options);
      } else if (rule.validator) {
        try {
          res = rule.validator(rule, data.value, cb, data.source, options);
        } catch (error) {
          console.error == null ? void 0 : console.error(error);
          if (!options.suppressValidatorError) {
            setTimeout(function() {
              throw error;
            }, 0);
          }
          cb(error.message);
        }
        if (res === true) {
          cb();
        } else if (res === false) {
          cb(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
        } else if (res instanceof Array) {
          cb(res);
        } else if (res instanceof Error) {
          cb(res.message);
        }
      }
      if (res && res.then) {
        res.then(function() {
          return cb();
        }, function(e2) {
          return cb(e2);
        });
      }
    }, function(results) {
      complete(results);
    }, source);
  };
  _proto.getType = function getType(rule) {
    if (rule.type === void 0 && rule.pattern instanceof RegExp) {
      rule.type = "pattern";
    }
    if (typeof rule.validator !== "function" && rule.type && !validators.hasOwnProperty(rule.type)) {
      throw new Error(format$1("Unknown rule type %s", rule.type));
    }
    return rule.type || "string";
  };
  _proto.getValidationMethod = function getValidationMethod(rule) {
    if (typeof rule.validator === "function") {
      return rule.validator;
    }
    var keys2 = Object.keys(rule);
    var messageIndex = keys2.indexOf("message");
    if (messageIndex !== -1) {
      keys2.splice(messageIndex, 1);
    }
    if (keys2.length === 1 && keys2[0] === "required") {
      return validators.required;
    }
    return validators[this.getType(rule)] || void 0;
  };
  return Schema2;
}();
Schema.register = function register(type4, validator) {
  if (typeof validator !== "function") {
    throw new Error("Cannot register a validator by type, validator is not a function");
  }
  validators[type4] = validator;
};
Schema.warning = warning;
Schema.messages = messages;
Schema.validators = validators;
function toArray$4(value) {
  if (value === void 0 || value === null) {
    return [];
  }
  return Array.isArray(value) ? value : [value];
}
function get(entity, path2) {
  let current = entity;
  for (let i2 = 0; i2 < path2.length; i2 += 1) {
    if (current === null || current === void 0) {
      return void 0;
    }
    current = current[path2[i2]];
  }
  return current;
}
function internalSet(entity, paths, value, removeIfUndefined) {
  if (!paths.length) {
    return value;
  }
  const [path2, ...restPath] = paths;
  let clone2;
  if (!entity && typeof path2 === "number") {
    clone2 = [];
  } else if (Array.isArray(entity)) {
    clone2 = [...entity];
  } else {
    clone2 = _extends$1({}, entity);
  }
  if (removeIfUndefined && value === void 0 && restPath.length === 1) {
    delete clone2[path2][restPath[0]];
  } else {
    clone2[path2] = internalSet(clone2[path2], restPath, value, removeIfUndefined);
  }
  return clone2;
}
function set(entity, paths, value) {
  let removeIfUndefined = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  if (paths.length && removeIfUndefined && value === void 0 && !get(entity, paths.slice(0, -1))) {
    return entity;
  }
  return internalSet(entity, paths, value, removeIfUndefined);
}
function getNamePath(path2) {
  return toArray$4(path2);
}
function getValue(store, namePath) {
  const value = get(store, namePath);
  return value;
}
function setValue(store, namePath, value) {
  let removeIfUndefined = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  const newStore = set(store, namePath, value, removeIfUndefined);
  return newStore;
}
function containsNamePath(namePathList, namePath) {
  return namePathList && namePathList.some((path2) => matchNamePath(path2, namePath));
}
function isObject(obj) {
  return typeof obj === "object" && obj !== null && Object.getPrototypeOf(obj) === Object.prototype;
}
function internalSetValues(store, values) {
  const newStore = Array.isArray(store) ? [...store] : _extends$1({}, store);
  if (!values) {
    return newStore;
  }
  Object.keys(values).forEach((key2) => {
    const prevValue = newStore[key2];
    const value = values[key2];
    const recursive = isObject(prevValue) && isObject(value);
    newStore[key2] = recursive ? internalSetValues(prevValue, value || {}) : value;
  });
  return newStore;
}
function setValues(store) {
  for (var _len = arguments.length, restValues = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    restValues[_key - 1] = arguments[_key];
  }
  return restValues.reduce((current, newStore) => internalSetValues(current, newStore), store);
}
function cloneByNamePathList(store, namePathList) {
  let newStore = {};
  namePathList.forEach((namePath) => {
    const value = getValue(store, namePath);
    newStore = setValue(newStore, namePath, value);
  });
  return newStore;
}
function matchNamePath(namePath, changedNamePath) {
  if (!namePath || !changedNamePath || namePath.length !== changedNamePath.length) {
    return false;
  }
  return namePath.every((nameUnit, i2) => changedNamePath[i2] === nameUnit);
}
const typeTemplate = "'${name}' is not a valid ${type}";
const defaultValidateMessages = {
  default: "Validation error on field '${name}'",
  required: "'${name}' is required",
  enum: "'${name}' must be one of [${enum}]",
  whitespace: "'${name}' cannot be empty",
  date: {
    format: "'${name}' is invalid for format date",
    parse: "'${name}' could not be parsed as date",
    invalid: "'${name}' is invalid date"
  },
  types: {
    string: typeTemplate,
    method: typeTemplate,
    array: typeTemplate,
    object: typeTemplate,
    number: typeTemplate,
    date: typeTemplate,
    boolean: typeTemplate,
    integer: typeTemplate,
    float: typeTemplate,
    regexp: typeTemplate,
    email: typeTemplate,
    url: typeTemplate,
    hex: typeTemplate
  },
  string: {
    len: "'${name}' must be exactly ${len} characters",
    min: "'${name}' must be at least ${min} characters",
    max: "'${name}' cannot be longer than ${max} characters",
    range: "'${name}' must be between ${min} and ${max} characters"
  },
  number: {
    len: "'${name}' must equal ${len}",
    min: "'${name}' cannot be less than ${min}",
    max: "'${name}' cannot be greater than ${max}",
    range: "'${name}' must be between ${min} and ${max}"
  },
  array: {
    len: "'${name}' must be exactly ${len} in length",
    min: "'${name}' cannot be less than ${min} in length",
    max: "'${name}' cannot be greater than ${max} in length",
    range: "'${name}' must be between ${min} and ${max} in length"
  },
  pattern: {
    mismatch: "'${name}' does not match pattern ${pattern}"
  }
};
var __awaiter$2 = function(thisArg, _arguments, P2, generator2) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator2.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator2["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator2 = generator2.apply(thisArg, _arguments || [])).next());
  });
};
const AsyncValidator = Schema;
function replaceMessage(template, kv) {
  return template.replace(/\$\{\w+\}/g, (str) => {
    const key2 = str.slice(2, -1);
    return kv[key2];
  });
}
function validateRule(name, value, rule, options, messageVariables) {
  return __awaiter$2(this, void 0, void 0, function* () {
    const cloneRule = _extends$1({}, rule);
    delete cloneRule.ruleIndex;
    delete cloneRule.trigger;
    let subRuleField = null;
    if (cloneRule && cloneRule.type === "array" && cloneRule.defaultField) {
      subRuleField = cloneRule.defaultField;
      delete cloneRule.defaultField;
    }
    const validator = new AsyncValidator({
      [name]: [cloneRule]
    });
    const messages2 = setValues({}, defaultValidateMessages, options.validateMessages);
    validator.messages(messages2);
    let result = [];
    try {
      yield Promise.resolve(validator.validate({
        [name]: value
      }, _extends$1({}, options)));
    } catch (errObj) {
      if (errObj.errors) {
        result = errObj.errors.map((_ref, index2) => {
          let {
            message
          } = _ref;
          return (
            // Wrap VueNode with `key`
            isValidElement(message) ? cloneVNode(message, {
              key: `error_${index2}`
            }) : message
          );
        });
      } else {
        console.error(errObj);
        result = [messages2.default()];
      }
    }
    if (!result.length && subRuleField) {
      const subResults = yield Promise.all(value.map((subValue, i2) => validateRule(`${name}.${i2}`, subValue, subRuleField, options, messageVariables)));
      return subResults.reduce((prev2, errors) => [...prev2, ...errors], []);
    }
    const kv = _extends$1(_extends$1(_extends$1({}, rule), {
      name,
      enum: (rule.enum || []).join(", ")
    }), messageVariables);
    const fillVariableResult = result.map((error) => {
      if (typeof error === "string") {
        return replaceMessage(error, kv);
      }
      return error;
    });
    return fillVariableResult;
  });
}
function validateRules(namePath, value, rules2, options, validateFirst, messageVariables) {
  const name = namePath.join(".");
  const filledRules = rules2.map((currentRule, ruleIndex) => {
    const originValidatorFunc = currentRule.validator;
    const cloneRule = _extends$1(_extends$1({}, currentRule), {
      ruleIndex
    });
    if (originValidatorFunc) {
      cloneRule.validator = (rule, val, callback) => {
        let hasPromise = false;
        const wrappedCallback = function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          Promise.resolve().then(() => {
            if (!hasPromise) {
              callback(...args);
            }
          });
        };
        const promise = originValidatorFunc(rule, val, wrappedCallback);
        hasPromise = promise && typeof promise.then === "function" && typeof promise.catch === "function";
        if (hasPromise) {
          promise.then(() => {
            callback();
          }).catch((err) => {
            callback(err || " ");
          });
        }
      };
    }
    return cloneRule;
  }).sort((_ref2, _ref3) => {
    let {
      warningOnly: w1,
      ruleIndex: i1
    } = _ref2;
    let {
      warningOnly: w2,
      ruleIndex: i2
    } = _ref3;
    if (!!w1 === !!w2) {
      return i1 - i2;
    }
    if (w1) {
      return 1;
    }
    return -1;
  });
  let summaryPromise;
  if (validateFirst === true) {
    summaryPromise = new Promise((resolve, reject) => __awaiter$2(this, void 0, void 0, function* () {
      for (let i2 = 0; i2 < filledRules.length; i2 += 1) {
        const rule = filledRules[i2];
        const errors = yield validateRule(name, value, rule, options, messageVariables);
        if (errors.length) {
          reject([{
            errors,
            rule
          }]);
          return;
        }
      }
      resolve([]);
    }));
  } else {
    const rulePromises = filledRules.map((rule) => validateRule(name, value, rule, options, messageVariables).then((errors) => ({
      errors,
      rule
    })));
    summaryPromise = (validateFirst ? finishOnFirstFailed(rulePromises) : finishOnAllFailed(rulePromises)).then((errors) => {
      return Promise.reject(errors);
    });
  }
  summaryPromise.catch((e2) => e2);
  return summaryPromise;
}
function finishOnAllFailed(rulePromises) {
  return __awaiter$2(this, void 0, void 0, function* () {
    return Promise.all(rulePromises).then((errorsList) => {
      const errors = [].concat(...errorsList);
      return errors;
    });
  });
}
function finishOnFirstFailed(rulePromises) {
  return __awaiter$2(this, void 0, void 0, function* () {
    let count = 0;
    return new Promise((resolve) => {
      rulePromises.forEach((promise) => {
        promise.then((ruleError) => {
          if (ruleError.errors.length) {
            resolve([ruleError]);
          }
          count += 1;
          if (count === rulePromises.length) {
            resolve([]);
          }
        });
      });
    });
  });
}
const FormContextKey = Symbol("formContextKey");
const useProvideForm = (state) => {
  provide(FormContextKey, state);
};
const useInjectForm = () => {
  return inject(FormContextKey, {
    name: computed(() => void 0),
    labelAlign: computed(() => "right"),
    vertical: computed(() => false),
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    addField: (_eventKey, _field) => {
    },
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    removeField: (_eventKey) => {
    },
    model: computed(() => void 0),
    rules: computed(() => void 0),
    colon: computed(() => void 0),
    labelWrap: computed(() => void 0),
    labelCol: computed(() => void 0),
    requiredMark: computed(() => false),
    validateTrigger: computed(() => void 0),
    onValidate: () => {
    },
    validateMessages: computed(() => defaultValidateMessages)
  });
};
const FormItemPrefixContextKey = Symbol("formItemPrefixContextKey");
const useProvideFormItemPrefix = (state) => {
  provide(FormItemPrefixContextKey, state);
};
const useInjectFormItemPrefix = () => {
  return inject(FormItemPrefixContextKey, {
    prefixCls: computed(() => "")
  });
};
function parseFlex(flex) {
  if (typeof flex === "number") {
    return `${flex} ${flex} auto`;
  }
  if (/^\d+(\.\d+)?(px|em|rem|%)$/.test(flex)) {
    return `0 0 ${flex}`;
  }
  return flex;
}
const colProps = () => ({
  span: [String, Number],
  order: [String, Number],
  offset: [String, Number],
  push: [String, Number],
  pull: [String, Number],
  xs: {
    type: [String, Number, Object],
    default: void 0
  },
  sm: {
    type: [String, Number, Object],
    default: void 0
  },
  md: {
    type: [String, Number, Object],
    default: void 0
  },
  lg: {
    type: [String, Number, Object],
    default: void 0
  },
  xl: {
    type: [String, Number, Object],
    default: void 0
  },
  xxl: {
    type: [String, Number, Object],
    default: void 0
  },
  prefixCls: String,
  flex: [String, Number]
});
const sizes = ["xs", "sm", "md", "lg", "xl", "xxl"];
const Col$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ACol",
  inheritAttrs: false,
  props: colProps(),
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const {
      gutter,
      supportFlexGap,
      wrap
    } = useInjectRow();
    const {
      prefixCls,
      direction
    } = useConfigInject("col", props2);
    const [wrapSSR, hashId] = useColStyle(prefixCls);
    const classes = computed(() => {
      const {
        span,
        order,
        offset: offset3,
        push,
        pull
      } = props2;
      const pre = prefixCls.value;
      let sizeClassObj = {};
      sizes.forEach((size) => {
        let sizeProps = {};
        const propSize = props2[size];
        if (typeof propSize === "number") {
          sizeProps.span = propSize;
        } else if (typeof propSize === "object") {
          sizeProps = propSize || {};
        }
        sizeClassObj = _extends$1(_extends$1({}, sizeClassObj), {
          [`${pre}-${size}-${sizeProps.span}`]: sizeProps.span !== void 0,
          [`${pre}-${size}-order-${sizeProps.order}`]: sizeProps.order || sizeProps.order === 0,
          [`${pre}-${size}-offset-${sizeProps.offset}`]: sizeProps.offset || sizeProps.offset === 0,
          [`${pre}-${size}-push-${sizeProps.push}`]: sizeProps.push || sizeProps.push === 0,
          [`${pre}-${size}-pull-${sizeProps.pull}`]: sizeProps.pull || sizeProps.pull === 0,
          [`${pre}-rtl`]: direction.value === "rtl"
        });
      });
      return classNames(pre, {
        [`${pre}-${span}`]: span !== void 0,
        [`${pre}-order-${order}`]: order,
        [`${pre}-offset-${offset3}`]: offset3,
        [`${pre}-push-${push}`]: push,
        [`${pre}-pull-${pull}`]: pull
      }, sizeClassObj, attrs.class, hashId.value);
    });
    const mergedStyle = computed(() => {
      const {
        flex
      } = props2;
      const gutterVal = gutter.value;
      const style = {};
      if (gutterVal && gutterVal[0] > 0) {
        const horizontalGutter = `${gutterVal[0] / 2}px`;
        style.paddingLeft = horizontalGutter;
        style.paddingRight = horizontalGutter;
      }
      if (gutterVal && gutterVal[1] > 0 && !supportFlexGap.value) {
        const verticalGutter = `${gutterVal[1] / 2}px`;
        style.paddingTop = verticalGutter;
        style.paddingBottom = verticalGutter;
      }
      if (flex) {
        style.flex = parseFlex(flex);
        if (wrap.value === false && !style.minWidth) {
          style.minWidth = 0;
        }
      }
      return style;
    });
    return () => {
      var _a2;
      return wrapSSR(createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "class": classes.value,
        "style": [mergedStyle.value, attrs.style]
      }), [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]));
    };
  }
});
const FormItemLabel = (props2, _ref) => {
  let {
    slots,
    emit,
    attrs
  } = _ref;
  var _a2, _b, _c, _d, _e;
  const {
    prefixCls,
    htmlFor,
    labelCol,
    labelAlign,
    colon,
    required: required4,
    requiredMark
  } = _extends$1(_extends$1({}, props2), attrs);
  const [formLocale] = useLocaleReceiver("Form");
  const label = (_a2 = props2.label) !== null && _a2 !== void 0 ? _a2 : (_b = slots.label) === null || _b === void 0 ? void 0 : _b.call(slots);
  if (!label) return null;
  const {
    vertical,
    labelAlign: contextLabelAlign,
    labelCol: contextLabelCol,
    labelWrap,
    colon: contextColon
  } = useInjectForm();
  const mergedLabelCol = labelCol || (contextLabelCol === null || contextLabelCol === void 0 ? void 0 : contextLabelCol.value) || {};
  const mergedLabelAlign = labelAlign || (contextLabelAlign === null || contextLabelAlign === void 0 ? void 0 : contextLabelAlign.value);
  const labelClsBasic = `${prefixCls}-item-label`;
  const labelColClassName = classNames(labelClsBasic, mergedLabelAlign === "left" && `${labelClsBasic}-left`, mergedLabelCol.class, {
    [`${labelClsBasic}-wrap`]: !!labelWrap.value
  });
  let labelChildren = label;
  const computedColon = colon === true || (contextColon === null || contextColon === void 0 ? void 0 : contextColon.value) !== false && colon !== false;
  const haveColon = computedColon && !vertical.value;
  if (haveColon && typeof label === "string" && label.trim() !== "") {
    labelChildren = label.replace(/[:|：]\s*$/, "");
  }
  if (props2.tooltip || slots.tooltip) {
    const tooltipNode = createVNode("span", {
      "class": `${prefixCls}-item-tooltip`
    }, [createVNode(Tooltip, {
      "title": props2.tooltip
    }, {
      default: () => [createVNode(QuestionCircleOutlined, null, null)]
    })]);
    labelChildren = createVNode(Fragment, null, [labelChildren, slots.tooltip ? (_c = slots.tooltip) === null || _c === void 0 ? void 0 : _c.call(slots, {
      class: `${prefixCls}-item-tooltip`
    }) : tooltipNode]);
  }
  if (requiredMark === "optional" && !required4) {
    labelChildren = createVNode(Fragment, null, [labelChildren, createVNode("span", {
      "class": `${prefixCls}-item-optional`
    }, [((_d = formLocale.value) === null || _d === void 0 ? void 0 : _d.optional) || ((_e = localeValues.Form) === null || _e === void 0 ? void 0 : _e.optional)])]);
  }
  const labelClassName = classNames({
    [`${prefixCls}-item-required`]: required4,
    [`${prefixCls}-item-required-mark-optional`]: requiredMark === "optional",
    [`${prefixCls}-item-no-colon`]: !computedColon
  });
  return createVNode(Col$1, _objectSpread2$1(_objectSpread2$1({}, mergedLabelCol), {}, {
    "class": labelColClassName
  }), {
    default: () => [createVNode("label", {
      "for": htmlFor,
      "class": labelClassName,
      "title": typeof label === "string" ? label : "",
      "onClick": (e2) => emit("click", e2)
    }, [labelChildren])]
  });
};
FormItemLabel.displayName = "FormItemLabel";
FormItemLabel.inheritAttrs = false;
const genFormValidateMotionStyle = (token2) => {
  const {
    componentCls
  } = token2;
  const helpCls = `${componentCls}-show-help`;
  const helpItemCls = `${componentCls}-show-help-item`;
  return {
    [helpCls]: {
      // Explain holder
      transition: `opacity ${token2.motionDurationSlow} ${token2.motionEaseInOut}`,
      "&-appear, &-enter": {
        opacity: 0,
        "&-active": {
          opacity: 1
        }
      },
      "&-leave": {
        opacity: 1,
        "&-active": {
          opacity: 0
        }
      },
      // Explain
      [helpItemCls]: {
        overflow: "hidden",
        transition: `height ${token2.motionDurationSlow} ${token2.motionEaseInOut},
                     opacity ${token2.motionDurationSlow} ${token2.motionEaseInOut},
                     transform ${token2.motionDurationSlow} ${token2.motionEaseInOut} !important`,
        [`&${helpItemCls}-appear, &${helpItemCls}-enter`]: {
          transform: `translateY(-5px)`,
          opacity: 0,
          [`&-active`]: {
            transform: "translateY(0)",
            opacity: 1
          }
        },
        [`&${helpItemCls}-leave-active`]: {
          transform: `translateY(-5px)`
        }
      }
    }
  };
};
const resetForm = (token2) => ({
  legend: {
    display: "block",
    width: "100%",
    marginBottom: token2.marginLG,
    padding: 0,
    color: token2.colorTextDescription,
    fontSize: token2.fontSizeLG,
    lineHeight: "inherit",
    border: 0,
    borderBottom: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`
  },
  label: {
    fontSize: token2.fontSize
  },
  'input[type="search"]': {
    boxSizing: "border-box"
  },
  // Position radios and checkboxes better
  'input[type="radio"], input[type="checkbox"]': {
    lineHeight: "normal"
  },
  'input[type="file"]': {
    display: "block"
  },
  // Make range inputs behave like textual form controls
  'input[type="range"]': {
    display: "block",
    width: "100%"
  },
  // Make multiple select elements height not fixed
  "select[multiple], select[size]": {
    height: "auto"
  },
  // Focus for file, radio, and checkbox
  [`input[type='file']:focus,
  input[type='radio']:focus,
  input[type='checkbox']:focus`]: {
    outline: 0,
    boxShadow: `0 0 0 ${token2.controlOutlineWidth}px ${token2.controlOutline}`
  },
  // Adjust output element
  output: {
    display: "block",
    paddingTop: 15,
    color: token2.colorText,
    fontSize: token2.fontSize,
    lineHeight: token2.lineHeight
  }
});
const genFormSize = (token2, height) => {
  const {
    formItemCls
  } = token2;
  return {
    [formItemCls]: {
      [`${formItemCls}-label > label`]: {
        height
      },
      [`${formItemCls}-control-input`]: {
        minHeight: height
      }
    }
  };
};
const genFormStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [token2.componentCls]: _extends$1(_extends$1(_extends$1({}, resetComponent(token2)), resetForm(token2)), {
      [`${componentCls}-text`]: {
        display: "inline-block",
        paddingInlineEnd: token2.paddingSM
      },
      // ================================================================
      // =                             Size                             =
      // ================================================================
      "&-small": _extends$1({}, genFormSize(token2, token2.controlHeightSM)),
      "&-large": _extends$1({}, genFormSize(token2, token2.controlHeightLG))
    })
  };
};
const genFormItemStyle = (token2) => {
  const {
    formItemCls,
    iconCls,
    componentCls,
    rootPrefixCls
  } = token2;
  return {
    [formItemCls]: _extends$1(_extends$1({}, resetComponent(token2)), {
      marginBottom: token2.marginLG,
      verticalAlign: "top",
      "&-with-help": {
        transition: "none"
      },
      [`&-hidden,
        &-hidden.${rootPrefixCls}-row`]: {
        // https://github.com/ant-design/ant-design/issues/26141
        display: "none"
      },
      "&-has-warning": {
        [`${formItemCls}-split`]: {
          color: token2.colorError
        }
      },
      "&-has-error": {
        [`${formItemCls}-split`]: {
          color: token2.colorWarning
        }
      },
      // ==============================================================
      // =                            Label                           =
      // ==============================================================
      [`${formItemCls}-label`]: {
        display: "inline-block",
        flexGrow: 0,
        overflow: "hidden",
        whiteSpace: "nowrap",
        textAlign: "end",
        verticalAlign: "middle",
        "&-left": {
          textAlign: "start"
        },
        "&-wrap": {
          overflow: "unset",
          lineHeight: `${token2.lineHeight} - 0.25em`,
          whiteSpace: "unset"
        },
        "> label": {
          position: "relative",
          display: "inline-flex",
          alignItems: "center",
          maxWidth: "100%",
          height: token2.controlHeight,
          color: token2.colorTextHeading,
          fontSize: token2.fontSize,
          [`> ${iconCls}`]: {
            fontSize: token2.fontSize,
            verticalAlign: "top"
          },
          // Required mark
          [`&${formItemCls}-required:not(${formItemCls}-required-mark-optional)::before`]: {
            display: "inline-block",
            marginInlineEnd: token2.marginXXS,
            color: token2.colorError,
            fontSize: token2.fontSize,
            fontFamily: "SimSun, sans-serif",
            lineHeight: 1,
            content: '"*"',
            [`${componentCls}-hide-required-mark &`]: {
              display: "none"
            }
          },
          // Optional mark
          [`${formItemCls}-optional`]: {
            display: "inline-block",
            marginInlineStart: token2.marginXXS,
            color: token2.colorTextDescription,
            [`${componentCls}-hide-required-mark &`]: {
              display: "none"
            }
          },
          // Optional mark
          [`${formItemCls}-tooltip`]: {
            color: token2.colorTextDescription,
            cursor: "help",
            writingMode: "horizontal-tb",
            marginInlineStart: token2.marginXXS
          },
          "&::after": {
            content: '":"',
            position: "relative",
            marginBlock: 0,
            marginInlineStart: token2.marginXXS / 2,
            marginInlineEnd: token2.marginXS
          },
          [`&${formItemCls}-no-colon::after`]: {
            content: '" "'
          }
        }
      },
      // ==============================================================
      // =                            Input                           =
      // ==============================================================
      [`${formItemCls}-control`]: {
        display: "flex",
        flexDirection: "column",
        flexGrow: 1,
        [`&:first-child:not([class^="'${rootPrefixCls}-col-'"]):not([class*="' ${rootPrefixCls}-col-'"])`]: {
          width: "100%"
        },
        "&-input": {
          position: "relative",
          display: "flex",
          alignItems: "center",
          minHeight: token2.controlHeight,
          "&-content": {
            flex: "auto",
            maxWidth: "100%"
          }
        }
      },
      // ==============================================================
      // =                           Explain                          =
      // ==============================================================
      [formItemCls]: {
        "&-explain, &-extra": {
          clear: "both",
          color: token2.colorTextDescription,
          fontSize: token2.fontSize,
          lineHeight: token2.lineHeight
        },
        "&-explain-connected": {
          width: "100%"
        },
        "&-extra": {
          minHeight: token2.controlHeightSM,
          transition: `color ${token2.motionDurationMid} ${token2.motionEaseOut}`
          // sync input color transition
        },
        "&-explain": {
          "&-error": {
            color: token2.colorError
          },
          "&-warning": {
            color: token2.colorWarning
          }
        }
      },
      [`&-with-help ${formItemCls}-explain`]: {
        height: "auto",
        opacity: 1
      },
      // ==============================================================
      // =                        Feedback Icon                       =
      // ==============================================================
      [`${formItemCls}-feedback-icon`]: {
        fontSize: token2.fontSize,
        textAlign: "center",
        visibility: "visible",
        animationName: zoomIn,
        animationDuration: token2.motionDurationMid,
        animationTimingFunction: token2.motionEaseOutBack,
        pointerEvents: "none",
        "&-success": {
          color: token2.colorSuccess
        },
        "&-error": {
          color: token2.colorError
        },
        "&-warning": {
          color: token2.colorWarning
        },
        "&-validating": {
          color: token2.colorPrimary
        }
      }
    })
  };
};
const genHorizontalStyle$1 = (token2) => {
  const {
    componentCls,
    formItemCls,
    rootPrefixCls
  } = token2;
  return {
    [`${componentCls}-horizontal`]: {
      [`${formItemCls}-label`]: {
        flexGrow: 0
      },
      [`${formItemCls}-control`]: {
        flex: "1 1 0",
        // https://github.com/ant-design/ant-design/issues/32777
        // https://github.com/ant-design/ant-design/issues/33773
        minWidth: 0
      },
      // https://github.com/ant-design/ant-design/issues/32980
      [`${formItemCls}-label.${rootPrefixCls}-col-24 + ${formItemCls}-control`]: {
        minWidth: "unset"
      }
    }
  };
};
const genInlineStyle = (token2) => {
  const {
    componentCls,
    formItemCls
  } = token2;
  return {
    [`${componentCls}-inline`]: {
      display: "flex",
      flexWrap: "wrap",
      [formItemCls]: {
        flex: "none",
        flexWrap: "nowrap",
        marginInlineEnd: token2.margin,
        marginBottom: 0,
        "&-with-help": {
          marginBottom: token2.marginLG
        },
        [`> ${formItemCls}-label,
        > ${formItemCls}-control`]: {
          display: "inline-block",
          verticalAlign: "top"
        },
        [`> ${formItemCls}-label`]: {
          flex: "none"
        },
        [`${componentCls}-text`]: {
          display: "inline-block"
        },
        [`${formItemCls}-has-feedback`]: {
          display: "inline-block"
        }
      }
    }
  };
};
const makeVerticalLayoutLabel = (token2) => ({
  margin: 0,
  padding: `0 0 ${token2.paddingXS}px`,
  whiteSpace: "initial",
  textAlign: "start",
  "> label": {
    margin: 0,
    "&::after": {
      display: "none"
    }
  }
});
const makeVerticalLayout = (token2) => {
  const {
    componentCls,
    formItemCls
  } = token2;
  return {
    [`${formItemCls} ${formItemCls}-label`]: makeVerticalLayoutLabel(token2),
    [componentCls]: {
      [formItemCls]: {
        flexWrap: "wrap",
        [`${formItemCls}-label,
          ${formItemCls}-control`]: {
          flex: "0 0 100%",
          maxWidth: "100%"
        }
      }
    }
  };
};
const genVerticalStyle$1 = (token2) => {
  const {
    componentCls,
    formItemCls,
    rootPrefixCls
  } = token2;
  return {
    [`${componentCls}-vertical`]: {
      [formItemCls]: {
        "&-row": {
          flexDirection: "column"
        },
        "&-label > label": {
          height: "auto"
        },
        [`${componentCls}-item-control`]: {
          width: "100%"
        }
      }
    },
    [`${componentCls}-vertical ${formItemCls}-label,
      .${rootPrefixCls}-col-24${formItemCls}-label,
      .${rootPrefixCls}-col-xl-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2),
    [`@media (max-width: ${token2.screenXSMax}px)`]: [makeVerticalLayout(token2), {
      [componentCls]: {
        [`.${rootPrefixCls}-col-xs-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
      }
    }],
    [`@media (max-width: ${token2.screenSMMax}px)`]: {
      [componentCls]: {
        [`.${rootPrefixCls}-col-sm-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
      }
    },
    [`@media (max-width: ${token2.screenMDMax}px)`]: {
      [componentCls]: {
        [`.${rootPrefixCls}-col-md-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
      }
    },
    [`@media (max-width: ${token2.screenLGMax}px)`]: {
      [componentCls]: {
        [`.${rootPrefixCls}-col-lg-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
      }
    }
  };
};
const useStyle$q = genComponentStyleHook("Form", (token2, _ref) => {
  let {
    rootPrefixCls
  } = _ref;
  const formToken = merge(token2, {
    formItemCls: `${token2.componentCls}-item`,
    rootPrefixCls
  });
  return [genFormStyle(formToken), genFormItemStyle(formToken), genFormValidateMotionStyle(formToken), genHorizontalStyle$1(formToken), genInlineStyle(formToken), genVerticalStyle$1(formToken), genCollapseMotion(formToken), zoomIn];
});
const ErrorList = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ErrorList",
  inheritAttrs: false,
  props: ["errors", "help", "onErrorVisibleChanged", "helpStatus", "warnings"],
  setup(props2, _ref) {
    let {
      attrs
    } = _ref;
    const {
      prefixCls,
      status
    } = useInjectFormItemPrefix();
    const baseClassName = computed(() => `${prefixCls.value}-item-explain`);
    const visible = computed(() => !!(props2.errors && props2.errors.length));
    const innerStatus = ref(status.value);
    const [, hashId] = useStyle$q(prefixCls);
    watch([visible, status], () => {
      if (visible.value) {
        innerStatus.value = status.value;
      }
    });
    return () => {
      var _a2, _b;
      const colMItem = collapseMotion(`${prefixCls.value}-show-help-item`);
      const transitionGroupProps = getTransitionGroupProps(`${prefixCls.value}-show-help-item`, colMItem);
      transitionGroupProps.role = "alert";
      transitionGroupProps.class = [hashId.value, baseClassName.value, attrs.class, `${prefixCls.value}-show-help`];
      return createVNode(Transition, _objectSpread2$1(_objectSpread2$1({}, getTransitionProps(`${prefixCls.value}-show-help`)), {}, {
        "onAfterEnter": () => props2.onErrorVisibleChanged(true),
        "onAfterLeave": () => props2.onErrorVisibleChanged(false)
      }), {
        default: () => [withDirectives(createVNode(TransitionGroup, _objectSpread2$1(_objectSpread2$1({}, transitionGroupProps), {}, {
          "tag": "div"
        }), {
          default: () => [(_b = props2.errors) === null || _b === void 0 ? void 0 : _b.map((error, index2) => createVNode("div", {
            "key": index2,
            "class": innerStatus.value ? `${baseClassName.value}-${innerStatus.value}` : ""
          }, [error]))]
        }), [[vShow, !!((_a2 = props2.errors) === null || _a2 === void 0 ? void 0 : _a2.length)]])]
      });
    };
  }
});
const FormItemInput = defineComponent({
  compatConfig: {
    MODE: 3
  },
  slots: Object,
  inheritAttrs: false,
  props: ["prefixCls", "errors", "hasFeedback", "onDomErrorVisibleChange", "wrapperCol", "help", "extra", "status", "marginBottom", "onErrorVisibleChanged"],
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const formContext = useInjectForm();
    const {
      wrapperCol: contextWrapperCol
    } = formContext;
    const subFormContext = _extends$1({}, formContext);
    delete subFormContext.labelCol;
    delete subFormContext.wrapperCol;
    useProvideForm(subFormContext);
    useProvideFormItemPrefix({
      prefixCls: computed(() => props2.prefixCls),
      status: computed(() => props2.status)
    });
    return () => {
      var _a2, _b, _c;
      const {
        prefixCls,
        wrapperCol,
        marginBottom,
        onErrorVisibleChanged,
        help = (_a2 = slots.help) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
        errors = filterEmpty((_b = slots.errors) === null || _b === void 0 ? void 0 : _b.call(slots)),
        // hasFeedback,
        // status,
        extra = (_c = slots.extra) === null || _c === void 0 ? void 0 : _c.call(slots)
      } = props2;
      const baseClassName = `${prefixCls}-item`;
      const mergedWrapperCol = wrapperCol || (contextWrapperCol === null || contextWrapperCol === void 0 ? void 0 : contextWrapperCol.value) || {};
      const className = classNames(`${baseClassName}-control`, mergedWrapperCol.class);
      return createVNode(Col$1, _objectSpread2$1(_objectSpread2$1({}, mergedWrapperCol), {}, {
        "class": className
      }), {
        default: () => {
          var _a3;
          return createVNode(Fragment, null, [createVNode("div", {
            "class": `${baseClassName}-control-input`
          }, [createVNode("div", {
            "class": `${baseClassName}-control-input-content`
          }, [(_a3 = slots.default) === null || _a3 === void 0 ? void 0 : _a3.call(slots)])]), marginBottom !== null || errors.length ? createVNode("div", {
            "style": {
              display: "flex",
              flexWrap: "nowrap"
            }
          }, [createVNode(ErrorList, {
            "errors": errors,
            "help": help,
            "class": `${baseClassName}-explain-connected`,
            "onErrorVisibleChanged": onErrorVisibleChanged
          }, null), !!marginBottom && createVNode("div", {
            "style": {
              width: 0,
              height: `${marginBottom}px`
            }
          }, null)]) : null, extra ? createVNode("div", {
            "class": `${baseClassName}-extra`
          }, [extra]) : null]);
        }
      });
    };
  }
});
function useDebounce(value) {
  const cacheValue = shallowRef(value.value.slice());
  let timeout = null;
  watchEffect(() => {
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      cacheValue.value = value.value;
    }, value.value.length ? 0 : 10);
  });
  return cacheValue;
}
tuple$1("success", "warning", "error", "validating", "");
const iconMap = {
  success: CheckCircleFilled,
  warning: ExclamationCircleFilled,
  error: CloseCircleFilled,
  validating: LoadingOutlined
};
function getPropByPath$1(obj, namePathList, strict) {
  let tempObj = obj;
  const keyArr = namePathList;
  let i2 = 0;
  try {
    for (let len = keyArr.length; i2 < len - 1; ++i2) {
      if (!tempObj && !strict) break;
      const key2 = keyArr[i2];
      if (key2 in tempObj) {
        tempObj = tempObj[key2];
      } else {
        if (strict) {
          throw Error("please transfer a valid name path to form item!");
        }
        break;
      }
    }
    if (strict && !tempObj) {
      throw Error("please transfer a valid name path to form item!");
    }
  } catch (error) {
    console.error("please transfer a valid name path to form item!");
  }
  return {
    o: tempObj,
    k: keyArr[i2],
    v: tempObj ? tempObj[keyArr[i2]] : void 0
  };
}
const formItemProps = () => ({
  htmlFor: String,
  prefixCls: String,
  label: PropTypes.any,
  help: PropTypes.any,
  extra: PropTypes.any,
  labelCol: {
    type: Object
  },
  wrapperCol: {
    type: Object
  },
  hasFeedback: {
    type: Boolean,
    default: false
  },
  colon: {
    type: Boolean,
    default: void 0
  },
  labelAlign: String,
  prop: {
    type: [String, Number, Array]
  },
  name: {
    type: [String, Number, Array]
  },
  rules: [Array, Object],
  autoLink: {
    type: Boolean,
    default: true
  },
  required: {
    type: Boolean,
    default: void 0
  },
  validateFirst: {
    type: Boolean,
    default: void 0
  },
  validateStatus: PropTypes.oneOf(tuple$1("", "success", "warning", "error", "validating")),
  validateTrigger: {
    type: [String, Array]
  },
  messageVariables: {
    type: Object
  },
  hidden: Boolean,
  noStyle: Boolean,
  tooltip: String
});
let indexGuid$1 = 0;
const defaultItemNamePrefixCls = "form_item";
const FormItem = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AFormItem",
  inheritAttrs: false,
  __ANT_NEW_FORM_ITEM: true,
  props: formItemProps(),
  slots: Object,
  setup(props2, _ref) {
    let {
      slots,
      attrs,
      expose
    } = _ref;
    warning$2(props2.prop === void 0);
    const eventKey = `form-item-${++indexGuid$1}`;
    const {
      prefixCls
    } = useConfigInject("form", props2);
    const [wrapSSR, hashId] = useStyle$q(prefixCls);
    const itemRef = shallowRef();
    const formContext = useInjectForm();
    const fieldName = computed(() => props2.name || props2.prop);
    const errors = shallowRef([]);
    const validateDisabled = shallowRef(false);
    const inputRef = shallowRef();
    const namePath = computed(() => {
      const val = fieldName.value;
      return getNamePath(val);
    });
    const fieldId = computed(() => {
      if (!namePath.value.length) {
        return void 0;
      } else {
        const formName = formContext.name.value;
        const mergedId = namePath.value.join("_");
        return formName ? `${formName}_${mergedId}` : `${defaultItemNamePrefixCls}_${mergedId}`;
      }
    });
    const getNewFieldValue = () => {
      const model = formContext.model.value;
      if (!model || !fieldName.value) {
        return;
      } else {
        return getPropByPath$1(model, namePath.value, true).v;
      }
    };
    const fieldValue = computed(() => getNewFieldValue());
    const initialValue = shallowRef(cloneDeep(fieldValue.value));
    const mergedValidateTrigger = computed(() => {
      let validateTrigger = props2.validateTrigger !== void 0 ? props2.validateTrigger : formContext.validateTrigger.value;
      validateTrigger = validateTrigger === void 0 ? "change" : validateTrigger;
      return toArray$4(validateTrigger);
    });
    const rulesRef = computed(() => {
      let formRules = formContext.rules.value;
      const selfRules = props2.rules;
      const requiredRule = props2.required !== void 0 ? {
        required: !!props2.required,
        trigger: mergedValidateTrigger.value
      } : [];
      const prop = getPropByPath$1(formRules, namePath.value);
      formRules = formRules ? prop.o[prop.k] || prop.v : [];
      const rules2 = [].concat(selfRules || formRules || []);
      if (find(rules2, (rule) => rule.required)) {
        return rules2;
      } else {
        return rules2.concat(requiredRule);
      }
    });
    const isRequired2 = computed(() => {
      const rules2 = rulesRef.value;
      let isRequired3 = false;
      if (rules2 && rules2.length) {
        rules2.every((rule) => {
          if (rule.required) {
            isRequired3 = true;
            return false;
          }
          return true;
        });
      }
      return isRequired3 || props2.required;
    });
    const validateState = shallowRef();
    watchEffect(() => {
      validateState.value = props2.validateStatus;
    });
    const messageVariables = computed(() => {
      let variables = {};
      if (typeof props2.label === "string") {
        variables.label = props2.label;
      } else if (props2.name) {
        variables.label = String(props2.name);
      }
      if (props2.messageVariables) {
        variables = _extends$1(_extends$1({}, variables), props2.messageVariables);
      }
      return variables;
    });
    const validateRules$1 = (options) => {
      if (namePath.value.length === 0) {
        return;
      }
      const {
        validateFirst = false
      } = props2;
      const {
        triggerName
      } = options || {};
      let filteredRules = rulesRef.value;
      if (triggerName) {
        filteredRules = filteredRules.filter((rule) => {
          const {
            trigger
          } = rule;
          if (!trigger && !mergedValidateTrigger.value.length) {
            return true;
          }
          const triggerList = toArray$4(trigger || mergedValidateTrigger.value);
          return triggerList.includes(triggerName);
        });
      }
      if (!filteredRules.length) {
        return Promise.resolve();
      }
      const promise = validateRules(namePath.value, fieldValue.value, filteredRules, _extends$1({
        validateMessages: formContext.validateMessages.value
      }, options), validateFirst, messageVariables.value);
      validateState.value = "validating";
      errors.value = [];
      promise.catch((e2) => e2).then(function() {
        let results = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        if (validateState.value === "validating") {
          const res = results.filter((result) => result && result.errors.length);
          validateState.value = res.length ? "error" : "success";
          errors.value = res.map((r2) => r2.errors);
          formContext.onValidate(fieldName.value, !errors.value.length, errors.value.length ? toRaw(errors.value[0]) : null);
        }
      });
      return promise;
    };
    const onFieldBlur = () => {
      validateRules$1({
        triggerName: "blur"
      });
    };
    const onFieldChange = () => {
      if (validateDisabled.value) {
        validateDisabled.value = false;
        return;
      }
      validateRules$1({
        triggerName: "change"
      });
    };
    const clearValidate = () => {
      validateState.value = props2.validateStatus;
      validateDisabled.value = false;
      errors.value = [];
    };
    const resetField = () => {
      var _a2;
      validateState.value = props2.validateStatus;
      validateDisabled.value = true;
      errors.value = [];
      const model = formContext.model.value || {};
      const value = fieldValue.value;
      const prop = getPropByPath$1(model, namePath.value, true);
      if (Array.isArray(value)) {
        prop.o[prop.k] = [].concat((_a2 = initialValue.value) !== null && _a2 !== void 0 ? _a2 : []);
      } else {
        prop.o[prop.k] = initialValue.value;
      }
      nextTick(() => {
        validateDisabled.value = false;
      });
    };
    const htmlFor = computed(() => {
      return props2.htmlFor === void 0 ? fieldId.value : props2.htmlFor;
    });
    const onLabelClick = () => {
      const id = htmlFor.value;
      if (!id || !inputRef.value) {
        return;
      }
      const control = inputRef.value.$el.querySelector(`[id="${id}"]`);
      if (control && control.focus) {
        control.focus();
      }
    };
    expose({
      onFieldBlur,
      onFieldChange,
      clearValidate,
      resetField
    });
    useProvideFormItemContext({
      id: fieldId,
      onFieldBlur: () => {
        if (props2.autoLink) {
          onFieldBlur();
        }
      },
      onFieldChange: () => {
        if (props2.autoLink) {
          onFieldChange();
        }
      },
      clearValidate
    }, computed(() => {
      return !!(props2.autoLink && formContext.model.value && fieldName.value);
    }));
    let registered = false;
    watch(fieldName, (val) => {
      if (val) {
        if (!registered) {
          registered = true;
          formContext.addField(eventKey, {
            fieldValue,
            fieldId,
            fieldName,
            resetField,
            clearValidate,
            namePath,
            validateRules: validateRules$1,
            rules: rulesRef
          });
        }
      } else {
        registered = false;
        formContext.removeField(eventKey);
      }
    }, {
      immediate: true
    });
    onBeforeUnmount(() => {
      formContext.removeField(eventKey);
    });
    const debounceErrors = useDebounce(errors);
    const mergedValidateStatus = computed(() => {
      if (props2.validateStatus !== void 0) {
        return props2.validateStatus;
      } else if (debounceErrors.value.length) {
        return "error";
      }
      return validateState.value;
    });
    const itemClassName = computed(() => ({
      [`${prefixCls.value}-item`]: true,
      [hashId.value]: true,
      // Status
      [`${prefixCls.value}-item-has-feedback`]: mergedValidateStatus.value && props2.hasFeedback,
      [`${prefixCls.value}-item-has-success`]: mergedValidateStatus.value === "success",
      [`${prefixCls.value}-item-has-warning`]: mergedValidateStatus.value === "warning",
      [`${prefixCls.value}-item-has-error`]: mergedValidateStatus.value === "error",
      [`${prefixCls.value}-item-is-validating`]: mergedValidateStatus.value === "validating",
      [`${prefixCls.value}-item-hidden`]: props2.hidden
    }));
    const formItemInputContext = reactive({});
    FormItemInputContext.useProvide(formItemInputContext);
    watchEffect(() => {
      let feedbackIcon;
      if (props2.hasFeedback) {
        const IconNode = mergedValidateStatus.value && iconMap[mergedValidateStatus.value];
        feedbackIcon = IconNode ? createVNode("span", {
          "class": classNames(`${prefixCls.value}-item-feedback-icon`, `${prefixCls.value}-item-feedback-icon-${mergedValidateStatus.value}`)
        }, [createVNode(IconNode, null, null)]) : null;
      }
      _extends$1(formItemInputContext, {
        status: mergedValidateStatus.value,
        hasFeedback: props2.hasFeedback,
        feedbackIcon,
        isFormItemInput: true
      });
    });
    const marginBottom = shallowRef(null);
    const showMarginOffset = shallowRef(false);
    const updateMarginBottom = () => {
      if (itemRef.value) {
        const itemStyle = getComputedStyle(itemRef.value);
        marginBottom.value = parseInt(itemStyle.marginBottom, 10);
      }
    };
    onMounted(() => {
      watch(showMarginOffset, () => {
        if (showMarginOffset.value) {
          updateMarginBottom();
        }
      }, {
        flush: "post",
        immediate: true
      });
    });
    const onErrorVisibleChanged = (nextVisible) => {
      if (!nextVisible) {
        marginBottom.value = null;
      }
    };
    return () => {
      var _a2, _b;
      if (props2.noStyle) return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
      const help = (_b = props2.help) !== null && _b !== void 0 ? _b : slots.help ? filterEmpty(slots.help()) : null;
      const withHelp = !!(help !== void 0 && help !== null && Array.isArray(help) && help.length || debounceErrors.value.length);
      showMarginOffset.value = withHelp;
      return wrapSSR(createVNode("div", {
        "class": [itemClassName.value, withHelp ? `${prefixCls.value}-item-with-help` : "", attrs.class],
        "ref": itemRef
      }, [createVNode(ARow, _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "class": `${prefixCls.value}-item-row`,
        "key": "row"
      }), {
        default: () => {
          var _a3, _b2;
          return createVNode(Fragment, null, [createVNode(FormItemLabel, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
            "htmlFor": htmlFor.value,
            "required": isRequired2.value,
            "requiredMark": formContext.requiredMark.value,
            "prefixCls": prefixCls.value,
            "onClick": onLabelClick,
            "label": props2.label
          }), {
            label: slots.label,
            tooltip: slots.tooltip
          }), createVNode(FormItemInput, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
            "errors": help !== void 0 && help !== null ? toArray$4(help) : debounceErrors.value,
            "marginBottom": marginBottom.value,
            "prefixCls": prefixCls.value,
            "status": mergedValidateStatus.value,
            "ref": inputRef,
            "help": help,
            "extra": (_a3 = props2.extra) !== null && _a3 !== void 0 ? _a3 : (_b2 = slots.extra) === null || _b2 === void 0 ? void 0 : _b2.call(slots),
            "onErrorVisibleChanged": onErrorVisibleChanged
          }), {
            default: slots.default
          })]);
        }
      }), !!marginBottom.value && createVNode("div", {
        "class": `${prefixCls.value}-margin-offset`,
        "style": {
          marginBottom: `-${marginBottom.value}px`
        }
      }, null)]));
    };
  }
});
function allPromiseFinish(promiseList) {
  let hasError = false;
  let count = promiseList.length;
  const results = [];
  if (!promiseList.length) {
    return Promise.resolve([]);
  }
  return new Promise((resolve, reject) => {
    promiseList.forEach((promise, index2) => {
      promise.catch((e2) => {
        hasError = true;
        return e2;
      }).then((result) => {
        count -= 1;
        results[index2] = result;
        if (count > 0) {
          return;
        }
        if (hasError) {
          reject(results);
        }
        resolve(results);
      });
    });
  });
}
function isRequired(rules2) {
  let isRequired2 = false;
  if (rules2 && rules2.length) {
    rules2.every((rule) => {
      if (rule.required) {
        isRequired2 = true;
        return false;
      }
      return true;
    });
  }
  return isRequired2;
}
function toArray$3(value) {
  if (value === void 0 || value === null) {
    return [];
  }
  return Array.isArray(value) ? value : [value];
}
function getPropByPath(obj, path2, strict) {
  let tempObj = obj;
  path2 = path2.replace(/\[(\w+)\]/g, ".$1");
  path2 = path2.replace(/^\./, "");
  const keyArr = path2.split(".");
  let i2 = 0;
  for (let len = keyArr.length; i2 < len - 1; ++i2) {
    if (!tempObj && !strict) break;
    const key2 = keyArr[i2];
    if (key2 in tempObj) {
      tempObj = tempObj[key2];
    } else {
      if (strict) {
        throw new Error("please transfer a valid name path to validate!");
      }
      break;
    }
  }
  return {
    o: tempObj,
    k: keyArr[i2],
    v: tempObj ? tempObj[keyArr[i2]] : null,
    isValid: tempObj && keyArr[i2] in tempObj
  };
}
function useForm(modelRef) {
  let rulesRef = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ref({});
  let options = arguments.length > 2 ? arguments[2] : void 0;
  const initialModel = cloneDeep(unref(modelRef));
  const validateInfos = reactive({});
  const rulesKeys = shallowRef([]);
  const resetFields = (newValues) => {
    _extends$1(unref(modelRef), _extends$1(_extends$1({}, cloneDeep(initialModel)), newValues));
    nextTick(() => {
      Object.keys(validateInfos).forEach((key2) => {
        validateInfos[key2] = {
          autoLink: false,
          required: isRequired(unref(rulesRef)[key2])
        };
      });
    });
  };
  const filterRules = function() {
    let rules2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    let trigger = arguments.length > 1 ? arguments[1] : void 0;
    if (!trigger.length) {
      return rules2;
    } else {
      return rules2.filter((rule) => {
        const triggerList = toArray$3(rule.trigger || "change");
        return intersection(triggerList, trigger).length;
      });
    }
  };
  let lastValidatePromise = null;
  const validateFields = function(names2) {
    let option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let strict = arguments.length > 2 ? arguments[2] : void 0;
    const promiseList = [];
    const values = {};
    for (let i2 = 0; i2 < names2.length; i2++) {
      const name = names2[i2];
      const prop = getPropByPath(unref(modelRef), name, strict);
      if (!prop.isValid) continue;
      values[name] = prop.v;
      const rules2 = filterRules(unref(rulesRef)[name], toArray$3(option && option.trigger));
      if (rules2.length) {
        promiseList.push(validateField(name, prop.v, rules2, option || {}).then(() => ({
          name,
          errors: [],
          warnings: []
        })).catch((ruleErrors) => {
          const mergedErrors = [];
          const mergedWarnings = [];
          ruleErrors.forEach((_ref) => {
            let {
              rule: {
                warningOnly
              },
              errors
            } = _ref;
            if (warningOnly) {
              mergedWarnings.push(...errors);
            } else {
              mergedErrors.push(...errors);
            }
          });
          if (mergedErrors.length) {
            return Promise.reject({
              name,
              errors: mergedErrors,
              warnings: mergedWarnings
            });
          }
          return {
            name,
            errors: mergedErrors,
            warnings: mergedWarnings
          };
        }));
      }
    }
    const summaryPromise = allPromiseFinish(promiseList);
    lastValidatePromise = summaryPromise;
    const returnPromise = summaryPromise.then(() => {
      if (lastValidatePromise === summaryPromise) {
        return Promise.resolve(values);
      }
      return Promise.reject([]);
    }).catch((results) => {
      const errorList = results.filter((result) => result && result.errors.length);
      return errorList.length ? Promise.reject({
        values,
        errorFields: errorList,
        outOfDate: lastValidatePromise !== summaryPromise
      }) : Promise.resolve(values);
    });
    returnPromise.catch((e2) => e2);
    return returnPromise;
  };
  const validateField = function(name, value, rules2) {
    let option = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const promise = validateRules([name], value, rules2, _extends$1({
      validateMessages: defaultValidateMessages
    }, option), !!option.validateFirst);
    if (!validateInfos[name]) {
      return promise.catch((e2) => e2);
    }
    validateInfos[name].validateStatus = "validating";
    promise.catch((e2) => e2).then(function() {
      let results = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      var _a2;
      if (validateInfos[name].validateStatus === "validating") {
        const res = results.filter((result) => result && result.errors.length);
        validateInfos[name].validateStatus = res.length ? "error" : "success";
        validateInfos[name].help = res.length ? res.map((r2) => r2.errors) : null;
        (_a2 = options === null || options === void 0 ? void 0 : options.onValidate) === null || _a2 === void 0 ? void 0 : _a2.call(options, name, !res.length, res.length ? toRaw(validateInfos[name].help[0]) : null);
      }
    });
    return promise;
  };
  const validate = (names2, option) => {
    let keys2 = [];
    let strict = true;
    if (!names2) {
      strict = false;
      keys2 = rulesKeys.value;
    } else if (Array.isArray(names2)) {
      keys2 = names2;
    } else {
      keys2 = [names2];
    }
    const promises = validateFields(keys2, option || {}, strict);
    promises.catch((e2) => e2);
    return promises;
  };
  const clearValidate = (names2) => {
    let keys2 = [];
    if (!names2) {
      keys2 = rulesKeys.value;
    } else if (Array.isArray(names2)) {
      keys2 = names2;
    } else {
      keys2 = [names2];
    }
    keys2.forEach((key2) => {
      validateInfos[key2] && _extends$1(validateInfos[key2], {
        validateStatus: "",
        help: null
      });
    });
  };
  const mergeValidateInfo = (items) => {
    const info = {
      autoLink: false
    };
    const help = [];
    const infos = Array.isArray(items) ? items : [items];
    for (let i2 = 0; i2 < infos.length; i2++) {
      const arg = infos[i2];
      if ((arg === null || arg === void 0 ? void 0 : arg.validateStatus) === "error") {
        info.validateStatus = "error";
        arg.help && help.push(arg.help);
      }
      info.required = info.required || (arg === null || arg === void 0 ? void 0 : arg.required);
    }
    info.help = help;
    return info;
  };
  let oldModel = initialModel;
  let isFirstTime = true;
  const modelFn = (model) => {
    const names2 = [];
    rulesKeys.value.forEach((key2) => {
      const prop = getPropByPath(model, key2, false);
      const oldProp = getPropByPath(oldModel, key2, false);
      const isFirstValidation = isFirstTime && (options === null || options === void 0 ? void 0 : options.immediate) && prop.isValid;
      if (isFirstValidation || !isEqual$2(prop.v, oldProp.v)) {
        names2.push(key2);
      }
    });
    validate(names2, {
      trigger: "change"
    });
    isFirstTime = false;
    oldModel = cloneDeep(toRaw(model));
  };
  const debounceOptions = options === null || options === void 0 ? void 0 : options.debounce;
  let first = true;
  watch(rulesRef, () => {
    rulesKeys.value = rulesRef ? Object.keys(unref(rulesRef)) : [];
    if (!first && options && options.validateOnRuleChange) {
      validate();
    }
    first = false;
  }, {
    deep: true,
    immediate: true
  });
  watch(rulesKeys, () => {
    const newValidateInfos = {};
    rulesKeys.value.forEach((key2) => {
      newValidateInfos[key2] = _extends$1({}, validateInfos[key2], {
        autoLink: false,
        required: isRequired(unref(rulesRef)[key2])
      });
      delete validateInfos[key2];
    });
    for (const key2 in validateInfos) {
      if (Object.prototype.hasOwnProperty.call(validateInfos, key2)) {
        delete validateInfos[key2];
      }
    }
    _extends$1(validateInfos, newValidateInfos);
  }, {
    immediate: true
  });
  watch(modelRef, debounceOptions && debounceOptions.wait ? debounce$1(modelFn, debounceOptions.wait, omit(debounceOptions, ["wait"])) : modelFn, {
    immediate: options && !!options.immediate,
    deep: true
  });
  return {
    modelRef,
    rulesRef,
    initialModel,
    validateInfos,
    resetFields,
    validate,
    validateField,
    mergeValidateInfo,
    clearValidate
  };
}
const formProps = () => ({
  layout: PropTypes.oneOf(tuple$1("horizontal", "inline", "vertical")),
  labelCol: objectType(),
  wrapperCol: objectType(),
  colon: booleanType(),
  labelAlign: stringType(),
  labelWrap: booleanType(),
  prefixCls: String,
  requiredMark: someType([String, Boolean]),
  /** @deprecated Will warning in future branch. Pls use `requiredMark` instead. */
  hideRequiredMark: booleanType(),
  model: PropTypes.object,
  rules: objectType(),
  validateMessages: objectType(),
  validateOnRuleChange: booleanType(),
  // 提交失败自动滚动到第一个错误字段
  scrollToFirstError: anyType(),
  onSubmit: functionType(),
  name: String,
  validateTrigger: someType([String, Array]),
  size: stringType(),
  disabled: booleanType(),
  onValuesChange: functionType(),
  onFieldsChange: functionType(),
  onFinish: functionType(),
  onFinishFailed: functionType(),
  onValidate: functionType()
});
function isEqualName(name1, name2) {
  return isEqual$2(toArray$4(name1), toArray$4(name2));
}
const Form = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AForm",
  inheritAttrs: false,
  props: initDefaultProps(formProps(), {
    layout: "horizontal",
    hideRequiredMark: false,
    colon: true
  }),
  Item: FormItem,
  useForm,
  // emits: ['finishFailed', 'submit', 'finish', 'validate'],
  setup(props2, _ref) {
    let {
      emit,
      slots,
      expose,
      attrs
    } = _ref;
    const {
      prefixCls,
      direction,
      form: contextForm,
      size,
      disabled
    } = useConfigInject("form", props2);
    const requiredMark = computed(() => props2.requiredMark === "" || props2.requiredMark);
    const mergedRequiredMark = computed(() => {
      var _a2;
      if (requiredMark.value !== void 0) {
        return requiredMark.value;
      }
      if (contextForm && ((_a2 = contextForm.value) === null || _a2 === void 0 ? void 0 : _a2.requiredMark) !== void 0) {
        return contextForm.value.requiredMark;
      }
      if (props2.hideRequiredMark) {
        return false;
      }
      return true;
    });
    useProviderSize(size);
    useProviderDisabled(disabled);
    const mergedColon = computed(() => {
      var _a2, _b;
      return (_a2 = props2.colon) !== null && _a2 !== void 0 ? _a2 : (_b = contextForm.value) === null || _b === void 0 ? void 0 : _b.colon;
    });
    const {
      validateMessages: globalValidateMessages
    } = useInjectGlobalForm();
    const validateMessages = computed(() => {
      return _extends$1(_extends$1(_extends$1({}, defaultValidateMessages), globalValidateMessages.value), props2.validateMessages);
    });
    const [wrapSSR, hashId] = useStyle$q(prefixCls);
    const formClassName = computed(() => classNames(prefixCls.value, {
      [`${prefixCls.value}-${props2.layout}`]: true,
      [`${prefixCls.value}-hide-required-mark`]: mergedRequiredMark.value === false,
      [`${prefixCls.value}-rtl`]: direction.value === "rtl",
      [`${prefixCls.value}-${size.value}`]: size.value
    }, hashId.value));
    const lastValidatePromise = ref();
    const fields = {};
    const addField = (eventKey, field) => {
      fields[eventKey] = field;
    };
    const removeField = (eventKey) => {
      delete fields[eventKey];
    };
    const getFieldsByNameList = (nameList) => {
      const provideNameList = !!nameList;
      const namePathList = provideNameList ? toArray$4(nameList).map(getNamePath) : [];
      if (!provideNameList) {
        return Object.values(fields);
      } else {
        return Object.values(fields).filter((field) => namePathList.findIndex((namePath) => isEqualName(namePath, field.fieldName.value)) > -1);
      }
    };
    const resetFields = (name) => {
      if (!props2.model) {
        return;
      }
      getFieldsByNameList(name).forEach((field) => {
        field.resetField();
      });
    };
    const clearValidate = (name) => {
      getFieldsByNameList(name).forEach((field) => {
        field.clearValidate();
      });
    };
    const handleFinishFailed = (errorInfo) => {
      const {
        scrollToFirstError
      } = props2;
      emit("finishFailed", errorInfo);
      if (scrollToFirstError && errorInfo.errorFields.length) {
        let scrollToFieldOptions = {};
        if (typeof scrollToFirstError === "object") {
          scrollToFieldOptions = scrollToFirstError;
        }
        scrollToField(errorInfo.errorFields[0].name, scrollToFieldOptions);
      }
    };
    const validate = function() {
      return validateField(...arguments);
    };
    const scrollToField = function(name) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const fields2 = getFieldsByNameList(name ? [name] : void 0);
      if (fields2.length) {
        const fieldId = fields2[0].fieldId.value;
        const node2 = fieldId ? document.getElementById(fieldId) : null;
        if (node2) {
          scrollIntoView(node2, _extends$1({
            scrollMode: "if-needed",
            block: "nearest"
          }, options));
        }
      }
    };
    const getFieldsValue = function() {
      let nameList = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      if (nameList === true) {
        const allNameList = [];
        Object.values(fields).forEach((_ref2) => {
          let {
            namePath
          } = _ref2;
          allNameList.push(namePath.value);
        });
        return cloneByNamePathList(props2.model, allNameList);
      } else {
        return cloneByNamePathList(props2.model, nameList);
      }
    };
    const validateFields = (nameList, options) => {
      if (!props2.model) {
        return Promise.reject("Form `model` is required for validateFields to work.");
      }
      const provideNameList = !!nameList;
      const namePathList = provideNameList ? toArray$4(nameList).map(getNamePath) : [];
      const promiseList = [];
      Object.values(fields).forEach((field) => {
        var _a2;
        if (!provideNameList) {
          namePathList.push(field.namePath.value);
        }
        if (!((_a2 = field.rules) === null || _a2 === void 0 ? void 0 : _a2.value.length)) {
          return;
        }
        const fieldNamePath = field.namePath.value;
        if (!provideNameList || containsNamePath(namePathList, fieldNamePath)) {
          const promise = field.validateRules(_extends$1({
            validateMessages: validateMessages.value
          }, options));
          promiseList.push(promise.then(() => ({
            name: fieldNamePath,
            errors: [],
            warnings: []
          })).catch((ruleErrors) => {
            const mergedErrors = [];
            const mergedWarnings = [];
            ruleErrors.forEach((_ref3) => {
              let {
                rule: {
                  warningOnly
                },
                errors
              } = _ref3;
              if (warningOnly) {
                mergedWarnings.push(...errors);
              } else {
                mergedErrors.push(...errors);
              }
            });
            if (mergedErrors.length) {
              return Promise.reject({
                name: fieldNamePath,
                errors: mergedErrors,
                warnings: mergedWarnings
              });
            }
            return {
              name: fieldNamePath,
              errors: mergedErrors,
              warnings: mergedWarnings
            };
          }));
        }
      });
      const summaryPromise = allPromiseFinish(promiseList);
      lastValidatePromise.value = summaryPromise;
      const returnPromise = summaryPromise.then(() => {
        if (lastValidatePromise.value === summaryPromise) {
          return Promise.resolve(getFieldsValue(namePathList));
        }
        return Promise.reject([]);
      }).catch((results) => {
        const errorList = results.filter((result) => result && result.errors.length);
        return Promise.reject({
          values: getFieldsValue(namePathList),
          errorFields: errorList,
          outOfDate: lastValidatePromise.value !== summaryPromise
        });
      });
      returnPromise.catch((e2) => e2);
      return returnPromise;
    };
    const validateField = function() {
      return validateFields(...arguments);
    };
    const handleSubmit = (e2) => {
      e2.preventDefault();
      e2.stopPropagation();
      emit("submit", e2);
      if (props2.model) {
        const res = validateFields();
        res.then((values) => {
          emit("finish", values);
        }).catch((errors) => {
          handleFinishFailed(errors);
        });
      }
    };
    expose({
      resetFields,
      clearValidate,
      validateFields,
      getFieldsValue,
      validate,
      scrollToField
    });
    useProvideForm({
      model: computed(() => props2.model),
      name: computed(() => props2.name),
      labelAlign: computed(() => props2.labelAlign),
      labelCol: computed(() => props2.labelCol),
      labelWrap: computed(() => props2.labelWrap),
      wrapperCol: computed(() => props2.wrapperCol),
      vertical: computed(() => props2.layout === "vertical"),
      colon: mergedColon,
      requiredMark: mergedRequiredMark,
      validateTrigger: computed(() => props2.validateTrigger),
      rules: computed(() => props2.rules),
      addField,
      removeField,
      onValidate: (name, status, errors) => {
        emit("validate", name, status, errors);
      },
      validateMessages
    });
    watch(() => props2.rules, () => {
      if (props2.validateOnRuleChange) {
        validateFields();
      }
    });
    return () => {
      var _a2;
      return wrapSSR(createVNode("form", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "onSubmit": handleSubmit,
        "class": [formClassName.value, attrs.class]
      }), [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]));
    };
  }
});
Form.useInjectFormItemContext = useInjectFormItemContext;
Form.ItemRest = FormItemRest;
Form.install = function(app) {
  app.component(Form.name, Form);
  app.component(Form.Item.name, Form.Item);
  app.component(FormItemRest.name, FormItemRest);
  return app;
};
const antCheckboxEffect = new Keyframe("antCheckboxEffect", {
  "0%": {
    transform: "scale(1)",
    opacity: 0.5
  },
  "100%": {
    transform: "scale(1.6)",
    opacity: 0
  }
});
const genCheckboxStyle = (token2) => {
  const {
    checkboxCls
  } = token2;
  const wrapperCls = `${checkboxCls}-wrapper`;
  return [
    // ===================== Basic =====================
    {
      // Group
      [`${checkboxCls}-group`]: _extends$1(_extends$1({}, resetComponent(token2)), {
        display: "inline-flex",
        flexWrap: "wrap",
        columnGap: token2.marginXS,
        // Group > Grid
        [`> ${token2.antCls}-row`]: {
          flex: 1
        }
      }),
      // Wrapper
      [wrapperCls]: _extends$1(_extends$1({}, resetComponent(token2)), {
        display: "inline-flex",
        alignItems: "baseline",
        cursor: "pointer",
        // Fix checkbox & radio in flex align #30260
        "&:after": {
          display: "inline-block",
          width: 0,
          overflow: "hidden",
          content: "'\\a0'"
        },
        // Checkbox near checkbox
        [`& + ${wrapperCls}`]: {
          marginInlineStart: 0
        },
        [`&${wrapperCls}-in-form-item`]: {
          'input[type="checkbox"]': {
            width: 14,
            height: 14
            // FIXME: magic
          }
        }
      }),
      // Wrapper > Checkbox
      [checkboxCls]: _extends$1(_extends$1({}, resetComponent(token2)), {
        position: "relative",
        whiteSpace: "nowrap",
        lineHeight: 1,
        cursor: "pointer",
        // To make alignment right when `controlHeight` is changed
        // Ref: https://github.com/ant-design/ant-design/issues/41564
        alignSelf: "center",
        // Wrapper > Checkbox > input
        [`${checkboxCls}-input`]: {
          position: "absolute",
          // Since baseline align will get additional space offset,
          // we need to move input to top to make it align with text.
          // Ref: https://github.com/ant-design/ant-design/issues/38926#issuecomment-1486137799
          inset: 0,
          zIndex: 1,
          cursor: "pointer",
          opacity: 0,
          margin: 0,
          [`&:focus-visible + ${checkboxCls}-inner`]: _extends$1({}, genFocusOutline(token2))
        },
        // Wrapper > Checkbox > inner
        [`${checkboxCls}-inner`]: {
          boxSizing: "border-box",
          position: "relative",
          top: 0,
          insetInlineStart: 0,
          display: "block",
          width: token2.checkboxSize,
          height: token2.checkboxSize,
          direction: "ltr",
          backgroundColor: token2.colorBgContainer,
          border: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`,
          borderRadius: token2.borderRadiusSM,
          borderCollapse: "separate",
          transition: `all ${token2.motionDurationSlow}`,
          "&:after": {
            boxSizing: "border-box",
            position: "absolute",
            top: "50%",
            insetInlineStart: "21.5%",
            display: "table",
            width: token2.checkboxSize / 14 * 5,
            height: token2.checkboxSize / 14 * 8,
            border: `${token2.lineWidthBold}px solid ${token2.colorWhite}`,
            borderTop: 0,
            borderInlineStart: 0,
            transform: "rotate(45deg) scale(0) translate(-50%,-50%)",
            opacity: 0,
            content: '""',
            transition: `all ${token2.motionDurationFast} ${token2.motionEaseInBack}, opacity ${token2.motionDurationFast}`
          }
        },
        // Wrapper > Checkbox + Text
        "& + span": {
          paddingInlineStart: token2.paddingXS,
          paddingInlineEnd: token2.paddingXS
        }
      })
    },
    // ================= Indeterminate =================
    {
      [checkboxCls]: {
        "&-indeterminate": {
          // Wrapper > Checkbox > inner
          [`${checkboxCls}-inner`]: {
            "&:after": {
              top: "50%",
              insetInlineStart: "50%",
              width: token2.fontSizeLG / 2,
              height: token2.fontSizeLG / 2,
              backgroundColor: token2.colorPrimary,
              border: 0,
              transform: "translate(-50%, -50%) scale(1)",
              opacity: 1,
              content: '""'
            }
          }
        }
      }
    },
    // ===================== Hover =====================
    {
      // Wrapper
      [`${wrapperCls}:hover ${checkboxCls}:after`]: {
        visibility: "visible"
      },
      // Wrapper & Wrapper > Checkbox
      [`
        ${wrapperCls}:not(${wrapperCls}-disabled),
        ${checkboxCls}:not(${checkboxCls}-disabled)
      `]: {
        [`&:hover ${checkboxCls}-inner`]: {
          borderColor: token2.colorPrimary
        }
      },
      [`${wrapperCls}:not(${wrapperCls}-disabled)`]: {
        [`&:hover ${checkboxCls}-checked:not(${checkboxCls}-disabled) ${checkboxCls}-inner`]: {
          backgroundColor: token2.colorPrimaryHover,
          borderColor: "transparent"
        },
        [`&:hover ${checkboxCls}-checked:not(${checkboxCls}-disabled):after`]: {
          borderColor: token2.colorPrimaryHover
        }
      }
    },
    // ==================== Checked ====================
    {
      // Wrapper > Checkbox
      [`${checkboxCls}-checked`]: {
        [`${checkboxCls}-inner`]: {
          backgroundColor: token2.colorPrimary,
          borderColor: token2.colorPrimary,
          "&:after": {
            opacity: 1,
            transform: "rotate(45deg) scale(1) translate(-50%,-50%)",
            transition: `all ${token2.motionDurationMid} ${token2.motionEaseOutBack} ${token2.motionDurationFast}`
          }
        },
        // Checked Effect
        "&:after": {
          position: "absolute",
          top: 0,
          insetInlineStart: 0,
          width: "100%",
          height: "100%",
          borderRadius: token2.borderRadiusSM,
          visibility: "hidden",
          border: `${token2.lineWidthBold}px solid ${token2.colorPrimary}`,
          animationName: antCheckboxEffect,
          animationDuration: token2.motionDurationSlow,
          animationTimingFunction: "ease-in-out",
          animationFillMode: "backwards",
          content: '""',
          transition: `all ${token2.motionDurationSlow}`
        }
      },
      [`
        ${wrapperCls}-checked:not(${wrapperCls}-disabled),
        ${checkboxCls}-checked:not(${checkboxCls}-disabled)
      `]: {
        [`&:hover ${checkboxCls}-inner`]: {
          backgroundColor: token2.colorPrimaryHover,
          borderColor: "transparent"
        },
        [`&:hover ${checkboxCls}:after`]: {
          borderColor: token2.colorPrimaryHover
        }
      }
    },
    // ==================== Disable ====================
    {
      // Wrapper
      [`${wrapperCls}-disabled`]: {
        cursor: "not-allowed"
      },
      // Wrapper > Checkbox
      [`${checkboxCls}-disabled`]: {
        // Wrapper > Checkbox > input
        [`&, ${checkboxCls}-input`]: {
          cursor: "not-allowed",
          // Disabled for native input to enable Tooltip event handler
          // ref: https://github.com/ant-design/ant-design/issues/39822#issuecomment-1365075901
          pointerEvents: "none"
        },
        // Wrapper > Checkbox > inner
        [`${checkboxCls}-inner`]: {
          background: token2.colorBgContainerDisabled,
          borderColor: token2.colorBorder,
          "&:after": {
            borderColor: token2.colorTextDisabled
          }
        },
        "&:after": {
          display: "none"
        },
        "& + span": {
          color: token2.colorTextDisabled
        },
        [`&${checkboxCls}-indeterminate ${checkboxCls}-inner::after`]: {
          background: token2.colorTextDisabled
        }
      }
    }
  ];
};
function getStyle$2(prefixCls, token2) {
  const checkboxToken = merge(token2, {
    checkboxCls: `.${prefixCls}`,
    checkboxSize: token2.controlInteractiveSize
  });
  return [genCheckboxStyle(checkboxToken)];
}
const useStyle$p = genComponentStyleHook("Checkbox", (token2, _ref) => {
  let {
    prefixCls
  } = _ref;
  return [getStyle$2(prefixCls, token2)];
});
const genBaseStyle$9 = (token2) => {
  const {
    prefixCls,
    componentCls,
    antCls
  } = token2;
  const cascaderMenuItemCls = `${componentCls}-menu-item`;
  const iconCls = `
    &${cascaderMenuItemCls}-expand ${cascaderMenuItemCls}-expand-icon,
    ${cascaderMenuItemCls}-loading-icon
  `;
  const itemPaddingVertical = Math.round((token2.controlHeight - token2.fontSize * token2.lineHeight) / 2);
  return [
    // =====================================================
    // ==                     Control                     ==
    // =====================================================
    {
      [componentCls]: {
        width: token2.controlWidth
      }
    },
    // =====================================================
    // ==                      Popup                      ==
    // =====================================================
    {
      [`${componentCls}-dropdown`]: [
        // ==================== Checkbox ====================
        getStyle$2(`${prefixCls}-checkbox`, token2),
        {
          [`&${antCls}-select-dropdown`]: {
            padding: 0
          }
        },
        {
          [componentCls]: {
            // ================== Checkbox ==================
            "&-checkbox": {
              top: 0,
              marginInlineEnd: token2.paddingXS
            },
            // ==================== Menu ====================
            // >>> Menus
            "&-menus": {
              display: "flex",
              flexWrap: "nowrap",
              alignItems: "flex-start",
              [`&${componentCls}-menu-empty`]: {
                [`${componentCls}-menu`]: {
                  width: "100%",
                  height: "auto",
                  [cascaderMenuItemCls]: {
                    color: token2.colorTextDisabled
                  }
                }
              }
            },
            // >>> Menu
            "&-menu": {
              flexGrow: 1,
              minWidth: token2.controlItemWidth,
              height: token2.dropdownHeight,
              margin: 0,
              padding: token2.paddingXXS,
              overflow: "auto",
              verticalAlign: "top",
              listStyle: "none",
              "-ms-overflow-style": "-ms-autohiding-scrollbar",
              "&:not(:last-child)": {
                borderInlineEnd: `${token2.lineWidth}px ${token2.lineType} ${token2.colorSplit}`
              },
              "&-item": _extends$1(_extends$1({}, textEllipsis), {
                display: "flex",
                flexWrap: "nowrap",
                alignItems: "center",
                padding: `${itemPaddingVertical}px ${token2.paddingSM}px`,
                lineHeight: token2.lineHeight,
                cursor: "pointer",
                transition: `all ${token2.motionDurationMid}`,
                borderRadius: token2.borderRadiusSM,
                "&:hover": {
                  background: token2.controlItemBgHover
                },
                "&-disabled": {
                  color: token2.colorTextDisabled,
                  cursor: "not-allowed",
                  "&:hover": {
                    background: "transparent"
                  },
                  [iconCls]: {
                    color: token2.colorTextDisabled
                  }
                },
                [`&-active:not(${cascaderMenuItemCls}-disabled)`]: {
                  [`&, &:hover`]: {
                    fontWeight: token2.fontWeightStrong,
                    backgroundColor: token2.controlItemBgActive
                  }
                },
                "&-content": {
                  flex: "auto"
                },
                [iconCls]: {
                  marginInlineStart: token2.paddingXXS,
                  color: token2.colorTextDescription,
                  fontSize: token2.fontSizeIcon
                },
                "&-keyword": {
                  color: token2.colorHighlight
                }
              })
            }
          }
        }
      ]
    },
    // =====================================================
    // ==                       RTL                       ==
    // =====================================================
    {
      [`${componentCls}-dropdown-rtl`]: {
        direction: "rtl"
      }
    },
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    genCompactItemStyle(token2)
  ];
};
const useStyle$o = genComponentStyleHook("Cascader", (token2) => [genBaseStyle$9(token2)], {
  controlWidth: 184,
  controlItemWidth: 111,
  dropdownHeight: 180
});
var __rest$L = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
function highlightKeyword(str, lowerKeyword, prefixCls) {
  const cells = str.toLowerCase().split(lowerKeyword).reduce((list, cur, index2) => index2 === 0 ? [cur] : [...list, lowerKeyword, cur], []);
  const fillCells = [];
  let start = 0;
  cells.forEach((cell, index2) => {
    const end = start + cell.length;
    let originWorld = str.slice(start, end);
    start = end;
    if (index2 % 2 === 1) {
      originWorld = createVNode("span", {
        "class": `${prefixCls}-menu-item-keyword`,
        "key": "seperator"
      }, [originWorld]);
    }
    fillCells.push(originWorld);
  });
  return fillCells;
}
const defaultSearchRender = (_ref) => {
  let {
    inputValue,
    path: path2,
    prefixCls,
    fieldNames
  } = _ref;
  const optionList = [];
  const lower = inputValue.toLowerCase();
  path2.forEach((node2, index2) => {
    if (index2 !== 0) {
      optionList.push(" / ");
    }
    let label = node2[fieldNames.label];
    const type4 = typeof label;
    if (type4 === "string" || type4 === "number") {
      label = highlightKeyword(String(label), lower, prefixCls);
    }
    optionList.push(label);
  });
  return optionList;
};
function cascaderProps() {
  return _extends$1(_extends$1({}, omit$1(internalCascaderProps(), ["customSlots", "checkable", "options"])), {
    multiple: {
      type: Boolean,
      default: void 0
    },
    size: String,
    bordered: {
      type: Boolean,
      default: void 0
    },
    placement: {
      type: String
    },
    suffixIcon: PropTypes.any,
    status: String,
    options: Array,
    popupClassName: String,
    /** @deprecated Please use `popupClassName` instead */
    dropdownClassName: String,
    "onUpdate:value": Function
  });
}
const Cascader = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ACascader",
  inheritAttrs: false,
  props: initDefaultProps(cascaderProps(), {
    bordered: true,
    choiceTransitionName: "",
    allowClear: true
  }),
  setup(props2, _ref2) {
    let {
      attrs,
      expose,
      slots,
      emit
    } = _ref2;
    const formItemContext = useInjectFormItemContext();
    const formItemInputContext = FormItemInputContext.useInject();
    const mergedStatus = computed(() => getMergedStatus(formItemInputContext.status, props2.status));
    const {
      prefixCls: cascaderPrefixCls,
      rootPrefixCls,
      getPrefixCls,
      direction,
      getPopupContainer,
      renderEmpty: renderEmpty2,
      size: contextSize,
      disabled
    } = useConfigInject("cascader", props2);
    const prefixCls = computed(() => getPrefixCls("select", props2.prefixCls));
    const {
      compactSize,
      compactItemClassnames
    } = useCompactItemContext(prefixCls, direction);
    const mergedSize = computed(() => compactSize.value || contextSize.value);
    const contextDisabled = useInjectDisabled();
    const mergedDisabled = computed(() => {
      var _a2;
      return (_a2 = disabled.value) !== null && _a2 !== void 0 ? _a2 : contextDisabled.value;
    });
    const [wrapSelectSSR, hashId] = useSelectStyle(prefixCls);
    const [wrapCascaderSSR] = useStyle$o(cascaderPrefixCls);
    const isRtl = computed(() => direction.value === "rtl");
    const mergedShowSearch = computed(() => {
      if (!props2.showSearch) {
        return props2.showSearch;
      }
      let searchConfig = {
        render: defaultSearchRender
      };
      if (typeof props2.showSearch === "object") {
        searchConfig = _extends$1(_extends$1({}, searchConfig), props2.showSearch);
      }
      return searchConfig;
    });
    const mergedDropdownClassName = computed(() => classNames(props2.popupClassName || props2.dropdownClassName, `${cascaderPrefixCls.value}-dropdown`, {
      [`${cascaderPrefixCls.value}-dropdown-rtl`]: isRtl.value
    }, hashId.value));
    const selectRef = ref();
    expose({
      focus() {
        var _a2;
        (_a2 = selectRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
      },
      blur() {
        var _a2;
        (_a2 = selectRef.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
      }
    });
    const handleChange = function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      emit("update:value", args[0]);
      emit("change", ...args);
      formItemContext.onFieldChange();
    };
    const handleBlur = function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      emit("blur", ...args);
      formItemContext.onFieldBlur();
    };
    const mergedShowArrow = computed(() => props2.showArrow !== void 0 ? props2.showArrow : props2.loading || !props2.multiple);
    const placement = computed(() => {
      if (props2.placement !== void 0) {
        return props2.placement;
      }
      return direction.value === "rtl" ? "bottomRight" : "bottomLeft";
    });
    return () => {
      var _a2, _b;
      const {
        notFoundContent = (_a2 = slots.notFoundContent) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
        expandIcon = (_b = slots.expandIcon) === null || _b === void 0 ? void 0 : _b.call(slots),
        multiple,
        bordered,
        allowClear,
        choiceTransitionName,
        transitionName: transitionName2,
        id = formItemContext.id.value
      } = props2, restProps = __rest$L(props2, ["notFoundContent", "expandIcon", "multiple", "bordered", "allowClear", "choiceTransitionName", "transitionName", "id"]);
      const mergedNotFoundContent = notFoundContent || renderEmpty2("Cascader");
      let mergedExpandIcon = expandIcon;
      if (!expandIcon) {
        mergedExpandIcon = isRtl.value ? createVNode(LeftOutlined, null, null) : createVNode(RightOutlined, null, null);
      }
      const loadingIcon = createVNode("span", {
        "class": `${prefixCls.value}-menu-item-loading-icon`
      }, [createVNode(LoadingOutlined, {
        "spin": true
      }, null)]);
      const {
        suffixIcon,
        removeIcon,
        clearIcon
      } = getIcons(_extends$1(_extends$1({}, props2), {
        hasFeedback: formItemInputContext.hasFeedback,
        feedbackIcon: formItemInputContext.feedbackIcon,
        multiple,
        prefixCls: prefixCls.value,
        showArrow: mergedShowArrow.value
      }), slots);
      return wrapCascaderSSR(wrapSelectSSR(createVNode(Cascader$2, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, restProps), attrs), {}, {
        "id": id,
        "prefixCls": prefixCls.value,
        "class": [cascaderPrefixCls.value, {
          [`${prefixCls.value}-lg`]: mergedSize.value === "large",
          [`${prefixCls.value}-sm`]: mergedSize.value === "small",
          [`${prefixCls.value}-rtl`]: isRtl.value,
          [`${prefixCls.value}-borderless`]: !bordered,
          [`${prefixCls.value}-in-form-item`]: formItemInputContext.isFormItemInput
        }, getStatusClassNames(prefixCls.value, mergedStatus.value, formItemInputContext.hasFeedback), compactItemClassnames.value, attrs.class, hashId.value],
        "disabled": mergedDisabled.value,
        "direction": direction.value,
        "placement": placement.value,
        "notFoundContent": mergedNotFoundContent,
        "allowClear": allowClear,
        "showSearch": mergedShowSearch.value,
        "expandIcon": mergedExpandIcon,
        "inputIcon": suffixIcon,
        "removeIcon": removeIcon,
        "clearIcon": clearIcon,
        "loadingIcon": loadingIcon,
        "checkable": !!multiple,
        "dropdownClassName": mergedDropdownClassName.value,
        "dropdownPrefixCls": cascaderPrefixCls.value,
        "choiceTransitionName": getTransitionName(rootPrefixCls.value, "", choiceTransitionName),
        "transitionName": getTransitionName(rootPrefixCls.value, getTransitionDirection(placement.value), transitionName2),
        "getPopupContainer": getPopupContainer === null || getPopupContainer === void 0 ? void 0 : getPopupContainer.value,
        "customSlots": _extends$1(_extends$1({}, slots), {
          checkable: () => createVNode("span", {
            "class": `${cascaderPrefixCls.value}-checkbox-inner`
          }, null)
        }),
        "tagRender": props2.tagRender || slots.tagRender,
        "displayRender": props2.displayRender || slots.displayRender,
        "maxTagPlaceholder": props2.maxTagPlaceholder || slots.maxTagPlaceholder,
        "showArrow": formItemInputContext.hasFeedback || props2.showArrow,
        "onChange": handleChange,
        "onBlur": handleBlur,
        "ref": selectRef
      }), slots)));
    };
  }
});
const Cascader$1 = withInstall(_extends$1(Cascader, {
  SHOW_CHILD,
  SHOW_PARENT
}));
const abstractCheckboxGroupProps = () => {
  return {
    name: String,
    prefixCls: String,
    options: arrayType([]),
    disabled: Boolean,
    id: String
  };
};
const checkboxGroupProps = () => {
  return _extends$1(_extends$1({}, abstractCheckboxGroupProps()), {
    defaultValue: arrayType(),
    value: arrayType(),
    onChange: functionType(),
    "onUpdate:value": functionType()
  });
};
const abstractCheckboxProps = () => {
  return {
    prefixCls: String,
    defaultChecked: booleanType(),
    checked: booleanType(),
    disabled: booleanType(),
    isGroup: booleanType(),
    value: PropTypes.any,
    name: String,
    id: String,
    indeterminate: booleanType(),
    type: stringType("checkbox"),
    autofocus: booleanType(),
    onChange: functionType(),
    "onUpdate:checked": functionType(),
    onClick: functionType(),
    skipGroup: booleanType(false)
  };
};
const checkboxProps = () => {
  return _extends$1(_extends$1({}, abstractCheckboxProps()), {
    indeterminate: booleanType(false)
  });
};
const CheckboxGroupContextKey = Symbol("CheckboxGroupContext");
var __rest$K = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const Checkbox = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ACheckbox",
  inheritAttrs: false,
  __ANT_CHECKBOX: true,
  props: checkboxProps(),
  // emits: ['change', 'update:checked'],
  setup(props2, _ref) {
    let {
      emit,
      attrs,
      slots,
      expose
    } = _ref;
    const formItemContext = useInjectFormItemContext();
    const formItemInputContext = FormItemInputContext.useInject();
    const {
      prefixCls,
      direction,
      disabled
    } = useConfigInject("checkbox", props2);
    const contextDisabled = useInjectDisabled();
    const [wrapSSR, hashId] = useStyle$p(prefixCls);
    const checkboxGroup = inject(CheckboxGroupContextKey, void 0);
    const uniId = Symbol("checkboxUniId");
    const mergedDisabled = computed(() => {
      return (checkboxGroup === null || checkboxGroup === void 0 ? void 0 : checkboxGroup.disabled.value) || disabled.value;
    });
    watchEffect(() => {
      if (!props2.skipGroup && checkboxGroup) {
        checkboxGroup.registerValue(uniId, props2.value);
      }
    });
    onBeforeUnmount(() => {
      if (checkboxGroup) {
        checkboxGroup.cancelValue(uniId);
      }
    });
    onMounted(() => {
      warning$1(!!(props2.checked !== void 0 || checkboxGroup || props2.value === void 0));
    });
    const handleChange = (event) => {
      const targetChecked = event.target.checked;
      emit("update:checked", targetChecked);
      emit("change", event);
      formItemContext.onFieldChange();
    };
    const checkboxRef = ref();
    const focus = () => {
      var _a2;
      (_a2 = checkboxRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
    };
    const blur = () => {
      var _a2;
      (_a2 = checkboxRef.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
    };
    expose({
      focus,
      blur
    });
    return () => {
      var _a2;
      const children = flattenChildren((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots));
      const {
        indeterminate,
        skipGroup,
        id = formItemContext.id.value
      } = props2, restProps = __rest$K(props2, ["indeterminate", "skipGroup", "id"]);
      const {
        onMouseenter,
        onMouseleave,
        onInput,
        class: className,
        style
      } = attrs, restAttrs = __rest$K(attrs, ["onMouseenter", "onMouseleave", "onInput", "class", "style"]);
      const checkboxProps2 = _extends$1(_extends$1(_extends$1(_extends$1({}, restProps), {
        id,
        prefixCls: prefixCls.value
      }), restAttrs), {
        disabled: mergedDisabled.value
      });
      if (checkboxGroup && !skipGroup) {
        checkboxProps2.onChange = function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          emit("change", ...args);
          checkboxGroup.toggleOption({
            label: children,
            value: props2.value
          });
        };
        checkboxProps2.name = checkboxGroup.name.value;
        checkboxProps2.checked = checkboxGroup.mergedValue.value.includes(props2.value);
        checkboxProps2.disabled = mergedDisabled.value || contextDisabled.value;
        checkboxProps2.indeterminate = indeterminate;
      } else {
        checkboxProps2.onChange = handleChange;
      }
      const classString = classNames({
        [`${prefixCls.value}-wrapper`]: true,
        [`${prefixCls.value}-rtl`]: direction.value === "rtl",
        [`${prefixCls.value}-wrapper-checked`]: checkboxProps2.checked,
        [`${prefixCls.value}-wrapper-disabled`]: checkboxProps2.disabled,
        [`${prefixCls.value}-wrapper-in-form-item`]: formItemInputContext.isFormItemInput
      }, className, hashId.value);
      const checkboxClass = classNames({
        [`${prefixCls.value}-indeterminate`]: indeterminate
      }, hashId.value);
      const ariaChecked = indeterminate ? "mixed" : void 0;
      return wrapSSR(createVNode("label", {
        "class": classString,
        "style": style,
        "onMouseenter": onMouseenter,
        "onMouseleave": onMouseleave
      }, [createVNode(VcCheckbox, _objectSpread2$1(_objectSpread2$1({
        "aria-checked": ariaChecked
      }, checkboxProps2), {}, {
        "class": checkboxClass,
        "ref": checkboxRef
      }), null), children.length ? createVNode("span", null, [children]) : null]));
    };
  }
});
const CheckboxGroup = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ACheckboxGroup",
  inheritAttrs: false,
  props: checkboxGroupProps(),
  // emits: ['change', 'update:value'],
  setup(props2, _ref) {
    let {
      slots,
      attrs,
      emit,
      expose
    } = _ref;
    const formItemContext = useInjectFormItemContext();
    const {
      prefixCls,
      direction
    } = useConfigInject("checkbox", props2);
    const groupPrefixCls = computed(() => `${prefixCls.value}-group`);
    const [wrapSSR, hashId] = useStyle$p(groupPrefixCls);
    const mergedValue = ref((props2.value === void 0 ? props2.defaultValue : props2.value) || []);
    watch(() => props2.value, () => {
      mergedValue.value = props2.value || [];
    });
    const options = computed(() => {
      return props2.options.map((option) => {
        if (typeof option === "string" || typeof option === "number") {
          return {
            label: option,
            value: option
          };
        }
        return option;
      });
    });
    const triggerUpdate = ref(Symbol());
    const registeredValuesMap = ref(/* @__PURE__ */ new Map());
    const cancelValue = (id) => {
      registeredValuesMap.value.delete(id);
      triggerUpdate.value = Symbol();
    };
    const registerValue = (id, value) => {
      registeredValuesMap.value.set(id, value);
      triggerUpdate.value = Symbol();
    };
    const registeredValues = ref(/* @__PURE__ */ new Map());
    watch(triggerUpdate, () => {
      const valuseMap = /* @__PURE__ */ new Map();
      for (const value of registeredValuesMap.value.values()) {
        valuseMap.set(value, true);
      }
      registeredValues.value = valuseMap;
    });
    const toggleOption = (option) => {
      const optionIndex = mergedValue.value.indexOf(option.value);
      const value = [...mergedValue.value];
      if (optionIndex === -1) {
        value.push(option.value);
      } else {
        value.splice(optionIndex, 1);
      }
      if (props2.value === void 0) {
        mergedValue.value = value;
      }
      const val = value.filter((val2) => registeredValues.value.has(val2)).sort((a2, b2) => {
        const indexA = options.value.findIndex((opt) => opt.value === a2);
        const indexB = options.value.findIndex((opt) => opt.value === b2);
        return indexA - indexB;
      });
      emit("update:value", val);
      emit("change", val);
      formItemContext.onFieldChange();
    };
    provide(CheckboxGroupContextKey, {
      cancelValue,
      registerValue,
      toggleOption,
      mergedValue,
      name: computed(() => props2.name),
      disabled: computed(() => props2.disabled)
    });
    expose({
      mergedValue
    });
    return () => {
      var _a2;
      const {
        id = formItemContext.id.value
      } = props2;
      let children = null;
      if (options.value && options.value.length > 0) {
        children = options.value.map((option) => {
          var _a3;
          return createVNode(Checkbox, {
            "prefixCls": prefixCls.value,
            "key": option.value.toString(),
            "disabled": "disabled" in option ? option.disabled : props2.disabled,
            "indeterminate": option.indeterminate,
            "value": option.value,
            "checked": mergedValue.value.indexOf(option.value) !== -1,
            "onChange": option.onChange,
            "class": `${groupPrefixCls.value}-item`
          }, {
            default: () => [slots.label !== void 0 ? (_a3 = slots.label) === null || _a3 === void 0 ? void 0 : _a3.call(slots, option) : option.label]
          });
        });
      }
      return wrapSSR(createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "class": [groupPrefixCls.value, {
          [`${groupPrefixCls.value}-rtl`]: direction.value === "rtl"
        }, attrs.class, hashId.value],
        "id": id
      }), [children || ((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots))]));
    };
  }
});
Checkbox.Group = CheckboxGroup;
Checkbox.install = function(app) {
  app.component(Checkbox.name, Checkbox);
  app.component(CheckboxGroup.name, CheckboxGroup);
  return app;
};
const Col = withInstall(Col$1);
let runtimeLocale = _extends$1({}, localeValues.Modal);
function changeConfirmLocale(newLocale) {
  if (newLocale) {
    runtimeLocale = _extends$1(_extends$1({}, runtimeLocale), newLocale);
  } else {
    runtimeLocale = _extends$1({}, localeValues.Modal);
  }
}
function getConfirmLocale() {
  return runtimeLocale;
}
const ANT_MARK = "internalMark";
const LocaleProvider = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ALocaleProvider",
  props: {
    locale: {
      type: Object
    },
    ANT_MARK__: String
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    warning$1(props2.ANT_MARK__ === ANT_MARK);
    const state = reactive({
      antLocale: _extends$1(_extends$1({}, props2.locale), {
        exist: true
      }),
      ANT_MARK__: ANT_MARK
    });
    provide("localeData", state);
    watch(() => props2.locale, (locale2) => {
      changeConfirmLocale(locale2 && locale2.Modal);
      state.antLocale = _extends$1(_extends$1({}, locale2), {
        exist: true
      });
    }, {
      immediate: true
    });
    return () => {
      var _a2;
      return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
    };
  }
});
LocaleProvider.install = function(app) {
  app.component(LocaleProvider.name, LocaleProvider);
  return app;
};
const locale = withInstall(LocaleProvider);
const Notice = defineComponent({
  name: "Notice",
  inheritAttrs: false,
  props: ["prefixCls", "duration", "updateMark", "noticeKey", "closeIcon", "closable", "props", "onClick", "onClose", "holder", "visible"],
  setup(props2, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    let closeTimer;
    let isUnMounted = false;
    const duration = computed(() => props2.duration === void 0 ? 4.5 : props2.duration);
    const startCloseTimer = () => {
      if (duration.value && !isUnMounted) {
        closeTimer = setTimeout(() => {
          close();
        }, duration.value * 1e3);
      }
    };
    const clearCloseTimer = () => {
      if (closeTimer) {
        clearTimeout(closeTimer);
        closeTimer = null;
      }
    };
    const close = (e2) => {
      if (e2) {
        e2.stopPropagation();
      }
      clearCloseTimer();
      const {
        onClose,
        noticeKey
      } = props2;
      if (onClose) {
        onClose(noticeKey);
      }
    };
    const restartCloseTimer = () => {
      clearCloseTimer();
      startCloseTimer();
    };
    onMounted(() => {
      startCloseTimer();
    });
    onUnmounted(() => {
      isUnMounted = true;
      clearCloseTimer();
    });
    watch([duration, () => props2.updateMark, () => props2.visible], (_ref2, _ref3) => {
      let [preDuration, preUpdateMark, preVisible] = _ref2;
      let [newDuration, newUpdateMark, newVisible] = _ref3;
      if (preDuration !== newDuration || preUpdateMark !== newUpdateMark || preVisible !== newVisible && newVisible) {
        restartCloseTimer();
      }
    }, {
      flush: "post"
    });
    return () => {
      var _a2, _b;
      const {
        prefixCls,
        closable,
        closeIcon = (_a2 = slots.closeIcon) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
        onClick,
        holder
      } = props2;
      const {
        class: className,
        style
      } = attrs;
      const componentClass = `${prefixCls}-notice`;
      const dataOrAriaAttributeProps = Object.keys(attrs).reduce((acc, key2) => {
        if (key2.startsWith("data-") || key2.startsWith("aria-") || key2 === "role") {
          acc[key2] = attrs[key2];
        }
        return acc;
      }, {});
      const node2 = createVNode("div", _objectSpread2$1({
        "class": classNames(componentClass, className, {
          [`${componentClass}-closable`]: closable
        }),
        "style": style,
        "onMouseenter": clearCloseTimer,
        "onMouseleave": startCloseTimer,
        "onClick": onClick
      }, dataOrAriaAttributeProps), [createVNode("div", {
        "class": `${componentClass}-content`
      }, [(_b = slots.default) === null || _b === void 0 ? void 0 : _b.call(slots)]), closable ? createVNode("a", {
        "tabindex": 0,
        "onClick": close,
        "class": `${componentClass}-close`
      }, [closeIcon || createVNode("span", {
        "class": `${componentClass}-close-x`
      }, null)]) : null]);
      if (holder) {
        return createVNode(Teleport, {
          "to": holder
        }, {
          default: () => node2
        });
      }
      return node2;
    };
  }
});
var __rest$J = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
let seed$1 = 0;
const now$2 = Date.now();
function getUuid$1() {
  const id = seed$1;
  seed$1 += 1;
  return `rcNotification_${now$2}_${id}`;
}
const Notification$1 = defineComponent({
  name: "Notification",
  inheritAttrs: false,
  props: ["prefixCls", "transitionName", "animation", "maxCount", "closeIcon", "hashId"],
  setup(props2, _ref) {
    let {
      attrs,
      expose,
      slots
    } = _ref;
    const hookRefs = /* @__PURE__ */ new Map();
    const notices = ref([]);
    const transitionProps = computed(() => {
      const {
        prefixCls,
        animation = "fade"
      } = props2;
      let name = props2.transitionName;
      if (!name && animation) {
        name = `${prefixCls}-${animation}`;
      }
      return getTransitionGroupProps(name);
    });
    const add = (originNotice, holderCallback) => {
      const key2 = originNotice.key || getUuid$1();
      const notice2 = _extends$1(_extends$1({}, originNotice), {
        key: key2
      });
      const {
        maxCount: maxCount2
      } = props2;
      const noticeIndex = notices.value.map((v2) => v2.notice.key).indexOf(key2);
      const updatedNotices = notices.value.concat();
      if (noticeIndex !== -1) {
        updatedNotices.splice(noticeIndex, 1, {
          notice: notice2,
          holderCallback
        });
      } else {
        if (maxCount2 && notices.value.length >= maxCount2) {
          notice2.key = updatedNotices[0].notice.key;
          notice2.updateMark = getUuid$1();
          notice2.userPassKey = key2;
          updatedNotices.shift();
        }
        updatedNotices.push({
          notice: notice2,
          holderCallback
        });
      }
      notices.value = updatedNotices;
    };
    const remove = (removeKey) => {
      notices.value = toRaw(notices.value).filter((_ref2) => {
        let {
          notice: {
            key: key2,
            userPassKey
          }
        } = _ref2;
        const mergedKey = userPassKey || key2;
        return mergedKey !== removeKey;
      });
    };
    expose({
      add,
      remove,
      notices
    });
    return () => {
      var _a2;
      const {
        prefixCls,
        closeIcon = (_a2 = slots.closeIcon) === null || _a2 === void 0 ? void 0 : _a2.call(slots, {
          prefixCls
        })
      } = props2;
      const noticeNodes = notices.value.map((_ref3, index2) => {
        let {
          notice: notice2,
          holderCallback
        } = _ref3;
        const updateMark = index2 === notices.value.length - 1 ? notice2.updateMark : void 0;
        const {
          key: key2,
          userPassKey
        } = notice2;
        const {
          content
        } = notice2;
        const noticeProps = _extends$1(_extends$1(_extends$1({
          prefixCls,
          closeIcon: typeof closeIcon === "function" ? closeIcon({
            prefixCls
          }) : closeIcon
        }, notice2), notice2.props), {
          key: key2,
          noticeKey: userPassKey || key2,
          updateMark,
          onClose: (noticeKey) => {
            var _a3;
            remove(noticeKey);
            (_a3 = notice2.onClose) === null || _a3 === void 0 ? void 0 : _a3.call(notice2);
          },
          onClick: notice2.onClick
        });
        if (holderCallback) {
          return createVNode("div", {
            "key": key2,
            "class": `${prefixCls}-hook-holder`,
            "ref": (div) => {
              if (typeof key2 === "undefined") {
                return;
              }
              if (div) {
                hookRefs.set(key2, div);
                holderCallback(div, noticeProps);
              } else {
                hookRefs.delete(key2);
              }
            }
          }, null);
        }
        return createVNode(Notice, _objectSpread2$1(_objectSpread2$1({}, noticeProps), {}, {
          "class": classNames(noticeProps.class, props2.hashId)
        }), {
          default: () => [typeof content === "function" ? content({
            prefixCls
          }) : content]
        });
      });
      const className = {
        [prefixCls]: 1,
        [attrs.class]: !!attrs.class,
        [props2.hashId]: true
      };
      return createVNode("div", {
        "class": className,
        "style": attrs.style || {
          top: "65px",
          left: "50%"
        }
      }, [createVNode(TransitionGroup, _objectSpread2$1({
        "tag": "div"
      }, transitionProps.value), {
        default: () => [noticeNodes]
      })]);
    };
  }
});
Notification$1.newInstance = function newNotificationInstance(properties, callback) {
  const _a2 = properties || {}, {
    name = "notification",
    getContainer: getContainer2,
    appContext,
    prefixCls: customizePrefixCls,
    rootPrefixCls: customRootPrefixCls,
    transitionName: customTransitionName,
    hasTransitionName: hasTransitionName2,
    useStyle: useStyle2
  } = _a2, props2 = __rest$J(_a2, ["name", "getContainer", "appContext", "prefixCls", "rootPrefixCls", "transitionName", "hasTransitionName", "useStyle"]);
  const div = document.createElement("div");
  if (getContainer2) {
    const root2 = getContainer2();
    root2.appendChild(div);
  } else {
    document.body.appendChild(div);
  }
  const Wrapper = defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "NotificationWrapper",
    setup(_props, _ref4) {
      let {
        attrs
      } = _ref4;
      const notiRef = shallowRef();
      const prefixCls = computed(() => globalConfigForApi.getPrefixCls(name, customizePrefixCls));
      const [, hashId] = useStyle2(prefixCls);
      onMounted(() => {
        callback({
          notice(noticeProps) {
            var _a3;
            (_a3 = notiRef.value) === null || _a3 === void 0 ? void 0 : _a3.add(noticeProps);
          },
          removeNotice(key2) {
            var _a3;
            (_a3 = notiRef.value) === null || _a3 === void 0 ? void 0 : _a3.remove(key2);
          },
          destroy() {
            render(null, div);
            if (div.parentNode) {
              div.parentNode.removeChild(div);
            }
          },
          component: notiRef
        });
      });
      return () => {
        const global2 = globalConfigForApi;
        const rootPrefixCls = global2.getRootPrefixCls(customRootPrefixCls, prefixCls.value);
        const transitionName2 = hasTransitionName2 ? customTransitionName : `${prefixCls.value}-${customTransitionName}`;
        return createVNode(ConfigProvider, _objectSpread2$1(_objectSpread2$1({}, global2), {}, {
          "prefixCls": rootPrefixCls
        }), {
          default: () => [createVNode(Notification$1, _objectSpread2$1(_objectSpread2$1({
            "ref": notiRef
          }, attrs), {}, {
            "prefixCls": prefixCls.value,
            "transitionName": transitionName2,
            "hashId": hashId.value
          }), null)]
        });
      };
    }
  });
  const vm = createVNode(Wrapper, props2);
  vm.appContext = appContext || vm.appContext;
  render(vm, div);
};
let seed = 0;
const now$1 = Date.now();
function getUuid() {
  const id = seed;
  seed += 1;
  return `rcNotification_${now$1}_${id}`;
}
const Notification = defineComponent({
  name: "HookNotification",
  inheritAttrs: false,
  props: ["prefixCls", "transitionName", "animation", "maxCount", "closeIcon", "hashId", "remove", "notices", "getStyles", "getClassName", "onAllRemoved", "getContainer"],
  setup(props2, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const hookRefs = /* @__PURE__ */ new Map();
    const notices = computed(() => props2.notices);
    const transitionProps = computed(() => {
      let name = props2.transitionName;
      if (!name && props2.animation) {
        switch (typeof props2.animation) {
          case "string":
            name = props2.animation;
            break;
          case "function":
            name = props2.animation().name;
            break;
          case "object":
            name = props2.animation.name;
            break;
          default:
            name = `${props2.prefixCls}-fade`;
            break;
        }
      }
      return getTransitionGroupProps(name);
    });
    const remove = (key2) => props2.remove(key2);
    const placements2 = ref({});
    watch(notices, () => {
      const nextPlacements = {};
      Object.keys(placements2.value).forEach((placement) => {
        nextPlacements[placement] = [];
      });
      props2.notices.forEach((config) => {
        const {
          placement = "topRight"
        } = config.notice;
        if (placement) {
          nextPlacements[placement] = nextPlacements[placement] || [];
          nextPlacements[placement].push(config);
        }
      });
      placements2.value = nextPlacements;
    });
    const placementList = computed(() => Object.keys(placements2.value));
    return () => {
      var _a2;
      const {
        prefixCls,
        closeIcon = (_a2 = slots.closeIcon) === null || _a2 === void 0 ? void 0 : _a2.call(slots, {
          prefixCls
        })
      } = props2;
      const noticeNodes = placementList.value.map((placement) => {
        var _a3, _b;
        const noticesForPlacement = placements2.value[placement];
        const classes = (_a3 = props2.getClassName) === null || _a3 === void 0 ? void 0 : _a3.call(props2, placement);
        const styles = (_b = props2.getStyles) === null || _b === void 0 ? void 0 : _b.call(props2, placement);
        const noticeNodesForPlacement = noticesForPlacement.map((_ref2, index2) => {
          let {
            notice: notice2,
            holderCallback
          } = _ref2;
          const updateMark = index2 === notices.value.length - 1 ? notice2.updateMark : void 0;
          const {
            key: key2,
            userPassKey
          } = notice2;
          const {
            content
          } = notice2;
          const noticeProps = _extends$1(_extends$1(_extends$1({
            prefixCls,
            closeIcon: typeof closeIcon === "function" ? closeIcon({
              prefixCls
            }) : closeIcon
          }, notice2), notice2.props), {
            key: key2,
            noticeKey: userPassKey || key2,
            updateMark,
            onClose: (noticeKey) => {
              var _a4;
              remove(noticeKey);
              (_a4 = notice2.onClose) === null || _a4 === void 0 ? void 0 : _a4.call(notice2);
            },
            onClick: notice2.onClick
          });
          if (holderCallback) {
            return createVNode("div", {
              "key": key2,
              "class": `${prefixCls}-hook-holder`,
              "ref": (div) => {
                if (typeof key2 === "undefined") {
                  return;
                }
                if (div) {
                  hookRefs.set(key2, div);
                  holderCallback(div, noticeProps);
                } else {
                  hookRefs.delete(key2);
                }
              }
            }, null);
          }
          return createVNode(Notice, _objectSpread2$1(_objectSpread2$1({}, noticeProps), {}, {
            "class": classNames(noticeProps.class, props2.hashId)
          }), {
            default: () => [typeof content === "function" ? content({
              prefixCls
            }) : content]
          });
        });
        const className = {
          [prefixCls]: 1,
          [`${prefixCls}-${placement}`]: 1,
          [attrs.class]: !!attrs.class,
          [props2.hashId]: true,
          [classes]: !!classes
        };
        function onAfterLeave() {
          var _a4;
          if (noticesForPlacement.length > 0) {
            return;
          }
          Reflect.deleteProperty(placements2.value, placement);
          (_a4 = props2.onAllRemoved) === null || _a4 === void 0 ? void 0 : _a4.call(props2);
        }
        return createVNode("div", {
          "key": placement,
          "class": className,
          "style": attrs.style || styles || {
            top: "65px",
            left: "50%"
          }
        }, [createVNode(TransitionGroup, _objectSpread2$1(_objectSpread2$1({
          "tag": "div"
        }, transitionProps.value), {}, {
          "onAfterLeave": onAfterLeave
        }), {
          default: () => [noticeNodesForPlacement]
        })]);
      });
      return createVNode(Portal$1, {
        "getContainer": props2.getContainer
      }, {
        default: () => [noticeNodes]
      });
    };
  }
});
var __rest$I = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const defaultGetContainer$1 = () => document.body;
let uniqueKey = 0;
function mergeConfig() {
  const clone2 = {};
  for (var _len = arguments.length, objList = new Array(_len), _key = 0; _key < _len; _key++) {
    objList[_key] = arguments[_key];
  }
  objList.forEach((obj) => {
    if (obj) {
      Object.keys(obj).forEach((key2) => {
        const val = obj[key2];
        if (val !== void 0) {
          clone2[key2] = val;
        }
      });
    }
  });
  return clone2;
}
function useNotification$1() {
  let rootConfig = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const {
    getContainer: getContainer2 = defaultGetContainer$1,
    motion,
    prefixCls,
    maxCount: maxCount2,
    getClassName,
    getStyles,
    onAllRemoved
  } = rootConfig, shareConfig = __rest$I(rootConfig, ["getContainer", "motion", "prefixCls", "maxCount", "getClassName", "getStyles", "onAllRemoved"]);
  const notices = shallowRef([]);
  const notificationsRef = shallowRef();
  const add = (originNotice, holderCallback) => {
    const key2 = originNotice.key || getUuid();
    const notice2 = _extends$1(_extends$1({}, originNotice), {
      key: key2
    });
    const noticeIndex = notices.value.map((v2) => v2.notice.key).indexOf(key2);
    const updatedNotices = notices.value.concat();
    if (noticeIndex !== -1) {
      updatedNotices.splice(noticeIndex, 1, {
        notice: notice2,
        holderCallback
      });
    } else {
      if (maxCount2 && notices.value.length >= maxCount2) {
        notice2.key = updatedNotices[0].notice.key;
        notice2.updateMark = getUuid();
        notice2.userPassKey = key2;
        updatedNotices.shift();
      }
      updatedNotices.push({
        notice: notice2,
        holderCallback
      });
    }
    notices.value = updatedNotices;
  };
  const removeNotice = (removeKey) => {
    notices.value = notices.value.filter((_ref) => {
      let {
        notice: {
          key: key2,
          userPassKey
        }
      } = _ref;
      const mergedKey = userPassKey || key2;
      return mergedKey !== removeKey;
    });
  };
  const destroy = () => {
    notices.value = [];
  };
  const contextHolder = () => createVNode(Notification, {
    "ref": notificationsRef,
    "prefixCls": prefixCls,
    "maxCount": maxCount2,
    "notices": notices.value,
    "remove": removeNotice,
    "getClassName": getClassName,
    "getStyles": getStyles,
    "animation": motion,
    "hashId": rootConfig.hashId,
    "onAllRemoved": onAllRemoved,
    "getContainer": getContainer2
  }, null);
  const taskQueue = shallowRef([]);
  const api2 = {
    open: (config) => {
      const mergedConfig = mergeConfig(shareConfig, config);
      if (mergedConfig.key === null || mergedConfig.key === void 0) {
        mergedConfig.key = `vc-notification-${uniqueKey}`;
        uniqueKey += 1;
      }
      taskQueue.value = [...taskQueue.value, {
        type: "open",
        config: mergedConfig
      }];
    },
    close: (key2) => {
      taskQueue.value = [...taskQueue.value, {
        type: "close",
        key: key2
      }];
    },
    destroy: () => {
      taskQueue.value = [...taskQueue.value, {
        type: "destroy"
      }];
    }
  };
  watch(taskQueue, () => {
    if (taskQueue.value.length) {
      taskQueue.value.forEach((task) => {
        switch (task.type) {
          case "open":
            add(task.config);
            break;
          case "close":
            removeNotice(task.key);
            break;
          case "destroy":
            destroy();
            break;
        }
      });
      taskQueue.value = [];
    }
  });
  return [api2, contextHolder];
}
const genMessageStyle = (token2) => {
  const {
    componentCls,
    iconCls,
    boxShadowSecondary,
    colorBgElevated,
    colorSuccess,
    colorError,
    colorWarning,
    colorInfo,
    fontSizeLG,
    motionEaseInOutCirc,
    motionDurationSlow,
    marginXS,
    paddingXS,
    borderRadiusLG,
    zIndexPopup,
    // Custom token
    messageNoticeContentPadding
  } = token2;
  const messageMoveIn = new Keyframe("MessageMoveIn", {
    "0%": {
      padding: 0,
      transform: "translateY(-100%)",
      opacity: 0
    },
    "100%": {
      padding: paddingXS,
      transform: "translateY(0)",
      opacity: 1
    }
  });
  const messageMoveOut = new Keyframe("MessageMoveOut", {
    "0%": {
      maxHeight: token2.height,
      padding: paddingXS,
      opacity: 1
    },
    "100%": {
      maxHeight: 0,
      padding: 0,
      opacity: 0
    }
  });
  return [
    // ============================ Holder ============================
    {
      [componentCls]: _extends$1(_extends$1({}, resetComponent(token2)), {
        position: "fixed",
        top: marginXS,
        left: "50%",
        transform: "translateX(-50%)",
        width: "100%",
        pointerEvents: "none",
        zIndex: zIndexPopup,
        [`${componentCls}-move-up`]: {
          animationFillMode: "forwards"
        },
        [`
        ${componentCls}-move-up-appear,
        ${componentCls}-move-up-enter
      `]: {
          animationName: messageMoveIn,
          animationDuration: motionDurationSlow,
          animationPlayState: "paused",
          animationTimingFunction: motionEaseInOutCirc
        },
        [`
        ${componentCls}-move-up-appear${componentCls}-move-up-appear-active,
        ${componentCls}-move-up-enter${componentCls}-move-up-enter-active
      `]: {
          animationPlayState: "running"
        },
        [`${componentCls}-move-up-leave`]: {
          animationName: messageMoveOut,
          animationDuration: motionDurationSlow,
          animationPlayState: "paused",
          animationTimingFunction: motionEaseInOutCirc
        },
        [`${componentCls}-move-up-leave${componentCls}-move-up-leave-active`]: {
          animationPlayState: "running"
        },
        "&-rtl": {
          direction: "rtl",
          span: {
            direction: "rtl"
          }
        }
      })
    },
    // ============================ Notice ============================
    {
      [`${componentCls}-notice`]: {
        padding: paddingXS,
        textAlign: "center",
        [iconCls]: {
          verticalAlign: "text-bottom",
          marginInlineEnd: marginXS,
          fontSize: fontSizeLG
        },
        [`${componentCls}-notice-content`]: {
          display: "inline-block",
          padding: messageNoticeContentPadding,
          background: colorBgElevated,
          borderRadius: borderRadiusLG,
          boxShadow: boxShadowSecondary,
          pointerEvents: "all"
        },
        [`${componentCls}-success ${iconCls}`]: {
          color: colorSuccess
        },
        [`${componentCls}-error ${iconCls}`]: {
          color: colorError
        },
        [`${componentCls}-warning ${iconCls}`]: {
          color: colorWarning
        },
        [`
        ${componentCls}-info ${iconCls},
        ${componentCls}-loading ${iconCls}`]: {
          color: colorInfo
        }
      }
    },
    // ============================= Pure =============================
    {
      [`${componentCls}-notice-pure-panel`]: {
        padding: 0,
        textAlign: "start"
      }
    }
  ];
};
const useStyle$n = genComponentStyleHook("Message", (token2) => {
  const combinedToken = merge(token2, {
    messageNoticeContentPadding: `${(token2.controlHeightLG - token2.fontSize * token2.lineHeight) / 2}px ${token2.paddingSM}px`
  });
  return [genMessageStyle(combinedToken)];
}, (token2) => ({
  height: 150,
  zIndexPopup: token2.zIndexPopupBase + 10
}));
const TypeIcon = {
  info: createVNode(InfoCircleFilled, null, null),
  success: createVNode(CheckCircleFilled, null, null),
  error: createVNode(CloseCircleFilled, null, null),
  warning: createVNode(ExclamationCircleFilled, null, null),
  loading: createVNode(LoadingOutlined, null, null)
};
const PureContent$1 = defineComponent({
  name: "PureContent",
  inheritAttrs: false,
  props: ["prefixCls", "type", "icon"],
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    return () => {
      var _a2;
      return createVNode("div", {
        "class": classNames(`${props2.prefixCls}-custom-content`, `${props2.prefixCls}-${props2.type}`)
      }, [props2.icon || TypeIcon[props2.type], createVNode("span", null, [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)])]);
    };
  }
});
var __rest$H = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const DEFAULT_OFFSET$1 = 8;
const DEFAULT_DURATION$1 = 3;
const Holder$1 = defineComponent({
  name: "Holder",
  inheritAttrs: false,
  props: ["top", "prefixCls", "getContainer", "maxCount", "duration", "rtl", "transitionName", "onAllRemoved", "animation", "staticGetContainer"],
  setup(props2, _ref) {
    let {
      expose
    } = _ref;
    var _a2, _b;
    const {
      getPrefixCls,
      getPopupContainer
    } = useConfigInject("message", props2);
    const prefixCls = computed(() => getPrefixCls("message", props2.prefixCls));
    const [, hashId] = useStyle$n(prefixCls);
    const getStyles = () => {
      var _a3;
      const top = (_a3 = props2.top) !== null && _a3 !== void 0 ? _a3 : DEFAULT_OFFSET$1;
      return {
        left: "50%",
        transform: "translateX(-50%)",
        top: typeof top === "number" ? `${top}px` : top
      };
    };
    const getClassName = () => classNames(hashId.value, props2.rtl ? `${prefixCls.value}-rtl` : "");
    const getNotificationMotion = () => {
      var _a3;
      return getMotion$1({
        prefixCls: prefixCls.value,
        animation: (_a3 = props2.animation) !== null && _a3 !== void 0 ? _a3 : `move-up`,
        transitionName: props2.transitionName
      });
    };
    const mergedCloseIcon = createVNode("span", {
      "class": `${prefixCls.value}-close-x`
    }, [createVNode(CloseOutlined, {
      "class": `${prefixCls.value}-close-icon`
    }, null)]);
    const [api2, holder] = useNotification$1({
      //@ts-ignore
      getStyles,
      prefixCls: prefixCls.value,
      getClassName,
      motion: getNotificationMotion,
      closable: false,
      closeIcon: mergedCloseIcon,
      duration: (_a2 = props2.duration) !== null && _a2 !== void 0 ? _a2 : DEFAULT_DURATION$1,
      getContainer: (_b = props2.staticGetContainer) !== null && _b !== void 0 ? _b : getPopupContainer.value,
      maxCount: props2.maxCount,
      onAllRemoved: props2.onAllRemoved
    });
    expose(_extends$1(_extends$1({}, api2), {
      prefixCls,
      hashId
    }));
    return holder;
  }
});
let keyIndex = 0;
function useInternalMessage(messageConfig) {
  const holderRef = shallowRef(null);
  const holderKey = Symbol("messageHolderKey");
  const close = (key2) => {
    var _a2;
    (_a2 = holderRef.value) === null || _a2 === void 0 ? void 0 : _a2.close(key2);
  };
  const open2 = (config) => {
    if (!holderRef.value) {
      const fakeResult = () => {
      };
      fakeResult.then = () => {
      };
      return fakeResult;
    }
    const {
      open: originOpen,
      prefixCls,
      hashId
    } = holderRef.value;
    const noticePrefixCls = `${prefixCls}-notice`;
    const {
      content,
      icon,
      type: type4,
      key: key2,
      class: className,
      onClose
    } = config, restConfig = __rest$H(config, ["content", "icon", "type", "key", "class", "onClose"]);
    let mergedKey = key2;
    if (mergedKey === void 0 || mergedKey === null) {
      keyIndex += 1;
      mergedKey = `antd-message-${keyIndex}`;
    }
    return wrapPromiseFn((resolve) => {
      originOpen(_extends$1(_extends$1({}, restConfig), {
        key: mergedKey,
        content: () => createVNode(PureContent$1, {
          "prefixCls": prefixCls,
          "type": type4,
          "icon": typeof icon === "function" ? icon() : icon
        }, {
          default: () => [typeof content === "function" ? content() : content]
        }),
        placement: "top",
        // @ts-ignore
        class: classNames(type4 && `${noticePrefixCls}-${type4}`, hashId, className),
        onClose: () => {
          onClose === null || onClose === void 0 ? void 0 : onClose();
          resolve();
        }
      }));
      return () => {
        close(mergedKey);
      };
    });
  };
  const destroy = (key2) => {
    var _a2;
    if (key2 !== void 0) {
      close(key2);
    } else {
      (_a2 = holderRef.value) === null || _a2 === void 0 ? void 0 : _a2.destroy();
    }
  };
  const wrapAPI = {
    open: open2,
    destroy
  };
  const keys2 = ["info", "success", "warning", "error", "loading"];
  keys2.forEach((type4) => {
    const typeOpen = (jointContent, duration, onClose) => {
      let config;
      if (jointContent && typeof jointContent === "object" && "content" in jointContent) {
        config = jointContent;
      } else {
        config = {
          content: jointContent
        };
      }
      let mergedDuration;
      let mergedOnClose;
      if (typeof duration === "function") {
        mergedOnClose = duration;
      } else {
        mergedDuration = duration;
        mergedOnClose = onClose;
      }
      const mergedConfig = _extends$1(_extends$1({
        onClose: mergedOnClose,
        duration: mergedDuration
      }, config), {
        type: type4
      });
      return open2(mergedConfig);
    };
    wrapAPI[type4] = typeOpen;
  });
  return [wrapAPI, () => createVNode(Holder$1, _objectSpread2$1(_objectSpread2$1({
    "key": holderKey
  }, messageConfig), {}, {
    "ref": holderRef
  }), null)];
}
function useMessage(messageConfig) {
  return useInternalMessage(messageConfig);
}
let defaultDuration$1 = 3;
let defaultTop$1;
let messageInstance;
let key = 1;
let localPrefixCls = "";
let transitionName = "move-up";
let hasTransitionName = false;
let getContainer = () => document.body;
let maxCount$1;
let rtl$1 = false;
function getKeyThenIncreaseKey() {
  return key++;
}
function setMessageConfig(options) {
  if (options.top !== void 0) {
    defaultTop$1 = options.top;
    messageInstance = null;
  }
  if (options.duration !== void 0) {
    defaultDuration$1 = options.duration;
  }
  if (options.prefixCls !== void 0) {
    localPrefixCls = options.prefixCls;
  }
  if (options.getContainer !== void 0) {
    getContainer = options.getContainer;
    messageInstance = null;
  }
  if (options.transitionName !== void 0) {
    transitionName = options.transitionName;
    messageInstance = null;
    hasTransitionName = true;
  }
  if (options.maxCount !== void 0) {
    maxCount$1 = options.maxCount;
    messageInstance = null;
  }
  if (options.rtl !== void 0) {
    rtl$1 = options.rtl;
  }
}
function getMessageInstance(args, callback) {
  if (messageInstance) {
    callback(messageInstance);
    return;
  }
  Notification$1.newInstance({
    appContext: args.appContext,
    prefixCls: args.prefixCls || localPrefixCls,
    rootPrefixCls: args.rootPrefixCls,
    transitionName,
    hasTransitionName,
    style: {
      top: defaultTop$1
    },
    getContainer: getContainer || args.getPopupContainer,
    maxCount: maxCount$1,
    name: "message",
    useStyle: useStyle$n
  }, (instance) => {
    if (messageInstance) {
      callback(messageInstance);
      return;
    }
    messageInstance = instance;
    callback(instance);
  });
}
const typeToIcon$2 = {
  info: InfoCircleFilled,
  success: CheckCircleFilled,
  error: CloseCircleFilled,
  warning: ExclamationCircleFilled,
  loading: LoadingOutlined
};
const typeList = Object.keys(typeToIcon$2);
function notice$1(args) {
  const duration = args.duration !== void 0 ? args.duration : defaultDuration$1;
  const target = args.key || getKeyThenIncreaseKey();
  const closePromise = new Promise((resolve) => {
    const callback = () => {
      if (typeof args.onClose === "function") {
        args.onClose();
      }
      return resolve(true);
    };
    getMessageInstance(args, (instance) => {
      instance.notice({
        key: target,
        duration,
        style: args.style || {},
        class: args.class,
        content: (_ref) => {
          let {
            prefixCls
          } = _ref;
          const Icon3 = typeToIcon$2[args.type];
          const iconNode = Icon3 ? createVNode(Icon3, null, null) : "";
          const messageClass = classNames(`${prefixCls}-custom-content`, {
            [`${prefixCls}-${args.type}`]: args.type,
            [`${prefixCls}-rtl`]: rtl$1 === true
          });
          return createVNode("div", {
            "class": messageClass
          }, [typeof args.icon === "function" ? args.icon() : args.icon || iconNode, createVNode("span", null, [typeof args.content === "function" ? args.content() : args.content])]);
        },
        onClose: callback,
        onClick: args.onClick
      });
    });
  });
  const result = () => {
    if (messageInstance) {
      messageInstance.removeNotice(target);
    }
  };
  result.then = (filled, rejected) => closePromise.then(filled, rejected);
  result.promise = closePromise;
  return result;
}
function isArgsProps(content) {
  return Object.prototype.toString.call(content) === "[object Object]" && !!content.content;
}
const api$1 = {
  open: notice$1,
  config: setMessageConfig,
  destroy(messageKey) {
    if (messageInstance) {
      if (messageKey) {
        const {
          removeNotice
        } = messageInstance;
        removeNotice(messageKey);
      } else {
        const {
          destroy
        } = messageInstance;
        destroy();
        messageInstance = null;
      }
    }
  }
};
function attachTypeApi(originalApi, type4) {
  originalApi[type4] = (content, duration, onClose) => {
    if (isArgsProps(content)) {
      return originalApi.open(_extends$1(_extends$1({}, content), {
        type: type4
      }));
    }
    if (typeof duration === "function") {
      onClose = duration;
      duration = void 0;
    }
    return originalApi.open({
      content,
      duration,
      type: type4,
      onClose
    });
  };
}
typeList.forEach((type4) => attachTypeApi(api$1, type4));
api$1.warn = api$1.warning;
api$1.useMessage = useMessage;
const genNotificationPlacementStyle = (token2) => {
  const {
    componentCls,
    width,
    notificationMarginEdge
  } = token2;
  const notificationTopFadeIn = new Keyframe("antNotificationTopFadeIn", {
    "0%": {
      marginTop: "-100%",
      opacity: 0
    },
    "100%": {
      marginTop: 0,
      opacity: 1
    }
  });
  const notificationBottomFadeIn = new Keyframe("antNotificationBottomFadeIn", {
    "0%": {
      marginBottom: "-100%",
      opacity: 0
    },
    "100%": {
      marginBottom: 0,
      opacity: 1
    }
  });
  const notificationLeftFadeIn = new Keyframe("antNotificationLeftFadeIn", {
    "0%": {
      right: {
        _skip_check_: true,
        value: width
      },
      opacity: 0
    },
    "100%": {
      right: {
        _skip_check_: true,
        value: 0
      },
      opacity: 1
    }
  });
  return {
    [`&${componentCls}-top, &${componentCls}-bottom`]: {
      marginInline: 0
    },
    [`&${componentCls}-top`]: {
      [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {
        animationName: notificationTopFadeIn
      }
    },
    [`&${componentCls}-bottom`]: {
      [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {
        animationName: notificationBottomFadeIn
      }
    },
    [`&${componentCls}-topLeft, &${componentCls}-bottomLeft`]: {
      marginInlineEnd: 0,
      marginInlineStart: notificationMarginEdge,
      [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {
        animationName: notificationLeftFadeIn
      }
    }
  };
};
const genNotificationStyle = (token2) => {
  const {
    iconCls,
    componentCls,
    // .ant-notification
    boxShadowSecondary,
    fontSizeLG,
    notificationMarginBottom,
    borderRadiusLG,
    colorSuccess,
    colorInfo,
    colorWarning,
    colorError,
    colorTextHeading,
    notificationBg,
    notificationPadding,
    notificationMarginEdge,
    motionDurationMid,
    motionEaseInOut,
    fontSize,
    lineHeight,
    width,
    notificationIconSize
  } = token2;
  const noticeCls = `${componentCls}-notice`;
  const notificationFadeIn = new Keyframe("antNotificationFadeIn", {
    "0%": {
      left: {
        _skip_check_: true,
        value: width
      },
      opacity: 0
    },
    "100%": {
      left: {
        _skip_check_: true,
        value: 0
      },
      opacity: 1
    }
  });
  const notificationFadeOut = new Keyframe("antNotificationFadeOut", {
    "0%": {
      maxHeight: token2.animationMaxHeight,
      marginBottom: notificationMarginBottom,
      opacity: 1
    },
    "100%": {
      maxHeight: 0,
      marginBottom: 0,
      paddingTop: 0,
      paddingBottom: 0,
      opacity: 0
    }
  });
  return [
    // ============================ Holder ============================
    {
      [componentCls]: _extends$1(_extends$1(_extends$1(_extends$1({}, resetComponent(token2)), {
        position: "fixed",
        zIndex: token2.zIndexPopup,
        marginInlineEnd: notificationMarginEdge,
        [`${componentCls}-hook-holder`]: {
          position: "relative"
        },
        [`&${componentCls}-top, &${componentCls}-bottom`]: {
          [`${componentCls}-notice`]: {
            marginInline: "auto auto"
          }
        },
        [`&${componentCls}-topLeft, &${componentCls}-bottomLeft`]: {
          [`${componentCls}-notice`]: {
            marginInlineEnd: "auto",
            marginInlineStart: 0
          }
        },
        //  animation
        [`${componentCls}-fade-enter, ${componentCls}-fade-appear`]: {
          animationDuration: token2.motionDurationMid,
          animationTimingFunction: motionEaseInOut,
          animationFillMode: "both",
          opacity: 0,
          animationPlayState: "paused"
        },
        [`${componentCls}-fade-leave`]: {
          animationTimingFunction: motionEaseInOut,
          animationFillMode: "both",
          animationDuration: motionDurationMid,
          animationPlayState: "paused"
        },
        [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {
          animationName: notificationFadeIn,
          animationPlayState: "running"
        },
        [`${componentCls}-fade-leave${componentCls}-fade-leave-active`]: {
          animationName: notificationFadeOut,
          animationPlayState: "running"
        }
      }), genNotificationPlacementStyle(token2)), {
        // RTL
        "&-rtl": {
          direction: "rtl",
          [`${componentCls}-notice-btn`]: {
            float: "left"
          }
        }
      })
    },
    // ============================ Notice ============================
    {
      [noticeCls]: {
        position: "relative",
        width,
        maxWidth: `calc(100vw - ${notificationMarginEdge * 2}px)`,
        marginBottom: notificationMarginBottom,
        marginInlineStart: "auto",
        padding: notificationPadding,
        overflow: "hidden",
        lineHeight,
        wordWrap: "break-word",
        background: notificationBg,
        borderRadius: borderRadiusLG,
        boxShadow: boxShadowSecondary,
        [`${componentCls}-close-icon`]: {
          fontSize,
          cursor: "pointer"
        },
        [`${noticeCls}-message`]: {
          marginBottom: token2.marginXS,
          color: colorTextHeading,
          fontSize: fontSizeLG,
          lineHeight: token2.lineHeightLG
        },
        [`${noticeCls}-description`]: {
          fontSize
        },
        [`&${noticeCls}-closable ${noticeCls}-message`]: {
          paddingInlineEnd: token2.paddingLG
        },
        [`${noticeCls}-with-icon ${noticeCls}-message`]: {
          marginBottom: token2.marginXS,
          marginInlineStart: token2.marginSM + notificationIconSize,
          fontSize: fontSizeLG
        },
        [`${noticeCls}-with-icon ${noticeCls}-description`]: {
          marginInlineStart: token2.marginSM + notificationIconSize,
          fontSize
        },
        // Icon & color style in different selector level
        // https://github.com/ant-design/ant-design/issues/16503
        // https://github.com/ant-design/ant-design/issues/15512
        [`${noticeCls}-icon`]: {
          position: "absolute",
          fontSize: notificationIconSize,
          lineHeight: 0,
          // icon-font
          [`&-success${iconCls}`]: {
            color: colorSuccess
          },
          [`&-info${iconCls}`]: {
            color: colorInfo
          },
          [`&-warning${iconCls}`]: {
            color: colorWarning
          },
          [`&-error${iconCls}`]: {
            color: colorError
          }
        },
        [`${noticeCls}-close`]: {
          position: "absolute",
          top: token2.notificationPaddingVertical,
          insetInlineEnd: token2.notificationPaddingHorizontal,
          color: token2.colorIcon,
          outline: "none",
          width: token2.notificationCloseButtonSize,
          height: token2.notificationCloseButtonSize,
          borderRadius: token2.borderRadiusSM,
          transition: `background-color ${token2.motionDurationMid}, color ${token2.motionDurationMid}`,
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          "&:hover": {
            color: token2.colorIconHover,
            backgroundColor: token2.wireframe ? "transparent" : token2.colorFillContent
          }
        },
        [`${noticeCls}-btn`]: {
          float: "right",
          marginTop: token2.marginSM
        }
      }
    },
    // ============================= Pure =============================
    {
      [`${noticeCls}-pure-panel`]: {
        margin: 0
      }
    }
  ];
};
const useStyle$m = genComponentStyleHook("Notification", (token2) => {
  const notificationPaddingVertical = token2.paddingMD;
  const notificationPaddingHorizontal = token2.paddingLG;
  const notificationToken = merge(token2, {
    // default.less variables
    notificationBg: token2.colorBgElevated,
    notificationPaddingVertical,
    notificationPaddingHorizontal,
    // index.less variables
    notificationPadding: `${token2.paddingMD}px ${token2.paddingContentHorizontalLG}px`,
    notificationMarginBottom: token2.margin,
    notificationMarginEdge: token2.marginLG,
    animationMaxHeight: 150,
    notificationIconSize: token2.fontSizeLG * token2.lineHeightLG,
    notificationCloseButtonSize: token2.controlHeightLG * 0.55
  });
  return [genNotificationStyle(notificationToken)];
}, (token2) => ({
  zIndexPopup: token2.zIndexPopupBase + 50,
  width: 384
}));
function getCloseIcon(prefixCls, closeIcon) {
  return createVNode("span", {
    "class": `${prefixCls}-close-x`
  }, [createVNode(CloseOutlined, {
    "class": `${prefixCls}-close-icon`
  }, null)]);
}
({
  info: createVNode(InfoCircleFilled, null, null),
  success: createVNode(CheckCircleFilled, null, null),
  error: createVNode(CloseCircleFilled, null, null),
  warning: createVNode(ExclamationCircleFilled, null, null),
  loading: createVNode(LoadingOutlined, null, null)
});
const typeToIcon$1 = {
  success: CheckCircleFilled,
  info: InfoCircleFilled,
  error: CloseCircleFilled,
  warning: ExclamationCircleFilled
};
function PureContent(_ref) {
  let {
    prefixCls,
    icon,
    type: type4,
    message,
    description,
    btn
  } = _ref;
  let iconNode = null;
  if (icon) {
    iconNode = createVNode("span", {
      "class": `${prefixCls}-icon`
    }, [renderHelper(icon)]);
  } else if (type4) {
    const Icon3 = typeToIcon$1[type4];
    iconNode = createVNode(Icon3, {
      "class": `${prefixCls}-icon ${prefixCls}-icon-${type4}`
    }, null);
  }
  return createVNode("div", {
    "class": classNames({
      [`${prefixCls}-with-icon`]: iconNode
    }),
    "role": "alert"
  }, [iconNode, createVNode("div", {
    "class": `${prefixCls}-message`
  }, [message]), createVNode("div", {
    "class": `${prefixCls}-description`
  }, [description]), btn && createVNode("div", {
    "class": `${prefixCls}-btn`
  }, [btn])]);
}
function getPlacementStyle(placement, top, bottom) {
  let style;
  top = typeof top === "number" ? `${top}px` : top;
  bottom = typeof bottom === "number" ? `${bottom}px` : bottom;
  switch (placement) {
    case "top":
      style = {
        left: "50%",
        transform: "translateX(-50%)",
        right: "auto",
        top,
        bottom: "auto"
      };
      break;
    case "topLeft":
      style = {
        left: 0,
        top,
        bottom: "auto"
      };
      break;
    case "topRight":
      style = {
        right: 0,
        top,
        bottom: "auto"
      };
      break;
    case "bottom":
      style = {
        left: "50%",
        transform: "translateX(-50%)",
        right: "auto",
        top: "auto",
        bottom
      };
      break;
    case "bottomLeft":
      style = {
        left: 0,
        top: "auto",
        bottom
      };
      break;
    default:
      style = {
        right: 0,
        top: "auto",
        bottom
      };
      break;
  }
  return style;
}
function getMotion(prefixCls) {
  return {
    name: `${prefixCls}-fade`
  };
}
var __rest$G = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const DEFAULT_OFFSET = 24;
const DEFAULT_DURATION = 4.5;
const Holder = defineComponent({
  name: "Holder",
  inheritAttrs: false,
  props: ["prefixCls", "class", "type", "icon", "content", "onAllRemoved"],
  setup(props2, _ref) {
    let {
      expose
    } = _ref;
    const {
      getPrefixCls,
      getPopupContainer
    } = useConfigInject("notification", props2);
    const prefixCls = computed(() => props2.prefixCls || getPrefixCls("notification"));
    const getStyles = (placement) => {
      var _a2, _b;
      return getPlacementStyle(placement, (_a2 = props2.top) !== null && _a2 !== void 0 ? _a2 : DEFAULT_OFFSET, (_b = props2.bottom) !== null && _b !== void 0 ? _b : DEFAULT_OFFSET);
    };
    const [, hashId] = useStyle$m(prefixCls);
    const getClassName = () => classNames(hashId.value, {
      [`${prefixCls.value}-rtl`]: props2.rtl
    });
    const getNotificationMotion = () => getMotion(prefixCls.value);
    const [api2, holder] = useNotification$1({
      prefixCls: prefixCls.value,
      getStyles,
      getClassName,
      motion: getNotificationMotion,
      closable: true,
      closeIcon: getCloseIcon(prefixCls.value),
      duration: DEFAULT_DURATION,
      getContainer: () => {
        var _a2, _b;
        return ((_a2 = props2.getPopupContainer) === null || _a2 === void 0 ? void 0 : _a2.call(props2)) || ((_b = getPopupContainer.value) === null || _b === void 0 ? void 0 : _b.call(getPopupContainer)) || document.body;
      },
      maxCount: props2.maxCount,
      hashId: hashId.value,
      onAllRemoved: props2.onAllRemoved
    });
    expose(_extends$1(_extends$1({}, api2), {
      prefixCls: prefixCls.value,
      hashId
    }));
    return holder;
  }
});
function useInternalNotification(notificationConfig) {
  const holderRef = shallowRef(null);
  const holderKey = Symbol("notificationHolderKey");
  const open2 = (config) => {
    if (!holderRef.value) {
      return;
    }
    const {
      open: originOpen,
      prefixCls,
      hashId
    } = holderRef.value;
    const noticePrefixCls = `${prefixCls}-notice`;
    const {
      message,
      description,
      icon,
      type: type4,
      btn,
      class: className
    } = config, restConfig = __rest$G(config, ["message", "description", "icon", "type", "btn", "class"]);
    return originOpen(_extends$1(_extends$1({
      placement: "topRight"
    }, restConfig), {
      content: () => createVNode(PureContent, {
        "prefixCls": noticePrefixCls,
        "icon": typeof icon === "function" ? icon() : icon,
        "type": type4,
        "message": typeof message === "function" ? message() : message,
        "description": typeof description === "function" ? description() : description,
        "btn": typeof btn === "function" ? btn() : btn
      }, null),
      // @ts-ignore
      class: classNames(type4 && `${noticePrefixCls}-${type4}`, hashId, className)
    }));
  };
  const destroy = (key2) => {
    var _a2, _b;
    if (key2 !== void 0) {
      (_a2 = holderRef.value) === null || _a2 === void 0 ? void 0 : _a2.close(key2);
    } else {
      (_b = holderRef.value) === null || _b === void 0 ? void 0 : _b.destroy();
    }
  };
  const wrapAPI = {
    open: open2,
    destroy
  };
  const keys2 = ["success", "info", "warning", "error"];
  keys2.forEach((type4) => {
    wrapAPI[type4] = (config) => open2(_extends$1(_extends$1({}, config), {
      type: type4
    }));
  });
  return [wrapAPI, () => createVNode(Holder, _objectSpread2$1(_objectSpread2$1({
    "key": holderKey
  }, notificationConfig), {}, {
    "ref": holderRef
  }), null)];
}
function useNotification(notificationConfig) {
  return useInternalNotification(notificationConfig);
}
const notificationInstance = {};
let defaultDuration = 4.5;
let defaultTop = "24px";
let defaultBottom = "24px";
let defaultPrefixCls$1 = "";
let defaultPlacement = "topRight";
let defaultGetContainer = () => document.body;
let defaultCloseIcon = null;
let rtl = false;
let maxCount;
function setNotificationConfig(options) {
  const {
    duration,
    placement,
    bottom,
    top,
    getContainer: getContainer2,
    closeIcon,
    prefixCls
  } = options;
  if (prefixCls !== void 0) {
    defaultPrefixCls$1 = prefixCls;
  }
  if (duration !== void 0) {
    defaultDuration = duration;
  }
  if (placement !== void 0) {
    defaultPlacement = placement;
  }
  if (bottom !== void 0) {
    defaultBottom = typeof bottom === "number" ? `${bottom}px` : bottom;
  }
  if (top !== void 0) {
    defaultTop = typeof top === "number" ? `${top}px` : top;
  }
  if (getContainer2 !== void 0) {
    defaultGetContainer = getContainer2;
  }
  if (closeIcon !== void 0) {
    defaultCloseIcon = closeIcon;
  }
  if (options.rtl !== void 0) {
    rtl = options.rtl;
  }
  if (options.maxCount !== void 0) {
    maxCount = options.maxCount;
  }
}
function getNotificationInstance(_ref, callback) {
  let {
    prefixCls: customizePrefixCls,
    placement = defaultPlacement,
    getContainer: getContainer2 = defaultGetContainer,
    top,
    bottom,
    closeIcon = defaultCloseIcon,
    appContext
  } = _ref;
  const {
    getPrefixCls
  } = globalConfig();
  const prefixCls = getPrefixCls("notification", customizePrefixCls || defaultPrefixCls$1);
  const cacheKey = `${prefixCls}-${placement}-${rtl}`;
  const cacheInstance = notificationInstance[cacheKey];
  if (cacheInstance) {
    Promise.resolve(cacheInstance).then((instance) => {
      callback(instance);
    });
    return;
  }
  const notificationClass = classNames(`${prefixCls}-${placement}`, {
    [`${prefixCls}-rtl`]: rtl === true
  });
  Notification$1.newInstance({
    name: "notification",
    prefixCls: customizePrefixCls || defaultPrefixCls$1,
    useStyle: useStyle$m,
    class: notificationClass,
    style: getPlacementStyle(placement, top !== null && top !== void 0 ? top : defaultTop, bottom !== null && bottom !== void 0 ? bottom : defaultBottom),
    appContext,
    getContainer: getContainer2,
    closeIcon: (_ref2) => {
      let {
        prefixCls: prefixCls2
      } = _ref2;
      const closeIconToRender = createVNode("span", {
        "class": `${prefixCls2}-close-x`
      }, [renderHelper(closeIcon, {}, createVNode(CloseOutlined, {
        "class": `${prefixCls2}-close-icon`
      }, null))]);
      return closeIconToRender;
    },
    maxCount,
    hasTransitionName: true
  }, (notification) => {
    notificationInstance[cacheKey] = notification;
    callback(notification);
  });
}
const typeToIcon = {
  success: CheckCircleOutlined,
  info: InfoCircleOutlined,
  error: CloseCircleOutlined,
  warning: ExclamationCircleOutlined
};
function notice(args) {
  const {
    icon,
    type: type4,
    description,
    message,
    btn
  } = args;
  const duration = args.duration === void 0 ? defaultDuration : args.duration;
  getNotificationInstance(args, (notification) => {
    notification.notice({
      content: (_ref3) => {
        let {
          prefixCls: outerPrefixCls
        } = _ref3;
        const prefixCls = `${outerPrefixCls}-notice`;
        let iconNode = null;
        if (icon) {
          iconNode = () => createVNode("span", {
            "class": `${prefixCls}-icon`
          }, [renderHelper(icon)]);
        } else if (type4) {
          const Icon3 = typeToIcon[type4];
          iconNode = () => createVNode(Icon3, {
            "class": `${prefixCls}-icon ${prefixCls}-icon-${type4}`
          }, null);
        }
        return createVNode("div", {
          "class": iconNode ? `${prefixCls}-with-icon` : ""
        }, [iconNode && iconNode(), createVNode("div", {
          "class": `${prefixCls}-message`
        }, [!description && iconNode ? createVNode("span", {
          "class": `${prefixCls}-message-single-line-auto-margin`
        }, null) : null, renderHelper(message)]), createVNode("div", {
          "class": `${prefixCls}-description`
        }, [renderHelper(description)]), btn ? createVNode("span", {
          "class": `${prefixCls}-btn`
        }, [renderHelper(btn)]) : null]);
      },
      duration,
      closable: true,
      onClose: args.onClose,
      onClick: args.onClick,
      key: args.key,
      style: args.style || {},
      class: args.class
    });
  });
}
const api = {
  open: notice,
  close(key2) {
    Object.keys(notificationInstance).forEach((cacheKey) => Promise.resolve(notificationInstance[cacheKey]).then((instance) => {
      instance.removeNotice(key2);
    }));
  },
  config: setNotificationConfig,
  destroy() {
    Object.keys(notificationInstance).forEach((cacheKey) => {
      Promise.resolve(notificationInstance[cacheKey]).then((instance) => {
        instance.destroy();
      });
      delete notificationInstance[cacheKey];
    });
  }
};
const iconTypes = ["success", "info", "warning", "error"];
iconTypes.forEach((type4) => {
  api[type4] = (args) => api.open(_extends$1(_extends$1({}, args), {
    type: type4
  }));
});
api.warn = api.warning;
api.useNotification = useNotification;
const dynamicStyleMark = `-ant-${Date.now()}-${Math.random()}`;
function getStyle$1(globalPrefixCls, theme2) {
  const variables = {};
  const formatColor = (color, updater) => {
    let clone2 = color.clone();
    clone2 = (updater === null || updater === void 0 ? void 0 : updater(clone2)) || clone2;
    return clone2.toRgbString();
  };
  const fillColor = (colorVal, type4) => {
    const baseColor = new TinyColor(colorVal);
    const colorPalettes = generate$1(baseColor.toRgbString());
    variables[`${type4}-color`] = formatColor(baseColor);
    variables[`${type4}-color-disabled`] = colorPalettes[1];
    variables[`${type4}-color-hover`] = colorPalettes[4];
    variables[`${type4}-color-active`] = colorPalettes[6];
    variables[`${type4}-color-outline`] = baseColor.clone().setAlpha(0.2).toRgbString();
    variables[`${type4}-color-deprecated-bg`] = colorPalettes[0];
    variables[`${type4}-color-deprecated-border`] = colorPalettes[2];
  };
  if (theme2.primaryColor) {
    fillColor(theme2.primaryColor, "primary");
    const primaryColor = new TinyColor(theme2.primaryColor);
    const primaryColors = generate$1(primaryColor.toRgbString());
    primaryColors.forEach((color, index2) => {
      variables[`primary-${index2 + 1}`] = color;
    });
    variables["primary-color-deprecated-l-35"] = formatColor(primaryColor, (c2) => c2.lighten(35));
    variables["primary-color-deprecated-l-20"] = formatColor(primaryColor, (c2) => c2.lighten(20));
    variables["primary-color-deprecated-t-20"] = formatColor(primaryColor, (c2) => c2.tint(20));
    variables["primary-color-deprecated-t-50"] = formatColor(primaryColor, (c2) => c2.tint(50));
    variables["primary-color-deprecated-f-12"] = formatColor(primaryColor, (c2) => c2.setAlpha(c2.getAlpha() * 0.12));
    const primaryActiveColor = new TinyColor(primaryColors[0]);
    variables["primary-color-active-deprecated-f-30"] = formatColor(primaryActiveColor, (c2) => c2.setAlpha(c2.getAlpha() * 0.3));
    variables["primary-color-active-deprecated-d-02"] = formatColor(primaryActiveColor, (c2) => c2.darken(2));
  }
  if (theme2.successColor) {
    fillColor(theme2.successColor, "success");
  }
  if (theme2.warningColor) {
    fillColor(theme2.warningColor, "warning");
  }
  if (theme2.errorColor) {
    fillColor(theme2.errorColor, "error");
  }
  if (theme2.infoColor) {
    fillColor(theme2.infoColor, "info");
  }
  const cssList = Object.keys(variables).map((key2) => `--${globalPrefixCls}-${key2}: ${variables[key2]};`);
  return `
  :root {
    ${cssList.join("\n")}
  }
  `.trim();
}
function registerTheme(globalPrefixCls, theme2) {
  const style = getStyle$1(globalPrefixCls, theme2);
  if (canUseDom()) {
    updateCSS(style, `${dynamicStyleMark}-dynamic-theme`);
  }
}
const useStyle$l = (iconPrefixCls) => {
  const [theme2, token2] = useToken$1();
  return useStyleRegister(computed(() => ({
    theme: theme2.value,
    token: token2.value,
    hashId: "",
    path: ["ant-design-icons", iconPrefixCls.value]
  })), () => [{
    [`.${iconPrefixCls.value}`]: _extends$1(_extends$1({}, resetIcon()), {
      [`.${iconPrefixCls.value} .${iconPrefixCls.value}-icon`]: {
        display: "block"
      }
    })
  }]);
};
function useTheme(theme2, parentTheme) {
  const themeConfig = computed(() => (theme2 === null || theme2 === void 0 ? void 0 : theme2.value) || {});
  const parentThemeConfig = computed(() => themeConfig.value.inherit === false || !(parentTheme === null || parentTheme === void 0 ? void 0 : parentTheme.value) ? defaultConfig : parentTheme.value);
  const mergedTheme = computed(() => {
    if (!(theme2 === null || theme2 === void 0 ? void 0 : theme2.value)) {
      return parentTheme === null || parentTheme === void 0 ? void 0 : parentTheme.value;
    }
    const mergedComponents = _extends$1({}, parentThemeConfig.value.components);
    Object.keys(theme2.value.components || {}).forEach((componentName) => {
      mergedComponents[componentName] = _extends$1(_extends$1({}, mergedComponents[componentName]), theme2.value.components[componentName]);
    });
    return _extends$1(_extends$1(_extends$1({}, parentThemeConfig.value), themeConfig.value), {
      token: _extends$1(_extends$1({}, parentThemeConfig.value.token), themeConfig.value.token),
      components: mergedComponents
    });
  });
  return mergedTheme;
}
var __rest$F = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const defaultPrefixCls = "ant";
function getGlobalPrefixCls() {
  return globalConfigForApi.prefixCls || defaultPrefixCls;
}
function getGlobalIconPrefixCls() {
  return globalConfigForApi.iconPrefixCls || defaultIconPrefixCls;
}
const globalConfigBySet = reactive({});
const globalConfigForApi = reactive({});
watchEffect(() => {
  _extends$1(globalConfigForApi, globalConfigBySet);
  globalConfigForApi.prefixCls = getGlobalPrefixCls();
  globalConfigForApi.iconPrefixCls = getGlobalIconPrefixCls();
  globalConfigForApi.getPrefixCls = (suffixCls, customizePrefixCls) => {
    if (customizePrefixCls) return customizePrefixCls;
    return suffixCls ? `${globalConfigForApi.prefixCls}-${suffixCls}` : globalConfigForApi.prefixCls;
  };
  globalConfigForApi.getRootPrefixCls = () => {
    if (globalConfigForApi.prefixCls) {
      return globalConfigForApi.prefixCls;
    }
    return getGlobalPrefixCls();
  };
});
let stopWatchEffect;
const setGlobalConfig = (params) => {
  if (stopWatchEffect) {
    stopWatchEffect();
  }
  stopWatchEffect = watchEffect(() => {
    _extends$1(globalConfigBySet, reactive(params));
    _extends$1(globalConfigForApi, reactive(params));
  });
  if (params.theme) {
    registerTheme(getGlobalPrefixCls(), params.theme);
  }
};
const globalConfig = () => ({
  getPrefixCls: (suffixCls, customizePrefixCls) => {
    if (customizePrefixCls) return customizePrefixCls;
    return suffixCls ? `${getGlobalPrefixCls()}-${suffixCls}` : getGlobalPrefixCls();
  },
  getIconPrefixCls: getGlobalIconPrefixCls,
  getRootPrefixCls: () => {
    if (globalConfigForApi.prefixCls) {
      return globalConfigForApi.prefixCls;
    }
    return getGlobalPrefixCls();
  }
});
const ConfigProvider = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AConfigProvider",
  inheritAttrs: false,
  props: configProviderProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const parentContext = useConfigContextInject();
    const getPrefixCls = (suffixCls, customizePrefixCls) => {
      const {
        prefixCls = "ant"
      } = props2;
      if (customizePrefixCls) return customizePrefixCls;
      const mergedPrefixCls = prefixCls || parentContext.getPrefixCls("");
      return suffixCls ? `${mergedPrefixCls}-${suffixCls}` : mergedPrefixCls;
    };
    const iconPrefixCls = computed(() => props2.iconPrefixCls || parentContext.iconPrefixCls.value || defaultIconPrefixCls);
    const shouldWrapSSR = computed(() => iconPrefixCls.value !== parentContext.iconPrefixCls.value);
    const csp = computed(() => {
      var _a2;
      return props2.csp || ((_a2 = parentContext.csp) === null || _a2 === void 0 ? void 0 : _a2.value);
    });
    const wrapSSR = useStyle$l(iconPrefixCls);
    const mergedTheme = useTheme(computed(() => props2.theme), computed(() => {
      var _a2;
      return (_a2 = parentContext.theme) === null || _a2 === void 0 ? void 0 : _a2.value;
    }));
    const renderEmptyComponent = (name) => {
      const renderEmpty$1 = props2.renderEmpty || slots.renderEmpty || parentContext.renderEmpty || renderEmpty;
      return renderEmpty$1(name);
    };
    const autoInsertSpaceInButton = computed(() => {
      var _a2, _b;
      return (_a2 = props2.autoInsertSpaceInButton) !== null && _a2 !== void 0 ? _a2 : (_b = parentContext.autoInsertSpaceInButton) === null || _b === void 0 ? void 0 : _b.value;
    });
    const locale$12 = computed(() => {
      var _a2;
      return props2.locale || ((_a2 = parentContext.locale) === null || _a2 === void 0 ? void 0 : _a2.value);
    });
    watch(locale$12, () => {
      globalConfigBySet.locale = locale$12.value;
    }, {
      immediate: true
    });
    const direction = computed(() => {
      var _a2;
      return props2.direction || ((_a2 = parentContext.direction) === null || _a2 === void 0 ? void 0 : _a2.value);
    });
    const space = computed(() => {
      var _a2, _b;
      return (_a2 = props2.space) !== null && _a2 !== void 0 ? _a2 : (_b = parentContext.space) === null || _b === void 0 ? void 0 : _b.value;
    });
    const virtual = computed(() => {
      var _a2, _b;
      return (_a2 = props2.virtual) !== null && _a2 !== void 0 ? _a2 : (_b = parentContext.virtual) === null || _b === void 0 ? void 0 : _b.value;
    });
    const dropdownMatchSelectWidth = computed(() => {
      var _a2, _b;
      return (_a2 = props2.dropdownMatchSelectWidth) !== null && _a2 !== void 0 ? _a2 : (_b = parentContext.dropdownMatchSelectWidth) === null || _b === void 0 ? void 0 : _b.value;
    });
    const getTargetContainer = computed(() => {
      var _a2;
      return props2.getTargetContainer !== void 0 ? props2.getTargetContainer : (_a2 = parentContext.getTargetContainer) === null || _a2 === void 0 ? void 0 : _a2.value;
    });
    const getPopupContainer = computed(() => {
      var _a2;
      return props2.getPopupContainer !== void 0 ? props2.getPopupContainer : (_a2 = parentContext.getPopupContainer) === null || _a2 === void 0 ? void 0 : _a2.value;
    });
    const pageHeader = computed(() => {
      var _a2;
      return props2.pageHeader !== void 0 ? props2.pageHeader : (_a2 = parentContext.pageHeader) === null || _a2 === void 0 ? void 0 : _a2.value;
    });
    const input = computed(() => {
      var _a2;
      return props2.input !== void 0 ? props2.input : (_a2 = parentContext.input) === null || _a2 === void 0 ? void 0 : _a2.value;
    });
    const pagination = computed(() => {
      var _a2;
      return props2.pagination !== void 0 ? props2.pagination : (_a2 = parentContext.pagination) === null || _a2 === void 0 ? void 0 : _a2.value;
    });
    const form = computed(() => {
      var _a2;
      return props2.form !== void 0 ? props2.form : (_a2 = parentContext.form) === null || _a2 === void 0 ? void 0 : _a2.value;
    });
    const select = computed(() => {
      var _a2;
      return props2.select !== void 0 ? props2.select : (_a2 = parentContext.select) === null || _a2 === void 0 ? void 0 : _a2.value;
    });
    const componentSize = computed(() => props2.componentSize);
    const componentDisabled = computed(() => props2.componentDisabled);
    const wave = computed(() => {
      var _a2, _b;
      return (_a2 = props2.wave) !== null && _a2 !== void 0 ? _a2 : (_b = parentContext.wave) === null || _b === void 0 ? void 0 : _b.value;
    });
    const configProvider = {
      csp,
      autoInsertSpaceInButton,
      locale: locale$12,
      direction,
      space,
      virtual,
      dropdownMatchSelectWidth,
      getPrefixCls,
      iconPrefixCls,
      theme: computed(() => {
        var _a2, _b;
        return (_a2 = mergedTheme.value) !== null && _a2 !== void 0 ? _a2 : (_b = parentContext.theme) === null || _b === void 0 ? void 0 : _b.value;
      }),
      renderEmpty: renderEmptyComponent,
      getTargetContainer,
      getPopupContainer,
      pageHeader,
      input,
      pagination,
      form,
      select,
      componentSize,
      componentDisabled,
      transformCellText: computed(() => props2.transformCellText),
      wave
    };
    const memoTheme = computed(() => {
      const _a2 = mergedTheme.value || {}, {
        algorithm,
        token: token2
      } = _a2, rest = __rest$F(_a2, ["algorithm", "token"]);
      const themeObj = algorithm && (!Array.isArray(algorithm) || algorithm.length > 0) ? createTheme(algorithm) : void 0;
      return _extends$1(_extends$1({}, rest), {
        theme: themeObj,
        token: _extends$1(_extends$1({}, seedToken), token2)
      });
    });
    const validateMessagesRef = computed(() => {
      var _a2, _b;
      let validateMessages = {};
      if (locale$12.value) {
        validateMessages = ((_a2 = locale$12.value.Form) === null || _a2 === void 0 ? void 0 : _a2.defaultValidateMessages) || ((_b = localeValues.Form) === null || _b === void 0 ? void 0 : _b.defaultValidateMessages) || {};
      }
      if (props2.form && props2.form.validateMessages) {
        validateMessages = _extends$1(_extends$1({}, validateMessages), props2.form.validateMessages);
      }
      return validateMessages;
    });
    useConfigContextProvider(configProvider);
    useProvideGlobalForm({
      validateMessages: validateMessagesRef
    });
    useProviderSize(componentSize);
    useProviderDisabled(componentDisabled);
    const renderProvider = (legacyLocale) => {
      var _a2, _b;
      let childNode = shouldWrapSSR.value ? wrapSSR((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)) : (_b = slots.default) === null || _b === void 0 ? void 0 : _b.call(slots);
      if (props2.theme) {
        const _childNode = /* @__PURE__ */ function() {
          return childNode;
        }();
        childNode = createVNode(DesignTokenProvider, {
          "value": memoTheme.value
        }, {
          default: () => [_childNode]
        });
      }
      return createVNode(locale, {
        "locale": locale$12.value || legacyLocale,
        "ANT_MARK__": ANT_MARK
      }, {
        default: () => [childNode]
      });
    };
    watchEffect(() => {
      if (direction.value) {
        api$1.config({
          rtl: direction.value === "rtl"
        });
        api.config({
          rtl: direction.value === "rtl"
        });
      }
    });
    return () => createVNode(LocaleReceiver, {
      "children": (_2, __, legacyLocale) => renderProvider(legacyLocale)
    }, null);
  }
});
ConfigProvider.config = setGlobalConfig;
ConfigProvider.install = function(app) {
  app.component(ConfigProvider.name, ConfigProvider);
};
const PickerButton = (props2, _ref) => {
  let {
    attrs,
    slots
  } = _ref;
  return createVNode(Button$1, _objectSpread2$1(_objectSpread2$1({
    "size": "small",
    "type": "primary"
  }, props2), attrs), slots);
};
const genTagStatusStyle = (token2, status, cssVariableType) => {
  const capitalizedCssVariableType = capitalize(cssVariableType);
  return {
    [`${token2.componentCls}-${status}`]: {
      color: token2[`color${cssVariableType}`],
      background: token2[`color${capitalizedCssVariableType}Bg`],
      borderColor: token2[`color${capitalizedCssVariableType}Border`],
      [`&${token2.componentCls}-borderless`]: {
        borderColor: "transparent"
      }
    }
  };
};
const genPresetStyle = (token2) => genPresetColor(token2, (colorKey, _ref) => {
  let {
    textColor,
    lightBorderColor,
    lightColor,
    darkColor
  } = _ref;
  return {
    [`${token2.componentCls}-${colorKey}`]: {
      color: textColor,
      background: lightColor,
      borderColor: lightBorderColor,
      // Inverse color
      "&-inverse": {
        color: token2.colorTextLightSolid,
        background: darkColor,
        borderColor: darkColor
      },
      [`&${token2.componentCls}-borderless`]: {
        borderColor: "transparent"
      }
    }
  };
});
const genBaseStyle$8 = (token2) => {
  const {
    paddingXXS,
    lineWidth,
    tagPaddingHorizontal,
    componentCls
  } = token2;
  const paddingInline = tagPaddingHorizontal - lineWidth;
  const iconMarginInline = paddingXXS - lineWidth;
  return {
    // Result
    [componentCls]: _extends$1(_extends$1({}, resetComponent(token2)), {
      display: "inline-block",
      height: "auto",
      marginInlineEnd: token2.marginXS,
      paddingInline,
      fontSize: token2.tagFontSize,
      lineHeight: `${token2.tagLineHeight}px`,
      whiteSpace: "nowrap",
      background: token2.tagDefaultBg,
      border: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`,
      borderRadius: token2.borderRadiusSM,
      opacity: 1,
      transition: `all ${token2.motionDurationMid}`,
      textAlign: "start",
      // RTL
      [`&${componentCls}-rtl`]: {
        direction: "rtl"
      },
      "&, a, a:hover": {
        color: token2.tagDefaultColor
      },
      [`${componentCls}-close-icon`]: {
        marginInlineStart: iconMarginInline,
        color: token2.colorTextDescription,
        fontSize: token2.tagIconSize,
        cursor: "pointer",
        transition: `all ${token2.motionDurationMid}`,
        "&:hover": {
          color: token2.colorTextHeading
        }
      },
      [`&${componentCls}-has-color`]: {
        borderColor: "transparent",
        [`&, a, a:hover, ${token2.iconCls}-close, ${token2.iconCls}-close:hover`]: {
          color: token2.colorTextLightSolid
        }
      },
      [`&-checkable`]: {
        backgroundColor: "transparent",
        borderColor: "transparent",
        cursor: "pointer",
        [`&:not(${componentCls}-checkable-checked):hover`]: {
          color: token2.colorPrimary,
          backgroundColor: token2.colorFillSecondary
        },
        "&:active, &-checked": {
          color: token2.colorTextLightSolid
        },
        "&-checked": {
          backgroundColor: token2.colorPrimary,
          "&:hover": {
            backgroundColor: token2.colorPrimaryHover
          }
        },
        "&:active": {
          backgroundColor: token2.colorPrimaryActive
        }
      },
      [`&-hidden`]: {
        display: "none"
      },
      // To ensure that a space will be placed between character and `Icon`.
      [`> ${token2.iconCls} + span, > span + ${token2.iconCls}`]: {
        marginInlineStart: paddingInline
      }
    }),
    [`${componentCls}-borderless`]: {
      borderColor: "transparent",
      background: token2.tagBorderlessBg
    }
  };
};
const useStyle$k = genComponentStyleHook("Tag", (token2) => {
  const {
    fontSize,
    lineHeight,
    lineWidth,
    fontSizeIcon
  } = token2;
  const tagHeight = Math.round(fontSize * lineHeight);
  const tagFontSize = token2.fontSizeSM;
  const tagLineHeight = tagHeight - lineWidth * 2;
  const tagDefaultBg = token2.colorFillAlter;
  const tagDefaultColor = token2.colorText;
  const tagToken = merge(token2, {
    tagFontSize,
    tagLineHeight,
    tagDefaultBg,
    tagDefaultColor,
    tagIconSize: fontSizeIcon - 2 * lineWidth,
    tagPaddingHorizontal: 8,
    tagBorderlessBg: token2.colorFillTertiary
  });
  return [genBaseStyle$8(tagToken), genPresetStyle(tagToken), genTagStatusStyle(tagToken, "success", "Success"), genTagStatusStyle(tagToken, "processing", "Info"), genTagStatusStyle(tagToken, "error", "Error"), genTagStatusStyle(tagToken, "warning", "Warning")];
});
const checkableTagProps = () => ({
  prefixCls: String,
  checked: {
    type: Boolean,
    default: void 0
  },
  onChange: {
    type: Function
  },
  onClick: {
    type: Function
  },
  "onUpdate:checked": Function
});
const CheckableTag = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ACheckableTag",
  inheritAttrs: false,
  props: checkableTagProps(),
  // emits: ['update:checked', 'change', 'click'],
  setup(props2, _ref) {
    let {
      slots,
      emit,
      attrs
    } = _ref;
    const {
      prefixCls
    } = useConfigInject("tag", props2);
    const [wrapSSR, hashId] = useStyle$k(prefixCls);
    const handleClick = (e2) => {
      const {
        checked
      } = props2;
      emit("update:checked", !checked);
      emit("change", !checked);
      emit("click", e2);
    };
    const cls = computed(() => classNames(prefixCls.value, hashId.value, {
      [`${prefixCls.value}-checkable`]: true,
      [`${prefixCls.value}-checkable-checked`]: props2.checked
    }));
    return () => {
      var _a2;
      return wrapSSR(createVNode("span", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "class": [cls.value, attrs.class],
        "onClick": handleClick
      }), [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]));
    };
  }
});
const tagProps = () => ({
  prefixCls: String,
  color: {
    type: String
  },
  closable: {
    type: Boolean,
    default: false
  },
  closeIcon: PropTypes.any,
  /** @deprecated `visible` will be removed in next major version. */
  visible: {
    type: Boolean,
    default: void 0
  },
  onClose: {
    type: Function
  },
  onClick: eventType(),
  "onUpdate:visible": Function,
  icon: PropTypes.any,
  bordered: {
    type: Boolean,
    default: true
  }
});
const Tag = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ATag",
  inheritAttrs: false,
  props: tagProps(),
  // emits: ['update:visible', 'close'],
  slots: Object,
  setup(props2, _ref) {
    let {
      slots,
      emit,
      attrs
    } = _ref;
    const {
      prefixCls,
      direction
    } = useConfigInject("tag", props2);
    const [wrapSSR, hashId] = useStyle$k(prefixCls);
    const visible = shallowRef(true);
    watchEffect(() => {
      if (props2.visible !== void 0) {
        visible.value = props2.visible;
      }
    });
    const handleCloseClick = (e2) => {
      e2.stopPropagation();
      emit("update:visible", false);
      emit("close", e2);
      if (e2.defaultPrevented) {
        return;
      }
      if (props2.visible === void 0) {
        visible.value = false;
      }
    };
    const isInternalColor = computed(() => isPresetColor(props2.color) || isPresetStatusColor(props2.color));
    const tagClassName = computed(() => classNames(prefixCls.value, hashId.value, {
      [`${prefixCls.value}-${props2.color}`]: isInternalColor.value,
      [`${prefixCls.value}-has-color`]: props2.color && !isInternalColor.value,
      [`${prefixCls.value}-hidden`]: !visible.value,
      [`${prefixCls.value}-rtl`]: direction.value === "rtl",
      [`${prefixCls.value}-borderless`]: !props2.bordered
    }));
    const handleClick = (e2) => {
      emit("click", e2);
    };
    return () => {
      var _a2, _b, _c;
      const {
        icon = (_a2 = slots.icon) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
        color,
        closeIcon = (_b = slots.closeIcon) === null || _b === void 0 ? void 0 : _b.call(slots),
        closable = false
      } = props2;
      const renderCloseIcon = () => {
        if (closable) {
          return closeIcon ? createVNode("span", {
            "class": `${prefixCls.value}-close-icon`,
            "onClick": handleCloseClick
          }, [closeIcon]) : createVNode(CloseOutlined, {
            "class": `${prefixCls.value}-close-icon`,
            "onClick": handleCloseClick
          }, null);
        }
        return null;
      };
      const tagStyle = {
        backgroundColor: color && !isInternalColor.value ? color : void 0
      };
      const iconNode = icon || null;
      const children = (_c = slots.default) === null || _c === void 0 ? void 0 : _c.call(slots);
      const kids = iconNode ? createVNode(Fragment, null, [iconNode, createVNode("span", null, [children])]) : children;
      const isNeedWave = props2.onClick !== void 0;
      const tagNode = createVNode("span", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "onClick": handleClick,
        "class": [tagClassName.value, attrs.class],
        "style": [tagStyle, attrs.style]
      }), [kids, renderCloseIcon()]);
      return wrapSSR(isNeedWave ? createVNode(Wave, null, {
        default: () => [tagNode]
      }) : tagNode);
    };
  }
});
Tag.CheckableTag = CheckableTag;
Tag.install = function(app) {
  app.component(Tag.name, Tag);
  app.component(CheckableTag.name, CheckableTag);
  return app;
};
function PickerTag(props2, _ref) {
  let {
    slots,
    attrs
  } = _ref;
  return createVNode(Tag, _objectSpread2$1(_objectSpread2$1({
    "color": "blue"
  }, props2), attrs), slots);
}
function getPlaceholder(locale2, picker, customizePlaceholder) {
  if (customizePlaceholder !== void 0) {
    return customizePlaceholder;
  }
  if (picker === "year" && locale2.lang.yearPlaceholder) {
    return locale2.lang.yearPlaceholder;
  }
  if (picker === "quarter" && locale2.lang.quarterPlaceholder) {
    return locale2.lang.quarterPlaceholder;
  }
  if (picker === "month" && locale2.lang.monthPlaceholder) {
    return locale2.lang.monthPlaceholder;
  }
  if (picker === "week" && locale2.lang.weekPlaceholder) {
    return locale2.lang.weekPlaceholder;
  }
  if (picker === "time" && locale2.timePickerLocale.placeholder) {
    return locale2.timePickerLocale.placeholder;
  }
  return locale2.lang.placeholder;
}
function getRangePlaceholder(locale2, picker, customizePlaceholder) {
  if (customizePlaceholder !== void 0) {
    return customizePlaceholder;
  }
  if (picker === "year" && locale2.lang.yearPlaceholder) {
    return locale2.lang.rangeYearPlaceholder;
  }
  if (picker === "month" && locale2.lang.monthPlaceholder) {
    return locale2.lang.rangeMonthPlaceholder;
  }
  if (picker === "week" && locale2.lang.weekPlaceholder) {
    return locale2.lang.rangeWeekPlaceholder;
  }
  if (picker === "time" && locale2.timePickerLocale.placeholder) {
    return locale2.timePickerLocale.rangePlaceholder;
  }
  return locale2.lang.rangePlaceholder;
}
function transPlacement2DropdownAlign(direction, placement) {
  const overflow = {
    adjustX: 1,
    adjustY: 1
  };
  switch (placement) {
    case "bottomLeft": {
      return {
        points: ["tl", "bl"],
        offset: [0, 4],
        overflow
      };
    }
    case "bottomRight": {
      return {
        points: ["tr", "br"],
        offset: [0, 4],
        overflow
      };
    }
    case "topLeft": {
      return {
        points: ["bl", "tl"],
        offset: [0, -4],
        overflow
      };
    }
    case "topRight": {
      return {
        points: ["br", "tr"],
        offset: [0, -4],
        overflow
      };
    }
    default: {
      return {
        points: direction === "rtl" ? ["tr", "br"] : ["tl", "bl"],
        offset: [0, 4],
        overflow
      };
    }
  }
}
function commonProps() {
  return {
    id: String,
    /**
     * @deprecated `dropdownClassName` is deprecated which will be removed in next major
     *   version.Please use `popupClassName` instead.
     */
    dropdownClassName: String,
    popupClassName: String,
    popupStyle: objectType(),
    transitionName: String,
    placeholder: String,
    allowClear: booleanType(),
    autofocus: booleanType(),
    disabled: booleanType(),
    tabindex: Number,
    open: booleanType(),
    defaultOpen: booleanType(),
    /** Make input readOnly to avoid popup keyboard in mobile */
    inputReadOnly: booleanType(),
    format: someType([String, Function, Array]),
    // Value
    // format:  string | CustomFormat<DateType> | (string | CustomFormat<DateType>)[];
    // Render
    // suffixIcon?: VueNode;
    // clearIcon?: VueNode;
    // prevIcon?: VueNode;
    // nextIcon?: VueNode;
    // superPrevIcon?: VueNode;
    // superNextIcon?: VueNode;
    getPopupContainer: functionType(),
    panelRender: functionType(),
    // // Events
    onChange: functionType(),
    "onUpdate:value": functionType(),
    onOk: functionType(),
    onOpenChange: functionType(),
    "onUpdate:open": functionType(),
    onFocus: functionType(),
    onBlur: functionType(),
    onMousedown: functionType(),
    onMouseup: functionType(),
    onMouseenter: functionType(),
    onMouseleave: functionType(),
    onClick: functionType(),
    onContextmenu: functionType(),
    onKeydown: functionType(),
    // WAI-ARIA
    role: String,
    name: String,
    autocomplete: String,
    direction: stringType(),
    showToday: booleanType(),
    showTime: someType([Boolean, Object]),
    locale: objectType(),
    size: stringType(),
    bordered: booleanType(),
    dateRender: functionType(),
    disabledDate: functionType(),
    mode: stringType(),
    picker: stringType(),
    valueFormat: String,
    placement: stringType(),
    status: stringType(),
    /** @deprecated Please use `disabledTime` instead. */
    disabledHours: functionType(),
    /** @deprecated Please use `disabledTime` instead. */
    disabledMinutes: functionType(),
    /** @deprecated Please use `disabledTime` instead. */
    disabledSeconds: functionType()
  };
}
function datePickerProps() {
  return {
    defaultPickerValue: someType([Object, String]),
    defaultValue: someType([Object, String]),
    value: someType([Object, String]),
    presets: arrayType(),
    disabledTime: functionType(),
    renderExtraFooter: functionType(),
    showNow: booleanType(),
    monthCellRender: functionType(),
    // deprecated  Please use `monthCellRender"` instead.',
    monthCellContentRender: functionType()
  };
}
function rangePickerProps() {
  return {
    allowEmpty: arrayType(),
    dateRender: functionType(),
    defaultPickerValue: arrayType(),
    defaultValue: arrayType(),
    value: arrayType(),
    presets: arrayType(),
    disabledTime: functionType(),
    disabled: someType([Boolean, Array]),
    renderExtraFooter: functionType(),
    separator: {
      type: String
    },
    showTime: someType([Boolean, Object]),
    ranges: objectType(),
    placeholder: arrayType(),
    mode: arrayType(),
    onChange: functionType(),
    "onUpdate:value": functionType(),
    onCalendarChange: functionType(),
    onPanelChange: functionType(),
    onOk: functionType()
  };
}
var __rest$E = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
function generateSinglePicker(generateConfig2, extraProps) {
  function getPicker(picker, displayName) {
    const comProps = _extends$1(_extends$1(_extends$1({}, commonProps()), datePickerProps()), extraProps);
    return defineComponent({
      compatConfig: {
        MODE: 3
      },
      name: displayName,
      inheritAttrs: false,
      props: comProps,
      slots: Object,
      setup(_props, _ref) {
        let {
          slots,
          expose,
          attrs,
          emit
        } = _ref;
        const props2 = _props;
        const formItemContext = useInjectFormItemContext();
        const formItemInputContext = FormItemInputContext.useInject();
        const {
          prefixCls,
          direction,
          getPopupContainer,
          size,
          rootPrefixCls,
          disabled
        } = useConfigInject("picker", props2);
        const {
          compactSize,
          compactItemClassnames
        } = useCompactItemContext(prefixCls, direction);
        const mergedSize = computed(() => compactSize.value || size.value);
        const [wrapSSR, hashId] = useStyle$v(prefixCls);
        const pickerRef = ref();
        expose({
          focus: () => {
            var _a2;
            (_a2 = pickerRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
          },
          blur: () => {
            var _a2;
            (_a2 = pickerRef.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
          }
        });
        const maybeToString = (date4) => {
          return props2.valueFormat ? generateConfig2.toString(date4, props2.valueFormat) : date4;
        };
        const onChange = (date4, dateString) => {
          const value2 = maybeToString(date4);
          emit("update:value", value2);
          emit("change", value2, dateString);
          formItemContext.onFieldChange();
        };
        const onOpenChange = (open2) => {
          emit("update:open", open2);
          emit("openChange", open2);
        };
        const onFocus = (e2) => {
          emit("focus", e2);
        };
        const onBlur = (e2) => {
          emit("blur", e2);
          formItemContext.onFieldBlur();
        };
        const onPanelChange = (date4, mode) => {
          const value2 = maybeToString(date4);
          emit("panelChange", value2, mode);
        };
        const onOk = (date4) => {
          const value2 = maybeToString(date4);
          emit("ok", value2);
        };
        const [contextLocale] = useLocaleReceiver("DatePicker", locale$1);
        const value = computed(() => {
          if (props2.value) {
            return props2.valueFormat ? generateConfig2.toDate(props2.value, props2.valueFormat) : props2.value;
          }
          return props2.value === "" ? void 0 : props2.value;
        });
        const defaultValue = computed(() => {
          if (props2.defaultValue) {
            return props2.valueFormat ? generateConfig2.toDate(props2.defaultValue, props2.valueFormat) : props2.defaultValue;
          }
          return props2.defaultValue === "" ? void 0 : props2.defaultValue;
        });
        const defaultPickerValue = computed(() => {
          if (props2.defaultPickerValue) {
            return props2.valueFormat ? generateConfig2.toDate(props2.defaultPickerValue, props2.valueFormat) : props2.defaultPickerValue;
          }
          return props2.defaultPickerValue === "" ? void 0 : props2.defaultPickerValue;
        });
        return () => {
          var _a2, _b, _c, _d, _e, _f;
          const locale2 = _extends$1(_extends$1({}, contextLocale.value), props2.locale);
          const p = _extends$1(_extends$1({}, props2), attrs);
          const {
            bordered = true,
            placeholder,
            suffixIcon = (_a2 = slots.suffixIcon) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
            showToday = true,
            transitionName: transitionName2,
            allowClear = true,
            dateRender = slots.dateRender,
            renderExtraFooter = slots.renderExtraFooter,
            monthCellRender = slots.monthCellRender || props2.monthCellContentRender || slots.monthCellContentRender,
            clearIcon = (_b = slots.clearIcon) === null || _b === void 0 ? void 0 : _b.call(slots),
            id = formItemContext.id.value
          } = p, restProps = __rest$E(p, ["bordered", "placeholder", "suffixIcon", "showToday", "transitionName", "allowClear", "dateRender", "renderExtraFooter", "monthCellRender", "clearIcon", "id"]);
          const showTime = p.showTime === "" ? true : p.showTime;
          const {
            format: format2
          } = p;
          let additionalOverrideProps = {};
          if (picker) {
            additionalOverrideProps.picker = picker;
          }
          const mergedPicker = picker || p.picker || "date";
          additionalOverrideProps = _extends$1(_extends$1(_extends$1({}, additionalOverrideProps), showTime ? getTimeProps(_extends$1({
            format: format2,
            picker: mergedPicker
          }, typeof showTime === "object" ? showTime : {})) : {}), mergedPicker === "time" ? getTimeProps(_extends$1(_extends$1({
            format: format2
          }, restProps), {
            picker: mergedPicker
          })) : {});
          const pre = prefixCls.value;
          const suffixNode = createVNode(Fragment, null, [suffixIcon || (picker === "time" ? createVNode(ClockCircleOutlined, null, null) : createVNode(CalendarOutlined, null, null)), formItemInputContext.hasFeedback && formItemInputContext.feedbackIcon]);
          return wrapSSR(createVNode(Picker$1, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
            "monthCellRender": monthCellRender,
            "dateRender": dateRender,
            "renderExtraFooter": renderExtraFooter,
            "ref": pickerRef,
            "placeholder": getPlaceholder(locale2, mergedPicker, placeholder),
            "suffixIcon": suffixNode,
            "dropdownAlign": transPlacement2DropdownAlign(direction.value, props2.placement),
            "clearIcon": clearIcon || createVNode(CloseCircleFilled, null, null),
            "allowClear": allowClear,
            "transitionName": transitionName2 || `${rootPrefixCls.value}-slide-up`
          }, restProps), additionalOverrideProps), {}, {
            "id": id,
            "picker": mergedPicker,
            "value": value.value,
            "defaultValue": defaultValue.value,
            "defaultPickerValue": defaultPickerValue.value,
            "showToday": showToday,
            "locale": locale2.lang,
            "class": classNames({
              [`${pre}-${mergedSize.value}`]: mergedSize.value,
              [`${pre}-borderless`]: !bordered
            }, getStatusClassNames(pre, getMergedStatus(formItemInputContext.status, props2.status), formItemInputContext.hasFeedback), attrs.class, hashId.value, compactItemClassnames.value),
            "disabled": disabled.value,
            "prefixCls": pre,
            "getPopupContainer": attrs.getCalendarContainer || getPopupContainer.value,
            "generateConfig": generateConfig2,
            "prevIcon": ((_c = slots.prevIcon) === null || _c === void 0 ? void 0 : _c.call(slots)) || createVNode("span", {
              "class": `${pre}-prev-icon`
            }, null),
            "nextIcon": ((_d = slots.nextIcon) === null || _d === void 0 ? void 0 : _d.call(slots)) || createVNode("span", {
              "class": `${pre}-next-icon`
            }, null),
            "superPrevIcon": ((_e = slots.superPrevIcon) === null || _e === void 0 ? void 0 : _e.call(slots)) || createVNode("span", {
              "class": `${pre}-super-prev-icon`
            }, null),
            "superNextIcon": ((_f = slots.superNextIcon) === null || _f === void 0 ? void 0 : _f.call(slots)) || createVNode("span", {
              "class": `${pre}-super-next-icon`
            }, null),
            "components": Components,
            "direction": direction.value,
            "dropdownClassName": classNames(hashId.value, props2.popupClassName, props2.dropdownClassName),
            "onChange": onChange,
            "onOpenChange": onOpenChange,
            "onFocus": onFocus,
            "onBlur": onBlur,
            "onPanelChange": onPanelChange,
            "onOk": onOk
          }), null));
        };
      }
    });
  }
  const DatePicker2 = getPicker(void 0, "ADatePicker");
  const WeekPicker2 = getPicker("week", "AWeekPicker");
  const MonthPicker2 = getPicker("month", "AMonthPicker");
  const YearPicker2 = getPicker("year", "AYearPicker");
  const TimePicker2 = getPicker("time", "TimePicker");
  const QuarterPicker2 = getPicker("quarter", "AQuarterPicker");
  return {
    DatePicker: DatePicker2,
    WeekPicker: WeekPicker2,
    MonthPicker: MonthPicker2,
    YearPicker: YearPicker2,
    TimePicker: TimePicker2,
    QuarterPicker: QuarterPicker2
  };
}
var __rest$D = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
function generateRangePicker(generateConfig2, extraProps) {
  const RangePicker2 = defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "ARangePicker",
    inheritAttrs: false,
    props: _extends$1(_extends$1(_extends$1({}, commonProps()), rangePickerProps()), extraProps),
    slots: Object,
    setup(_props, _ref) {
      let {
        expose,
        slots,
        attrs,
        emit
      } = _ref;
      const props2 = _props;
      const formItemContext = useInjectFormItemContext();
      const formItemInputContext = FormItemInputContext.useInject();
      const {
        prefixCls,
        direction,
        getPopupContainer,
        size,
        rootPrefixCls,
        disabled
      } = useConfigInject("picker", props2);
      const {
        compactSize,
        compactItemClassnames
      } = useCompactItemContext(prefixCls, direction);
      const mergedSize = computed(() => compactSize.value || size.value);
      const [wrapSSR, hashId] = useStyle$v(prefixCls);
      const pickerRef = ref();
      expose({
        focus: () => {
          var _a2;
          (_a2 = pickerRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
        },
        blur: () => {
          var _a2;
          (_a2 = pickerRef.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
        }
      });
      const maybeToStrings = (dates) => {
        return props2.valueFormat ? generateConfig2.toString(dates, props2.valueFormat) : dates;
      };
      const onChange = (dates, dateStrings) => {
        const values = maybeToStrings(dates);
        emit("update:value", values);
        emit("change", values, dateStrings);
        formItemContext.onFieldChange();
      };
      const onOpenChange = (open2) => {
        emit("update:open", open2);
        emit("openChange", open2);
      };
      const onFocus = (e2) => {
        emit("focus", e2);
      };
      const onBlur = (e2) => {
        emit("blur", e2);
        formItemContext.onFieldBlur();
      };
      const onPanelChange = (dates, modes) => {
        const values = maybeToStrings(dates);
        emit("panelChange", values, modes);
      };
      const onOk = (dates) => {
        const value2 = maybeToStrings(dates);
        emit("ok", value2);
      };
      const onCalendarChange = (dates, dateStrings, info) => {
        const values = maybeToStrings(dates);
        emit("calendarChange", values, dateStrings, info);
      };
      const [contextLocale] = useLocaleReceiver("DatePicker", locale$1);
      const value = computed(() => {
        if (props2.value) {
          return props2.valueFormat ? generateConfig2.toDate(props2.value, props2.valueFormat) : props2.value;
        }
        return props2.value;
      });
      const defaultValue = computed(() => {
        if (props2.defaultValue) {
          return props2.valueFormat ? generateConfig2.toDate(props2.defaultValue, props2.valueFormat) : props2.defaultValue;
        }
        return props2.defaultValue;
      });
      const defaultPickerValue = computed(() => {
        if (props2.defaultPickerValue) {
          return props2.valueFormat ? generateConfig2.toDate(props2.defaultPickerValue, props2.valueFormat) : props2.defaultPickerValue;
        }
        return props2.defaultPickerValue;
      });
      return () => {
        var _a2, _b, _c, _d, _e, _f, _g;
        const locale2 = _extends$1(_extends$1({}, contextLocale.value), props2.locale);
        const p = _extends$1(_extends$1({}, props2), attrs);
        const {
          prefixCls: customizePrefixCls,
          bordered = true,
          placeholder,
          suffixIcon = (_a2 = slots.suffixIcon) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
          picker = "date",
          transitionName: transitionName2,
          allowClear = true,
          dateRender = slots.dateRender,
          renderExtraFooter = slots.renderExtraFooter,
          separator = (_b = slots.separator) === null || _b === void 0 ? void 0 : _b.call(slots),
          clearIcon = (_c = slots.clearIcon) === null || _c === void 0 ? void 0 : _c.call(slots),
          id = formItemContext.id.value
        } = p, restProps = __rest$D(p, ["prefixCls", "bordered", "placeholder", "suffixIcon", "picker", "transitionName", "allowClear", "dateRender", "renderExtraFooter", "separator", "clearIcon", "id"]);
        delete restProps["onUpdate:value"];
        delete restProps["onUpdate:open"];
        const {
          format: format2,
          showTime
        } = p;
        let additionalOverrideProps = {};
        additionalOverrideProps = _extends$1(_extends$1(_extends$1({}, additionalOverrideProps), showTime ? getTimeProps(_extends$1({
          format: format2,
          picker
        }, showTime)) : {}), picker === "time" ? getTimeProps(_extends$1(_extends$1({
          format: format2
        }, omit$1(restProps, ["disabledTime"])), {
          picker
        })) : {});
        const pre = prefixCls.value;
        const suffixNode = createVNode(Fragment, null, [suffixIcon || (picker === "time" ? createVNode(ClockCircleOutlined, null, null) : createVNode(CalendarOutlined, null, null)), formItemInputContext.hasFeedback && formItemInputContext.feedbackIcon]);
        return wrapSSR(createVNode(InterRangerPicker, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
          "dateRender": dateRender,
          "renderExtraFooter": renderExtraFooter,
          "separator": separator || createVNode("span", {
            "aria-label": "to",
            "class": `${pre}-separator`
          }, [createVNode(SwapRightOutlined, null, null)]),
          "ref": pickerRef,
          "dropdownAlign": transPlacement2DropdownAlign(direction.value, props2.placement),
          "placeholder": getRangePlaceholder(locale2, picker, placeholder),
          "suffixIcon": suffixNode,
          "clearIcon": clearIcon || createVNode(CloseCircleFilled, null, null),
          "allowClear": allowClear,
          "transitionName": transitionName2 || `${rootPrefixCls.value}-slide-up`
        }, restProps), additionalOverrideProps), {}, {
          "disabled": disabled.value,
          "id": id,
          "value": value.value,
          "defaultValue": defaultValue.value,
          "defaultPickerValue": defaultPickerValue.value,
          "picker": picker,
          "class": classNames({
            [`${pre}-${mergedSize.value}`]: mergedSize.value,
            [`${pre}-borderless`]: !bordered
          }, getStatusClassNames(pre, getMergedStatus(formItemInputContext.status, props2.status), formItemInputContext.hasFeedback), attrs.class, hashId.value, compactItemClassnames.value),
          "locale": locale2.lang,
          "prefixCls": pre,
          "getPopupContainer": attrs.getCalendarContainer || getPopupContainer.value,
          "generateConfig": generateConfig2,
          "prevIcon": ((_d = slots.prevIcon) === null || _d === void 0 ? void 0 : _d.call(slots)) || createVNode("span", {
            "class": `${pre}-prev-icon`
          }, null),
          "nextIcon": ((_e = slots.nextIcon) === null || _e === void 0 ? void 0 : _e.call(slots)) || createVNode("span", {
            "class": `${pre}-next-icon`
          }, null),
          "superPrevIcon": ((_f = slots.superPrevIcon) === null || _f === void 0 ? void 0 : _f.call(slots)) || createVNode("span", {
            "class": `${pre}-super-prev-icon`
          }, null),
          "superNextIcon": ((_g = slots.superNextIcon) === null || _g === void 0 ? void 0 : _g.call(slots)) || createVNode("span", {
            "class": `${pre}-super-next-icon`
          }, null),
          "components": Components,
          "direction": direction.value,
          "dropdownClassName": classNames(hashId.value, props2.popupClassName, props2.dropdownClassName),
          "onChange": onChange,
          "onOpenChange": onOpenChange,
          "onFocus": onFocus,
          "onBlur": onBlur,
          "onPanelChange": onPanelChange,
          "onOk": onOk,
          "onCalendarChange": onCalendarChange
        }), null));
      };
    }
  });
  return RangePicker2;
}
const Components = {
  button: PickerButton,
  rangeItem: PickerTag
};
function toArray$2(list) {
  if (!list) {
    return [];
  }
  return Array.isArray(list) ? list : [list];
}
function getTimeProps(props2) {
  const {
    format: format2,
    picker,
    showHour,
    showMinute,
    showSecond,
    use12Hours
  } = props2;
  const firstFormat = toArray$2(format2)[0];
  const showTimeObj = _extends$1({}, props2);
  if (firstFormat && typeof firstFormat === "string") {
    if (!firstFormat.includes("s") && showSecond === void 0) {
      showTimeObj.showSecond = false;
    }
    if (!firstFormat.includes("m") && showMinute === void 0) {
      showTimeObj.showMinute = false;
    }
    if (!firstFormat.includes("H") && !firstFormat.includes("h") && showHour === void 0) {
      showTimeObj.showHour = false;
    }
    if ((firstFormat.includes("a") || firstFormat.includes("A")) && use12Hours === void 0) {
      showTimeObj.use12Hours = true;
    }
  }
  if (picker === "time") {
    return showTimeObj;
  }
  if (typeof firstFormat === "function") {
    delete showTimeObj.format;
  }
  return {
    showTime: showTimeObj
  };
}
function generatePicker(generateConfig2, extraProps) {
  const {
    DatePicker: DatePicker2,
    WeekPicker: WeekPicker2,
    MonthPicker: MonthPicker2,
    YearPicker: YearPicker2,
    TimePicker: TimePicker2,
    QuarterPicker: QuarterPicker2
  } = generateSinglePicker(generateConfig2, extraProps);
  const RangePicker2 = generateRangePicker(generateConfig2, extraProps);
  return {
    DatePicker: DatePicker2,
    WeekPicker: WeekPicker2,
    MonthPicker: MonthPicker2,
    YearPicker: YearPicker2,
    TimePicker: TimePicker2,
    QuarterPicker: QuarterPicker2,
    RangePicker: RangePicker2
  };
}
const {
  DatePicker,
  WeekPicker,
  MonthPicker,
  YearPicker,
  TimePicker: TimePicker$2,
  QuarterPicker,
  RangePicker
} = generatePicker(generateConfig);
const DatePicker$1 = _extends$1(DatePicker, {
  WeekPicker,
  MonthPicker,
  YearPicker,
  RangePicker,
  TimePicker: TimePicker$2,
  QuarterPicker,
  install: (app) => {
    app.component(DatePicker.name, DatePicker);
    app.component(RangePicker.name, RangePicker);
    app.component(MonthPicker.name, MonthPicker);
    app.component(WeekPicker.name, WeekPicker);
    app.component(QuarterPicker.name, QuarterPicker);
    return app;
  }
});
const genSharedDividerStyle = (token2) => {
  const {
    componentCls,
    sizePaddingEdgeHorizontal,
    colorSplit,
    lineWidth
  } = token2;
  return {
    [componentCls]: _extends$1(_extends$1({}, resetComponent(token2)), {
      borderBlockStart: `${lineWidth}px solid ${colorSplit}`,
      // vertical
      "&-vertical": {
        position: "relative",
        top: "-0.06em",
        display: "inline-block",
        height: "0.9em",
        margin: `0 ${token2.dividerVerticalGutterMargin}px`,
        verticalAlign: "middle",
        borderTop: 0,
        borderInlineStart: `${lineWidth}px solid ${colorSplit}`
      },
      "&-horizontal": {
        display: "flex",
        clear: "both",
        width: "100%",
        minWidth: "100%",
        margin: `${token2.dividerHorizontalGutterMargin}px 0`
      },
      [`&-horizontal${componentCls}-with-text`]: {
        display: "flex",
        alignItems: "center",
        margin: `${token2.dividerHorizontalWithTextGutterMargin}px 0`,
        color: token2.colorTextHeading,
        fontWeight: 500,
        fontSize: token2.fontSizeLG,
        whiteSpace: "nowrap",
        textAlign: "center",
        borderBlockStart: `0 ${colorSplit}`,
        "&::before, &::after": {
          position: "relative",
          width: "50%",
          borderBlockStart: `${lineWidth}px solid transparent`,
          // Chrome not accept `inherit` in `border-top`
          borderBlockStartColor: "inherit",
          borderBlockEnd: 0,
          transform: "translateY(50%)",
          content: "''"
        }
      },
      [`&-horizontal${componentCls}-with-text-left`]: {
        "&::before": {
          width: "5%"
        },
        "&::after": {
          width: "95%"
        }
      },
      [`&-horizontal${componentCls}-with-text-right`]: {
        "&::before": {
          width: "95%"
        },
        "&::after": {
          width: "5%"
        }
      },
      [`${componentCls}-inner-text`]: {
        display: "inline-block",
        padding: "0 1em"
      },
      "&-dashed": {
        background: "none",
        borderColor: colorSplit,
        borderStyle: "dashed",
        borderWidth: `${lineWidth}px 0 0`
      },
      [`&-horizontal${componentCls}-with-text${componentCls}-dashed`]: {
        "&::before, &::after": {
          borderStyle: "dashed none none"
        }
      },
      [`&-vertical${componentCls}-dashed`]: {
        borderInlineStartWidth: lineWidth,
        borderInlineEnd: 0,
        borderBlockStart: 0,
        borderBlockEnd: 0
      },
      [`&-plain${componentCls}-with-text`]: {
        color: token2.colorText,
        fontWeight: "normal",
        fontSize: token2.fontSize
      },
      [`&-horizontal${componentCls}-with-text-left${componentCls}-no-default-orientation-margin-left`]: {
        "&::before": {
          width: 0
        },
        "&::after": {
          width: "100%"
        },
        [`${componentCls}-inner-text`]: {
          paddingInlineStart: sizePaddingEdgeHorizontal
        }
      },
      [`&-horizontal${componentCls}-with-text-right${componentCls}-no-default-orientation-margin-right`]: {
        "&::before": {
          width: "100%"
        },
        "&::after": {
          width: 0
        },
        [`${componentCls}-inner-text`]: {
          paddingInlineEnd: sizePaddingEdgeHorizontal
        }
      }
    })
  };
};
const useStyle$j = genComponentStyleHook("Divider", (token2) => {
  const dividerToken = merge(token2, {
    dividerVerticalGutterMargin: token2.marginXS,
    dividerHorizontalWithTextGutterMargin: token2.margin,
    dividerHorizontalGutterMargin: token2.marginLG
  });
  return [genSharedDividerStyle(dividerToken)];
}, {
  sizePaddingEdgeHorizontal: 0
});
const dividerProps = () => ({
  prefixCls: String,
  type: {
    type: String,
    default: "horizontal"
  },
  dashed: {
    type: Boolean,
    default: false
  },
  orientation: {
    type: String,
    default: "center"
  },
  plain: {
    type: Boolean,
    default: false
  },
  orientationMargin: [String, Number]
});
const Divider = defineComponent({
  name: "ADivider",
  inheritAttrs: false,
  compatConfig: {
    MODE: 3
  },
  props: dividerProps(),
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const {
      prefixCls: prefixClsRef,
      direction
    } = useConfigInject("divider", props2);
    const [wrapSSR, hashId] = useStyle$j(prefixClsRef);
    const hasCustomMarginLeft = computed(() => props2.orientation === "left" && props2.orientationMargin != null);
    const hasCustomMarginRight = computed(() => props2.orientation === "right" && props2.orientationMargin != null);
    const classString = computed(() => {
      const {
        type: type4,
        dashed,
        plain
      } = props2;
      const prefixCls = prefixClsRef.value;
      return {
        [prefixCls]: true,
        [hashId.value]: !!hashId.value,
        [`${prefixCls}-${type4}`]: true,
        [`${prefixCls}-dashed`]: !!dashed,
        [`${prefixCls}-plain`]: !!plain,
        [`${prefixCls}-rtl`]: direction.value === "rtl",
        [`${prefixCls}-no-default-orientation-margin-left`]: hasCustomMarginLeft.value,
        [`${prefixCls}-no-default-orientation-margin-right`]: hasCustomMarginRight.value
      };
    });
    const innerStyle = computed(() => {
      const marginValue = typeof props2.orientationMargin === "number" ? `${props2.orientationMargin}px` : props2.orientationMargin;
      return _extends$1(_extends$1({}, hasCustomMarginLeft.value && {
        marginLeft: marginValue
      }), hasCustomMarginRight.value && {
        marginRight: marginValue
      });
    });
    const orientationPrefix = computed(() => props2.orientation.length > 0 ? "-" + props2.orientation : props2.orientation);
    return () => {
      var _a2;
      const children = flattenChildren((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots));
      return wrapSSR(createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "class": [classString.value, children.length ? `${prefixClsRef.value}-with-text ${prefixClsRef.value}-with-text${orientationPrefix.value}` : "", attrs.class],
        "role": "separator"
      }), [children.length ? createVNode("span", {
        "class": `${prefixClsRef.value}-inner-text`,
        "style": innerStyle.value
      }, [children]) : null]));
    };
  }
});
const Divider$1 = withInstall(Divider);
Dropdown.Button = DropdownButton;
Dropdown.install = function(app) {
  app.component(Dropdown.name, Dropdown);
  app.component(DropdownButton.name, DropdownButton);
  return app;
};
const props = () => ({
  prefixCls: String,
  width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  height: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  style: {
    type: Object,
    default: void 0
  },
  class: String,
  rootClassName: String,
  rootStyle: objectType(),
  placement: {
    type: String
  },
  wrapperClassName: String,
  level: {
    type: [String, Array]
  },
  levelMove: {
    type: [Number, Function, Array]
  },
  duration: String,
  ease: String,
  showMask: {
    type: Boolean,
    default: void 0
  },
  maskClosable: {
    type: Boolean,
    default: void 0
  },
  maskStyle: {
    type: Object,
    default: void 0
  },
  afterVisibleChange: Function,
  keyboard: {
    type: Boolean,
    default: void 0
  },
  contentWrapperStyle: arrayType(),
  autofocus: {
    type: Boolean,
    default: void 0
  },
  open: {
    type: Boolean,
    default: void 0
  },
  // Motion
  motion: functionType(),
  maskMotion: objectType()
});
const drawerProps$1 = () => _extends$1(_extends$1({}, props()), {
  forceRender: {
    type: Boolean,
    default: void 0
  },
  getContainer: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.object, PropTypes.looseBool])
});
const drawerChildProps = () => _extends$1(_extends$1({}, props()), {
  getContainer: Function,
  getOpenCount: Function,
  scrollLocker: PropTypes.any,
  inline: Boolean
});
function dataToArray(vars) {
  if (Array.isArray(vars)) {
    return vars;
  }
  return [vars];
}
const transitionEndObject = {
  transition: "transitionend",
  WebkitTransition: "webkitTransitionEnd",
  MozTransition: "transitionend",
  OTransition: "oTransitionEnd otransitionend"
};
Object.keys(transitionEndObject).filter((key2) => {
  if (typeof document === "undefined") {
    return false;
  }
  const html = document.getElementsByTagName("html")[0];
  return key2 in (html ? html.style : {});
})[0];
const windowIsUndefined = !(typeof window !== "undefined" && window.document && window.document.createElement);
var __rest$C = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const DrawerChild = defineComponent({
  compatConfig: {
    MODE: 3
  },
  inheritAttrs: false,
  props: drawerChildProps(),
  emits: ["close", "handleClick", "change"],
  setup(props2, _ref) {
    let {
      emit,
      slots
    } = _ref;
    const contentWrapper = shallowRef();
    const dom = shallowRef();
    const maskDom = shallowRef();
    const handlerDom = shallowRef();
    const contentDom = shallowRef();
    let levelDom = [];
    `drawer_id_${Number((Date.now() + Math.random()).toString().replace(".", Math.round(Math.random() * 9).toString())).toString(16)}`;
    onMounted(() => {
      nextTick(() => {
        var _a2;
        const {
          open: open2,
          getContainer: getContainer2,
          showMask,
          autofocus
        } = props2;
        const container = getContainer2 === null || getContainer2 === void 0 ? void 0 : getContainer2();
        getLevelDom(props2);
        if (open2) {
          if (container && container.parentNode === document.body) ;
          nextTick(() => {
            if (autofocus) {
              domFocus();
            }
          });
          if (showMask) {
            (_a2 = props2.scrollLocker) === null || _a2 === void 0 ? void 0 : _a2.lock();
          }
        }
      });
    });
    watch(() => props2.level, () => {
      getLevelDom(props2);
    }, {
      flush: "post"
    });
    watch(() => props2.open, () => {
      const {
        open: open2,
        getContainer: getContainer2,
        scrollLocker,
        showMask,
        autofocus
      } = props2;
      const container = getContainer2 === null || getContainer2 === void 0 ? void 0 : getContainer2();
      if (container && container.parentNode === document.body) ;
      if (open2) {
        if (autofocus) {
          domFocus();
        }
        if (showMask) {
          scrollLocker === null || scrollLocker === void 0 ? void 0 : scrollLocker.lock();
        }
      } else {
        scrollLocker === null || scrollLocker === void 0 ? void 0 : scrollLocker.unLock();
      }
    }, {
      flush: "post"
    });
    onUnmounted(() => {
      var _a2;
      const {
        open: open2
      } = props2;
      if (open2) {
        document.body.style.touchAction = "";
      }
      (_a2 = props2.scrollLocker) === null || _a2 === void 0 ? void 0 : _a2.unLock();
    });
    watch(() => props2.placement, (val) => {
      if (val) {
        contentDom.value = null;
      }
    });
    const domFocus = () => {
      var _a2, _b;
      (_b = (_a2 = dom.value) === null || _a2 === void 0 ? void 0 : _a2.focus) === null || _b === void 0 ? void 0 : _b.call(_a2);
    };
    const onClose = (e2) => {
      emit("close", e2);
    };
    const onKeyDown2 = (e2) => {
      if (e2.keyCode === KeyCode.ESC) {
        e2.stopPropagation();
        onClose(e2);
      }
    };
    const onAfterVisibleChange = () => {
      const {
        open: open2,
        afterVisibleChange
      } = props2;
      if (afterVisibleChange) {
        afterVisibleChange(!!open2);
      }
    };
    const getLevelDom = (_ref2) => {
      let {
        level,
        getContainer: getContainer2
      } = _ref2;
      if (windowIsUndefined) {
        return;
      }
      const container = getContainer2 === null || getContainer2 === void 0 ? void 0 : getContainer2();
      const parent2 = container ? container.parentNode : null;
      levelDom = [];
      if (level === "all") {
        const children = parent2 ? Array.prototype.slice.call(parent2.children) : [];
        children.forEach((child) => {
          if (child.nodeName !== "SCRIPT" && child.nodeName !== "STYLE" && child.nodeName !== "LINK" && child !== container) {
            levelDom.push(child);
          }
        });
      } else if (level) {
        dataToArray(level).forEach((key2) => {
          document.querySelectorAll(key2).forEach((item) => {
            levelDom.push(item);
          });
        });
      }
    };
    const onHandleClick = (e2) => {
      emit("handleClick", e2);
    };
    const canOpen = shallowRef(false);
    watch(dom, () => {
      nextTick(() => {
        canOpen.value = true;
      });
    });
    return () => {
      var _a2, _b;
      const {
        width,
        height,
        open: $open,
        prefixCls,
        placement,
        level,
        levelMove,
        ease,
        duration,
        getContainer: getContainer2,
        onChange,
        afterVisibleChange,
        showMask,
        maskClosable,
        maskStyle,
        keyboard,
        getOpenCount,
        scrollLocker,
        contentWrapperStyle,
        style,
        class: className,
        rootClassName,
        rootStyle,
        maskMotion,
        motion,
        inline
      } = props2, otherProps = __rest$C(props2, ["width", "height", "open", "prefixCls", "placement", "level", "levelMove", "ease", "duration", "getContainer", "onChange", "afterVisibleChange", "showMask", "maskClosable", "maskStyle", "keyboard", "getOpenCount", "scrollLocker", "contentWrapperStyle", "style", "class", "rootClassName", "rootStyle", "maskMotion", "motion", "inline"]);
      const open2 = $open && canOpen.value;
      const wrapperClassName = classNames(prefixCls, {
        [`${prefixCls}-${placement}`]: true,
        [`${prefixCls}-open`]: open2,
        [`${prefixCls}-inline`]: inline,
        "no-mask": !showMask,
        [rootClassName]: true
      });
      const motionProps = typeof motion === "function" ? motion(placement) : motion;
      return createVNode("div", _objectSpread2$1(_objectSpread2$1({}, omit$1(otherProps, ["autofocus"])), {}, {
        "tabindex": -1,
        "class": wrapperClassName,
        "style": rootStyle,
        "ref": dom,
        "onKeydown": open2 && keyboard ? onKeyDown2 : void 0
      }), [createVNode(Transition, maskMotion, {
        default: () => [showMask && withDirectives(createVNode("div", {
          "class": `${prefixCls}-mask`,
          "onClick": maskClosable ? onClose : void 0,
          "style": maskStyle,
          "ref": maskDom
        }, null), [[vShow, open2]])]
      }), createVNode(Transition, _objectSpread2$1(_objectSpread2$1({}, motionProps), {}, {
        "onAfterEnter": onAfterVisibleChange,
        "onAfterLeave": onAfterVisibleChange
      }), {
        default: () => [withDirectives(createVNode("div", {
          "class": `${prefixCls}-content-wrapper`,
          "style": [contentWrapperStyle],
          "ref": contentWrapper
        }, [createVNode("div", {
          "class": [`${prefixCls}-content`, className],
          "style": style,
          "ref": contentDom
        }, [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]), slots.handler ? createVNode("div", {
          "onClick": onHandleClick,
          "ref": handlerDom
        }, [(_b = slots.handler) === null || _b === void 0 ? void 0 : _b.call(slots)]) : null]), [[vShow, open2]])]
      })]);
    };
  }
});
var __rest$B = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const DrawerWrapper = defineComponent({
  compatConfig: {
    MODE: 3
  },
  inheritAttrs: false,
  props: initDefaultProps(drawerProps$1(), {
    prefixCls: "drawer",
    placement: "left",
    getContainer: "body",
    level: "all",
    duration: ".3s",
    ease: "cubic-bezier(0.78, 0.14, 0.15, 0.86)",
    afterVisibleChange: () => {
    },
    showMask: true,
    maskClosable: true,
    maskStyle: {},
    wrapperClassName: "",
    keyboard: true,
    forceRender: false,
    autofocus: true
  }),
  emits: ["handleClick", "close"],
  setup(props2, _ref) {
    let {
      emit,
      slots
    } = _ref;
    const dom = ref(null);
    const onHandleClick = (e2) => {
      emit("handleClick", e2);
    };
    const onClose = (e2) => {
      emit("close", e2);
    };
    return () => {
      const {
        getContainer: getContainer2,
        wrapperClassName,
        rootClassName,
        rootStyle,
        forceRender
      } = props2, otherProps = __rest$B(props2, ["getContainer", "wrapperClassName", "rootClassName", "rootStyle", "forceRender"]);
      let portal = null;
      if (!getContainer2) {
        return createVNode(DrawerChild, _objectSpread2$1(_objectSpread2$1({}, otherProps), {}, {
          "rootClassName": rootClassName,
          "rootStyle": rootStyle,
          "open": props2.open,
          "onClose": onClose,
          "onHandleClick": onHandleClick,
          "inline": true
        }), slots);
      }
      const $forceRender = !!slots.handler || forceRender;
      if ($forceRender || props2.open || dom.value) {
        portal = createVNode(Portal, {
          "autoLock": true,
          "visible": props2.open,
          "forceRender": $forceRender,
          "getContainer": getContainer2,
          "wrapperClassName": wrapperClassName
        }, {
          default: (_a2) => {
            var {
              visible,
              afterClose
            } = _a2, rest = __rest$B(_a2, ["visible", "afterClose"]);
            return createVNode(DrawerChild, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
              "ref": dom
            }, otherProps), rest), {}, {
              "rootClassName": rootClassName,
              "rootStyle": rootStyle,
              "open": visible !== void 0 ? visible : props2.open,
              "afterVisibleChange": afterClose !== void 0 ? afterClose : props2.afterVisibleChange,
              "onClose": onClose,
              "onHandleClick": onHandleClick
            }), slots);
          }
        });
      }
      return portal;
    };
  }
});
const genMotionStyle$1 = (token2) => {
  const {
    componentCls,
    motionDurationSlow
  } = token2;
  const sharedPanelMotion = {
    "&-enter, &-appear, &-leave": {
      "&-start": {
        transition: "none"
      },
      "&-active": {
        transition: `all ${motionDurationSlow}`
      }
    }
  };
  return {
    [componentCls]: {
      // ======================== Mask ========================
      [`${componentCls}-mask-motion`]: {
        "&-enter, &-appear, &-leave": {
          "&-active": {
            transition: `all ${motionDurationSlow}`
          }
        },
        "&-enter, &-appear": {
          opacity: 0,
          "&-active": {
            opacity: 1
          }
        },
        "&-leave": {
          opacity: 1,
          "&-active": {
            opacity: 0
          }
        }
      },
      // ======================= Panel ========================
      [`${componentCls}-panel-motion`]: {
        // Left
        "&-left": [sharedPanelMotion, {
          "&-enter, &-appear": {
            "&-start": {
              transform: "translateX(-100%) !important"
            },
            "&-active": {
              transform: "translateX(0)"
            }
          },
          "&-leave": {
            transform: "translateX(0)",
            "&-active": {
              transform: "translateX(-100%)"
            }
          }
        }],
        // Right
        "&-right": [sharedPanelMotion, {
          "&-enter, &-appear": {
            "&-start": {
              transform: "translateX(100%) !important"
            },
            "&-active": {
              transform: "translateX(0)"
            }
          },
          "&-leave": {
            transform: "translateX(0)",
            "&-active": {
              transform: "translateX(100%)"
            }
          }
        }],
        // Top
        "&-top": [sharedPanelMotion, {
          "&-enter, &-appear": {
            "&-start": {
              transform: "translateY(-100%) !important"
            },
            "&-active": {
              transform: "translateY(0)"
            }
          },
          "&-leave": {
            transform: "translateY(0)",
            "&-active": {
              transform: "translateY(-100%)"
            }
          }
        }],
        // Bottom
        "&-bottom": [sharedPanelMotion, {
          "&-enter, &-appear": {
            "&-start": {
              transform: "translateY(100%) !important"
            },
            "&-active": {
              transform: "translateY(0)"
            }
          },
          "&-leave": {
            transform: "translateY(0)",
            "&-active": {
              transform: "translateY(100%)"
            }
          }
        }]
      }
    }
  };
};
const genDrawerStyle = (token2) => {
  const {
    componentCls,
    zIndexPopup,
    colorBgMask,
    colorBgElevated,
    motionDurationSlow,
    motionDurationMid,
    padding,
    paddingLG,
    fontSizeLG,
    lineHeightLG,
    lineWidth,
    lineType,
    colorSplit,
    marginSM,
    colorIcon,
    colorIconHover,
    colorText,
    fontWeightStrong,
    drawerFooterPaddingVertical,
    drawerFooterPaddingHorizontal
  } = token2;
  const wrapperCls = `${componentCls}-content-wrapper`;
  return {
    [componentCls]: {
      position: "fixed",
      inset: 0,
      zIndex: zIndexPopup,
      pointerEvents: "none",
      "&-pure": {
        position: "relative",
        background: colorBgElevated,
        [`&${componentCls}-left`]: {
          boxShadow: token2.boxShadowDrawerLeft
        },
        [`&${componentCls}-right`]: {
          boxShadow: token2.boxShadowDrawerRight
        },
        [`&${componentCls}-top`]: {
          boxShadow: token2.boxShadowDrawerUp
        },
        [`&${componentCls}-bottom`]: {
          boxShadow: token2.boxShadowDrawerDown
        }
      },
      "&-inline": {
        position: "absolute"
      },
      // ====================== Mask ======================
      [`${componentCls}-mask`]: {
        position: "absolute",
        inset: 0,
        zIndex: zIndexPopup,
        background: colorBgMask,
        pointerEvents: "auto"
      },
      // ==================== Content =====================
      [wrapperCls]: {
        position: "absolute",
        zIndex: zIndexPopup,
        transition: `all ${motionDurationSlow}`,
        "&-hidden": {
          display: "none"
        }
      },
      // Placement
      [`&-left > ${wrapperCls}`]: {
        top: 0,
        bottom: 0,
        left: {
          _skip_check_: true,
          value: 0
        },
        boxShadow: token2.boxShadowDrawerLeft
      },
      [`&-right > ${wrapperCls}`]: {
        top: 0,
        right: {
          _skip_check_: true,
          value: 0
        },
        bottom: 0,
        boxShadow: token2.boxShadowDrawerRight
      },
      [`&-top > ${wrapperCls}`]: {
        top: 0,
        insetInline: 0,
        boxShadow: token2.boxShadowDrawerUp
      },
      [`&-bottom > ${wrapperCls}`]: {
        bottom: 0,
        insetInline: 0,
        boxShadow: token2.boxShadowDrawerDown
      },
      [`${componentCls}-content`]: {
        width: "100%",
        height: "100%",
        overflow: "auto",
        background: colorBgElevated,
        pointerEvents: "auto"
      },
      // ===================== Panel ======================
      [`${componentCls}-wrapper-body`]: {
        display: "flex",
        flexDirection: "column",
        width: "100%",
        height: "100%"
      },
      // Header
      [`${componentCls}-header`]: {
        display: "flex",
        flex: 0,
        alignItems: "center",
        padding: `${padding}px ${paddingLG}px`,
        fontSize: fontSizeLG,
        lineHeight: lineHeightLG,
        borderBottom: `${lineWidth}px ${lineType} ${colorSplit}`,
        "&-title": {
          display: "flex",
          flex: 1,
          alignItems: "center",
          minWidth: 0,
          minHeight: 0
        }
      },
      [`${componentCls}-extra`]: {
        flex: "none"
      },
      [`${componentCls}-close`]: {
        display: "inline-block",
        marginInlineEnd: marginSM,
        color: colorIcon,
        fontWeight: fontWeightStrong,
        fontSize: fontSizeLG,
        fontStyle: "normal",
        lineHeight: 1,
        textAlign: "center",
        textTransform: "none",
        textDecoration: "none",
        background: "transparent",
        border: 0,
        outline: 0,
        cursor: "pointer",
        transition: `color ${motionDurationMid}`,
        textRendering: "auto",
        "&:focus, &:hover": {
          color: colorIconHover,
          textDecoration: "none"
        }
      },
      [`${componentCls}-title`]: {
        flex: 1,
        margin: 0,
        color: colorText,
        fontWeight: token2.fontWeightStrong,
        fontSize: fontSizeLG,
        lineHeight: lineHeightLG
      },
      // Body
      [`${componentCls}-body`]: {
        flex: 1,
        minWidth: 0,
        minHeight: 0,
        padding: paddingLG,
        overflow: "auto"
      },
      // Footer
      [`${componentCls}-footer`]: {
        flexShrink: 0,
        padding: `${drawerFooterPaddingVertical}px ${drawerFooterPaddingHorizontal}px`,
        borderTop: `${lineWidth}px ${lineType} ${colorSplit}`
      },
      // ====================== RTL =======================
      "&-rtl": {
        direction: "rtl"
      }
    }
  };
};
const useStyle$i = genComponentStyleHook("Drawer", (token2) => {
  const drawerToken = merge(token2, {
    drawerFooterPaddingVertical: token2.paddingXS,
    drawerFooterPaddingHorizontal: token2.padding
  });
  return [genDrawerStyle(drawerToken), genMotionStyle$1(drawerToken)];
}, (token2) => ({
  zIndexPopup: token2.zIndexPopupBase
}));
var __rest$A = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const PlacementTypes = ["top", "right", "bottom", "left"];
const defaultPushState = {
  distance: 180
};
const drawerProps = () => ({
  autofocus: {
    type: Boolean,
    default: void 0
  },
  closable: {
    type: Boolean,
    default: void 0
  },
  closeIcon: PropTypes.any,
  destroyOnClose: {
    type: Boolean,
    default: void 0
  },
  forceRender: {
    type: Boolean,
    default: void 0
  },
  getContainer: {
    type: [String, Function, Boolean, Object],
    default: void 0
  },
  maskClosable: {
    type: Boolean,
    default: void 0
  },
  mask: {
    type: Boolean,
    default: void 0
  },
  maskStyle: objectType(),
  rootClassName: String,
  rootStyle: objectType(),
  size: {
    type: String
  },
  drawerStyle: objectType(),
  headerStyle: objectType(),
  bodyStyle: objectType(),
  contentWrapperStyle: {
    type: Object,
    default: void 0
  },
  title: PropTypes.any,
  /** @deprecated Please use `open` instead */
  visible: {
    type: Boolean,
    default: void 0
  },
  open: {
    type: Boolean,
    default: void 0
  },
  width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  height: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  zIndex: Number,
  prefixCls: String,
  push: PropTypes.oneOfType([PropTypes.looseBool, {
    type: Object
  }]),
  placement: PropTypes.oneOf(PlacementTypes),
  keyboard: {
    type: Boolean,
    default: void 0
  },
  extra: PropTypes.any,
  footer: PropTypes.any,
  footerStyle: objectType(),
  level: PropTypes.any,
  levelMove: {
    type: [Number, Array, Function]
  },
  handle: PropTypes.any,
  /** @deprecated Use `@afterVisibleChange` instead */
  afterVisibleChange: Function,
  /** @deprecated Please use `@afterOpenChange` instead */
  onAfterVisibleChange: Function,
  onAfterOpenChange: Function,
  /** @deprecated Please use `onUpdate:open` instead */
  "onUpdate:visible": Function,
  "onUpdate:open": Function,
  onClose: Function
});
const Drawer = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ADrawer",
  inheritAttrs: false,
  props: initDefaultProps(drawerProps(), {
    closable: true,
    placement: "right",
    maskClosable: true,
    mask: true,
    level: null,
    keyboard: true,
    push: defaultPushState
  }),
  slots: Object,
  // emits: ['update:visible', 'close', 'afterVisibleChange'],
  setup(props2, _ref) {
    let {
      emit,
      slots,
      attrs
    } = _ref;
    const sPush = shallowRef(false);
    const destroyClose = shallowRef(false);
    const vcDrawer = shallowRef(null);
    const load = shallowRef(false);
    const visible = shallowRef(false);
    const mergedOpen = computed(() => {
      var _a2;
      return (_a2 = props2.open) !== null && _a2 !== void 0 ? _a2 : props2.visible;
    });
    watch(mergedOpen, () => {
      if (mergedOpen.value) {
        load.value = true;
      } else {
        visible.value = false;
      }
    }, {
      immediate: true
    });
    watch([mergedOpen, load], () => {
      if (mergedOpen.value && load.value) {
        visible.value = true;
      }
    }, {
      immediate: true
    });
    const parentDrawerOpts = inject("parentDrawerOpts", null);
    const {
      prefixCls,
      getPopupContainer,
      direction
    } = useConfigInject("drawer", props2);
    const [wrapSSR, hashId] = useStyle$i(prefixCls);
    const getContainer2 = computed(() => (
      // 有可能为 false，所以不能直接判断
      props2.getContainer === void 0 && (getPopupContainer === null || getPopupContainer === void 0 ? void 0 : getPopupContainer.value) ? () => getPopupContainer.value(document.body) : props2.getContainer
    ));
    devWarning(!props2.afterVisibleChange, "Drawer", "`afterVisibleChange` prop is deprecated, please use `@afterVisibleChange` event instead");
    const setPush = () => {
      sPush.value = true;
    };
    const setPull = () => {
      sPush.value = false;
      nextTick(() => {
        domFocus();
      });
    };
    provide("parentDrawerOpts", {
      setPush,
      setPull
    });
    onMounted(() => {
      if (mergedOpen.value && parentDrawerOpts) {
        parentDrawerOpts.setPush();
      }
    });
    onUnmounted(() => {
      if (parentDrawerOpts) {
        parentDrawerOpts.setPull();
      }
    });
    watch(visible, () => {
      if (parentDrawerOpts) {
        if (visible.value) {
          parentDrawerOpts.setPush();
        } else {
          parentDrawerOpts.setPull();
        }
      }
    }, {
      flush: "post"
    });
    const domFocus = () => {
      var _a2, _b;
      (_b = (_a2 = vcDrawer.value) === null || _a2 === void 0 ? void 0 : _a2.domFocus) === null || _b === void 0 ? void 0 : _b.call(_a2);
    };
    const close = (e2) => {
      emit("update:visible", false);
      emit("update:open", false);
      emit("close", e2);
    };
    const afterVisibleChange = (open2) => {
      var _a2;
      if (!open2) {
        if (destroyClose.value === false) {
          destroyClose.value = true;
        }
        if (props2.destroyOnClose) {
          load.value = false;
        }
      }
      (_a2 = props2.afterVisibleChange) === null || _a2 === void 0 ? void 0 : _a2.call(props2, open2);
      emit("afterVisibleChange", open2);
      emit("afterOpenChange", open2);
    };
    const pushTransform = computed(() => {
      const {
        push,
        placement
      } = props2;
      let distance;
      if (typeof push === "boolean") {
        distance = push ? defaultPushState.distance : 0;
      } else {
        distance = push.distance;
      }
      distance = parseFloat(String(distance || 0));
      if (placement === "left" || placement === "right") {
        return `translateX(${placement === "left" ? distance : -distance}px)`;
      }
      if (placement === "top" || placement === "bottom") {
        return `translateY(${placement === "top" ? distance : -distance}px)`;
      }
      return null;
    });
    const mergedWidth = computed(() => {
      var _a2;
      return (_a2 = props2.width) !== null && _a2 !== void 0 ? _a2 : props2.size === "large" ? 736 : 378;
    });
    const mergedHeight = computed(() => {
      var _a2;
      return (_a2 = props2.height) !== null && _a2 !== void 0 ? _a2 : props2.size === "large" ? 736 : 378;
    });
    const offsetStyle = computed(() => {
      const {
        mask,
        placement
      } = props2;
      if (!visible.value && !mask) {
        return {};
      }
      const val = {};
      if (placement === "left" || placement === "right") {
        val.width = isNumeric(mergedWidth.value) ? `${mergedWidth.value}px` : mergedWidth.value;
      } else {
        val.height = isNumeric(mergedHeight.value) ? `${mergedHeight.value}px` : mergedHeight.value;
      }
      return val;
    });
    const wrapperStyle2 = computed(() => {
      const {
        zIndex,
        contentWrapperStyle
      } = props2;
      const val = offsetStyle.value;
      return [{
        zIndex,
        transform: sPush.value ? pushTransform.value : void 0
      }, _extends$1({}, contentWrapperStyle), val];
    });
    const renderHeader = (prefixCls2) => {
      const {
        closable,
        headerStyle
      } = props2;
      const extra = getPropsSlot(slots, props2, "extra");
      const title = getPropsSlot(slots, props2, "title");
      if (!title && !closable) {
        return null;
      }
      return createVNode("div", {
        "class": classNames(`${prefixCls2}-header`, {
          [`${prefixCls2}-header-close-only`]: closable && !title && !extra
        }),
        "style": headerStyle
      }, [createVNode("div", {
        "class": `${prefixCls2}-header-title`
      }, [renderCloseIcon(prefixCls2), title && createVNode("div", {
        "class": `${prefixCls2}-title`
      }, [title])]), extra && createVNode("div", {
        "class": `${prefixCls2}-extra`
      }, [extra])]);
    };
    const renderCloseIcon = (prefixCls2) => {
      var _a2;
      const {
        closable
      } = props2;
      const $closeIcon = slots.closeIcon ? (_a2 = slots.closeIcon) === null || _a2 === void 0 ? void 0 : _a2.call(slots) : props2.closeIcon;
      return closable && createVNode("button", {
        "key": "closer",
        "onClick": close,
        "aria-label": "Close",
        "class": `${prefixCls2}-close`
      }, [$closeIcon === void 0 ? createVNode(CloseOutlined, null, null) : $closeIcon]);
    };
    const renderBody = (prefixCls2) => {
      var _a2;
      if (destroyClose.value && !props2.forceRender && !load.value) {
        return null;
      }
      const {
        bodyStyle,
        drawerStyle
      } = props2;
      return createVNode("div", {
        "class": `${prefixCls2}-wrapper-body`,
        "style": drawerStyle
      }, [renderHeader(prefixCls2), createVNode("div", {
        "key": "body",
        "class": `${prefixCls2}-body`,
        "style": bodyStyle
      }, [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]), renderFooter(prefixCls2)]);
    };
    const renderFooter = (prefixCls2) => {
      const footer = getPropsSlot(slots, props2, "footer");
      if (!footer) {
        return null;
      }
      const footerClassName = `${prefixCls2}-footer`;
      return createVNode("div", {
        "class": footerClassName,
        "style": props2.footerStyle
      }, [footer]);
    };
    const drawerClassName = computed(() => classNames({
      "no-mask": !props2.mask,
      [`${prefixCls.value}-rtl`]: direction.value === "rtl"
    }, props2.rootClassName, hashId.value));
    const maskMotion = computed(() => {
      return getTransitionProps(getTransitionName(prefixCls.value, "mask-motion"));
    });
    const panelMotion = (motionPlacement) => {
      return getTransitionProps(getTransitionName(prefixCls.value, `panel-motion-${motionPlacement}`));
    };
    return () => {
      const {
        width,
        height,
        placement,
        mask,
        forceRender
      } = props2, rest = __rest$A(props2, ["width", "height", "placement", "mask", "forceRender"]);
      const vcDrawerProps = _extends$1(_extends$1(_extends$1({}, attrs), omit$1(rest, ["size", "closeIcon", "closable", "destroyOnClose", "drawerStyle", "headerStyle", "bodyStyle", "title", "push", "onAfterVisibleChange", "onClose", "onUpdate:visible", "onUpdate:open", "visible"])), {
        forceRender,
        onClose: close,
        afterVisibleChange,
        handler: false,
        prefixCls: prefixCls.value,
        open: visible.value,
        showMask: mask,
        placement,
        ref: vcDrawer
      });
      return wrapSSR(createVNode(NoCompactStyle, null, {
        default: () => [createVNode(DrawerWrapper, _objectSpread2$1(_objectSpread2$1({}, vcDrawerProps), {}, {
          "maskMotion": maskMotion.value,
          "motion": panelMotion,
          "width": mergedWidth.value,
          "height": mergedHeight.value,
          "getContainer": getContainer2.value,
          "rootClassName": drawerClassName.value,
          "rootStyle": props2.rootStyle,
          "contentWrapperStyle": wrapperStyle2.value
        }), {
          handler: props2.handle ? () => props2.handle : slots.handle,
          default: () => renderBody(prefixCls.value)
        })]
      }));
    };
  }
});
const Drawer$1 = withInstall(Drawer);
const isValid$1 = (value) => {
  return value !== void 0 && value !== null && (Array.isArray(value) ? filterEmpty(value).length : true);
};
function hasPrefixSuffix(propsAndSlots) {
  return isValid$1(propsAndSlots.prefix) || isValid$1(propsAndSlots.suffix) || isValid$1(propsAndSlots.allowClear);
}
function hasAddon$1(propsAndSlots) {
  return isValid$1(propsAndSlots.addonBefore) || isValid$1(propsAndSlots.addonAfter);
}
function fixControlledValue(value) {
  if (typeof value === "undefined" || value === null) {
    return "";
  }
  return String(value);
}
function resolveOnChange(target, e2, onChange, targetValue) {
  if (!onChange) {
    return;
  }
  const event = e2;
  if (e2.type === "click") {
    Object.defineProperty(event, "target", {
      writable: true
    });
    Object.defineProperty(event, "currentTarget", {
      writable: true
    });
    const currentTarget = target.cloneNode(true);
    event.target = currentTarget;
    event.currentTarget = currentTarget;
    currentTarget.value = "";
    onChange(event);
    return;
  }
  if (targetValue !== void 0) {
    Object.defineProperty(event, "target", {
      writable: true
    });
    Object.defineProperty(event, "currentTarget", {
      writable: true
    });
    event.target = target;
    event.currentTarget = target;
    target.value = targetValue;
    onChange(event);
    return;
  }
  onChange(event);
}
function triggerFocus(element, option) {
  if (!element) return;
  element.focus(option);
  const {
    cursor
  } = option || {};
  if (cursor) {
    const len = element.value.length;
    switch (cursor) {
      case "start":
        element.setSelectionRange(0, 0);
        break;
      case "end":
        element.setSelectionRange(len, len);
        break;
      default:
        element.setSelectionRange(0, len);
    }
  }
}
const commonInputProps = () => {
  return {
    addonBefore: PropTypes.any,
    addonAfter: PropTypes.any,
    prefix: PropTypes.any,
    suffix: PropTypes.any,
    clearIcon: PropTypes.any,
    affixWrapperClassName: String,
    groupClassName: String,
    wrapperClassName: String,
    inputClassName: String,
    allowClear: {
      type: Boolean,
      default: void 0
    }
  };
};
const baseInputProps = () => {
  return _extends$1(_extends$1({}, commonInputProps()), {
    value: {
      type: [String, Number, Symbol],
      default: void 0
    },
    defaultValue: {
      type: [String, Number, Symbol],
      default: void 0
    },
    inputElement: PropTypes.any,
    prefixCls: String,
    disabled: {
      type: Boolean,
      default: void 0
    },
    focused: {
      type: Boolean,
      default: void 0
    },
    triggerFocus: Function,
    readonly: {
      type: Boolean,
      default: void 0
    },
    handleReset: Function,
    hidden: {
      type: Boolean,
      default: void 0
    }
  });
};
const inputProps$1 = () => _extends$1(_extends$1({}, baseInputProps()), {
  id: String,
  placeholder: {
    type: [String, Number]
  },
  autocomplete: String,
  type: stringType("text"),
  name: String,
  size: {
    type: String
  },
  autofocus: {
    type: Boolean,
    default: void 0
  },
  lazy: {
    type: Boolean,
    default: true
  },
  maxlength: Number,
  loading: {
    type: Boolean,
    default: void 0
  },
  bordered: {
    type: Boolean,
    default: void 0
  },
  showCount: {
    type: [Boolean, Object]
  },
  htmlSize: Number,
  onPressEnter: Function,
  onKeydown: Function,
  onKeyup: Function,
  onFocus: Function,
  onBlur: Function,
  onChange: Function,
  onInput: Function,
  "onUpdate:value": Function,
  onCompositionstart: Function,
  onCompositionend: Function,
  valueModifiers: Object,
  hidden: {
    type: Boolean,
    default: void 0
  },
  status: String
});
const BaseInput = defineComponent({
  name: "BaseInput",
  inheritAttrs: false,
  props: baseInputProps(),
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const containerRef = ref();
    const onInputMouseDown = (e2) => {
      var _a2;
      if ((_a2 = containerRef.value) === null || _a2 === void 0 ? void 0 : _a2.contains(e2.target)) {
        const {
          triggerFocus: triggerFocus2
        } = props2;
        triggerFocus2 === null || triggerFocus2 === void 0 ? void 0 : triggerFocus2();
      }
    };
    const getClearIcon = () => {
      var _a2;
      const {
        allowClear,
        value,
        disabled,
        readonly,
        handleReset,
        suffix = slots.suffix,
        prefixCls
      } = props2;
      if (!allowClear) {
        return null;
      }
      const needClear = !disabled && !readonly && value;
      const className = `${prefixCls}-clear-icon`;
      const iconNode = ((_a2 = slots.clearIcon) === null || _a2 === void 0 ? void 0 : _a2.call(slots)) || "*";
      return createVNode("span", {
        "onClick": handleReset,
        "onMousedown": (e2) => e2.preventDefault(),
        "class": classNames({
          [`${className}-hidden`]: !needClear,
          [`${className}-has-suffix`]: !!suffix
        }, className),
        "role": "button",
        "tabindex": -1
      }, [iconNode]);
    };
    return () => {
      var _a2, _b;
      const {
        focused,
        value,
        disabled,
        allowClear,
        readonly,
        hidden,
        prefixCls,
        prefix = (_a2 = slots.prefix) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
        suffix = (_b = slots.suffix) === null || _b === void 0 ? void 0 : _b.call(slots),
        addonAfter = slots.addonAfter,
        addonBefore = slots.addonBefore,
        inputElement,
        affixWrapperClassName,
        wrapperClassName,
        groupClassName
      } = props2;
      let element = cloneElement(inputElement, {
        value,
        hidden
      });
      if (hasPrefixSuffix({
        prefix,
        suffix,
        allowClear
      })) {
        const affixWrapperPrefixCls = `${prefixCls}-affix-wrapper`;
        const affixWrapperCls = classNames(affixWrapperPrefixCls, {
          [`${affixWrapperPrefixCls}-disabled`]: disabled,
          [`${affixWrapperPrefixCls}-focused`]: focused,
          [`${affixWrapperPrefixCls}-readonly`]: readonly,
          [`${affixWrapperPrefixCls}-input-with-clear-btn`]: suffix && allowClear && value
        }, !hasAddon$1({
          addonAfter,
          addonBefore
        }) && attrs.class, affixWrapperClassName);
        const suffixNode = (suffix || allowClear) && createVNode("span", {
          "class": `${prefixCls}-suffix`
        }, [getClearIcon(), suffix]);
        element = createVNode("span", {
          "class": affixWrapperCls,
          "style": attrs.style,
          "hidden": !hasAddon$1({
            addonAfter,
            addonBefore
          }) && hidden,
          "onMousedown": onInputMouseDown,
          "ref": containerRef
        }, [prefix && createVNode("span", {
          "class": `${prefixCls}-prefix`
        }, [prefix]), cloneElement(inputElement, {
          style: null,
          value,
          hidden: null
        }), suffixNode]);
      }
      if (hasAddon$1({
        addonAfter,
        addonBefore
      })) {
        const wrapperCls = `${prefixCls}-group`;
        const addonCls = `${wrapperCls}-addon`;
        const mergedWrapperClassName = classNames(`${prefixCls}-wrapper`, wrapperCls, wrapperClassName);
        const mergedGroupClassName = classNames(`${prefixCls}-group-wrapper`, attrs.class, groupClassName);
        return createVNode("span", {
          "class": mergedGroupClassName,
          "style": attrs.style,
          "hidden": hidden
        }, [createVNode("span", {
          "class": mergedWrapperClassName
        }, [addonBefore && createVNode("span", {
          "class": addonCls
        }, [addonBefore]), cloneElement(element, {
          style: null,
          hidden: null
        }), addonAfter && createVNode("span", {
          "class": addonCls
        }, [addonAfter])])]);
      }
      return element;
    };
  }
});
var __rest$z = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const VcInput = defineComponent({
  name: "VCInput",
  inheritAttrs: false,
  props: inputProps$1(),
  setup(props2, _ref) {
    let {
      slots,
      attrs,
      expose,
      emit
    } = _ref;
    const stateValue = shallowRef(props2.value === void 0 ? props2.defaultValue : props2.value);
    const focused = shallowRef(false);
    const inputRef = shallowRef();
    const rootRef = shallowRef();
    watch(() => props2.value, () => {
      stateValue.value = props2.value;
    });
    watch(() => props2.disabled, () => {
      if (props2.disabled) {
        focused.value = false;
      }
    });
    const focus = (option) => {
      if (inputRef.value) {
        triggerFocus(inputRef.value.input, option);
      }
    };
    const blur = () => {
      var _a2;
      (_a2 = inputRef.value.input) === null || _a2 === void 0 ? void 0 : _a2.blur();
    };
    const setSelectionRange = (start, end, direction) => {
      var _a2;
      (_a2 = inputRef.value.input) === null || _a2 === void 0 ? void 0 : _a2.setSelectionRange(start, end, direction);
    };
    const select = () => {
      var _a2;
      (_a2 = inputRef.value.input) === null || _a2 === void 0 ? void 0 : _a2.select();
    };
    expose({
      focus,
      blur,
      input: computed(() => {
        var _a2;
        return (_a2 = inputRef.value.input) === null || _a2 === void 0 ? void 0 : _a2.input;
      }),
      stateValue,
      setSelectionRange,
      select
    });
    const triggerChange = (e2) => {
      emit("change", e2);
    };
    const setValue2 = (value, callback) => {
      if (stateValue.value === value) {
        return;
      }
      if (props2.value === void 0) {
        stateValue.value = value;
      } else {
        nextTick(() => {
          var _a2;
          if (inputRef.value.input.value !== stateValue.value) {
            (_a2 = rootRef.value) === null || _a2 === void 0 ? void 0 : _a2.$forceUpdate();
          }
        });
      }
      nextTick(() => {
        callback && callback();
      });
    };
    const handleChange = (e2) => {
      const {
        value
      } = e2.target;
      if (stateValue.value === value) return;
      const newVal = e2.target.value;
      resolveOnChange(inputRef.value.input, e2, triggerChange);
      setValue2(newVal);
    };
    const handleKeyDown = (e2) => {
      if (e2.keyCode === 13) {
        emit("pressEnter", e2);
      }
      emit("keydown", e2);
    };
    const handleFocus = (e2) => {
      focused.value = true;
      emit("focus", e2);
    };
    const handleBlur = (e2) => {
      focused.value = false;
      emit("blur", e2);
    };
    const handleReset = (e2) => {
      resolveOnChange(inputRef.value.input, e2, triggerChange);
      setValue2("", () => {
        focus();
      });
    };
    const getInputElement = () => {
      var _a2, _b;
      const {
        addonBefore = slots.addonBefore,
        addonAfter = slots.addonAfter,
        disabled,
        valueModifiers = {},
        htmlSize,
        autocomplete,
        prefixCls,
        inputClassName,
        prefix = (_a2 = slots.prefix) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
        suffix = (_b = slots.suffix) === null || _b === void 0 ? void 0 : _b.call(slots),
        allowClear,
        type: type4 = "text"
      } = props2;
      const otherProps = omit$1(props2, [
        "prefixCls",
        "onPressEnter",
        "addonBefore",
        "addonAfter",
        "prefix",
        "suffix",
        "allowClear",
        // Input elements must be either controlled or uncontrolled,
        // specify either the value prop, or the defaultValue prop, but not both.
        "defaultValue",
        "size",
        "bordered",
        "htmlSize",
        "lazy",
        "showCount",
        "valueModifiers",
        "showCount",
        "affixWrapperClassName",
        "groupClassName",
        "inputClassName",
        "wrapperClassName"
      ]);
      const inputProps2 = _extends$1(_extends$1(_extends$1({}, otherProps), attrs), {
        autocomplete,
        onChange: handleChange,
        onInput: handleChange,
        onFocus: handleFocus,
        onBlur: handleBlur,
        onKeydown: handleKeyDown,
        class: classNames(prefixCls, {
          [`${prefixCls}-disabled`]: disabled
        }, inputClassName, !hasAddon$1({
          addonAfter,
          addonBefore
        }) && !hasPrefixSuffix({
          prefix,
          suffix,
          allowClear
        }) && attrs.class),
        ref: inputRef,
        key: "ant-input",
        size: htmlSize,
        type: type4,
        lazy: props2.lazy
      });
      if (valueModifiers.lazy) {
        delete inputProps2.onInput;
      }
      if (!inputProps2.autofocus) {
        delete inputProps2.autofocus;
      }
      const inputNode = createVNode(BaseInput$1, omit$1(inputProps2, ["size"]), null);
      return inputNode;
    };
    const getSuffix = () => {
      var _a2;
      const {
        maxlength,
        suffix = (_a2 = slots.suffix) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
        showCount,
        prefixCls
      } = props2;
      const hasMaxLength = Number(maxlength) > 0;
      if (suffix || showCount) {
        const valueLength = [...fixControlledValue(stateValue.value)].length;
        const dataCount = typeof showCount === "object" ? showCount.formatter({
          count: valueLength,
          maxlength
        }) : `${valueLength}${hasMaxLength ? ` / ${maxlength}` : ""}`;
        return createVNode(Fragment, null, [!!showCount && createVNode("span", {
          "class": classNames(`${prefixCls}-show-count-suffix`, {
            [`${prefixCls}-show-count-has-suffix`]: !!suffix
          })
        }, [dataCount]), suffix]);
      }
      return null;
    };
    onMounted(() => {
    });
    return () => {
      const {
        prefixCls,
        disabled
      } = props2, rest = __rest$z(props2, ["prefixCls", "disabled"]);
      return createVNode(BaseInput, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, rest), attrs), {}, {
        "ref": rootRef,
        "prefixCls": prefixCls,
        "inputElement": getInputElement(),
        "handleReset": handleReset,
        "value": fixControlledValue(stateValue.value),
        "focused": focused.value,
        "triggerFocus": focus,
        "suffix": getSuffix(),
        "disabled": disabled
      }), slots);
    };
  }
});
const inputProps = () => {
  return omit$1(inputProps$1(), ["wrapperClassName", "groupClassName", "inputClassName", "affixWrapperClassName"]);
};
const textAreaProps = () => _extends$1(_extends$1({}, omit$1(inputProps(), ["prefix", "addonBefore", "addonAfter", "suffix"])), {
  rows: Number,
  autosize: {
    type: [Boolean, Object],
    default: void 0
  },
  autoSize: {
    type: [Boolean, Object],
    default: void 0
  },
  onResize: {
    type: Function
  },
  onCompositionstart: eventType(),
  onCompositionend: eventType(),
  valueModifiers: Object
});
var __rest$y = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const Input = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AInput",
  inheritAttrs: false,
  props: inputProps(),
  setup(props2, _ref) {
    let {
      slots,
      attrs,
      expose,
      emit
    } = _ref;
    const inputRef = ref();
    const formItemContext = useInjectFormItemContext();
    const formItemInputContext = FormItemInputContext.useInject();
    const mergedStatus = computed(() => getMergedStatus(formItemInputContext.status, props2.status));
    const {
      direction,
      prefixCls,
      size,
      autocomplete
    } = useConfigInject("input", props2);
    const {
      compactSize,
      compactItemClassnames
    } = useCompactItemContext(prefixCls, direction);
    const mergedSize = computed(() => {
      return compactSize.value || size.value;
    });
    const [wrapSSR, hashId] = useStyle$w(prefixCls);
    const disabled = useInjectDisabled();
    const focus = (option) => {
      var _a2;
      (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus(option);
    };
    const blur = () => {
      var _a2;
      (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
    };
    const setSelectionRange = (start, end, direction2) => {
      var _a2;
      (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.setSelectionRange(start, end, direction2);
    };
    const select = () => {
      var _a2;
      (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.select();
    };
    expose({
      focus,
      blur,
      input: inputRef,
      setSelectionRange,
      select
    });
    const removePasswordTimeoutRef = ref([]);
    const removePasswordTimeout = () => {
      removePasswordTimeoutRef.value.push(setTimeout(() => {
        var _a2, _b, _c, _d;
        if (((_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.input) && ((_b = inputRef.value) === null || _b === void 0 ? void 0 : _b.input.getAttribute("type")) === "password" && ((_c = inputRef.value) === null || _c === void 0 ? void 0 : _c.input.hasAttribute("value"))) {
          (_d = inputRef.value) === null || _d === void 0 ? void 0 : _d.input.removeAttribute("value");
        }
      }));
    };
    onMounted(() => {
      removePasswordTimeout();
    });
    onBeforeUpdate(() => {
      removePasswordTimeoutRef.value.forEach((item) => clearTimeout(item));
    });
    onBeforeUnmount(() => {
      removePasswordTimeoutRef.value.forEach((item) => clearTimeout(item));
    });
    const handleBlur = (e2) => {
      removePasswordTimeout();
      emit("blur", e2);
      formItemContext.onFieldBlur();
    };
    const handleFocus = (e2) => {
      removePasswordTimeout();
      emit("focus", e2);
    };
    const triggerChange = (e2) => {
      emit("update:value", e2.target.value);
      emit("change", e2);
      emit("input", e2);
      formItemContext.onFieldChange();
    };
    return () => {
      var _a2, _b, _c, _d, _e, _f;
      const {
        hasFeedback,
        feedbackIcon
      } = formItemInputContext;
      const {
        allowClear,
        bordered = true,
        prefix = (_a2 = slots.prefix) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
        suffix = (_b = slots.suffix) === null || _b === void 0 ? void 0 : _b.call(slots),
        addonAfter = (_c = slots.addonAfter) === null || _c === void 0 ? void 0 : _c.call(slots),
        addonBefore = (_d = slots.addonBefore) === null || _d === void 0 ? void 0 : _d.call(slots),
        id = (_e = formItemContext.id) === null || _e === void 0 ? void 0 : _e.value
      } = props2, rest = __rest$y(props2, ["allowClear", "bordered", "prefix", "suffix", "addonAfter", "addonBefore", "id"]);
      const suffixNode = (hasFeedback || suffix) && createVNode(Fragment, null, [suffix, hasFeedback && feedbackIcon]);
      const prefixClsValue = prefixCls.value;
      const inputHasPrefixSuffix = hasPrefixSuffix({
        prefix,
        suffix
      }) || !!hasFeedback;
      const clearIcon = slots.clearIcon || (() => createVNode(CloseCircleFilled, null, null));
      return wrapSSR(createVNode(VcInput, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, attrs), omit$1(rest, ["onUpdate:value", "onChange", "onInput"])), {}, {
        "onChange": triggerChange,
        "id": id,
        "disabled": (_f = props2.disabled) !== null && _f !== void 0 ? _f : disabled.value,
        "ref": inputRef,
        "prefixCls": prefixClsValue,
        "autocomplete": autocomplete.value,
        "onBlur": handleBlur,
        "onFocus": handleFocus,
        "prefix": prefix,
        "suffix": suffixNode,
        "allowClear": allowClear,
        "addonAfter": addonAfter && createVNode(NoCompactStyle, null, {
          default: () => [createVNode(NoFormStatus, null, {
            default: () => [addonAfter]
          })]
        }),
        "addonBefore": addonBefore && createVNode(NoCompactStyle, null, {
          default: () => [createVNode(NoFormStatus, null, {
            default: () => [addonBefore]
          })]
        }),
        "class": [attrs.class, compactItemClassnames.value],
        "inputClassName": classNames({
          [`${prefixClsValue}-sm`]: mergedSize.value === "small",
          [`${prefixClsValue}-lg`]: mergedSize.value === "large",
          [`${prefixClsValue}-rtl`]: direction.value === "rtl",
          [`${prefixClsValue}-borderless`]: !bordered
        }, !inputHasPrefixSuffix && getStatusClassNames(prefixClsValue, mergedStatus.value), hashId.value),
        "affixWrapperClassName": classNames({
          [`${prefixClsValue}-affix-wrapper-sm`]: mergedSize.value === "small",
          [`${prefixClsValue}-affix-wrapper-lg`]: mergedSize.value === "large",
          [`${prefixClsValue}-affix-wrapper-rtl`]: direction.value === "rtl",
          [`${prefixClsValue}-affix-wrapper-borderless`]: !bordered
        }, getStatusClassNames(`${prefixClsValue}-affix-wrapper`, mergedStatus.value, hasFeedback), hashId.value),
        "wrapperClassName": classNames({
          [`${prefixClsValue}-group-rtl`]: direction.value === "rtl"
        }, hashId.value),
        "groupClassName": classNames({
          [`${prefixClsValue}-group-wrapper-sm`]: mergedSize.value === "small",
          [`${prefixClsValue}-group-wrapper-lg`]: mergedSize.value === "large",
          [`${prefixClsValue}-group-wrapper-rtl`]: direction.value === "rtl"
        }, getStatusClassNames(`${prefixClsValue}-group-wrapper`, mergedStatus.value, hasFeedback), hashId.value)
      }), _extends$1(_extends$1({}, slots), {
        clearIcon
      })));
    };
  }
});
const Group$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AInputGroup",
  inheritAttrs: false,
  props: {
    prefixCls: String,
    size: {
      type: String
    },
    compact: {
      type: Boolean,
      default: void 0
    }
  },
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const {
      prefixCls,
      direction,
      getPrefixCls
    } = useConfigInject("input-group", props2);
    const formItemInputContext = FormItemInputContext.useInject();
    FormItemInputContext.useProvide(formItemInputContext, {
      isFormItemInput: false
    });
    const inputPrefixCls = computed(() => getPrefixCls("input"));
    const [wrapSSR, hashId] = useStyle$w(inputPrefixCls);
    const cls = computed(() => {
      const pre = prefixCls.value;
      return {
        [`${pre}`]: true,
        [hashId.value]: true,
        [`${pre}-lg`]: props2.size === "large",
        [`${pre}-sm`]: props2.size === "small",
        [`${pre}-compact`]: props2.compact,
        [`${pre}-rtl`]: direction.value === "rtl"
      };
    });
    return () => {
      var _a2;
      return wrapSSR(createVNode("span", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "class": classNames(cls.value, attrs.class)
      }), [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]));
    };
  }
});
var __rest$x = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const InputSearch = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AInputSearch",
  inheritAttrs: false,
  props: _extends$1(_extends$1({}, inputProps()), {
    inputPrefixCls: String,
    // 不能设置默认值 https://github.com/vueComponent/ant-design-vue/issues/1916
    enterButton: PropTypes.any,
    onSearch: {
      type: Function
    }
  }),
  setup(props2, _ref) {
    let {
      slots,
      attrs,
      expose,
      emit
    } = _ref;
    const inputRef = shallowRef();
    const composedRef = shallowRef(false);
    const focus = () => {
      var _a2;
      (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
    };
    const blur = () => {
      var _a2;
      (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
    };
    expose({
      focus,
      blur
    });
    const onChange = (e2) => {
      emit("update:value", e2.target.value);
      if (e2 && e2.target && e2.type === "click") {
        emit("search", e2.target.value, e2);
      }
      emit("change", e2);
    };
    const onMousedown = (e2) => {
      var _a2;
      if (document.activeElement === ((_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.input)) {
        e2.preventDefault();
      }
    };
    const onSearch = (e2) => {
      var _a2, _b;
      emit("search", (_b = (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.input) === null || _b === void 0 ? void 0 : _b.stateValue, e2);
    };
    const onPressEnter = (e2) => {
      if (composedRef.value || props2.loading) {
        return;
      }
      onSearch(e2);
    };
    const handleOnCompositionStart = (e2) => {
      composedRef.value = true;
      emit("compositionstart", e2);
    };
    const handleOnCompositionEnd = (e2) => {
      composedRef.value = false;
      emit("compositionend", e2);
    };
    const {
      prefixCls,
      getPrefixCls,
      direction,
      size
    } = useConfigInject("input-search", props2);
    const inputPrefixCls = computed(() => getPrefixCls("input", props2.inputPrefixCls));
    return () => {
      var _a2, _b, _c, _d;
      const {
        disabled,
        loading,
        addonAfter = (_a2 = slots.addonAfter) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
        suffix = (_b = slots.suffix) === null || _b === void 0 ? void 0 : _b.call(slots)
      } = props2, restProps = __rest$x(props2, ["disabled", "loading", "addonAfter", "suffix"]);
      let {
        enterButton = (_d = (_c = slots.enterButton) === null || _c === void 0 ? void 0 : _c.call(slots)) !== null && _d !== void 0 ? _d : false
      } = props2;
      enterButton = enterButton || enterButton === "";
      const searchIcon = typeof enterButton === "boolean" ? createVNode(SearchOutlined, null, null) : null;
      const btnClassName = `${prefixCls.value}-button`;
      const enterButtonAsElement = Array.isArray(enterButton) ? enterButton[0] : enterButton;
      let button;
      const isAntdButton = enterButtonAsElement.type && isPlainObject(enterButtonAsElement.type) && enterButtonAsElement.type.__ANT_BUTTON;
      if (isAntdButton || enterButtonAsElement.tagName === "button") {
        button = cloneElement(enterButtonAsElement, _extends$1({
          onMousedown,
          onClick: onSearch,
          key: "enterButton"
        }, isAntdButton ? {
          class: btnClassName,
          size: size.value
        } : {}), false);
      } else {
        const iconOnly = searchIcon && !enterButton;
        button = createVNode(Button$1, {
          "class": btnClassName,
          "type": enterButton ? "primary" : void 0,
          "size": size.value,
          "disabled": disabled,
          "key": "enterButton",
          "onMousedown": onMousedown,
          "onClick": onSearch,
          "loading": loading,
          "icon": iconOnly ? searchIcon : null
        }, {
          default: () => [iconOnly ? null : searchIcon || enterButton]
        });
      }
      if (addonAfter) {
        button = [button, addonAfter];
      }
      const cls = classNames(prefixCls.value, {
        [`${prefixCls.value}-rtl`]: direction.value === "rtl",
        [`${prefixCls.value}-${size.value}`]: !!size.value,
        [`${prefixCls.value}-with-button`]: !!enterButton
      }, attrs.class);
      return createVNode(Input, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
        "ref": inputRef
      }, omit$1(restProps, ["onUpdate:value", "onSearch", "enterButton"])), attrs), {}, {
        "onPressEnter": onPressEnter,
        "onCompositionstart": handleOnCompositionStart,
        "onCompositionend": handleOnCompositionEnd,
        "size": size.value,
        "prefixCls": inputPrefixCls.value,
        "addonAfter": button,
        "suffix": suffix,
        "onChange": onChange,
        "class": cls,
        "disabled": disabled
      }), slots);
    };
  }
});
const isValid = (value) => {
  return value !== void 0 && value !== null && (Array.isArray(value) ? filterEmpty(value).length : true);
};
function hasAddon(propsAndSlots) {
  return isValid(propsAndSlots.addonBefore) || isValid(propsAndSlots.addonAfter);
}
const ClearableInputType = ["text", "input"];
const ClearableLabeledInput = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ClearableLabeledInput",
  inheritAttrs: false,
  props: {
    prefixCls: String,
    inputType: PropTypes.oneOf(tuple$1("text", "input")),
    value: anyType(),
    defaultValue: anyType(),
    allowClear: {
      type: Boolean,
      default: void 0
    },
    element: anyType(),
    handleReset: Function,
    disabled: {
      type: Boolean,
      default: void 0
    },
    direction: {
      type: String
    },
    size: {
      type: String
    },
    suffix: anyType(),
    prefix: anyType(),
    addonBefore: anyType(),
    addonAfter: anyType(),
    readonly: {
      type: Boolean,
      default: void 0
    },
    focused: {
      type: Boolean,
      default: void 0
    },
    bordered: {
      type: Boolean,
      default: true
    },
    triggerFocus: {
      type: Function
    },
    hidden: Boolean,
    status: String,
    hashId: String
  },
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const statusContext = FormItemInputContext.useInject();
    const renderClearIcon = (prefixCls) => {
      const {
        value,
        disabled,
        readonly,
        handleReset,
        suffix = slots.suffix
      } = props2;
      const needClear = !disabled && !readonly && value;
      const className = `${prefixCls}-clear-icon`;
      return createVNode(CloseCircleFilled, {
        "onClick": handleReset,
        "onMousedown": (e2) => e2.preventDefault(),
        "class": classNames({
          [`${className}-hidden`]: !needClear,
          [`${className}-has-suffix`]: !!suffix
        }, className),
        "role": "button"
      }, null);
    };
    const renderTextAreaWithClearIcon = (prefixCls, element) => {
      const {
        value,
        allowClear,
        direction,
        bordered,
        hidden,
        status: customStatus,
        addonAfter = slots.addonAfter,
        addonBefore = slots.addonBefore,
        hashId
      } = props2;
      const {
        status: contextStatus,
        hasFeedback
      } = statusContext;
      if (!allowClear) {
        return cloneElement(element, {
          value,
          disabled: props2.disabled
        });
      }
      const affixWrapperCls = classNames(`${prefixCls}-affix-wrapper`, `${prefixCls}-affix-wrapper-textarea-with-clear-btn`, getStatusClassNames(`${prefixCls}-affix-wrapper`, getMergedStatus(contextStatus, customStatus), hasFeedback), {
        [`${prefixCls}-affix-wrapper-rtl`]: direction === "rtl",
        [`${prefixCls}-affix-wrapper-borderless`]: !bordered,
        // className will go to addon wrapper
        [`${attrs.class}`]: !hasAddon({
          addonAfter,
          addonBefore
        }) && attrs.class
      }, hashId);
      return createVNode("span", {
        "class": affixWrapperCls,
        "style": attrs.style,
        "hidden": hidden
      }, [cloneElement(element, {
        style: null,
        value,
        disabled: props2.disabled
      }), renderClearIcon(prefixCls)]);
    };
    return () => {
      var _a2;
      const {
        prefixCls,
        inputType,
        element = (_a2 = slots.element) === null || _a2 === void 0 ? void 0 : _a2.call(slots)
      } = props2;
      if (inputType === ClearableInputType[0]) {
        return renderTextAreaWithClearIcon(prefixCls, element);
      }
      return null;
    };
  }
});
const HIDDEN_TEXTAREA_STYLE = `
  min-height:0 !important;
  max-height:none !important;
  height:0 !important;
  visibility:hidden !important;
  overflow:hidden !important;
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
  pointer-events: none !important;
`;
const SIZING_STYLE = ["letter-spacing", "line-height", "padding-top", "padding-bottom", "font-family", "font-weight", "font-size", "font-variant", "text-rendering", "text-transform", "width", "text-indent", "padding-left", "padding-right", "border-width", "box-sizing", "word-break", "white-space"];
const computedStyleCache = {};
let hiddenTextarea;
function calculateNodeStyling(node2) {
  let useCache2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  const nodeRef = node2.getAttribute("id") || node2.getAttribute("data-reactid") || node2.getAttribute("name");
  if (useCache2 && computedStyleCache[nodeRef]) {
    return computedStyleCache[nodeRef];
  }
  const style = window.getComputedStyle(node2);
  const boxSizing = style.getPropertyValue("box-sizing") || style.getPropertyValue("-moz-box-sizing") || style.getPropertyValue("-webkit-box-sizing");
  const paddingSize = parseFloat(style.getPropertyValue("padding-bottom")) + parseFloat(style.getPropertyValue("padding-top"));
  const borderSize = parseFloat(style.getPropertyValue("border-bottom-width")) + parseFloat(style.getPropertyValue("border-top-width"));
  const sizingStyle = SIZING_STYLE.map((name) => `${name}:${style.getPropertyValue(name)}`).join(";");
  const nodeInfo = {
    sizingStyle,
    paddingSize,
    borderSize,
    boxSizing
  };
  if (useCache2 && nodeRef) {
    computedStyleCache[nodeRef] = nodeInfo;
  }
  return nodeInfo;
}
function calculateAutoSizeStyle(uiTextNode) {
  let useCache2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  let minRows = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
  let maxRows = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  if (!hiddenTextarea) {
    hiddenTextarea = document.createElement("textarea");
    hiddenTextarea.setAttribute("tab-index", "-1");
    hiddenTextarea.setAttribute("aria-hidden", "true");
    document.body.appendChild(hiddenTextarea);
  }
  if (uiTextNode.getAttribute("wrap")) {
    hiddenTextarea.setAttribute("wrap", uiTextNode.getAttribute("wrap"));
  } else {
    hiddenTextarea.removeAttribute("wrap");
  }
  const {
    paddingSize,
    borderSize,
    boxSizing,
    sizingStyle
  } = calculateNodeStyling(uiTextNode, useCache2);
  hiddenTextarea.setAttribute("style", `${sizingStyle};${HIDDEN_TEXTAREA_STYLE}`);
  hiddenTextarea.value = uiTextNode.value || uiTextNode.placeholder || "";
  let minHeight = void 0;
  let maxHeight = void 0;
  let overflowY;
  let height = hiddenTextarea.scrollHeight;
  if (boxSizing === "border-box") {
    height += borderSize;
  } else if (boxSizing === "content-box") {
    height -= paddingSize;
  }
  if (minRows !== null || maxRows !== null) {
    hiddenTextarea.value = " ";
    const singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
    if (minRows !== null) {
      minHeight = singleRowHeight * minRows;
      if (boxSizing === "border-box") {
        minHeight = minHeight + paddingSize + borderSize;
      }
      height = Math.max(minHeight, height);
    }
    if (maxRows !== null) {
      maxHeight = singleRowHeight * maxRows;
      if (boxSizing === "border-box") {
        maxHeight = maxHeight + paddingSize + borderSize;
      }
      overflowY = height > maxHeight ? "" : "hidden";
      height = Math.min(maxHeight, height);
    }
  }
  const style = {
    height: `${height}px`,
    overflowY,
    resize: "none"
  };
  if (minHeight) {
    style.minHeight = `${minHeight}px`;
  }
  if (maxHeight) {
    style.maxHeight = `${maxHeight}px`;
  }
  return style;
}
const RESIZE_START = 0;
const RESIZE_MEASURING = 1;
const RESIZE_STABLE = 2;
const ResizableTextArea = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ResizableTextArea",
  inheritAttrs: false,
  props: textAreaProps(),
  setup(props2, _ref) {
    let {
      attrs,
      emit,
      expose
    } = _ref;
    let nextFrameActionId;
    let resizeFrameId;
    const textAreaRef = ref();
    const textareaStyles = ref({});
    const resizeStatus = ref(RESIZE_STABLE);
    onBeforeUnmount(() => {
      wrapperRaf.cancel(nextFrameActionId);
      wrapperRaf.cancel(resizeFrameId);
    });
    const fixFirefoxAutoScroll = () => {
      try {
        if (textAreaRef.value && document.activeElement === textAreaRef.value.input) {
          const currentStart = textAreaRef.value.getSelectionStart();
          const currentEnd = textAreaRef.value.getSelectionEnd();
          const scrollTop = textAreaRef.value.getScrollTop();
          textAreaRef.value.setSelectionRange(currentStart, currentEnd);
          textAreaRef.value.setScrollTop(scrollTop);
        }
      } catch (e2) {
      }
    };
    const minRows = ref();
    const maxRows = ref();
    watchEffect(() => {
      const autoSize = props2.autoSize || props2.autosize;
      if (autoSize) {
        minRows.value = autoSize.minRows;
        maxRows.value = autoSize.maxRows;
      } else {
        minRows.value = void 0;
        maxRows.value = void 0;
      }
    });
    const needAutoSize = computed(() => !!(props2.autoSize || props2.autosize));
    const startResize = () => {
      resizeStatus.value = RESIZE_START;
    };
    watch([() => props2.value, minRows, maxRows, needAutoSize], () => {
      if (needAutoSize.value) {
        startResize();
      }
    }, {
      immediate: true
    });
    const autoSizeStyle = ref();
    watch([resizeStatus, textAreaRef], () => {
      if (!textAreaRef.value) return;
      if (resizeStatus.value === RESIZE_START) {
        resizeStatus.value = RESIZE_MEASURING;
      } else if (resizeStatus.value === RESIZE_MEASURING) {
        const textareaStyles2 = calculateAutoSizeStyle(textAreaRef.value.input, false, minRows.value, maxRows.value);
        resizeStatus.value = RESIZE_STABLE;
        autoSizeStyle.value = textareaStyles2;
      } else {
        fixFirefoxAutoScroll();
      }
    }, {
      immediate: true,
      flush: "post"
    });
    const instance = getCurrentInstance();
    const resizeRafRef = ref();
    const cleanRaf = () => {
      wrapperRaf.cancel(resizeRafRef.value);
    };
    const onInternalResize = (size) => {
      if (resizeStatus.value === RESIZE_STABLE) {
        emit("resize", size);
        if (needAutoSize.value) {
          cleanRaf();
          resizeRafRef.value = wrapperRaf(() => {
            startResize();
          });
        }
      }
    };
    onBeforeUnmount(() => {
      cleanRaf();
    });
    const resizeTextarea = () => {
      startResize();
    };
    expose({
      resizeTextarea,
      textArea: computed(() => {
        var _a2;
        return (_a2 = textAreaRef.value) === null || _a2 === void 0 ? void 0 : _a2.input;
      }),
      instance
    });
    warning$1(props2.autosize === void 0);
    const renderTextArea = () => {
      const {
        prefixCls,
        disabled
      } = props2;
      const otherProps = omit$1(props2, ["prefixCls", "onPressEnter", "autoSize", "autosize", "defaultValue", "allowClear", "type", "maxlength", "valueModifiers"]);
      const cls = classNames(prefixCls, attrs.class, {
        [`${prefixCls}-disabled`]: disabled
      });
      const mergedAutoSizeStyle = needAutoSize.value ? autoSizeStyle.value : null;
      const style = [attrs.style, textareaStyles.value, mergedAutoSizeStyle];
      const textareaProps = _extends$1(_extends$1(_extends$1({}, otherProps), attrs), {
        style,
        class: cls
      });
      if (resizeStatus.value === RESIZE_START || resizeStatus.value === RESIZE_MEASURING) {
        style.push({
          overflowX: "hidden",
          overflowY: "hidden"
        });
      }
      if (!textareaProps.autofocus) {
        delete textareaProps.autofocus;
      }
      if (textareaProps.rows === 0) {
        delete textareaProps.rows;
      }
      return createVNode(ResizeObserver$1, {
        "onResize": onInternalResize,
        "disabled": !needAutoSize.value
      }, {
        default: () => [createVNode(BaseInput$1, _objectSpread2$1(_objectSpread2$1({}, textareaProps), {}, {
          "ref": textAreaRef,
          "tag": "textarea"
        }), null)]
      });
    };
    return () => {
      return renderTextArea();
    };
  }
});
function fixEmojiLength(value, maxLength) {
  return [...value || ""].slice(0, maxLength).join("");
}
function setTriggerValue(isCursorInEnd, preValue, triggerValue, maxLength) {
  let newTriggerValue = triggerValue;
  if (isCursorInEnd) {
    newTriggerValue = fixEmojiLength(triggerValue, maxLength);
  } else if ([...preValue || ""].length < triggerValue.length && [...triggerValue || ""].length > maxLength) {
    newTriggerValue = preValue;
  }
  return newTriggerValue;
}
const Textarea = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ATextarea",
  inheritAttrs: false,
  props: textAreaProps(),
  setup(props2, _ref) {
    let {
      attrs,
      expose,
      emit
    } = _ref;
    var _a2;
    const formItemContext = useInjectFormItemContext();
    const formItemInputContext = FormItemInputContext.useInject();
    const mergedStatus = computed(() => getMergedStatus(formItemInputContext.status, props2.status));
    const stateValue = shallowRef((_a2 = props2.value) !== null && _a2 !== void 0 ? _a2 : props2.defaultValue);
    const resizableTextArea = shallowRef();
    const mergedValue = shallowRef("");
    const {
      prefixCls,
      size,
      direction
    } = useConfigInject("input", props2);
    const [wrapSSR, hashId] = useStyle$w(prefixCls);
    const disabled = useInjectDisabled();
    const showCount = computed(() => {
      return props2.showCount === "" || props2.showCount || false;
    });
    const hasMaxLength = computed(() => Number(props2.maxlength) > 0);
    const compositing = shallowRef(false);
    const oldCompositionValueRef = shallowRef();
    const oldSelectionStartRef = shallowRef(0);
    const onInternalCompositionStart = (e2) => {
      compositing.value = true;
      oldCompositionValueRef.value = mergedValue.value;
      oldSelectionStartRef.value = e2.currentTarget.selectionStart;
      emit("compositionstart", e2);
    };
    const onInternalCompositionEnd = (e2) => {
      var _a3;
      compositing.value = false;
      let triggerValue = e2.currentTarget.value;
      if (hasMaxLength.value) {
        const isCursorInEnd = oldSelectionStartRef.value >= props2.maxlength + 1 || oldSelectionStartRef.value === ((_a3 = oldCompositionValueRef.value) === null || _a3 === void 0 ? void 0 : _a3.length);
        triggerValue = setTriggerValue(isCursorInEnd, oldCompositionValueRef.value, triggerValue, props2.maxlength);
      }
      if (triggerValue !== mergedValue.value) {
        setValue2(triggerValue);
        resolveOnChange(e2.currentTarget, e2, triggerChange, triggerValue);
      }
      emit("compositionend", e2);
    };
    const instance = getCurrentInstance();
    watch(() => props2.value, () => {
      var _a3;
      if ("value" in instance.vnode.props || {}) {
        stateValue.value = (_a3 = props2.value) !== null && _a3 !== void 0 ? _a3 : "";
      }
    });
    const focus = (option) => {
      var _a3;
      triggerFocus((_a3 = resizableTextArea.value) === null || _a3 === void 0 ? void 0 : _a3.textArea, option);
    };
    const blur = () => {
      var _a3, _b;
      (_b = (_a3 = resizableTextArea.value) === null || _a3 === void 0 ? void 0 : _a3.textArea) === null || _b === void 0 ? void 0 : _b.blur();
    };
    const setValue2 = (value, callback) => {
      if (stateValue.value === value) {
        return;
      }
      if (props2.value === void 0) {
        stateValue.value = value;
      } else {
        nextTick(() => {
          var _a3, _b, _c;
          if (resizableTextArea.value.textArea.value !== mergedValue.value) {
            (_c = (_a3 = resizableTextArea.value) === null || _a3 === void 0 ? void 0 : (_b = _a3.instance).update) === null || _c === void 0 ? void 0 : _c.call(_b);
          }
        });
      }
      nextTick(() => {
        callback && callback();
      });
    };
    const handleKeyDown = (e2) => {
      if (e2.keyCode === 13) {
        emit("pressEnter", e2);
      }
      emit("keydown", e2);
    };
    const onBlur = (e2) => {
      const {
        onBlur: onBlur2
      } = props2;
      onBlur2 === null || onBlur2 === void 0 ? void 0 : onBlur2(e2);
      formItemContext.onFieldBlur();
    };
    const triggerChange = (e2) => {
      emit("update:value", e2.target.value);
      emit("change", e2);
      emit("input", e2);
      formItemContext.onFieldChange();
    };
    const handleReset = (e2) => {
      resolveOnChange(resizableTextArea.value.textArea, e2, triggerChange);
      setValue2("", () => {
        focus();
      });
    };
    const handleChange = (e2) => {
      let triggerValue = e2.target.value;
      if (stateValue.value === triggerValue) return;
      if (hasMaxLength.value) {
        const target = e2.target;
        const isCursorInEnd = target.selectionStart >= props2.maxlength + 1 || target.selectionStart === triggerValue.length || !target.selectionStart;
        triggerValue = setTriggerValue(isCursorInEnd, mergedValue.value, triggerValue, props2.maxlength);
      }
      resolveOnChange(e2.currentTarget, e2, triggerChange, triggerValue);
      setValue2(triggerValue);
    };
    const renderTextArea = () => {
      var _a3, _b;
      const {
        class: customClass
      } = attrs;
      const {
        bordered = true
      } = props2;
      const resizeProps = _extends$1(_extends$1(_extends$1({}, omit$1(props2, ["allowClear"])), attrs), {
        class: [{
          [`${prefixCls.value}-borderless`]: !bordered,
          [`${customClass}`]: customClass && !showCount.value,
          [`${prefixCls.value}-sm`]: size.value === "small",
          [`${prefixCls.value}-lg`]: size.value === "large"
        }, getStatusClassNames(prefixCls.value, mergedStatus.value), hashId.value],
        disabled: disabled.value,
        showCount: null,
        prefixCls: prefixCls.value,
        onInput: handleChange,
        onChange: handleChange,
        onBlur,
        onKeydown: handleKeyDown,
        onCompositionstart: onInternalCompositionStart,
        onCompositionend: onInternalCompositionEnd
      });
      if ((_a3 = props2.valueModifiers) === null || _a3 === void 0 ? void 0 : _a3.lazy) {
        delete resizeProps.onInput;
      }
      return createVNode(ResizableTextArea, _objectSpread2$1(_objectSpread2$1({}, resizeProps), {}, {
        "id": (_b = resizeProps === null || resizeProps === void 0 ? void 0 : resizeProps.id) !== null && _b !== void 0 ? _b : formItemContext.id.value,
        "ref": resizableTextArea,
        "maxlength": props2.maxlength,
        "lazy": props2.lazy
      }), null);
    };
    expose({
      focus,
      blur,
      resizableTextArea
    });
    watchEffect(() => {
      let val = fixControlledValue(stateValue.value);
      if (!compositing.value && hasMaxLength.value && (props2.value === null || props2.value === void 0)) {
        val = fixEmojiLength(val, props2.maxlength);
      }
      mergedValue.value = val;
    });
    return () => {
      var _a3;
      const {
        maxlength,
        bordered = true,
        hidden
      } = props2;
      const {
        style,
        class: customClass
      } = attrs;
      const inputProps2 = _extends$1(_extends$1(_extends$1({}, props2), attrs), {
        prefixCls: prefixCls.value,
        inputType: "text",
        handleReset,
        direction: direction.value,
        bordered,
        style: showCount.value ? void 0 : style,
        hashId: hashId.value,
        disabled: (_a3 = props2.disabled) !== null && _a3 !== void 0 ? _a3 : disabled.value
      });
      let textareaNode = createVNode(ClearableLabeledInput, _objectSpread2$1(_objectSpread2$1({}, inputProps2), {}, {
        "value": mergedValue.value,
        "status": props2.status
      }), {
        element: renderTextArea
      });
      if (showCount.value || formItemInputContext.hasFeedback) {
        const valueLength = [...mergedValue.value].length;
        let dataCount = "";
        if (typeof showCount.value === "object") {
          dataCount = showCount.value.formatter({
            value: mergedValue.value,
            count: valueLength,
            maxlength
          });
        } else {
          dataCount = `${valueLength}${hasMaxLength.value ? ` / ${maxlength}` : ""}`;
        }
        textareaNode = createVNode("div", {
          "hidden": hidden,
          "class": classNames(`${prefixCls.value}-textarea`, {
            [`${prefixCls.value}-textarea-rtl`]: direction.value === "rtl",
            [`${prefixCls.value}-textarea-show-count`]: showCount.value,
            [`${prefixCls.value}-textarea-in-form-item`]: formItemInputContext.isFormItemInput
          }, `${prefixCls.value}-textarea-show-count`, customClass, hashId.value),
          "style": style,
          "data-count": typeof dataCount !== "object" ? dataCount : void 0
        }, [textareaNode, formItemInputContext.hasFeedback && createVNode("span", {
          "class": `${prefixCls.value}-textarea-suffix`
        }, [formItemInputContext.feedbackIcon])]);
      }
      return wrapSSR(textareaNode);
    };
  }
});
var __rest$w = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const ActionMap = {
  click: "onClick",
  hover: "onMouseover"
};
const defaultIconRender = (visible) => visible ? createVNode(EyeOutlined, null, null) : createVNode(EyeInvisibleOutlined, null, null);
const Password = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AInputPassword",
  inheritAttrs: false,
  props: _extends$1(_extends$1({}, inputProps()), {
    prefixCls: String,
    inputPrefixCls: String,
    action: {
      type: String,
      default: "click"
    },
    visibilityToggle: {
      type: Boolean,
      default: true
    },
    visible: {
      type: Boolean,
      default: void 0
    },
    "onUpdate:visible": Function,
    iconRender: Function
  }),
  setup(props2, _ref) {
    let {
      slots,
      attrs,
      expose,
      emit
    } = _ref;
    const visible = shallowRef(false);
    const onVisibleChange = () => {
      const {
        disabled
      } = props2;
      if (disabled) {
        return;
      }
      visible.value = !visible.value;
      emit("update:visible", visible.value);
    };
    watchEffect(() => {
      if (props2.visible !== void 0) {
        visible.value = !!props2.visible;
      }
    });
    const inputRef = shallowRef();
    const focus = () => {
      var _a2;
      (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
    };
    const blur = () => {
      var _a2;
      (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
    };
    expose({
      focus,
      blur
    });
    const getIcon2 = (prefixCls2) => {
      const {
        action,
        iconRender = slots.iconRender || defaultIconRender
      } = props2;
      const iconTrigger = ActionMap[action] || "";
      const icon = iconRender(visible.value);
      const iconProps = {
        [iconTrigger]: onVisibleChange,
        class: `${prefixCls2}-icon`,
        key: "passwordIcon",
        onMousedown: (e2) => {
          e2.preventDefault();
        },
        onMouseup: (e2) => {
          e2.preventDefault();
        }
      };
      return cloneElement(isValidElement(icon) ? icon : createVNode("span", null, [icon]), iconProps);
    };
    const {
      prefixCls,
      getPrefixCls
    } = useConfigInject("input-password", props2);
    const inputPrefixCls = computed(() => getPrefixCls("input", props2.inputPrefixCls));
    const renderPassword = () => {
      const {
        size,
        visibilityToggle
      } = props2, restProps = __rest$w(props2, ["size", "visibilityToggle"]);
      const suffixIcon = visibilityToggle && getIcon2(prefixCls.value);
      const inputClassName = classNames(prefixCls.value, attrs.class, {
        [`${prefixCls.value}-${size}`]: !!size
      });
      const omittedProps = _extends$1(_extends$1(_extends$1({}, omit$1(restProps, ["suffix", "iconRender", "action"])), attrs), {
        type: visible.value ? "text" : "password",
        class: inputClassName,
        prefixCls: inputPrefixCls.value,
        suffix: suffixIcon
      });
      if (size) {
        omittedProps.size = size;
      }
      return createVNode(Input, _objectSpread2$1({
        "ref": inputRef
      }, omittedProps), slots);
    };
    return () => {
      return renderPassword();
    };
  }
});
Input.Group = Group$1;
Input.Search = InputSearch;
Input.TextArea = Textarea;
Input.Password = Password;
Input.install = function(app) {
  app.component(Input.name, Input);
  app.component(Input.Group.name, Input.Group);
  app.component(Input.Search.name, Input.Search);
  app.component(Input.TextArea.name, Input.TextArea);
  app.component(Input.Password.name, Input.Password);
  return app;
};
function dialogPropTypes() {
  return {
    keyboard: {
      type: Boolean,
      default: void 0
    },
    mask: {
      type: Boolean,
      default: void 0
    },
    afterClose: Function,
    closable: {
      type: Boolean,
      default: void 0
    },
    maskClosable: {
      type: Boolean,
      default: void 0
    },
    visible: {
      type: Boolean,
      default: void 0
    },
    destroyOnClose: {
      type: Boolean,
      default: void 0
    },
    mousePosition: PropTypes.shape({
      x: Number,
      y: Number
    }).loose,
    title: PropTypes.any,
    footer: PropTypes.any,
    transitionName: String,
    maskTransitionName: String,
    animation: PropTypes.any,
    maskAnimation: PropTypes.any,
    wrapStyle: {
      type: Object,
      default: void 0
    },
    bodyStyle: {
      type: Object,
      default: void 0
    },
    maskStyle: {
      type: Object,
      default: void 0
    },
    prefixCls: String,
    wrapClassName: String,
    rootClassName: String,
    width: [String, Number],
    height: [String, Number],
    zIndex: Number,
    bodyProps: PropTypes.any,
    maskProps: PropTypes.any,
    wrapProps: PropTypes.any,
    getContainer: PropTypes.any,
    dialogStyle: {
      type: Object,
      default: void 0
    },
    dialogClass: String,
    closeIcon: PropTypes.any,
    forceRender: {
      type: Boolean,
      default: void 0
    },
    getOpenCount: Function,
    // https://github.com/ant-design/ant-design/issues/19771
    // https://github.com/react-component/dialog/issues/95
    focusTriggerAfterClose: {
      type: Boolean,
      default: void 0
    },
    onClose: Function,
    modalRender: Function
  };
}
function getMotionName(prefixCls, transitionName2, animationName) {
  let motionName = transitionName2;
  if (!motionName && animationName) {
    motionName = `${prefixCls}-${animationName}`;
  }
  return motionName;
}
let uuid$2 = -1;
function getUUID() {
  uuid$2 += 1;
  return uuid$2;
}
function getScroll(w2, top) {
  let ret = w2[`page${top ? "Y" : "X"}Offset`];
  const method4 = `scroll${top ? "Top" : "Left"}`;
  if (typeof ret !== "number") {
    const d2 = w2.document;
    ret = d2.documentElement[method4];
    if (typeof ret !== "number") {
      ret = d2.body[method4];
    }
  }
  return ret;
}
function offset$1(el) {
  const rect = el.getBoundingClientRect();
  const pos = {
    left: rect.left,
    top: rect.top
  };
  const doc = el.ownerDocument;
  const w2 = doc.defaultView || doc.parentWindow;
  pos.left += getScroll(w2);
  pos.top += getScroll(w2, true);
  return pos;
}
const sentinelStyle = {
  width: 0,
  height: 0,
  overflow: "hidden",
  outline: "none"
};
const entityStyle = {
  outline: "none"
};
const Content$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "DialogContent",
  inheritAttrs: false,
  props: _extends$1(_extends$1({}, dialogPropTypes()), {
    motionName: String,
    ariaId: String,
    onVisibleChanged: Function,
    onMousedown: Function,
    onMouseup: Function
  }),
  setup(props2, _ref) {
    let {
      expose,
      slots,
      attrs
    } = _ref;
    const sentinelStartRef = ref();
    const sentinelEndRef = ref();
    const dialogRef = ref();
    expose({
      focus: () => {
        var _a2;
        (_a2 = sentinelStartRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus({
          preventScroll: true
        });
      },
      changeActive: (next2) => {
        const {
          activeElement
        } = document;
        if (next2 && activeElement === sentinelEndRef.value) {
          sentinelStartRef.value.focus({
            preventScroll: true
          });
        } else if (!next2 && activeElement === sentinelStartRef.value) {
          sentinelEndRef.value.focus({
            preventScroll: true
          });
        }
      }
    });
    const transformOrigin = ref();
    const contentStyleRef = computed(() => {
      const {
        width,
        height
      } = props2;
      const contentStyle = {};
      if (width !== void 0) {
        contentStyle.width = typeof width === "number" ? `${width}px` : width;
      }
      if (height !== void 0) {
        contentStyle.height = typeof height === "number" ? `${height}px` : height;
      }
      if (transformOrigin.value) {
        contentStyle.transformOrigin = transformOrigin.value;
      }
      return contentStyle;
    });
    const onPrepare = () => {
      nextTick(() => {
        if (dialogRef.value) {
          const elementOffset = offset$1(dialogRef.value);
          transformOrigin.value = props2.mousePosition ? `${props2.mousePosition.x - elementOffset.left}px ${props2.mousePosition.y - elementOffset.top}px` : "";
        }
      });
    };
    const onVisibleChanged = (visible) => {
      props2.onVisibleChanged(visible);
    };
    return () => {
      var _a2, _b, _c, _d;
      const {
        prefixCls,
        footer = (_a2 = slots.footer) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
        title = (_b = slots.title) === null || _b === void 0 ? void 0 : _b.call(slots),
        ariaId,
        closable,
        closeIcon = (_c = slots.closeIcon) === null || _c === void 0 ? void 0 : _c.call(slots),
        onClose,
        bodyStyle,
        bodyProps,
        onMousedown,
        onMouseup,
        visible,
        modalRender = slots.modalRender,
        destroyOnClose,
        motionName
      } = props2;
      let footerNode;
      if (footer) {
        footerNode = createVNode("div", {
          "class": `${prefixCls}-footer`
        }, [footer]);
      }
      let headerNode;
      if (title) {
        headerNode = createVNode("div", {
          "class": `${prefixCls}-header`
        }, [createVNode("div", {
          "class": `${prefixCls}-title`,
          "id": ariaId
        }, [title])]);
      }
      let closer;
      if (closable) {
        closer = createVNode("button", {
          "type": "button",
          "onClick": onClose,
          "aria-label": "Close",
          "class": `${prefixCls}-close`
        }, [closeIcon || createVNode("span", {
          "class": `${prefixCls}-close-x`
        }, null)]);
      }
      const content = createVNode("div", {
        "class": `${prefixCls}-content`
      }, [closer, headerNode, createVNode("div", _objectSpread2$1({
        "class": `${prefixCls}-body`,
        "style": bodyStyle
      }, bodyProps), [(_d = slots.default) === null || _d === void 0 ? void 0 : _d.call(slots)]), footerNode]);
      const transitionProps = getTransitionProps(motionName);
      return createVNode(Transition, _objectSpread2$1(_objectSpread2$1({}, transitionProps), {}, {
        "onBeforeEnter": onPrepare,
        "onAfterEnter": () => onVisibleChanged(true),
        "onAfterLeave": () => onVisibleChanged(false)
      }), {
        default: () => [visible || !destroyOnClose ? withDirectives(createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
          "ref": dialogRef,
          "key": "dialog-element",
          "role": "document",
          "style": [contentStyleRef.value, attrs.style],
          "class": [prefixCls, attrs.class],
          "onMousedown": onMousedown,
          "onMouseup": onMouseup
        }), [createVNode("div", {
          "tabindex": 0,
          "ref": sentinelStartRef,
          "style": entityStyle
        }, [modalRender ? modalRender({
          originVNode: content
        }) : content]), createVNode("div", {
          "tabindex": 0,
          "ref": sentinelEndRef,
          "style": sentinelStyle
        }, null)]), [[vShow, visible]]) : null]
      });
    };
  }
});
const Mask = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "DialogMask",
  props: {
    prefixCls: String,
    visible: Boolean,
    motionName: String,
    maskProps: Object
  },
  setup(props2, _ref) {
    return () => {
      const {
        prefixCls,
        visible,
        maskProps,
        motionName
      } = props2;
      const transitionProps = getTransitionProps(motionName);
      return createVNode(Transition, transitionProps, {
        default: () => [withDirectives(createVNode("div", _objectSpread2$1({
          "class": `${prefixCls}-mask`
        }, maskProps), null), [[vShow, visible]])]
      });
    };
  }
});
const Dialog = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "VcDialog",
  inheritAttrs: false,
  props: initDefaultProps(_extends$1(_extends$1({}, dialogPropTypes()), {
    getOpenCount: Function,
    scrollLocker: Object
  }), {
    mask: true,
    visible: false,
    keyboard: true,
    closable: true,
    maskClosable: true,
    destroyOnClose: false,
    prefixCls: "rc-dialog",
    getOpenCount: () => null,
    focusTriggerAfterClose: true
  }),
  setup(props2, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const lastOutSideActiveElementRef = shallowRef();
    const wrapperRef = shallowRef();
    const contentRef = shallowRef();
    const animatedVisible = shallowRef(props2.visible);
    const ariaIdRef = shallowRef(`vcDialogTitle${getUUID()}`);
    const onDialogVisibleChanged = (newVisible) => {
      var _a2, _b;
      if (newVisible) {
        if (!contains(wrapperRef.value, document.activeElement)) {
          lastOutSideActiveElementRef.value = document.activeElement;
          (_a2 = contentRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
        }
      } else {
        const preAnimatedVisible = animatedVisible.value;
        animatedVisible.value = false;
        if (props2.mask && lastOutSideActiveElementRef.value && props2.focusTriggerAfterClose) {
          try {
            lastOutSideActiveElementRef.value.focus({
              preventScroll: true
            });
          } catch (e2) {
          }
          lastOutSideActiveElementRef.value = null;
        }
        if (preAnimatedVisible) {
          (_b = props2.afterClose) === null || _b === void 0 ? void 0 : _b.call(props2);
        }
      }
    };
    const onInternalClose = (e2) => {
      var _a2;
      (_a2 = props2.onClose) === null || _a2 === void 0 ? void 0 : _a2.call(props2, e2);
    };
    const contentClickRef = shallowRef(false);
    const contentTimeoutRef = shallowRef();
    const onContentMouseDown = () => {
      clearTimeout(contentTimeoutRef.value);
      contentClickRef.value = true;
    };
    const onContentMouseUp = () => {
      contentTimeoutRef.value = setTimeout(() => {
        contentClickRef.value = false;
      });
    };
    const onWrapperClick = (e2) => {
      if (!props2.maskClosable) return null;
      if (contentClickRef.value) {
        contentClickRef.value = false;
      } else if (wrapperRef.value === e2.target) {
        onInternalClose(e2);
      }
    };
    const onWrapperKeyDown = (e2) => {
      if (props2.keyboard && e2.keyCode === KeyCode.ESC) {
        e2.stopPropagation();
        onInternalClose(e2);
        return;
      }
      if (props2.visible) {
        if (e2.keyCode === KeyCode.TAB) {
          contentRef.value.changeActive(!e2.shiftKey);
        }
      }
    };
    watch(() => props2.visible, () => {
      if (props2.visible) {
        animatedVisible.value = true;
      }
    }, {
      flush: "post"
    });
    onBeforeUnmount(() => {
      var _a2;
      clearTimeout(contentTimeoutRef.value);
      (_a2 = props2.scrollLocker) === null || _a2 === void 0 ? void 0 : _a2.unLock();
    });
    watchEffect(() => {
      var _a2, _b;
      (_a2 = props2.scrollLocker) === null || _a2 === void 0 ? void 0 : _a2.unLock();
      if (animatedVisible.value) {
        (_b = props2.scrollLocker) === null || _b === void 0 ? void 0 : _b.lock();
      }
    });
    return () => {
      const {
        prefixCls,
        mask,
        visible,
        maskTransitionName,
        maskAnimation,
        zIndex,
        wrapClassName,
        rootClassName,
        wrapStyle,
        closable,
        maskProps,
        maskStyle,
        transitionName: transitionName2,
        animation,
        wrapProps,
        title = slots.title
      } = props2;
      const {
        style,
        class: className
      } = attrs;
      return createVNode("div", _objectSpread2$1({
        "class": [`${prefixCls}-root`, rootClassName]
      }, pickAttrs(props2, {
        data: true
      })), [createVNode(Mask, {
        "prefixCls": prefixCls,
        "visible": mask && visible,
        "motionName": getMotionName(prefixCls, maskTransitionName, maskAnimation),
        "style": _extends$1({
          zIndex
        }, maskStyle),
        "maskProps": maskProps
      }, null), createVNode("div", _objectSpread2$1({
        "tabIndex": -1,
        "onKeydown": onWrapperKeyDown,
        "class": classNames(`${prefixCls}-wrap`, wrapClassName),
        "ref": wrapperRef,
        "onClick": onWrapperClick,
        "role": "dialog",
        "aria-labelledby": title ? ariaIdRef.value : null,
        "style": _extends$1(_extends$1({
          zIndex
        }, wrapStyle), {
          display: !animatedVisible.value ? "none" : null
        })
      }, wrapProps), [createVNode(Content$1, _objectSpread2$1(_objectSpread2$1({}, omit$1(props2, ["scrollLocker"])), {}, {
        "style": style,
        "class": className,
        "onMousedown": onContentMouseDown,
        "onMouseup": onContentMouseUp,
        "ref": contentRef,
        "closable": closable,
        "ariaId": ariaIdRef.value,
        "prefixCls": prefixCls,
        "visible": visible,
        "onClose": onInternalClose,
        "onVisibleChanged": onDialogVisibleChanged,
        "motionName": getMotionName(prefixCls, transitionName2, animation)
      }), slots)])]);
    };
  }
});
const IDialogPropTypes = dialogPropTypes();
const DialogWrap = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "DialogWrap",
  inheritAttrs: false,
  props: initDefaultProps(IDialogPropTypes, {
    visible: false
  }),
  setup(props2, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const animatedVisible = ref(props2.visible);
    useProvidePortal({}, {
      inTriggerContext: false
    });
    watch(() => props2.visible, () => {
      if (props2.visible) {
        animatedVisible.value = true;
      }
    }, {
      flush: "post"
    });
    return () => {
      const {
        visible,
        getContainer: getContainer2,
        forceRender,
        destroyOnClose = false,
        afterClose
      } = props2;
      let dialogProps = _extends$1(_extends$1(_extends$1({}, props2), attrs), {
        ref: "_component",
        key: "dialog"
      });
      if (getContainer2 === false) {
        return createVNode(Dialog, _objectSpread2$1(_objectSpread2$1({}, dialogProps), {}, {
          "getOpenCount": () => 2
        }), slots);
      }
      if (!forceRender && destroyOnClose && !animatedVisible.value) {
        return null;
      }
      return createVNode(Portal, {
        "autoLock": true,
        "visible": visible,
        "forceRender": forceRender,
        "getContainer": getContainer2
      }, {
        default: (childProps) => {
          dialogProps = _extends$1(_extends$1(_extends$1({}, dialogProps), childProps), {
            afterClose: () => {
              afterClose === null || afterClose === void 0 ? void 0 : afterClose();
              animatedVisible.value = false;
            }
          });
          return createVNode(Dialog, dialogProps, slots);
        }
      });
    };
  }
});
function useFrameSetState(initial) {
  const frame = ref(null);
  const state = reactive(_extends$1({}, initial));
  const queue = ref([]);
  const setFrameState = (newState) => {
    if (frame.value === null) {
      queue.value = [];
      frame.value = wrapperRaf(() => {
        let memoState;
        queue.value.forEach((queueState) => {
          memoState = _extends$1(_extends$1({}, memoState), queueState);
        });
        _extends$1(state, memoState);
        frame.value = null;
      });
    }
    queue.value.push(newState);
  };
  onMounted(() => {
    frame.value && wrapperRaf.cancel(frame.value);
  });
  return [state, setFrameState];
}
function fixPoint(key2, start, width, clientWidth) {
  const startAddWidth = start + width;
  const offsetStart = (width - clientWidth) / 2;
  if (width > clientWidth) {
    if (start > 0) {
      return {
        [key2]: offsetStart
      };
    }
    if (start < 0 && startAddWidth < clientWidth) {
      return {
        [key2]: -offsetStart
      };
    }
  } else if (start < 0 || startAddWidth > clientWidth) {
    return {
      [key2]: start < 0 ? offsetStart : -offsetStart
    };
  }
  return {};
}
function getFixScaleEleTransPosition(width, height, left, top) {
  const {
    width: clientWidth,
    height: clientHeight
  } = getClientSize();
  let fixPos = null;
  if (width <= clientWidth && height <= clientHeight) {
    fixPos = {
      x: 0,
      y: 0
    };
  } else if (width > clientWidth || height > clientHeight) {
    fixPos = _extends$1(_extends$1({}, fixPoint("x", left, width, clientWidth)), fixPoint("y", top, height, clientHeight));
  }
  return fixPos;
}
var __rest$v = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const previewGroupContext = Symbol("previewGroupContext");
const context = {
  provide: (val) => {
    provide(previewGroupContext, val);
  },
  inject: () => {
    return inject(previewGroupContext, {
      isPreviewGroup: shallowRef(false),
      previewUrls: computed(() => /* @__PURE__ */ new Map()),
      setPreviewUrls: () => {
      },
      current: ref(null),
      setCurrent: () => {
      },
      setShowPreview: () => {
      },
      setMousePosition: () => {
      },
      registerImage: null,
      rootClassName: ""
    });
  }
};
const imageGroupProps = () => ({
  previewPrefixCls: String,
  preview: {
    type: [Boolean, Object],
    default: true
  },
  icons: {
    type: Object,
    default: () => ({})
  }
});
const Group = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "PreviewGroup",
  inheritAttrs: false,
  props: imageGroupProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const preview = computed(() => {
      const defaultValues = {
        visible: void 0,
        onVisibleChange: () => {
        },
        getContainer: void 0,
        current: 0
      };
      return typeof props2.preview === "object" ? mergeDefaultValue(props2.preview, defaultValues) : defaultValues;
    });
    const previewUrls = reactive(/* @__PURE__ */ new Map());
    const current = ref();
    const previewVisible = computed(() => preview.value.visible);
    const getPreviewContainer = computed(() => preview.value.getContainer);
    const onPreviewVisibleChange = (val, preval) => {
      var _a2, _b;
      (_b = (_a2 = preview.value).onVisibleChange) === null || _b === void 0 ? void 0 : _b.call(_a2, val, preval);
    };
    const [isShowPreview, setShowPreview] = useMergedState(!!previewVisible.value, {
      value: previewVisible,
      onChange: onPreviewVisibleChange
    });
    const mousePosition2 = ref(null);
    const isControlled = computed(() => previewVisible.value !== void 0);
    const previewUrlsKeys = computed(() => Array.from(previewUrls.keys()));
    const currentControlledKey = computed(() => previewUrlsKeys.value[preview.value.current]);
    const canPreviewUrls = computed(() => new Map(Array.from(previewUrls).filter((_ref2) => {
      let [, {
        canPreview
      }] = _ref2;
      return !!canPreview;
    }).map((_ref3) => {
      let [id, {
        url: url2
      }] = _ref3;
      return [id, url2];
    })));
    const setPreviewUrls = function(id, url2) {
      let canPreview = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      previewUrls.set(id, {
        url: url2,
        canPreview
      });
    };
    const setCurrent = (val) => {
      current.value = val;
    };
    const setMousePosition = (val) => {
      mousePosition2.value = val;
    };
    const registerImage = function(id, url2) {
      let canPreview = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      const unRegister = () => {
        previewUrls.delete(id);
      };
      previewUrls.set(id, {
        url: url2,
        canPreview
      });
      return unRegister;
    };
    const onPreviewClose = (e2) => {
      e2 === null || e2 === void 0 ? void 0 : e2.stopPropagation();
      setShowPreview(false);
      setMousePosition(null);
    };
    watch(currentControlledKey, (val) => {
      setCurrent(val);
    }, {
      immediate: true,
      flush: "post"
    });
    watchEffect(() => {
      if (isShowPreview.value && isControlled.value) {
        setCurrent(currentControlledKey.value);
      }
    }, {
      flush: "post"
    });
    context.provide({
      isPreviewGroup: shallowRef(true),
      previewUrls: canPreviewUrls,
      setPreviewUrls,
      current,
      setCurrent,
      setShowPreview,
      setMousePosition,
      registerImage
    });
    return () => {
      const dialogProps = __rest$v(preview.value, []);
      return createVNode(Fragment, null, [slots.default && slots.default(), createVNode(Preview, _objectSpread2$1(_objectSpread2$1({}, dialogProps), {}, {
        "ria-hidden": !isShowPreview.value,
        "visible": isShowPreview.value,
        "prefixCls": props2.previewPrefixCls,
        "onClose": onPreviewClose,
        "mousePosition": mousePosition2.value,
        "src": canPreviewUrls.value.get(current.value),
        "icons": props2.icons,
        "getContainer": getPreviewContainer.value
      }), null)]);
    };
  }
});
const initialPosition = {
  x: 0,
  y: 0
};
const previewProps = _extends$1(_extends$1({}, dialogPropTypes()), {
  src: String,
  alt: String,
  rootClassName: String,
  icons: {
    type: Object,
    default: () => ({})
  }
});
const Preview = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Preview",
  inheritAttrs: false,
  props: previewProps,
  emits: ["close", "afterClose"],
  setup(props2, _ref) {
    let {
      emit,
      attrs
    } = _ref;
    const {
      rotateLeft,
      rotateRight,
      zoomIn: zoomIn2,
      zoomOut: zoomOut2,
      close,
      left,
      right,
      flipX,
      flipY
    } = reactive(props2.icons);
    const scale = shallowRef(1);
    const rotate = shallowRef(0);
    const flip2 = reactive({
      x: 1,
      y: 1
    });
    const [position2, setPosition] = useFrameSetState(initialPosition);
    const onClose = () => emit("close");
    const imgRef = shallowRef();
    const originPositionRef = reactive({
      originX: 0,
      originY: 0,
      deltaX: 0,
      deltaY: 0
    });
    const isMoving = shallowRef(false);
    const groupContext = context.inject();
    const {
      previewUrls,
      current,
      isPreviewGroup,
      setCurrent
    } = groupContext;
    const previewGroupCount = computed(() => previewUrls.value.size);
    const previewUrlsKeys = computed(() => Array.from(previewUrls.value.keys()));
    const currentPreviewIndex = computed(() => previewUrlsKeys.value.indexOf(current.value));
    const combinationSrc = computed(() => {
      return isPreviewGroup.value ? previewUrls.value.get(current.value) : props2.src;
    });
    const showLeftOrRightSwitches = computed(() => isPreviewGroup.value && previewGroupCount.value > 1);
    const lastWheelZoomDirection = shallowRef({
      wheelDirection: 0
    });
    const onAfterClose = () => {
      scale.value = 1;
      rotate.value = 0;
      flip2.x = 1;
      flip2.y = 1;
      setPosition(initialPosition);
      emit("afterClose");
    };
    const onZoomIn = (isWheel) => {
      if (!isWheel) {
        scale.value++;
      } else {
        scale.value += 0.5;
      }
      setPosition(initialPosition);
    };
    const onZoomOut = (isWheel) => {
      if (scale.value > 1) {
        if (!isWheel) {
          scale.value--;
        } else {
          scale.value -= 0.5;
        }
      }
      setPosition(initialPosition);
    };
    const onRotateRight = () => {
      rotate.value += 90;
    };
    const onRotateLeft = () => {
      rotate.value -= 90;
    };
    const onFlipX = () => {
      flip2.x = -flip2.x;
    };
    const onFlipY = () => {
      flip2.y = -flip2.y;
    };
    const onSwitchLeft = (event) => {
      event.preventDefault();
      event.stopPropagation();
      if (currentPreviewIndex.value > 0) {
        setCurrent(previewUrlsKeys.value[currentPreviewIndex.value - 1]);
      }
    };
    const onSwitchRight = (event) => {
      event.preventDefault();
      event.stopPropagation();
      if (currentPreviewIndex.value < previewGroupCount.value - 1) {
        setCurrent(previewUrlsKeys.value[currentPreviewIndex.value + 1]);
      }
    };
    const wrapClassName = classNames({
      [`${props2.prefixCls}-moving`]: isMoving.value
    });
    const toolClassName = `${props2.prefixCls}-operations-operation`;
    const iconClassName = `${props2.prefixCls}-operations-icon`;
    const tools = [{
      icon: close,
      onClick: onClose,
      type: "close"
    }, {
      icon: zoomIn2,
      onClick: () => onZoomIn(),
      type: "zoomIn"
    }, {
      icon: zoomOut2,
      onClick: () => onZoomOut(),
      type: "zoomOut",
      disabled: computed(() => scale.value === 1)
    }, {
      icon: rotateRight,
      onClick: onRotateRight,
      type: "rotateRight"
    }, {
      icon: rotateLeft,
      onClick: onRotateLeft,
      type: "rotateLeft"
    }, {
      icon: flipX,
      onClick: onFlipX,
      type: "flipX"
    }, {
      icon: flipY,
      onClick: onFlipY,
      type: "flipY"
    }];
    const onMouseUp = () => {
      if (props2.visible && isMoving.value) {
        const width = imgRef.value.offsetWidth * scale.value;
        const height = imgRef.value.offsetHeight * scale.value;
        const {
          left: left2,
          top
        } = getOffset$1(imgRef.value);
        const isRotate = rotate.value % 180 !== 0;
        isMoving.value = false;
        const fixState = getFixScaleEleTransPosition(isRotate ? height : width, isRotate ? width : height, left2, top);
        if (fixState) {
          setPosition(_extends$1({}, fixState));
        }
      }
    };
    const onMouseDown = (event) => {
      if (event.button !== 0) return;
      event.preventDefault();
      event.stopPropagation();
      originPositionRef.deltaX = event.pageX - position2.x;
      originPositionRef.deltaY = event.pageY - position2.y;
      originPositionRef.originX = position2.x;
      originPositionRef.originY = position2.y;
      isMoving.value = true;
    };
    const onMouseMove = (event) => {
      if (props2.visible && isMoving.value) {
        setPosition({
          x: event.pageX - originPositionRef.deltaX,
          y: event.pageY - originPositionRef.deltaY
        });
      }
    };
    const onWheelMove = (event) => {
      if (!props2.visible) return;
      event.preventDefault();
      const wheelDirection = event.deltaY;
      lastWheelZoomDirection.value = {
        wheelDirection
      };
    };
    const onKeyDown2 = (event) => {
      if (!props2.visible || !showLeftOrRightSwitches.value) return;
      event.preventDefault();
      if (event.keyCode === KeyCode.LEFT) {
        if (currentPreviewIndex.value > 0) {
          setCurrent(previewUrlsKeys.value[currentPreviewIndex.value - 1]);
        }
      } else if (event.keyCode === KeyCode.RIGHT) {
        if (currentPreviewIndex.value < previewGroupCount.value - 1) {
          setCurrent(previewUrlsKeys.value[currentPreviewIndex.value + 1]);
        }
      }
    };
    const onDoubleClick = () => {
      if (props2.visible) {
        if (scale.value !== 1) {
          scale.value = 1;
        }
        if (position2.x !== initialPosition.x || position2.y !== initialPosition.y) {
          setPosition(initialPosition);
        }
      }
    };
    let removeListeners = () => {
    };
    onMounted(() => {
      watch([() => props2.visible, isMoving], () => {
        removeListeners();
        let onTopMouseUpListener;
        let onTopMouseMoveListener;
        const onMouseUpListener = addEventListenerWrap(window, "mouseup", onMouseUp, false);
        const onMouseMoveListener = addEventListenerWrap(window, "mousemove", onMouseMove, false);
        const onScrollWheelListener = addEventListenerWrap(window, "wheel", onWheelMove, {
          passive: false
        });
        const onKeyDownListener = addEventListenerWrap(window, "keydown", onKeyDown2, false);
        try {
          if (window.top !== window.self) {
            onTopMouseUpListener = addEventListenerWrap(window.top, "mouseup", onMouseUp, false);
            onTopMouseMoveListener = addEventListenerWrap(window.top, "mousemove", onMouseMove, false);
          }
        } catch (error) {
        }
        removeListeners = () => {
          onMouseUpListener.remove();
          onMouseMoveListener.remove();
          onScrollWheelListener.remove();
          onKeyDownListener.remove();
          if (onTopMouseUpListener) onTopMouseUpListener.remove();
          if (onTopMouseMoveListener) onTopMouseMoveListener.remove();
        };
      }, {
        flush: "post",
        immediate: true
      });
      watch([lastWheelZoomDirection], () => {
        const {
          wheelDirection
        } = lastWheelZoomDirection.value;
        if (wheelDirection > 0) {
          onZoomOut(true);
        } else if (wheelDirection < 0) {
          onZoomIn(true);
        }
      });
    });
    onUnmounted(() => {
      removeListeners();
    });
    return () => {
      const {
        visible,
        prefixCls,
        rootClassName
      } = props2;
      return createVNode(DialogWrap, _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "transitionName": props2.transitionName,
        "maskTransitionName": props2.maskTransitionName,
        "closable": false,
        "keyboard": true,
        "prefixCls": prefixCls,
        "onClose": onClose,
        "afterClose": onAfterClose,
        "visible": visible,
        "wrapClassName": wrapClassName,
        "rootClassName": rootClassName,
        "getContainer": props2.getContainer
      }), {
        default: () => [createVNode("div", {
          "class": [`${props2.prefixCls}-operations-wrapper`, rootClassName]
        }, [createVNode("ul", {
          "class": `${props2.prefixCls}-operations`
        }, [tools.map((_ref2) => {
          let {
            icon: IconType,
            onClick,
            type: type4,
            disabled
          } = _ref2;
          return createVNode("li", {
            "class": classNames(toolClassName, {
              [`${props2.prefixCls}-operations-operation-disabled`]: disabled && (disabled === null || disabled === void 0 ? void 0 : disabled.value)
            }),
            "onClick": onClick,
            "key": type4
          }, [cloneVNode(IconType, {
            class: iconClassName
          })]);
        })])]), createVNode("div", {
          "class": `${props2.prefixCls}-img-wrapper`,
          "style": {
            transform: `translate3d(${position2.x}px, ${position2.y}px, 0)`
          }
        }, [createVNode("img", {
          "onMousedown": onMouseDown,
          "onDblclick": onDoubleClick,
          "ref": imgRef,
          "class": `${props2.prefixCls}-img`,
          "src": combinationSrc.value,
          "alt": props2.alt,
          "style": {
            transform: `scale3d(${flip2.x * scale.value}, ${flip2.y * scale.value}, 1) rotate(${rotate.value}deg)`
          }
        }, null)]), showLeftOrRightSwitches.value && createVNode("div", {
          "class": classNames(`${props2.prefixCls}-switch-left`, {
            [`${props2.prefixCls}-switch-left-disabled`]: currentPreviewIndex.value <= 0
          }),
          "onClick": onSwitchLeft
        }, [left]), showLeftOrRightSwitches.value && createVNode("div", {
          "class": classNames(`${props2.prefixCls}-switch-right`, {
            [`${props2.prefixCls}-switch-right-disabled`]: currentPreviewIndex.value >= previewGroupCount.value - 1
          }),
          "onClick": onSwitchRight
        }, [right])]
      });
    };
  }
});
var __rest$u = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const imageProps = () => ({
  src: String,
  wrapperClassName: String,
  wrapperStyle: {
    type: Object,
    default: void 0
  },
  rootClassName: String,
  prefixCls: String,
  previewPrefixCls: String,
  width: [Number, String],
  height: [Number, String],
  previewMask: {
    type: [Boolean, Function],
    default: void 0
  },
  placeholder: PropTypes.any,
  fallback: String,
  preview: {
    type: [Boolean, Object],
    default: true
  },
  onClick: {
    type: Function
  },
  onError: {
    type: Function
  }
});
const mergeDefaultValue = (obj, defaultValues) => {
  const res = _extends$1({}, obj);
  Object.keys(defaultValues).forEach((key2) => {
    if (obj[key2] === void 0) {
      res[key2] = defaultValues[key2];
    }
  });
  return res;
};
let uuid$1 = 0;
const ImageInternal = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "VcImage",
  inheritAttrs: false,
  props: imageProps(),
  emits: ["click", "error"],
  setup(props2, _ref) {
    let {
      attrs,
      slots,
      emit
    } = _ref;
    const prefixCls = computed(() => props2.prefixCls);
    const previewPrefixCls = computed(() => `${prefixCls.value}-preview`);
    const preview = computed(() => {
      const defaultValues = {
        visible: void 0,
        onVisibleChange: () => {
        },
        getContainer: void 0
      };
      return typeof props2.preview === "object" ? mergeDefaultValue(props2.preview, defaultValues) : defaultValues;
    });
    const src = computed(() => {
      var _a2;
      return (_a2 = preview.value.src) !== null && _a2 !== void 0 ? _a2 : props2.src;
    });
    const isCustomPlaceholder = computed(() => props2.placeholder && props2.placeholder !== true || slots.placeholder);
    const previewVisible = computed(() => preview.value.visible);
    const getPreviewContainer = computed(() => preview.value.getContainer);
    const isControlled = computed(() => previewVisible.value !== void 0);
    const onPreviewVisibleChange = (val, preval) => {
      var _a2, _b;
      (_b = (_a2 = preview.value).onVisibleChange) === null || _b === void 0 ? void 0 : _b.call(_a2, val, preval);
    };
    const [isShowPreview, setShowPreview] = useMergedState(!!previewVisible.value, {
      value: previewVisible,
      onChange: onPreviewVisibleChange
    });
    const status = ref(isCustomPlaceholder.value ? "loading" : "normal");
    watch(() => props2.src, () => {
      status.value = isCustomPlaceholder.value ? "loading" : "normal";
    });
    const mousePosition2 = ref(null);
    const isError = computed(() => status.value === "error");
    const groupContext = context.inject();
    const {
      isPreviewGroup,
      setCurrent,
      setShowPreview: setGroupShowPreview,
      setMousePosition: setGroupMousePosition,
      registerImage
    } = groupContext;
    const currentId = ref(uuid$1++);
    const canPreview = computed(() => props2.preview && !isError.value);
    const onLoad = () => {
      status.value = "normal";
    };
    const onError = (e2) => {
      status.value = "error";
      emit("error", e2);
    };
    const onPreview = (e2) => {
      if (!isControlled.value) {
        const {
          left,
          top
        } = getOffset$1(e2.target);
        if (isPreviewGroup.value) {
          setCurrent(currentId.value);
          setGroupMousePosition({
            x: left,
            y: top
          });
        } else {
          mousePosition2.value = {
            x: left,
            y: top
          };
        }
      }
      if (isPreviewGroup.value) {
        setGroupShowPreview(true);
      } else {
        setShowPreview(true);
      }
      emit("click", e2);
    };
    const onPreviewClose = () => {
      setShowPreview(false);
      if (!isControlled.value) {
        mousePosition2.value = null;
      }
    };
    const img = ref(null);
    watch(() => img, () => {
      if (status.value !== "loading") return;
      if (img.value.complete && (img.value.naturalWidth || img.value.naturalHeight)) {
        onLoad();
      }
    });
    let unRegister = () => {
    };
    onMounted(() => {
      watch([src, canPreview], () => {
        unRegister();
        if (!isPreviewGroup.value) {
          return () => {
          };
        }
        unRegister = registerImage(currentId.value, src.value, canPreview.value);
        if (!canPreview.value) {
          unRegister();
        }
      }, {
        flush: "post",
        immediate: true
      });
    });
    onUnmounted(() => {
      unRegister();
    });
    const toSizePx = (l2) => {
      if (isNumber(l2)) return l2 + "px";
      return l2;
    };
    return () => {
      const {
        prefixCls: prefixCls2,
        wrapperClassName,
        fallback,
        src: imgSrc,
        placeholder,
        wrapperStyle: wrapperStyle2,
        rootClassName,
        width,
        height,
        crossorigin,
        decoding,
        alt,
        sizes: sizes2,
        srcset,
        usemap,
        class: cls,
        style
      } = _extends$1(_extends$1({}, props2), attrs);
      const _a2 = preview.value, {
        icons: icons2,
        maskClassName
      } = _a2, dialogProps = __rest$u(_a2, ["icons", "maskClassName"]);
      const wrappperClass = classNames(prefixCls2, wrapperClassName, rootClassName, {
        [`${prefixCls2}-error`]: isError.value
      });
      const mergedSrc = isError.value && fallback ? fallback : src.value;
      const imgCommonProps = {
        crossorigin,
        decoding,
        alt,
        sizes: sizes2,
        srcset,
        usemap,
        width,
        height,
        class: classNames(`${prefixCls2}-img`, {
          [`${prefixCls2}-img-placeholder`]: placeholder === true
        }, cls),
        style: _extends$1({
          height: toSizePx(height)
        }, style)
      };
      return createVNode(Fragment, null, [createVNode("div", {
        "class": wrappperClass,
        "onClick": canPreview.value ? onPreview : (e2) => {
          emit("click", e2);
        },
        "style": _extends$1({
          width: toSizePx(width),
          height: toSizePx(height)
        }, wrapperStyle2)
      }, [createVNode("img", _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, imgCommonProps), isError.value && fallback ? {
        src: fallback
      } : {
        onLoad,
        onError,
        src: imgSrc
      }), {}, {
        "ref": img
      }), null), status.value === "loading" && createVNode("div", {
        "aria-hidden": "true",
        "class": `${prefixCls2}-placeholder`
      }, [placeholder || slots.placeholder && slots.placeholder()]), slots.previewMask && canPreview.value && createVNode("div", {
        "class": [`${prefixCls2}-mask`, maskClassName]
      }, [slots.previewMask()])]), !isPreviewGroup.value && canPreview.value && createVNode(Preview, _objectSpread2$1(_objectSpread2$1({}, dialogProps), {}, {
        "aria-hidden": !isShowPreview.value,
        "visible": isShowPreview.value,
        "prefixCls": previewPrefixCls.value,
        "onClose": onPreviewClose,
        "mousePosition": mousePosition2.value,
        "src": mergedSrc,
        "alt": alt,
        "getContainer": getPreviewContainer.value,
        "icons": icons2,
        "rootClassName": rootClassName
      }), null)]);
    };
  }
});
ImageInternal.PreviewGroup = Group;
function box(position2) {
  return {
    position: position2,
    top: 0,
    insetInlineEnd: 0,
    bottom: 0,
    insetInlineStart: 0
  };
}
const genModalMaskStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return [{
    [`${componentCls}-root`]: {
      [`${componentCls}${token2.antCls}-zoom-enter, ${componentCls}${token2.antCls}-zoom-appear`]: {
        // reset scale avoid mousePosition bug
        transform: "none",
        opacity: 0,
        animationDuration: token2.motionDurationSlow,
        // https://github.com/ant-design/ant-design/issues/11777
        userSelect: "none"
      },
      [`${componentCls}${token2.antCls}-zoom-leave ${componentCls}-content`]: {
        pointerEvents: "none"
      },
      [`${componentCls}-mask`]: _extends$1(_extends$1({}, box("fixed")), {
        zIndex: token2.zIndexPopupBase,
        height: "100%",
        backgroundColor: token2.colorBgMask,
        [`${componentCls}-hidden`]: {
          display: "none"
        }
      }),
      [`${componentCls}-wrap`]: _extends$1(_extends$1({}, box("fixed")), {
        overflow: "auto",
        outline: 0,
        WebkitOverflowScrolling: "touch"
      })
    }
  }, {
    [`${componentCls}-root`]: initFadeMotion(token2)
  }];
};
const genModalStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return [
    // ======================== Root =========================
    {
      [`${componentCls}-root`]: {
        [`${componentCls}-wrap`]: {
          zIndex: token2.zIndexPopupBase,
          position: "fixed",
          inset: 0,
          overflow: "auto",
          outline: 0,
          WebkitOverflowScrolling: "touch"
        },
        [`${componentCls}-wrap-rtl`]: {
          direction: "rtl"
        },
        [`${componentCls}-centered`]: {
          textAlign: "center",
          "&::before": {
            display: "inline-block",
            width: 0,
            height: "100%",
            verticalAlign: "middle",
            content: '""'
          },
          [componentCls]: {
            top: 0,
            display: "inline-block",
            paddingBottom: 0,
            textAlign: "start",
            verticalAlign: "middle"
          }
        },
        [`@media (max-width: ${token2.screenSMMax})`]: {
          [componentCls]: {
            maxWidth: "calc(100vw - 16px)",
            margin: `${token2.marginXS} auto`
          },
          [`${componentCls}-centered`]: {
            [componentCls]: {
              flex: 1
            }
          }
        }
      }
    },
    // ======================== Modal ========================
    {
      [componentCls]: _extends$1(_extends$1({}, resetComponent(token2)), {
        pointerEvents: "none",
        position: "relative",
        top: 100,
        width: "auto",
        maxWidth: `calc(100vw - ${token2.margin * 2}px)`,
        margin: "0 auto",
        paddingBottom: token2.paddingLG,
        [`${componentCls}-title`]: {
          margin: 0,
          color: token2.modalHeadingColor,
          fontWeight: token2.fontWeightStrong,
          fontSize: token2.modalHeaderTitleFontSize,
          lineHeight: token2.modalHeaderTitleLineHeight,
          wordWrap: "break-word"
        },
        [`${componentCls}-content`]: {
          position: "relative",
          backgroundColor: token2.modalContentBg,
          backgroundClip: "padding-box",
          border: 0,
          borderRadius: token2.borderRadiusLG,
          boxShadow: token2.boxShadowSecondary,
          pointerEvents: "auto",
          padding: `${token2.paddingMD}px ${token2.paddingContentHorizontalLG}px`
        },
        [`${componentCls}-close`]: _extends$1({
          position: "absolute",
          top: (token2.modalHeaderCloseSize - token2.modalCloseBtnSize) / 2,
          insetInlineEnd: (token2.modalHeaderCloseSize - token2.modalCloseBtnSize) / 2,
          zIndex: token2.zIndexPopupBase + 10,
          padding: 0,
          color: token2.modalCloseColor,
          fontWeight: token2.fontWeightStrong,
          lineHeight: 1,
          textDecoration: "none",
          background: "transparent",
          borderRadius: token2.borderRadiusSM,
          width: token2.modalConfirmIconSize,
          height: token2.modalConfirmIconSize,
          border: 0,
          outline: 0,
          cursor: "pointer",
          transition: `color ${token2.motionDurationMid}, background-color ${token2.motionDurationMid}`,
          "&-x": {
            display: "block",
            fontSize: token2.fontSizeLG,
            fontStyle: "normal",
            lineHeight: `${token2.modalCloseBtnSize}px`,
            textAlign: "center",
            textTransform: "none",
            textRendering: "auto"
          },
          "&:hover": {
            color: token2.modalIconHoverColor,
            backgroundColor: token2.wireframe ? "transparent" : token2.colorFillContent,
            textDecoration: "none"
          },
          "&:active": {
            backgroundColor: token2.wireframe ? "transparent" : token2.colorFillContentHover
          }
        }, genFocusStyle(token2)),
        [`${componentCls}-header`]: {
          color: token2.colorText,
          background: token2.modalHeaderBg,
          borderRadius: `${token2.borderRadiusLG}px ${token2.borderRadiusLG}px 0 0`,
          marginBottom: token2.marginXS
        },
        [`${componentCls}-body`]: {
          fontSize: token2.fontSize,
          lineHeight: token2.lineHeight,
          wordWrap: "break-word"
        },
        [`${componentCls}-footer`]: {
          textAlign: "end",
          background: token2.modalFooterBg,
          marginTop: token2.marginSM,
          [`${token2.antCls}-btn + ${token2.antCls}-btn:not(${token2.antCls}-dropdown-trigger)`]: {
            marginBottom: 0,
            marginInlineStart: token2.marginXS
          }
        },
        [`${componentCls}-open`]: {
          overflow: "hidden"
        }
      })
    },
    // ======================== Pure =========================
    {
      [`${componentCls}-pure-panel`]: {
        top: "auto",
        padding: 0,
        display: "flex",
        flexDirection: "column",
        [`${componentCls}-content,
          ${componentCls}-body,
          ${componentCls}-confirm-body-wrapper`]: {
          display: "flex",
          flexDirection: "column",
          flex: "auto"
        },
        [`${componentCls}-confirm-body`]: {
          marginBottom: "auto"
        }
      }
    }
  ];
};
const genModalConfirmStyle = (token2) => {
  const {
    componentCls
  } = token2;
  const confirmComponentCls = `${componentCls}-confirm`;
  return {
    [confirmComponentCls]: {
      "&-rtl": {
        direction: "rtl"
      },
      [`${token2.antCls}-modal-header`]: {
        display: "none"
      },
      [`${confirmComponentCls}-body-wrapper`]: _extends$1({}, clearFix()),
      [`${confirmComponentCls}-body`]: {
        display: "flex",
        flexWrap: "wrap",
        alignItems: "center",
        [`${confirmComponentCls}-title`]: {
          flex: "0 0 100%",
          display: "block",
          // create BFC to avoid
          // https://user-images.githubusercontent.com/507615/37702510-ba844e06-2d2d-11e8-9b67-8e19be57f445.png
          overflow: "hidden",
          color: token2.colorTextHeading,
          fontWeight: token2.fontWeightStrong,
          fontSize: token2.modalHeaderTitleFontSize,
          lineHeight: token2.modalHeaderTitleLineHeight,
          [`+ ${confirmComponentCls}-content`]: {
            marginBlockStart: token2.marginXS,
            flexBasis: "100%",
            maxWidth: `calc(100% - ${token2.modalConfirmIconSize + token2.marginSM}px)`
          }
        },
        [`${confirmComponentCls}-content`]: {
          color: token2.colorText,
          fontSize: token2.fontSize
        },
        [`> ${token2.iconCls}`]: {
          flex: "none",
          marginInlineEnd: token2.marginSM,
          fontSize: token2.modalConfirmIconSize,
          [`+ ${confirmComponentCls}-title`]: {
            flex: 1
          },
          // `content` after `icon` should set marginLeft
          [`+ ${confirmComponentCls}-title + ${confirmComponentCls}-content`]: {
            marginInlineStart: token2.modalConfirmIconSize + token2.marginSM
          }
        }
      },
      [`${confirmComponentCls}-btns`]: {
        textAlign: "end",
        marginTop: token2.marginSM,
        [`${token2.antCls}-btn + ${token2.antCls}-btn`]: {
          marginBottom: 0,
          marginInlineStart: token2.marginXS
        }
      }
    },
    [`${confirmComponentCls}-error ${confirmComponentCls}-body > ${token2.iconCls}`]: {
      color: token2.colorError
    },
    [`${confirmComponentCls}-warning ${confirmComponentCls}-body > ${token2.iconCls},
        ${confirmComponentCls}-confirm ${confirmComponentCls}-body > ${token2.iconCls}`]: {
      color: token2.colorWarning
    },
    [`${confirmComponentCls}-info ${confirmComponentCls}-body > ${token2.iconCls}`]: {
      color: token2.colorInfo
    },
    [`${confirmComponentCls}-success ${confirmComponentCls}-body > ${token2.iconCls}`]: {
      color: token2.colorSuccess
    },
    // https://github.com/ant-design/ant-design/issues/37329
    [`${componentCls}-zoom-leave ${componentCls}-btns`]: {
      pointerEvents: "none"
    }
  };
};
const genRTLStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-root`]: {
      [`${componentCls}-wrap-rtl`]: {
        direction: "rtl",
        [`${componentCls}-confirm-body`]: {
          direction: "rtl"
        }
      }
    }
  };
};
const genWireframeStyle = (token2) => {
  const {
    componentCls,
    antCls
  } = token2;
  const confirmComponentCls = `${componentCls}-confirm`;
  return {
    [componentCls]: {
      [`${componentCls}-content`]: {
        padding: 0
      },
      [`${componentCls}-header`]: {
        padding: token2.modalHeaderPadding,
        borderBottom: `${token2.modalHeaderBorderWidth}px ${token2.modalHeaderBorderStyle} ${token2.modalHeaderBorderColorSplit}`,
        marginBottom: 0
      },
      [`${componentCls}-body`]: {
        padding: token2.modalBodyPadding
      },
      [`${componentCls}-footer`]: {
        padding: `${token2.modalFooterPaddingVertical}px ${token2.modalFooterPaddingHorizontal}px`,
        borderTop: `${token2.modalFooterBorderWidth}px ${token2.modalFooterBorderStyle} ${token2.modalFooterBorderColorSplit}`,
        borderRadius: `0 0 ${token2.borderRadiusLG}px ${token2.borderRadiusLG}px`,
        marginTop: 0
      }
    },
    [confirmComponentCls]: {
      [`${antCls}-modal-body`]: {
        padding: `${token2.padding * 2}px ${token2.padding * 2}px ${token2.paddingLG}px`
      },
      [`${confirmComponentCls}-body`]: {
        [`> ${token2.iconCls}`]: {
          marginInlineEnd: token2.margin,
          // `content` after `icon` should set marginLeft
          [`+ ${confirmComponentCls}-title + ${confirmComponentCls}-content`]: {
            marginInlineStart: token2.modalConfirmIconSize + token2.margin
          }
        }
      },
      [`${confirmComponentCls}-btns`]: {
        marginTop: token2.marginLG
      }
    }
  };
};
const useStyle$h = genComponentStyleHook("Modal", (token2) => {
  const headerPaddingVertical = token2.padding;
  const headerFontSize = token2.fontSizeHeading5;
  const headerLineHeight = token2.lineHeightHeading5;
  const modalToken = merge(token2, {
    modalBodyPadding: token2.paddingLG,
    modalHeaderBg: token2.colorBgElevated,
    modalHeaderPadding: `${headerPaddingVertical}px ${token2.paddingLG}px`,
    modalHeaderBorderWidth: token2.lineWidth,
    modalHeaderBorderStyle: token2.lineType,
    modalHeaderTitleLineHeight: headerLineHeight,
    modalHeaderTitleFontSize: headerFontSize,
    modalHeaderBorderColorSplit: token2.colorSplit,
    modalHeaderCloseSize: headerLineHeight * headerFontSize + headerPaddingVertical * 2,
    modalContentBg: token2.colorBgElevated,
    modalHeadingColor: token2.colorTextHeading,
    modalCloseColor: token2.colorTextDescription,
    modalFooterBg: "transparent",
    modalFooterBorderColorSplit: token2.colorSplit,
    modalFooterBorderStyle: token2.lineType,
    modalFooterPaddingVertical: token2.paddingXS,
    modalFooterPaddingHorizontal: token2.padding,
    modalFooterBorderWidth: token2.lineWidth,
    modalConfirmTitleFontSize: token2.fontSizeLG,
    modalIconHoverColor: token2.colorIconHover,
    modalConfirmIconSize: token2.fontSize * token2.lineHeight,
    modalCloseBtnSize: token2.controlHeightLG * 0.55
  });
  return [genModalStyle(modalToken), genModalConfirmStyle(modalToken), genRTLStyle(modalToken), genModalMaskStyle(modalToken), token2.wireframe && genWireframeStyle(modalToken), initZoomMotion(modalToken, "zoom")];
});
const genBoxStyle = (position2) => ({
  position: position2 || "absolute",
  inset: 0
});
const genImageMaskStyle = (token2) => {
  const {
    iconCls,
    motionDurationSlow,
    paddingXXS,
    marginXXS,
    prefixCls
  } = token2;
  return {
    position: "absolute",
    inset: 0,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    color: "#fff",
    background: new TinyColor("#000").setAlpha(0.5).toRgbString(),
    cursor: "pointer",
    opacity: 0,
    transition: `opacity ${motionDurationSlow}`,
    [`.${prefixCls}-mask-info`]: _extends$1(_extends$1({}, textEllipsis), {
      padding: `0 ${paddingXXS}px`,
      [iconCls]: {
        marginInlineEnd: marginXXS,
        svg: {
          verticalAlign: "baseline"
        }
      }
    })
  };
};
const genPreviewOperationsStyle = (token2) => {
  const {
    previewCls,
    modalMaskBg,
    paddingSM,
    previewOperationColorDisabled,
    motionDurationSlow
  } = token2;
  const operationBg = new TinyColor(modalMaskBg).setAlpha(0.1);
  const operationBgHover = operationBg.clone().setAlpha(0.2);
  return {
    [`${previewCls}-operations`]: _extends$1(_extends$1({}, resetComponent(token2)), {
      display: "flex",
      flexDirection: "row-reverse",
      alignItems: "center",
      color: token2.previewOperationColor,
      listStyle: "none",
      background: operationBg.toRgbString(),
      pointerEvents: "auto",
      "&-operation": {
        marginInlineStart: paddingSM,
        padding: paddingSM,
        cursor: "pointer",
        transition: `all ${motionDurationSlow}`,
        userSelect: "none",
        "&:hover": {
          background: operationBgHover.toRgbString()
        },
        "&-disabled": {
          color: previewOperationColorDisabled,
          pointerEvents: "none"
        },
        "&:last-of-type": {
          marginInlineStart: 0
        }
      },
      "&-progress": {
        position: "absolute",
        left: {
          _skip_check_: true,
          value: "50%"
        },
        transform: "translateX(-50%)"
      },
      "&-icon": {
        fontSize: token2.previewOperationSize
      }
    })
  };
};
const genPreviewSwitchStyle = (token2) => {
  const {
    modalMaskBg,
    iconCls,
    previewOperationColorDisabled,
    previewCls,
    zIndexPopup,
    motionDurationSlow
  } = token2;
  const operationBg = new TinyColor(modalMaskBg).setAlpha(0.1);
  const operationBgHover = operationBg.clone().setAlpha(0.2);
  return {
    [`${previewCls}-switch-left, ${previewCls}-switch-right`]: {
      position: "fixed",
      insetBlockStart: "50%",
      zIndex: zIndexPopup + 1,
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      width: token2.imagePreviewSwitchSize,
      height: token2.imagePreviewSwitchSize,
      marginTop: -token2.imagePreviewSwitchSize / 2,
      color: token2.previewOperationColor,
      background: operationBg.toRgbString(),
      borderRadius: "50%",
      transform: `translateY(-50%)`,
      cursor: "pointer",
      transition: `all ${motionDurationSlow}`,
      pointerEvents: "auto",
      userSelect: "none",
      "&:hover": {
        background: operationBgHover.toRgbString()
      },
      [`&-disabled`]: {
        "&, &:hover": {
          color: previewOperationColorDisabled,
          background: "transparent",
          cursor: "not-allowed",
          [`> ${iconCls}`]: {
            cursor: "not-allowed"
          }
        }
      },
      [`> ${iconCls}`]: {
        fontSize: token2.previewOperationSize
      }
    },
    [`${previewCls}-switch-left`]: {
      insetInlineStart: token2.marginSM
    },
    [`${previewCls}-switch-right`]: {
      insetInlineEnd: token2.marginSM
    }
  };
};
const genImagePreviewStyle = (token2) => {
  const {
    motionEaseOut,
    previewCls,
    motionDurationSlow,
    componentCls
  } = token2;
  return [
    {
      [`${componentCls}-preview-root`]: {
        [previewCls]: {
          height: "100%",
          textAlign: "center",
          pointerEvents: "none"
        },
        [`${previewCls}-body`]: _extends$1(_extends$1({}, genBoxStyle()), {
          overflow: "hidden"
        }),
        [`${previewCls}-img`]: {
          maxWidth: "100%",
          maxHeight: "100%",
          verticalAlign: "middle",
          transform: "scale3d(1, 1, 1)",
          cursor: "grab",
          transition: `transform ${motionDurationSlow} ${motionEaseOut} 0s`,
          userSelect: "none",
          pointerEvents: "auto",
          "&-wrapper": _extends$1(_extends$1({}, genBoxStyle()), {
            transition: `transform ${motionDurationSlow} ${motionEaseOut} 0s`,
            // https://github.com/ant-design/ant-design/issues/39913
            // TailwindCSS will reset img default style.
            // Let's set back.
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            "&::before": {
              display: "inline-block",
              width: 1,
              height: "50%",
              marginInlineEnd: -1,
              content: '""'
            }
          })
        },
        [`${previewCls}-moving`]: {
          [`${previewCls}-preview-img`]: {
            cursor: "grabbing",
            "&-wrapper": {
              transitionDuration: "0s"
            }
          }
        }
      }
    },
    // Override
    {
      [`${componentCls}-preview-root`]: {
        [`${previewCls}-wrap`]: {
          zIndex: token2.zIndexPopup
        }
      }
    },
    // Preview operations & switch
    {
      [`${componentCls}-preview-operations-wrapper`]: {
        position: "fixed",
        insetBlockStart: 0,
        insetInlineEnd: 0,
        zIndex: token2.zIndexPopup + 1,
        width: "100%"
      },
      "&": [genPreviewOperationsStyle(token2), genPreviewSwitchStyle(token2)]
    }
  ];
};
const genImageStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    // ============================== image ==============================
    [componentCls]: {
      position: "relative",
      display: "inline-block",
      [`${componentCls}-img`]: {
        width: "100%",
        height: "auto",
        verticalAlign: "middle"
      },
      [`${componentCls}-img-placeholder`]: {
        backgroundColor: token2.colorBgContainerDisabled,
        backgroundImage: "url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNMTQuNSAyLjVoLTEzQS41LjUgMCAwIDAgMSAzdjEwYS41LjUgMCAwIDAgLjUuNWgxM2EuNS41IDAgMCAwIC41LS41VjNhLjUuNSAwIDAgMC0uNS0uNXpNNS4yODEgNC43NWExIDEgMCAwIDEgMCAyIDEgMSAwIDAgMSAwLTJ6bTguMDMgNi44M2EuMTI3LjEyNyAwIDAgMS0uMDgxLjAzSDIuNzY5YS4xMjUuMTI1IDAgMCAxLS4wOTYtLjIwN2wyLjY2MS0zLjE1NmEuMTI2LjEyNiAwIDAgMSAuMTc3LS4wMTZsLjAxNi4wMTZMNy4wOCAxMC4wOWwyLjQ3LTIuOTNhLjEyNi4xMjYgMCAwIDEgLjE3Ny0uMDE2bC4wMTUuMDE2IDMuNTg4IDQuMjQ0YS4xMjcuMTI3IDAgMCAxLS4wMi4xNzV6IiBmaWxsPSIjOEM4QzhDIiBmaWxsLXJ1bGU9Im5vbnplcm8iLz48L3N2Zz4=')",
        backgroundRepeat: "no-repeat",
        backgroundPosition: "center center",
        backgroundSize: "30%"
      },
      [`${componentCls}-mask`]: _extends$1({}, genImageMaskStyle(token2)),
      [`${componentCls}-mask:hover`]: {
        opacity: 1
      },
      [`${componentCls}-placeholder`]: _extends$1({}, genBoxStyle())
    }
  };
};
const genPreviewMotion = (token2) => {
  const {
    previewCls
  } = token2;
  return {
    [`${previewCls}-root`]: initZoomMotion(token2, "zoom"),
    [`&`]: initFadeMotion(token2, true)
  };
};
const useStyle$g = genComponentStyleHook("Image", (token2) => {
  const previewCls = `${token2.componentCls}-preview`;
  const imageToken = merge(token2, {
    previewCls,
    modalMaskBg: new TinyColor("#000").setAlpha(0.45).toRgbString(),
    imagePreviewSwitchSize: token2.controlHeightLG
  });
  return [genImageStyle(imageToken), genImagePreviewStyle(imageToken), genModalMaskStyle(merge(imageToken, {
    componentCls: previewCls
  })), genPreviewMotion(imageToken)];
}, (token2) => ({
  zIndexPopup: token2.zIndexPopupBase + 80,
  previewOperationColor: new TinyColor(token2.colorTextLightSolid).toRgbString(),
  previewOperationColorDisabled: new TinyColor(token2.colorTextLightSolid).setAlpha(0.25).toRgbString(),
  previewOperationSize: token2.fontSizeIcon * 1.5
  // FIXME: fontSizeIconLG
}));
const icons = {
  rotateLeft: createVNode(RotateLeftOutlined, null, null),
  rotateRight: createVNode(RotateRightOutlined, null, null),
  zoomIn: createVNode(ZoomInOutlined, null, null),
  zoomOut: createVNode(ZoomOutOutlined, null, null),
  close: createVNode(CloseOutlined, null, null),
  left: createVNode(LeftOutlined, null, null),
  right: createVNode(RightOutlined, null, null),
  flipX: createVNode(SwapOutlined, null, null),
  flipY: createVNode(SwapOutlined, {
    "rotate": 90
  }, null)
};
const previewGroupProps = () => ({
  previewPrefixCls: String,
  preview: anyType()
});
const InternalPreviewGroup = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AImagePreviewGroup",
  inheritAttrs: false,
  props: previewGroupProps(),
  setup(props2, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const {
      prefixCls,
      rootPrefixCls
    } = useConfigInject("image", props2);
    const previewPrefixCls = computed(() => `${prefixCls.value}-preview`);
    const [wrapSSR, hashId] = useStyle$g(prefixCls);
    const mergedPreview = computed(() => {
      const {
        preview
      } = props2;
      if (preview === false) {
        return preview;
      }
      const _preview = typeof preview === "object" ? preview : {};
      return _extends$1(_extends$1({}, _preview), {
        rootClassName: hashId.value,
        transitionName: getTransitionName(rootPrefixCls.value, "zoom", _preview.transitionName),
        maskTransitionName: getTransitionName(rootPrefixCls.value, "fade", _preview.maskTransitionName)
      });
    });
    return () => {
      return wrapSSR(createVNode(Group, _objectSpread2$1(_objectSpread2$1({}, _extends$1(_extends$1({}, attrs), props2)), {}, {
        "preview": mergedPreview.value,
        "icons": icons,
        "previewPrefixCls": previewPrefixCls.value
      }), slots));
    };
  }
});
const Image$1 = defineComponent({
  name: "AImage",
  inheritAttrs: false,
  props: imageProps(),
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const {
      prefixCls,
      rootPrefixCls,
      configProvider
    } = useConfigInject("image", props2);
    const [wrapSSR, hashId] = useStyle$g(prefixCls);
    const mergedPreview = computed(() => {
      const {
        preview
      } = props2;
      if (preview === false) {
        return preview;
      }
      const _preview = typeof preview === "object" ? preview : {};
      return _extends$1(_extends$1({
        icons
      }, _preview), {
        transitionName: getTransitionName(rootPrefixCls.value, "zoom", _preview.transitionName),
        maskTransitionName: getTransitionName(rootPrefixCls.value, "fade", _preview.maskTransitionName)
      });
    });
    return () => {
      var _a2, _b;
      const imageLocale = ((_b = (_a2 = configProvider.locale) === null || _a2 === void 0 ? void 0 : _a2.value) === null || _b === void 0 ? void 0 : _b.Image) || localeValues.Image;
      const defaultPreviewMask = () => createVNode("div", {
        "class": `${prefixCls.value}-mask-info`
      }, [createVNode(EyeOutlined, null, null), imageLocale === null || imageLocale === void 0 ? void 0 : imageLocale.preview]);
      const {
        previewMask = slots.previewMask || defaultPreviewMask
      } = props2;
      return wrapSSR(createVNode(ImageInternal, _objectSpread2$1(_objectSpread2$1({}, _extends$1(_extends$1(_extends$1({}, attrs), props2), {
        prefixCls: prefixCls.value
      })), {}, {
        "preview": mergedPreview.value,
        "rootClassName": classNames(props2.rootClassName, hashId.value)
      }), _extends$1(_extends$1({}, slots), {
        previewMask: typeof previewMask === "function" ? previewMask : null
      })));
    };
  }
});
Image$1.PreviewGroup = InternalPreviewGroup;
Image$1.install = function(app) {
  app.component(Image$1.name, Image$1);
  app.component(Image$1.PreviewGroup.name, Image$1.PreviewGroup);
  return app;
};
function supportBigInt() {
  return typeof BigInt === "function";
}
function trimNumber(numStr) {
  let str = numStr.trim();
  let negative = str.startsWith("-");
  if (negative) {
    str = str.slice(1);
  }
  str = str.replace(/(\.\d*[^0])0*$/, "$1").replace(/\.0*$/, "").replace(/^0+/, "");
  if (str.startsWith(".")) {
    str = `0${str}`;
  }
  const trimStr = str || "0";
  const splitNumber = trimStr.split(".");
  const integerStr = splitNumber[0] || "0";
  const decimalStr = splitNumber[1] || "0";
  if (integerStr === "0" && decimalStr === "0") {
    negative = false;
  }
  const negativeStr = negative ? "-" : "";
  return {
    negative,
    negativeStr,
    trimStr,
    integerStr,
    decimalStr,
    fullStr: `${negativeStr}${trimStr}`
  };
}
function isE(number4) {
  const str = String(number4);
  return !Number.isNaN(Number(str)) && str.includes("e");
}
function getNumberPrecision(number4) {
  const numStr = String(number4);
  if (isE(number4)) {
    let precision = Number(numStr.slice(numStr.indexOf("e-") + 2));
    const decimalMatch = numStr.match(/\.(\d+)/);
    if (decimalMatch === null || decimalMatch === void 0 ? void 0 : decimalMatch[1]) {
      precision += decimalMatch[1].length;
    }
    return precision;
  }
  return numStr.includes(".") && validateNumber(numStr) ? numStr.length - numStr.indexOf(".") - 1 : 0;
}
function num2str(number4) {
  let numStr = String(number4);
  if (isE(number4)) {
    if (number4 > Number.MAX_SAFE_INTEGER) {
      return String(supportBigInt() ? BigInt(number4).toString() : Number.MAX_SAFE_INTEGER);
    }
    if (number4 < Number.MIN_SAFE_INTEGER) {
      return String(supportBigInt() ? BigInt(number4).toString() : Number.MIN_SAFE_INTEGER);
    }
    numStr = number4.toFixed(getNumberPrecision(numStr));
  }
  return trimNumber(numStr).fullStr;
}
function validateNumber(num) {
  if (typeof num === "number") {
    return !Number.isNaN(num);
  }
  if (!num) {
    return false;
  }
  return (
    // Normal type: 11.28
    /^\s*-?\d+(\.\d+)?\s*$/.test(num) || // Pre-number: 1.
    /^\s*-?\d+\.\s*$/.test(num) || // Post-number: .1
    /^\s*-?\.\d+\s*$/.test(num)
  );
}
function isEmpty(value) {
  return !value && value !== 0 && !Number.isNaN(value) || !String(value).trim();
}
class NumberDecimal {
  constructor(value) {
    this.origin = "";
    if (isEmpty(value)) {
      this.empty = true;
      return;
    }
    this.origin = String(value);
    this.number = Number(value);
  }
  negate() {
    return new NumberDecimal(-this.toNumber());
  }
  add(value) {
    if (this.isInvalidate()) {
      return new NumberDecimal(value);
    }
    const target = Number(value);
    if (Number.isNaN(target)) {
      return this;
    }
    const number4 = this.number + target;
    if (number4 > Number.MAX_SAFE_INTEGER) {
      return new NumberDecimal(Number.MAX_SAFE_INTEGER);
    }
    if (number4 < Number.MIN_SAFE_INTEGER) {
      return new NumberDecimal(Number.MIN_SAFE_INTEGER);
    }
    const maxPrecision = Math.max(getNumberPrecision(this.number), getNumberPrecision(target));
    return new NumberDecimal(number4.toFixed(maxPrecision));
  }
  isEmpty() {
    return this.empty;
  }
  isNaN() {
    return Number.isNaN(this.number);
  }
  isInvalidate() {
    return this.isEmpty() || this.isNaN();
  }
  equals(target) {
    return this.toNumber() === (target === null || target === void 0 ? void 0 : target.toNumber());
  }
  lessEquals(target) {
    return this.add(target.negate().toString()).toNumber() <= 0;
  }
  toNumber() {
    return this.number;
  }
  toString() {
    let safe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    if (!safe) {
      return this.origin;
    }
    if (this.isInvalidate()) {
      return "";
    }
    return num2str(this.number);
  }
}
class BigIntDecimal {
  constructor(value) {
    this.origin = "";
    if (isEmpty(value)) {
      this.empty = true;
      return;
    }
    this.origin = String(value);
    if (value === "-" || Number.isNaN(value)) {
      this.nan = true;
      return;
    }
    let mergedValue = value;
    if (isE(mergedValue)) {
      mergedValue = Number(mergedValue);
    }
    mergedValue = typeof mergedValue === "string" ? mergedValue : num2str(mergedValue);
    if (validateNumber(mergedValue)) {
      const trimRet = trimNumber(mergedValue);
      this.negative = trimRet.negative;
      const numbers = trimRet.trimStr.split(".");
      this.integer = BigInt(numbers[0]);
      const decimalStr = numbers[1] || "0";
      this.decimal = BigInt(decimalStr);
      this.decimalLen = decimalStr.length;
    } else {
      this.nan = true;
    }
  }
  getMark() {
    return this.negative ? "-" : "";
  }
  getIntegerStr() {
    return this.integer.toString();
  }
  getDecimalStr() {
    return this.decimal.toString().padStart(this.decimalLen, "0");
  }
  /**
   * Align BigIntDecimal with same decimal length. e.g. 12.3 + 5 = 1230000
   * This is used for add function only.
   */
  alignDecimal(decimalLength) {
    const str = `${this.getMark()}${this.getIntegerStr()}${this.getDecimalStr().padEnd(decimalLength, "0")}`;
    return BigInt(str);
  }
  negate() {
    const clone2 = new BigIntDecimal(this.toString());
    clone2.negative = !clone2.negative;
    return clone2;
  }
  add(value) {
    if (this.isInvalidate()) {
      return new BigIntDecimal(value);
    }
    const offset3 = new BigIntDecimal(value);
    if (offset3.isInvalidate()) {
      return this;
    }
    const maxDecimalLength = Math.max(this.getDecimalStr().length, offset3.getDecimalStr().length);
    const myAlignedDecimal = this.alignDecimal(maxDecimalLength);
    const offsetAlignedDecimal = offset3.alignDecimal(maxDecimalLength);
    const valueStr = (myAlignedDecimal + offsetAlignedDecimal).toString();
    const {
      negativeStr,
      trimStr
    } = trimNumber(valueStr);
    const hydrateValueStr = `${negativeStr}${trimStr.padStart(maxDecimalLength + 1, "0")}`;
    return new BigIntDecimal(`${hydrateValueStr.slice(0, -maxDecimalLength)}.${hydrateValueStr.slice(-maxDecimalLength)}`);
  }
  isEmpty() {
    return this.empty;
  }
  isNaN() {
    return this.nan;
  }
  isInvalidate() {
    return this.isEmpty() || this.isNaN();
  }
  equals(target) {
    return this.toString() === (target === null || target === void 0 ? void 0 : target.toString());
  }
  lessEquals(target) {
    return this.add(target.negate().toString()).toNumber() <= 0;
  }
  toNumber() {
    if (this.isNaN()) {
      return NaN;
    }
    return Number(this.toString());
  }
  toString() {
    let safe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    if (!safe) {
      return this.origin;
    }
    if (this.isInvalidate()) {
      return "";
    }
    return trimNumber(`${this.getMark()}${this.getIntegerStr()}.${this.getDecimalStr()}`).fullStr;
  }
}
function getMiniDecimal(value) {
  if (supportBigInt()) {
    return new BigIntDecimal(value);
  }
  return new NumberDecimal(value);
}
function toFixed(numStr, separatorStr, precision) {
  let cutOnly = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  if (numStr === "") {
    return "";
  }
  const {
    negativeStr,
    integerStr,
    decimalStr
  } = trimNumber(numStr);
  const precisionDecimalStr = `${separatorStr}${decimalStr}`;
  const numberWithoutDecimal = `${negativeStr}${integerStr}`;
  if (precision >= 0) {
    const advancedNum = Number(decimalStr[precision]);
    if (advancedNum >= 5 && !cutOnly) {
      const advancedDecimal = getMiniDecimal(numStr).add(`${negativeStr}0.${"0".repeat(precision)}${10 - advancedNum}`);
      return toFixed(advancedDecimal.toString(), separatorStr, precision, cutOnly);
    }
    if (precision === 0) {
      return numberWithoutDecimal;
    }
    return `${numberWithoutDecimal}${separatorStr}${decimalStr.padEnd(precision, "0").slice(0, precision)}`;
  }
  if (precisionDecimalStr === ".0") {
    return numberWithoutDecimal;
  }
  return `${numberWithoutDecimal}${precisionDecimalStr}`;
}
const STEP_INTERVAL = 200;
const STEP_DELAY = 600;
const StepHandler = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "StepHandler",
  inheritAttrs: false,
  props: {
    prefixCls: String,
    upDisabled: Boolean,
    downDisabled: Boolean,
    onStep: functionType()
  },
  slots: Object,
  setup(props2, _ref) {
    let {
      slots,
      emit
    } = _ref;
    const stepTimeoutRef = ref();
    const onStepMouseDown = (e2, up) => {
      e2.preventDefault();
      emit("step", up);
      function loopStep() {
        emit("step", up);
        stepTimeoutRef.value = setTimeout(loopStep, STEP_INTERVAL);
      }
      stepTimeoutRef.value = setTimeout(loopStep, STEP_DELAY);
    };
    const onStopStep = () => {
      clearTimeout(stepTimeoutRef.value);
    };
    onBeforeUnmount(() => {
      onStopStep();
    });
    return () => {
      if (isMobile()) {
        return null;
      }
      const {
        prefixCls,
        upDisabled,
        downDisabled
      } = props2;
      const handlerClassName = `${prefixCls}-handler`;
      const upClassName = classNames(handlerClassName, `${handlerClassName}-up`, {
        [`${handlerClassName}-up-disabled`]: upDisabled
      });
      const downClassName = classNames(handlerClassName, `${handlerClassName}-down`, {
        [`${handlerClassName}-down-disabled`]: downDisabled
      });
      const sharedHandlerProps = {
        unselectable: "on",
        role: "button",
        onMouseup: onStopStep,
        onMouseleave: onStopStep
      };
      const {
        upNode,
        downNode
      } = slots;
      return createVNode("div", {
        "class": `${handlerClassName}-wrap`
      }, [createVNode("span", _objectSpread2$1(_objectSpread2$1({}, sharedHandlerProps), {}, {
        "onMousedown": (e2) => {
          onStepMouseDown(e2, true);
        },
        "aria-label": "Increase Value",
        "aria-disabled": upDisabled,
        "class": upClassName
      }), [(upNode === null || upNode === void 0 ? void 0 : upNode()) || createVNode("span", {
        "unselectable": "on",
        "class": `${prefixCls}-handler-up-inner`
      }, null)]), createVNode("span", _objectSpread2$1(_objectSpread2$1({}, sharedHandlerProps), {}, {
        "onMousedown": (e2) => {
          onStepMouseDown(e2, false);
        },
        "aria-label": "Decrease Value",
        "aria-disabled": downDisabled,
        "class": downClassName
      }), [(downNode === null || downNode === void 0 ? void 0 : downNode()) || createVNode("span", {
        "unselectable": "on",
        "class": `${prefixCls}-handler-down-inner`
      }, null)])]);
    };
  }
});
function useCursor(inputRef, focused) {
  const selectionRef = ref(null);
  function recordCursor() {
    try {
      const {
        selectionStart: start,
        selectionEnd: end,
        value
      } = inputRef.value;
      const beforeTxt = value.substring(0, start);
      const afterTxt = value.substring(end);
      selectionRef.value = {
        start,
        end,
        value,
        beforeTxt,
        afterTxt
      };
    } catch (e2) {
    }
  }
  function restoreCursor() {
    if (inputRef.value && selectionRef.value && focused.value) {
      try {
        const {
          value
        } = inputRef.value;
        const {
          beforeTxt,
          afterTxt,
          start
        } = selectionRef.value;
        let startPos = value.length;
        if (value.endsWith(afterTxt)) {
          startPos = value.length - selectionRef.value.afterTxt.length;
        } else if (value.startsWith(beforeTxt)) {
          startPos = beforeTxt.length;
        } else {
          const beforeLastChar = beforeTxt[start - 1];
          const newIndex = value.indexOf(beforeLastChar, start - 1);
          if (newIndex !== -1) {
            startPos = newIndex + 1;
          }
        }
        inputRef.value.setSelectionRange(startPos, startPos);
      } catch (e2) {
        warning$2(false, `Something warning of cursor restore. Please fire issue about this: ${e2.message}`);
      }
    }
  }
  return [recordCursor, restoreCursor];
}
const useFrame = () => {
  const idRef = shallowRef(0);
  const cleanUp = () => {
    wrapperRaf.cancel(idRef.value);
  };
  onBeforeUnmount(() => {
    cleanUp();
  });
  return (callback) => {
    cleanUp();
    idRef.value = wrapperRaf(() => {
      callback();
    });
  };
};
var __rest$t = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const getDecimalValue = (stringMode, decimalValue) => {
  if (stringMode || decimalValue.isEmpty()) {
    return decimalValue.toString();
  }
  return decimalValue.toNumber();
};
const getDecimalIfValidate = (value) => {
  const decimal = getMiniDecimal(value);
  return decimal.isInvalidate() ? null : decimal;
};
const inputNumberProps$1 = () => ({
  /** value will show as string */
  stringMode: booleanType(),
  defaultValue: someType([String, Number]),
  value: someType([String, Number]),
  prefixCls: stringType(),
  min: someType([String, Number]),
  max: someType([String, Number]),
  step: someType([String, Number], 1),
  tabindex: Number,
  controls: booleanType(true),
  readonly: booleanType(),
  disabled: booleanType(),
  autofocus: booleanType(),
  keyboard: booleanType(true),
  /** Parse display value to validate number */
  parser: functionType(),
  /** Transform `value` to display value show in input */
  formatter: functionType(),
  /** Syntactic sugar of `formatter`. Config precision of display. */
  precision: Number,
  /** Syntactic sugar of `formatter`. Config decimal separator of display. */
  decimalSeparator: String,
  onInput: functionType(),
  onChange: functionType(),
  onPressEnter: functionType(),
  onStep: functionType(),
  onBlur: functionType(),
  onFocus: functionType()
});
const VcInputNumber = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "InnerInputNumber",
  inheritAttrs: false,
  props: _extends$1(_extends$1({}, inputNumberProps$1()), {
    lazy: Boolean
  }),
  slots: Object,
  setup(props2, _ref) {
    let {
      attrs,
      slots,
      emit,
      expose
    } = _ref;
    const inputRef = shallowRef();
    const focus = shallowRef(false);
    const userTypingRef = shallowRef(false);
    const compositionRef = shallowRef(false);
    const decimalValue = shallowRef(getMiniDecimal(props2.value));
    function setUncontrolledDecimalValue(newDecimal) {
      if (props2.value === void 0) {
        decimalValue.value = newDecimal;
      }
    }
    const getPrecision2 = (numStr, userTyping) => {
      if (userTyping) {
        return void 0;
      }
      if (props2.precision >= 0) {
        return props2.precision;
      }
      return Math.max(getNumberPrecision(numStr), getNumberPrecision(props2.step));
    };
    const mergedParser = (num) => {
      const numStr = String(num);
      if (props2.parser) {
        return props2.parser(numStr);
      }
      let parsedStr = numStr;
      if (props2.decimalSeparator) {
        parsedStr = parsedStr.replace(props2.decimalSeparator, ".");
      }
      return parsedStr.replace(/[^\w.-]+/g, "");
    };
    const inputValue = shallowRef("");
    const mergedFormatter = (number4, userTyping) => {
      if (props2.formatter) {
        return props2.formatter(number4, {
          userTyping,
          input: String(inputValue.value)
        });
      }
      let str = typeof number4 === "number" ? num2str(number4) : number4;
      if (!userTyping) {
        const mergedPrecision = getPrecision2(str, userTyping);
        if (validateNumber(str) && (props2.decimalSeparator || mergedPrecision >= 0)) {
          const separatorStr = props2.decimalSeparator || ".";
          str = toFixed(str, separatorStr, mergedPrecision);
        }
      }
      return str;
    };
    const initValue = (() => {
      const initValue2 = props2.value;
      if (decimalValue.value.isInvalidate() && ["string", "number"].includes(typeof initValue2)) {
        return Number.isNaN(initValue2) ? "" : initValue2;
      }
      return mergedFormatter(decimalValue.value.toString(), false);
    })();
    inputValue.value = initValue;
    function setInputValue(newValue, userTyping) {
      inputValue.value = mergedFormatter(
        // Invalidate number is sometime passed by external control, we should let it go
        // Otherwise is controlled by internal interactive logic which check by userTyping
        // You can ref 'show limited value when input is not focused' test for more info.
        newValue.isInvalidate() ? newValue.toString(false) : newValue.toString(!userTyping),
        userTyping
      );
    }
    const maxDecimal = computed(() => getDecimalIfValidate(props2.max));
    const minDecimal = computed(() => getDecimalIfValidate(props2.min));
    const upDisabled = computed(() => {
      if (!maxDecimal.value || !decimalValue.value || decimalValue.value.isInvalidate()) {
        return false;
      }
      return maxDecimal.value.lessEquals(decimalValue.value);
    });
    const downDisabled = computed(() => {
      if (!minDecimal.value || !decimalValue.value || decimalValue.value.isInvalidate()) {
        return false;
      }
      return decimalValue.value.lessEquals(minDecimal.value);
    });
    const [recordCursor, restoreCursor] = useCursor(inputRef, focus);
    const getRangeValue = (target) => {
      if (maxDecimal.value && !target.lessEquals(maxDecimal.value)) {
        return maxDecimal.value;
      }
      if (minDecimal.value && !minDecimal.value.lessEquals(target)) {
        return minDecimal.value;
      }
      return null;
    };
    const isInRange2 = (target) => !getRangeValue(target);
    const triggerValueUpdate = (newValue, userTyping) => {
      var _a2;
      let updateValue = newValue;
      let isRangeValidate = isInRange2(updateValue) || updateValue.isEmpty();
      if (!updateValue.isEmpty() && !userTyping) {
        updateValue = getRangeValue(updateValue) || updateValue;
        isRangeValidate = true;
      }
      if (!props2.readonly && !props2.disabled && isRangeValidate) {
        const numStr = updateValue.toString();
        const mergedPrecision = getPrecision2(numStr, userTyping);
        if (mergedPrecision >= 0) {
          updateValue = getMiniDecimal(toFixed(numStr, ".", mergedPrecision));
        }
        if (!updateValue.equals(decimalValue.value)) {
          setUncontrolledDecimalValue(updateValue);
          (_a2 = props2.onChange) === null || _a2 === void 0 ? void 0 : _a2.call(props2, updateValue.isEmpty() ? null : getDecimalValue(props2.stringMode, updateValue));
          if (props2.value === void 0) {
            setInputValue(updateValue, userTyping);
          }
        }
        return updateValue;
      }
      return decimalValue.value;
    };
    const onNextPromise = useFrame();
    const collectInputValue = (inputStr) => {
      var _a2;
      recordCursor();
      inputValue.value = inputStr;
      if (!compositionRef.value) {
        const finalValue = mergedParser(inputStr);
        const finalDecimal = getMiniDecimal(finalValue);
        if (!finalDecimal.isNaN()) {
          triggerValueUpdate(finalDecimal, true);
        }
      }
      (_a2 = props2.onInput) === null || _a2 === void 0 ? void 0 : _a2.call(props2, inputStr);
      onNextPromise(() => {
        let nextInputStr = inputStr;
        if (!props2.parser) {
          nextInputStr = inputStr.replace(/。/g, ".");
        }
        if (nextInputStr !== inputStr) {
          collectInputValue(nextInputStr);
        }
      });
    };
    const onCompositionStart = () => {
      compositionRef.value = true;
    };
    const onCompositionEnd = () => {
      compositionRef.value = false;
      collectInputValue(inputRef.value.value);
    };
    const onInternalInput = (e2) => {
      collectInputValue(e2.target.value);
    };
    const onInternalStep = (up) => {
      var _a2, _b;
      if (up && upDisabled.value || !up && downDisabled.value) {
        return;
      }
      userTypingRef.value = false;
      let stepDecimal = getMiniDecimal(props2.step);
      if (!up) {
        stepDecimal = stepDecimal.negate();
      }
      const target = (decimalValue.value || getMiniDecimal(0)).add(stepDecimal.toString());
      const updatedValue = triggerValueUpdate(target, false);
      (_a2 = props2.onStep) === null || _a2 === void 0 ? void 0 : _a2.call(props2, getDecimalValue(props2.stringMode, updatedValue), {
        offset: props2.step,
        type: up ? "up" : "down"
      });
      (_b = inputRef.value) === null || _b === void 0 ? void 0 : _b.focus();
    };
    const flushInputValue = (userTyping) => {
      const parsedValue = getMiniDecimal(mergedParser(inputValue.value));
      let formatValue2 = parsedValue;
      if (!parsedValue.isNaN()) {
        formatValue2 = triggerValueUpdate(parsedValue, userTyping);
      } else {
        formatValue2 = decimalValue.value;
      }
      if (props2.value !== void 0) {
        setInputValue(decimalValue.value, false);
      } else if (!formatValue2.isNaN()) {
        setInputValue(formatValue2, false);
      }
    };
    const onBeforeInput = () => {
      userTypingRef.value = true;
    };
    const onKeyDown2 = (event) => {
      var _a2;
      const {
        which
      } = event;
      userTypingRef.value = true;
      if (which === KeyCode.ENTER) {
        if (!compositionRef.value) {
          userTypingRef.value = false;
        }
        flushInputValue(false);
        (_a2 = props2.onPressEnter) === null || _a2 === void 0 ? void 0 : _a2.call(props2, event);
      }
      if (props2.keyboard === false) {
        return;
      }
      if (!compositionRef.value && [KeyCode.UP, KeyCode.DOWN].includes(which)) {
        onInternalStep(KeyCode.UP === which);
        event.preventDefault();
      }
    };
    const onKeyUp = () => {
      userTypingRef.value = false;
    };
    const onBlur = (e2) => {
      flushInputValue(false);
      focus.value = false;
      userTypingRef.value = false;
      emit("blur", e2);
    };
    watch(() => props2.precision, () => {
      if (!decimalValue.value.isInvalidate()) {
        setInputValue(decimalValue.value, false);
      }
    }, {
      flush: "post"
    });
    watch(() => props2.value, () => {
      const newValue = getMiniDecimal(props2.value);
      decimalValue.value = newValue;
      const currentParsedValue = getMiniDecimal(mergedParser(inputValue.value));
      if (!newValue.equals(currentParsedValue) || !userTypingRef.value || props2.formatter) {
        setInputValue(newValue, userTypingRef.value);
      }
    }, {
      flush: "post"
    });
    watch(inputValue, () => {
      if (props2.formatter) {
        restoreCursor();
      }
    }, {
      flush: "post"
    });
    watch(() => props2.disabled, (val) => {
      if (val) {
        focus.value = false;
      }
    });
    expose({
      focus: () => {
        var _a2;
        (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
      },
      blur: () => {
        var _a2;
        (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
      }
    });
    return () => {
      const _a2 = _extends$1(_extends$1({}, attrs), props2), {
        prefixCls = "rc-input-number",
        min,
        max,
        step = 1,
        defaultValue,
        value,
        disabled,
        readonly,
        keyboard,
        controls = true,
        autofocus,
        stringMode,
        parser,
        formatter,
        precision,
        decimalSeparator,
        onChange,
        onInput,
        onPressEnter,
        onStep,
        lazy,
        class: className,
        style
      } = _a2, inputProps2 = __rest$t(_a2, ["prefixCls", "min", "max", "step", "defaultValue", "value", "disabled", "readonly", "keyboard", "controls", "autofocus", "stringMode", "parser", "formatter", "precision", "decimalSeparator", "onChange", "onInput", "onPressEnter", "onStep", "lazy", "class", "style"]);
      const {
        upHandler,
        downHandler
      } = slots;
      const inputClassName = `${prefixCls}-input`;
      const eventProps = {};
      if (lazy) {
        eventProps.onChange = onInternalInput;
      } else {
        eventProps.onInput = onInternalInput;
      }
      return createVNode("div", {
        "class": classNames(prefixCls, className, {
          [`${prefixCls}-focused`]: focus.value,
          [`${prefixCls}-disabled`]: disabled,
          [`${prefixCls}-readonly`]: readonly,
          [`${prefixCls}-not-a-number`]: decimalValue.value.isNaN(),
          [`${prefixCls}-out-of-range`]: !decimalValue.value.isInvalidate() && !isInRange2(decimalValue.value)
        }),
        "style": style,
        "onKeydown": onKeyDown2,
        "onKeyup": onKeyUp
      }, [controls && createVNode(StepHandler, {
        "prefixCls": prefixCls,
        "upDisabled": upDisabled.value,
        "downDisabled": downDisabled.value,
        "onStep": onInternalStep
      }, {
        upNode: upHandler,
        downNode: downHandler
      }), createVNode("div", {
        "class": `${inputClassName}-wrap`
      }, [createVNode("input", _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
        "autofocus": autofocus,
        "autocomplete": "off",
        "role": "spinbutton",
        "aria-valuemin": min,
        "aria-valuemax": max,
        "aria-valuenow": decimalValue.value.isInvalidate() ? null : decimalValue.value.toString(),
        "step": step
      }, inputProps2), {}, {
        "ref": inputRef,
        "class": inputClassName,
        "value": inputValue.value,
        "disabled": disabled,
        "readonly": readonly,
        "onFocus": (e2) => {
          focus.value = true;
          emit("focus", e2);
        }
      }, eventProps), {}, {
        "onBlur": onBlur,
        "onCompositionstart": onCompositionStart,
        "onCompositionend": onCompositionEnd,
        "onBeforeinput": onBeforeInput
      }), null)])]);
    };
  }
});
function isValidValue(val) {
  return val !== void 0 && val !== null;
}
const genInputNumberStyles = (token2) => {
  const {
    componentCls,
    lineWidth,
    lineType,
    colorBorder,
    borderRadius,
    fontSizeLG,
    controlHeightLG,
    controlHeightSM,
    colorError,
    inputPaddingHorizontalSM,
    colorTextDescription,
    motionDurationMid,
    colorPrimary,
    controlHeight,
    inputPaddingHorizontal,
    colorBgContainer,
    colorTextDisabled,
    borderRadiusSM,
    borderRadiusLG,
    controlWidth,
    handleVisible
  } = token2;
  return [
    {
      [componentCls]: _extends$1(_extends$1(_extends$1(_extends$1({}, resetComponent(token2)), genBasicInputStyle(token2)), genStatusStyle(token2, componentCls)), {
        display: "inline-block",
        width: controlWidth,
        margin: 0,
        padding: 0,
        border: `${lineWidth}px ${lineType} ${colorBorder}`,
        borderRadius,
        "&-rtl": {
          direction: "rtl",
          [`${componentCls}-input`]: {
            direction: "rtl"
          }
        },
        "&-lg": {
          padding: 0,
          fontSize: fontSizeLG,
          borderRadius: borderRadiusLG,
          [`input${componentCls}-input`]: {
            height: controlHeightLG - 2 * lineWidth
          }
        },
        "&-sm": {
          padding: 0,
          borderRadius: borderRadiusSM,
          [`input${componentCls}-input`]: {
            height: controlHeightSM - 2 * lineWidth,
            padding: `0 ${inputPaddingHorizontalSM}px`
          }
        },
        "&:hover": _extends$1({}, genHoverStyle(token2)),
        "&-focused": _extends$1({}, genActiveStyle(token2)),
        "&-disabled": _extends$1(_extends$1({}, genDisabledStyle(token2)), {
          [`${componentCls}-input`]: {
            cursor: "not-allowed"
          }
        }),
        // ===================== Out Of Range =====================
        "&-out-of-range": {
          input: {
            color: colorError
          }
        },
        // Style for input-group: input with label, with button or dropdown...
        "&-group": _extends$1(_extends$1(_extends$1({}, resetComponent(token2)), genInputGroupStyle(token2)), {
          "&-wrapper": {
            display: "inline-block",
            textAlign: "start",
            verticalAlign: "top",
            [`${componentCls}-affix-wrapper`]: {
              width: "100%"
            },
            // Size
            "&-lg": {
              [`${componentCls}-group-addon`]: {
                borderRadius: borderRadiusLG
              }
            },
            "&-sm": {
              [`${componentCls}-group-addon`]: {
                borderRadius: borderRadiusSM
              }
            }
          }
        }),
        [componentCls]: {
          "&-input": _extends$1(_extends$1({
            width: "100%",
            height: controlHeight - 2 * lineWidth,
            padding: `0 ${inputPaddingHorizontal}px`,
            textAlign: "start",
            backgroundColor: "transparent",
            border: 0,
            borderRadius,
            outline: 0,
            transition: `all ${motionDurationMid} linear`,
            appearance: "textfield",
            color: token2.colorText,
            fontSize: "inherit",
            verticalAlign: "top"
          }, genPlaceholderStyle(token2.colorTextPlaceholder)), {
            '&[type="number"]::-webkit-inner-spin-button, &[type="number"]::-webkit-outer-spin-button': {
              margin: 0,
              /* stylelint-disable-next-line property-no-vendor-prefix */
              webkitAppearance: "none",
              appearance: "none"
            }
          })
        }
      })
    },
    // Handler
    {
      [componentCls]: {
        [`&:hover ${componentCls}-handler-wrap, &-focused ${componentCls}-handler-wrap`]: {
          opacity: 1
        },
        [`${componentCls}-handler-wrap`]: {
          position: "absolute",
          insetBlockStart: 0,
          insetInlineEnd: 0,
          width: token2.handleWidth,
          height: "100%",
          background: colorBgContainer,
          borderStartStartRadius: 0,
          borderStartEndRadius: borderRadius,
          borderEndEndRadius: borderRadius,
          borderEndStartRadius: 0,
          opacity: handleVisible === true ? 1 : 0,
          display: "flex",
          flexDirection: "column",
          alignItems: "stretch",
          transition: `opacity ${motionDurationMid} linear ${motionDurationMid}`,
          // Fix input number inside Menu makes icon too large
          // We arise the selector priority by nest selector here
          // https://github.com/ant-design/ant-design/issues/14367
          [`${componentCls}-handler`]: {
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            flex: "auto",
            height: "40%",
            [`
              ${componentCls}-handler-up-inner,
              ${componentCls}-handler-down-inner
            `]: {
              marginInlineEnd: 0,
              fontSize: token2.handleFontSize
            }
          }
        },
        [`${componentCls}-handler`]: {
          height: "50%",
          overflow: "hidden",
          color: colorTextDescription,
          fontWeight: "bold",
          lineHeight: 0,
          textAlign: "center",
          cursor: "pointer",
          borderInlineStart: `${lineWidth}px ${lineType} ${colorBorder}`,
          transition: `all ${motionDurationMid} linear`,
          "&:active": {
            background: token2.colorFillAlter
          },
          // Hover
          "&:hover": {
            height: `60%`,
            [`
              ${componentCls}-handler-up-inner,
              ${componentCls}-handler-down-inner
            `]: {
              color: colorPrimary
            }
          },
          "&-up-inner, &-down-inner": _extends$1(_extends$1({}, resetIcon()), {
            color: colorTextDescription,
            transition: `all ${motionDurationMid} linear`,
            userSelect: "none"
          })
        },
        [`${componentCls}-handler-up`]: {
          borderStartEndRadius: borderRadius
        },
        [`${componentCls}-handler-down`]: {
          borderBlockStart: `${lineWidth}px ${lineType} ${colorBorder}`,
          borderEndEndRadius: borderRadius
        },
        // Disabled
        "&-disabled, &-readonly": {
          [`${componentCls}-handler-wrap`]: {
            display: "none"
          },
          [`${componentCls}-input`]: {
            color: "inherit"
          }
        },
        [`
          ${componentCls}-handler-up-disabled,
          ${componentCls}-handler-down-disabled
        `]: {
          cursor: "not-allowed"
        },
        [`
          ${componentCls}-handler-up-disabled:hover &-handler-up-inner,
          ${componentCls}-handler-down-disabled:hover &-handler-down-inner
        `]: {
          color: colorTextDisabled
        }
      }
    },
    // Border-less
    {
      [`${componentCls}-borderless`]: {
        borderColor: "transparent",
        boxShadow: "none",
        [`${componentCls}-handler-down`]: {
          borderBlockStartWidth: 0
        }
      }
    }
  ];
};
const genAffixWrapperStyles = (token2) => {
  const {
    componentCls,
    inputPaddingHorizontal,
    inputAffixPadding,
    controlWidth,
    borderRadiusLG,
    borderRadiusSM
  } = token2;
  return {
    [`${componentCls}-affix-wrapper`]: _extends$1(_extends$1(_extends$1({}, genBasicInputStyle(token2)), genStatusStyle(token2, `${componentCls}-affix-wrapper`)), {
      // or number handler will cover form status
      position: "relative",
      display: "inline-flex",
      width: controlWidth,
      padding: 0,
      paddingInlineStart: inputPaddingHorizontal,
      "&-lg": {
        borderRadius: borderRadiusLG
      },
      "&-sm": {
        borderRadius: borderRadiusSM
      },
      [`&:not(${componentCls}-affix-wrapper-disabled):hover`]: _extends$1(_extends$1({}, genHoverStyle(token2)), {
        zIndex: 1
      }),
      "&-focused, &:focus": {
        zIndex: 1
      },
      "&-disabled": {
        [`${componentCls}[disabled]`]: {
          background: "transparent"
        }
      },
      [`> div${componentCls}`]: {
        width: "100%",
        border: "none",
        outline: "none",
        [`&${componentCls}-focused`]: {
          boxShadow: "none !important"
        }
      },
      [`input${componentCls}-input`]: {
        padding: 0
      },
      "&::before": {
        width: 0,
        visibility: "hidden",
        content: '"\\a0"'
      },
      [`${componentCls}-handler-wrap`]: {
        zIndex: 2
      },
      [componentCls]: {
        "&-prefix, &-suffix": {
          display: "flex",
          flex: "none",
          alignItems: "center",
          pointerEvents: "none"
        },
        "&-prefix": {
          marginInlineEnd: inputAffixPadding
        },
        "&-suffix": {
          position: "absolute",
          insetBlockStart: 0,
          insetInlineEnd: 0,
          zIndex: 1,
          height: "100%",
          marginInlineEnd: inputPaddingHorizontal,
          marginInlineStart: inputAffixPadding
        }
      }
    })
  };
};
const useStyle$f = genComponentStyleHook("InputNumber", (token2) => {
  const inputNumberToken = initInputToken(token2);
  return [
    genInputNumberStyles(inputNumberToken),
    genAffixWrapperStyles(inputNumberToken),
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    genCompactItemStyle(inputNumberToken)
  ];
}, (token2) => ({
  controlWidth: 90,
  handleWidth: token2.controlHeightSM - token2.lineWidth * 2,
  handleFontSize: token2.fontSize / 2,
  handleVisible: "auto"
}));
var __rest$s = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const baseProps$1 = inputNumberProps$1();
const inputNumberProps = () => _extends$1(_extends$1({}, baseProps$1), {
  size: stringType(),
  bordered: booleanType(true),
  placeholder: String,
  name: String,
  id: String,
  type: String,
  addonBefore: PropTypes.any,
  addonAfter: PropTypes.any,
  prefix: PropTypes.any,
  "onUpdate:value": baseProps$1.onChange,
  valueModifiers: Object,
  status: stringType()
});
const InputNumber = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AInputNumber",
  inheritAttrs: false,
  props: inputNumberProps(),
  // emits: ['focus', 'blur', 'change', 'input', 'update:value'],
  slots: Object,
  setup(props2, _ref) {
    let {
      emit,
      expose,
      attrs,
      slots
    } = _ref;
    var _a2;
    const formItemContext = useInjectFormItemContext();
    const formItemInputContext = FormItemInputContext.useInject();
    const mergedStatus = computed(() => getMergedStatus(formItemInputContext.status, props2.status));
    const {
      prefixCls,
      size,
      direction,
      disabled
    } = useConfigInject("input-number", props2);
    const {
      compactSize,
      compactItemClassnames
    } = useCompactItemContext(prefixCls, direction);
    const disabledContext = useInjectDisabled();
    const mergedDisabled = computed(() => {
      var _a3;
      return (_a3 = disabled.value) !== null && _a3 !== void 0 ? _a3 : disabledContext.value;
    });
    const [wrapSSR, hashId] = useStyle$f(prefixCls);
    const mergedSize = computed(() => compactSize.value || size.value);
    const mergedValue = shallowRef((_a2 = props2.value) !== null && _a2 !== void 0 ? _a2 : props2.defaultValue);
    const focused = shallowRef(false);
    watch(() => props2.value, () => {
      mergedValue.value = props2.value;
    });
    const inputNumberRef = shallowRef(null);
    const focus = () => {
      var _a3;
      (_a3 = inputNumberRef.value) === null || _a3 === void 0 ? void 0 : _a3.focus();
    };
    const blur = () => {
      var _a3;
      (_a3 = inputNumberRef.value) === null || _a3 === void 0 ? void 0 : _a3.blur();
    };
    expose({
      focus,
      blur
    });
    const handleChange = (val) => {
      if (props2.value === void 0) {
        mergedValue.value = val;
      }
      emit("update:value", val);
      emit("change", val);
      formItemContext.onFieldChange();
    };
    const handleBlur = (e2) => {
      focused.value = false;
      emit("blur", e2);
      formItemContext.onFieldBlur();
    };
    const handleFocus = (e2) => {
      focused.value = true;
      emit("focus", e2);
    };
    return () => {
      var _a3, _b, _c, _d;
      const {
        hasFeedback,
        isFormItemInput,
        feedbackIcon
      } = formItemInputContext;
      const id = (_a3 = props2.id) !== null && _a3 !== void 0 ? _a3 : formItemContext.id.value;
      const _e = _extends$1(_extends$1(_extends$1({}, attrs), props2), {
        id,
        disabled: mergedDisabled.value
      }), {
        class: className,
        bordered,
        readonly,
        style,
        addonBefore = (_b = slots.addonBefore) === null || _b === void 0 ? void 0 : _b.call(slots),
        addonAfter = (_c = slots.addonAfter) === null || _c === void 0 ? void 0 : _c.call(slots),
        prefix = (_d = slots.prefix) === null || _d === void 0 ? void 0 : _d.call(slots),
        valueModifiers = {}
      } = _e, others = __rest$s(_e, ["class", "bordered", "readonly", "style", "addonBefore", "addonAfter", "prefix", "valueModifiers"]);
      const preCls = prefixCls.value;
      const inputNumberClass = classNames({
        [`${preCls}-lg`]: mergedSize.value === "large",
        [`${preCls}-sm`]: mergedSize.value === "small",
        [`${preCls}-rtl`]: direction.value === "rtl",
        [`${preCls}-readonly`]: readonly,
        [`${preCls}-borderless`]: !bordered,
        [`${preCls}-in-form-item`]: isFormItemInput
      }, getStatusClassNames(preCls, mergedStatus.value), className, compactItemClassnames.value, hashId.value);
      let element = createVNode(VcInputNumber, _objectSpread2$1(_objectSpread2$1({}, omit$1(others, ["size", "defaultValue"])), {}, {
        "ref": inputNumberRef,
        "lazy": !!valueModifiers.lazy,
        "value": mergedValue.value,
        "class": inputNumberClass,
        "prefixCls": preCls,
        "readonly": readonly,
        "onChange": handleChange,
        "onBlur": handleBlur,
        "onFocus": handleFocus
      }), {
        upHandler: slots.upIcon ? () => createVNode("span", {
          "class": `${preCls}-handler-up-inner`
        }, [slots.upIcon()]) : () => createVNode(UpOutlined, {
          "class": `${preCls}-handler-up-inner`
        }, null),
        downHandler: slots.downIcon ? () => createVNode("span", {
          "class": `${preCls}-handler-down-inner`
        }, [slots.downIcon()]) : () => createVNode(DownOutlined, {
          "class": `${preCls}-handler-down-inner`
        }, null)
      });
      const hasAddon2 = isValidValue(addonBefore) || isValidValue(addonAfter);
      const hasPrefix = isValidValue(prefix);
      if (hasPrefix || hasFeedback) {
        const affixWrapperCls = classNames(`${preCls}-affix-wrapper`, getStatusClassNames(`${preCls}-affix-wrapper`, mergedStatus.value, hasFeedback), {
          [`${preCls}-affix-wrapper-focused`]: focused.value,
          [`${preCls}-affix-wrapper-disabled`]: mergedDisabled.value,
          [`${preCls}-affix-wrapper-sm`]: mergedSize.value === "small",
          [`${preCls}-affix-wrapper-lg`]: mergedSize.value === "large",
          [`${preCls}-affix-wrapper-rtl`]: direction.value === "rtl",
          [`${preCls}-affix-wrapper-readonly`]: readonly,
          [`${preCls}-affix-wrapper-borderless`]: !bordered,
          // className will go to addon wrapper
          [`${className}`]: !hasAddon2 && className
        }, hashId.value);
        element = createVNode("div", {
          "class": affixWrapperCls,
          "style": style,
          "onClick": focus
        }, [hasPrefix && createVNode("span", {
          "class": `${preCls}-prefix`
        }, [prefix]), element, hasFeedback && createVNode("span", {
          "class": `${preCls}-suffix`
        }, [feedbackIcon])]);
      }
      if (hasAddon2) {
        const wrapperClassName = `${preCls}-group`;
        const addonClassName = `${wrapperClassName}-addon`;
        const addonBeforeNode = addonBefore ? createVNode("div", {
          "class": addonClassName
        }, [addonBefore]) : null;
        const addonAfterNode = addonAfter ? createVNode("div", {
          "class": addonClassName
        }, [addonAfter]) : null;
        const mergedWrapperClassName = classNames(`${preCls}-wrapper`, wrapperClassName, {
          [`${wrapperClassName}-rtl`]: direction.value === "rtl"
        }, hashId.value);
        const mergedGroupClassName = classNames(`${preCls}-group-wrapper`, {
          [`${preCls}-group-wrapper-sm`]: mergedSize.value === "small",
          [`${preCls}-group-wrapper-lg`]: mergedSize.value === "large",
          [`${preCls}-group-wrapper-rtl`]: direction.value === "rtl"
        }, getStatusClassNames(`${prefixCls}-group-wrapper`, mergedStatus.value, hasFeedback), className, hashId.value);
        element = createVNode("div", {
          "class": mergedGroupClassName,
          "style": style
        }, [createVNode("div", {
          "class": mergedWrapperClassName
        }, [addonBeforeNode && createVNode(NoCompactStyle, null, {
          default: () => [createVNode(NoFormStatus, null, {
            default: () => [addonBeforeNode]
          })]
        }), element, addonAfterNode && createVNode(NoCompactStyle, null, {
          default: () => [createVNode(NoFormStatus, null, {
            default: () => [addonAfterNode]
          })]
        })])]);
      }
      return wrapSSR(cloneElement(element, {
        style
      }));
    };
  }
});
const InputNumber$1 = _extends$1(InputNumber, {
  install: (app) => {
    app.component(InputNumber.name, InputNumber);
    return app;
  }
});
const genLayoutLightStyle = (token2) => {
  const {
    componentCls,
    colorBgContainer,
    colorBgBody,
    colorText
  } = token2;
  return {
    [`${componentCls}-sider-light`]: {
      background: colorBgContainer,
      [`${componentCls}-sider-trigger`]: {
        color: colorText,
        background: colorBgContainer
      },
      [`${componentCls}-sider-zero-width-trigger`]: {
        color: colorText,
        background: colorBgContainer,
        border: `1px solid ${colorBgBody}`,
        borderInlineStart: 0
      }
    }
  };
};
const genLayoutStyle = (token2) => {
  const {
    antCls,
    // .ant
    componentCls,
    // .ant-layout
    colorText,
    colorTextLightSolid,
    colorBgHeader,
    colorBgBody,
    colorBgTrigger,
    layoutHeaderHeight,
    layoutHeaderPaddingInline,
    layoutHeaderColor,
    layoutFooterPadding,
    layoutTriggerHeight,
    layoutZeroTriggerSize,
    motionDurationMid,
    motionDurationSlow,
    fontSize,
    borderRadius
  } = token2;
  return {
    [componentCls]: _extends$1(_extends$1({
      display: "flex",
      flex: "auto",
      flexDirection: "column",
      color: colorText,
      /* fix firefox can't set height smaller than content on flex item */
      minHeight: 0,
      background: colorBgBody,
      "&, *": {
        boxSizing: "border-box"
      },
      [`&${componentCls}-has-sider`]: {
        flexDirection: "row",
        [`> ${componentCls}, > ${componentCls}-content`]: {
          // https://segmentfault.com/a/1190000019498300
          width: 0
        }
      },
      [`${componentCls}-header, &${componentCls}-footer`]: {
        flex: "0 0 auto"
      },
      [`${componentCls}-header`]: {
        height: layoutHeaderHeight,
        paddingInline: layoutHeaderPaddingInline,
        color: layoutHeaderColor,
        lineHeight: `${layoutHeaderHeight}px`,
        background: colorBgHeader,
        // Other components/menu/style/index.less line:686
        // Integration with header element so menu items have the same height
        [`${antCls}-menu`]: {
          lineHeight: "inherit"
        }
      },
      [`${componentCls}-footer`]: {
        padding: layoutFooterPadding,
        color: colorText,
        fontSize,
        background: colorBgBody
      },
      [`${componentCls}-content`]: {
        flex: "auto",
        // fix firefox can't set height smaller than content on flex item
        minHeight: 0
      },
      [`${componentCls}-sider`]: {
        position: "relative",
        // fix firefox can't set width smaller than content on flex item
        minWidth: 0,
        background: colorBgHeader,
        transition: `all ${motionDurationMid}, background 0s`,
        "&-children": {
          height: "100%",
          // Hack for fixing margin collapse bug
          // https://github.com/ant-design/ant-design/issues/7967
          // solution from https://stackoverflow.com/a/33132624/3040605
          marginTop: -0.1,
          paddingTop: 0.1,
          [`${antCls}-menu${antCls}-menu-inline-collapsed`]: {
            width: "auto"
          }
        },
        "&-has-trigger": {
          paddingBottom: layoutTriggerHeight
        },
        "&-right": {
          order: 1
        },
        "&-trigger": {
          position: "fixed",
          bottom: 0,
          zIndex: 1,
          height: layoutTriggerHeight,
          color: colorTextLightSolid,
          lineHeight: `${layoutTriggerHeight}px`,
          textAlign: "center",
          background: colorBgTrigger,
          cursor: "pointer",
          transition: `all ${motionDurationMid}`
        },
        "&-zero-width": {
          "> *": {
            overflow: "hidden"
          },
          "&-trigger": {
            position: "absolute",
            top: layoutHeaderHeight,
            insetInlineEnd: -layoutZeroTriggerSize,
            zIndex: 1,
            width: layoutZeroTriggerSize,
            height: layoutZeroTriggerSize,
            color: colorTextLightSolid,
            fontSize: token2.fontSizeXL,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            background: colorBgHeader,
            borderStartStartRadius: 0,
            borderStartEndRadius: borderRadius,
            borderEndEndRadius: borderRadius,
            borderEndStartRadius: 0,
            cursor: "pointer",
            transition: `background ${motionDurationSlow} ease`,
            "&::after": {
              position: "absolute",
              inset: 0,
              background: "transparent",
              transition: `all ${motionDurationSlow}`,
              content: '""'
            },
            "&:hover::after": {
              // FIXME: Hardcode, but seems no need to create a token for this
              background: `rgba(255, 255, 255, 0.2)`
            },
            "&-right": {
              insetInlineStart: -layoutZeroTriggerSize,
              borderStartStartRadius: borderRadius,
              borderStartEndRadius: 0,
              borderEndEndRadius: 0,
              borderEndStartRadius: borderRadius
            }
          }
        }
      }
    }, genLayoutLightStyle(token2)), {
      // RTL
      "&-rtl": {
        direction: "rtl"
      }
    })
  };
};
const useStyle$e = genComponentStyleHook("Layout", (token2) => {
  const {
    colorText,
    controlHeightSM,
    controlHeight,
    controlHeightLG,
    marginXXS
  } = token2;
  const layoutHeaderPaddingInline = controlHeightLG * 1.25;
  const layoutToken = merge(token2, {
    // Layout
    layoutHeaderHeight: controlHeight * 2,
    layoutHeaderPaddingInline,
    layoutHeaderColor: colorText,
    layoutFooterPadding: `${controlHeightSM}px ${layoutHeaderPaddingInline}px`,
    layoutTriggerHeight: controlHeightLG + marginXXS * 2,
    layoutZeroTriggerSize: controlHeightLG
  });
  return [genLayoutStyle(layoutToken)];
}, (token2) => {
  const {
    colorBgLayout
  } = token2;
  return {
    colorBgHeader: "#001529",
    colorBgBody: colorBgLayout,
    colorBgTrigger: "#002140"
  };
});
const basicProps = () => ({
  prefixCls: String,
  hasSider: {
    type: Boolean,
    default: void 0
  },
  tagName: String
});
function generator(_ref) {
  let {
    suffixCls,
    tagName,
    name
  } = _ref;
  return (BasicComponent) => {
    const Adapter = defineComponent({
      compatConfig: {
        MODE: 3
      },
      name,
      props: basicProps(),
      setup(props2, _ref2) {
        let {
          slots
        } = _ref2;
        const {
          prefixCls
        } = useConfigInject(suffixCls, props2);
        return () => {
          const basicComponentProps = _extends$1(_extends$1({}, props2), {
            prefixCls: prefixCls.value,
            tagName
          });
          return createVNode(BasicComponent, basicComponentProps, slots);
        };
      }
    });
    return Adapter;
  };
}
const Basic = defineComponent({
  compatConfig: {
    MODE: 3
  },
  props: basicProps(),
  setup(props2, _ref3) {
    let {
      slots
    } = _ref3;
    return () => createVNode(props2.tagName, {
      class: props2.prefixCls
    }, slots);
  }
});
const BasicLayout = defineComponent({
  compatConfig: {
    MODE: 3
  },
  inheritAttrs: false,
  props: basicProps(),
  setup(props2, _ref4) {
    let {
      slots,
      attrs
    } = _ref4;
    const {
      prefixCls,
      direction
    } = useConfigInject("", props2);
    const [wrapSSR, hashId] = useStyle$e(prefixCls);
    const siders = ref([]);
    const siderHookProvider = {
      addSider: (id) => {
        siders.value = [...siders.value, id];
      },
      removeSider: (id) => {
        siders.value = siders.value.filter((currentId) => currentId !== id);
      }
    };
    provide(SiderHookProviderKey, siderHookProvider);
    const divCls = computed(() => {
      const {
        prefixCls: prefixCls2,
        hasSider
      } = props2;
      return {
        [hashId.value]: true,
        [`${prefixCls2}`]: true,
        [`${prefixCls2}-has-sider`]: typeof hasSider === "boolean" ? hasSider : siders.value.length > 0,
        [`${prefixCls2}-rtl`]: direction.value === "rtl"
      };
    });
    return () => {
      const {
        tagName
      } = props2;
      return wrapSSR(createVNode(tagName, _extends$1(_extends$1({}, attrs), {
        class: [divCls.value, attrs.class]
      }), slots));
    };
  }
});
const Layout$1 = generator({
  suffixCls: "layout",
  tagName: "section",
  name: "ALayout"
})(BasicLayout);
const Header$1 = generator({
  suffixCls: "layout-header",
  tagName: "header",
  name: "ALayoutHeader"
})(Basic);
const Footer$1 = generator({
  suffixCls: "layout-footer",
  tagName: "footer",
  name: "ALayoutFooter"
})(Basic);
const Content = generator({
  suffixCls: "layout-content",
  tagName: "main",
  name: "ALayoutContent"
})(Basic);
const dimensionMaxMap = {
  xs: "479.98px",
  sm: "575.98px",
  md: "767.98px",
  lg: "991.98px",
  xl: "1199.98px",
  xxl: "1599.98px",
  xxxl: "1999.98px"
};
const siderProps = () => ({
  prefixCls: String,
  collapsible: {
    type: Boolean,
    default: void 0
  },
  collapsed: {
    type: Boolean,
    default: void 0
  },
  defaultCollapsed: {
    type: Boolean,
    default: void 0
  },
  reverseArrow: {
    type: Boolean,
    default: void 0
  },
  zeroWidthTriggerStyle: {
    type: Object,
    default: void 0
  },
  trigger: PropTypes.any,
  width: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  collapsedWidth: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  breakpoint: PropTypes.oneOf(tuple$1("xs", "sm", "md", "lg", "xl", "xxl", "xxxl")),
  theme: PropTypes.oneOf(tuple$1("light", "dark")).def("dark"),
  onBreakpoint: Function,
  onCollapse: Function
});
const generateId = /* @__PURE__ */ (() => {
  let i2 = 0;
  return function() {
    let prefix = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    i2 += 1;
    return `${prefix}${i2}`;
  };
})();
const Sider = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ALayoutSider",
  inheritAttrs: false,
  props: initDefaultProps(siderProps(), {
    collapsible: false,
    defaultCollapsed: false,
    reverseArrow: false,
    width: 200,
    collapsedWidth: 80
  }),
  emits: ["breakpoint", "update:collapsed", "collapse"],
  setup(props2, _ref) {
    let {
      emit,
      attrs,
      slots
    } = _ref;
    const {
      prefixCls
    } = useConfigInject("layout-sider", props2);
    const siderHook = inject(SiderHookProviderKey, void 0);
    const collapsed = shallowRef(!!(props2.collapsed !== void 0 ? props2.collapsed : props2.defaultCollapsed));
    const below = shallowRef(false);
    watch(() => props2.collapsed, () => {
      collapsed.value = !!props2.collapsed;
    });
    provide(SiderCollapsedKey, collapsed);
    const handleSetCollapsed = (value, type4) => {
      if (props2.collapsed === void 0) {
        collapsed.value = value;
      }
      emit("update:collapsed", value);
      emit("collapse", value, type4);
    };
    const responsiveHandlerRef = shallowRef((mql2) => {
      below.value = mql2.matches;
      emit("breakpoint", mql2.matches);
      if (collapsed.value !== mql2.matches) {
        handleSetCollapsed(mql2.matches, "responsive");
      }
    });
    let mql;
    function responsiveHandler(mql2) {
      return responsiveHandlerRef.value(mql2);
    }
    const uniqueId = generateId("ant-sider-");
    siderHook && siderHook.addSider(uniqueId);
    onMounted(() => {
      watch(() => props2.breakpoint, () => {
        try {
          mql === null || mql === void 0 ? void 0 : mql.removeEventListener("change", responsiveHandler);
        } catch (error) {
          mql === null || mql === void 0 ? void 0 : mql.removeListener(responsiveHandler);
        }
        if (typeof window !== "undefined") {
          const {
            matchMedia
          } = window;
          if (matchMedia && props2.breakpoint && props2.breakpoint in dimensionMaxMap) {
            mql = matchMedia(`(max-width: ${dimensionMaxMap[props2.breakpoint]})`);
            try {
              mql.addEventListener("change", responsiveHandler);
            } catch (error) {
              mql.addListener(responsiveHandler);
            }
            responsiveHandler(mql);
          }
        }
      }, {
        immediate: true
      });
    });
    onBeforeUnmount(() => {
      try {
        mql === null || mql === void 0 ? void 0 : mql.removeEventListener("change", responsiveHandler);
      } catch (error) {
        mql === null || mql === void 0 ? void 0 : mql.removeListener(responsiveHandler);
      }
      siderHook && siderHook.removeSider(uniqueId);
    });
    const toggle = () => {
      handleSetCollapsed(!collapsed.value, "clickTrigger");
    };
    return () => {
      var _a2, _b;
      const pre = prefixCls.value;
      const {
        collapsedWidth,
        width,
        reverseArrow,
        zeroWidthTriggerStyle,
        trigger = (_a2 = slots.trigger) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
        collapsible,
        theme: theme2
      } = props2;
      const rawWidth = collapsed.value ? collapsedWidth : width;
      const siderWidth = isNumeric(rawWidth) ? `${rawWidth}px` : String(rawWidth);
      const zeroWidthTrigger = parseFloat(String(collapsedWidth || 0)) === 0 ? createVNode("span", {
        "onClick": toggle,
        "class": classNames(`${pre}-zero-width-trigger`, `${pre}-zero-width-trigger-${reverseArrow ? "right" : "left"}`),
        "style": zeroWidthTriggerStyle
      }, [trigger || createVNode(BarsOutlined, null, null)]) : null;
      const iconObj = {
        expanded: reverseArrow ? createVNode(RightOutlined, null, null) : createVNode(LeftOutlined, null, null),
        collapsed: reverseArrow ? createVNode(LeftOutlined, null, null) : createVNode(RightOutlined, null, null)
      };
      const status = collapsed.value ? "collapsed" : "expanded";
      const defaultTrigger = iconObj[status];
      const triggerDom = trigger !== null ? zeroWidthTrigger || createVNode("div", {
        "class": `${pre}-trigger`,
        "onClick": toggle,
        "style": {
          width: siderWidth
        }
      }, [trigger || defaultTrigger]) : null;
      const divStyle = [attrs.style, {
        flex: `0 0 ${siderWidth}`,
        maxWidth: siderWidth,
        minWidth: siderWidth,
        width: siderWidth
      }];
      const siderCls = classNames(pre, `${pre}-${theme2}`, {
        [`${pre}-collapsed`]: !!collapsed.value,
        [`${pre}-has-trigger`]: collapsible && trigger !== null && !zeroWidthTrigger,
        [`${pre}-below`]: !!below.value,
        [`${pre}-zero-width`]: parseFloat(siderWidth) === 0
      }, attrs.class);
      return createVNode("aside", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "class": siderCls,
        "style": divStyle
      }), [createVNode("div", {
        "class": `${pre}-children`
      }, [(_b = slots.default) === null || _b === void 0 ? void 0 : _b.call(slots)]), collapsible || below.value && zeroWidthTrigger ? triggerDom : null]);
    };
  }
});
const LayoutHeader = Header$1;
const LayoutSider = Sider;
const LayoutContent = Content;
const Layout = _extends$1(Layout$1, {
  Header: Header$1,
  Footer: Footer$1,
  Content,
  Sider,
  install: (app) => {
    app.component(Layout$1.name, Layout$1);
    app.component(Header$1.name, Header$1);
    app.component(Footer$1.name, Footer$1);
    app.component(Sider.name, Sider);
    app.component(Content.name, Content);
    return app;
  }
});
function throttle(delay, callback, options) {
  var _ref = options, _ref$noTrailing = _ref.noTrailing, noTrailing = _ref$noTrailing === void 0 ? false : _ref$noTrailing, _ref$noLeading = _ref.noLeading, noLeading = _ref$noLeading === void 0 ? false : _ref$noLeading, _ref$debounceMode = _ref.debounceMode, debounceMode = _ref$debounceMode === void 0 ? void 0 : _ref$debounceMode;
  var timeoutID;
  var cancelled = false;
  var lastExec = 0;
  function clearExistingTimeout() {
    if (timeoutID) {
      clearTimeout(timeoutID);
    }
  }
  function cancel(options2) {
    var _ref2 = options2 || {}, _ref2$upcomingOnly = _ref2.upcomingOnly, upcomingOnly = _ref2$upcomingOnly === void 0 ? false : _ref2$upcomingOnly;
    clearExistingTimeout();
    cancelled = !upcomingOnly;
  }
  function wrapper() {
    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
      arguments_[_key] = arguments[_key];
    }
    var self2 = this;
    var elapsed = Date.now() - lastExec;
    if (cancelled) {
      return;
    }
    function exec() {
      lastExec = Date.now();
      callback.apply(self2, arguments_);
    }
    function clear() {
      timeoutID = void 0;
    }
    if (!noLeading && debounceMode && !timeoutID) {
      exec();
    }
    clearExistingTimeout();
    if (debounceMode === void 0 && elapsed > delay) {
      if (noLeading) {
        lastExec = Date.now();
        if (!noTrailing) {
          timeoutID = setTimeout(debounceMode ? clear : exec, delay);
        }
      } else {
        exec();
      }
    } else if (noTrailing !== true) {
      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === void 0 ? delay - elapsed : delay);
    }
  }
  wrapper.cancel = cancel;
  return wrapper;
}
function debounce(delay, callback, options) {
  var _ref = {}, _ref$atBegin = _ref.atBegin, atBegin = _ref$atBegin === void 0 ? false : _ref$atBegin;
  return throttle(delay, callback, {
    debounceMode: atBegin !== false
  });
}
const antSpinMove = new Keyframe("antSpinMove", {
  to: {
    opacity: 1
  }
});
const antRotate = new Keyframe("antRotate", {
  to: {
    transform: "rotate(405deg)"
  }
});
const genSpinStyle = (token2) => ({
  [`${token2.componentCls}`]: _extends$1(_extends$1({}, resetComponent(token2)), {
    position: "absolute",
    display: "none",
    color: token2.colorPrimary,
    textAlign: "center",
    verticalAlign: "middle",
    opacity: 0,
    transition: `transform ${token2.motionDurationSlow} ${token2.motionEaseInOutCirc}`,
    "&-spinning": {
      position: "static",
      display: "inline-block",
      opacity: 1
    },
    "&-nested-loading": {
      position: "relative",
      [`> div > ${token2.componentCls}`]: {
        position: "absolute",
        top: 0,
        insetInlineStart: 0,
        zIndex: 4,
        display: "block",
        width: "100%",
        height: "100%",
        maxHeight: token2.contentHeight,
        [`${token2.componentCls}-dot`]: {
          position: "absolute",
          top: "50%",
          insetInlineStart: "50%",
          margin: -token2.spinDotSize / 2
        },
        [`${token2.componentCls}-text`]: {
          position: "absolute",
          top: "50%",
          width: "100%",
          paddingTop: (token2.spinDotSize - token2.fontSize) / 2 + 2,
          textShadow: `0 1px 2px ${token2.colorBgContainer}`
          // FIXME: shadow
        },
        [`&${token2.componentCls}-show-text ${token2.componentCls}-dot`]: {
          marginTop: -(token2.spinDotSize / 2) - 10
        },
        "&-sm": {
          [`${token2.componentCls}-dot`]: {
            margin: -token2.spinDotSizeSM / 2
          },
          [`${token2.componentCls}-text`]: {
            paddingTop: (token2.spinDotSizeSM - token2.fontSize) / 2 + 2
          },
          [`&${token2.componentCls}-show-text ${token2.componentCls}-dot`]: {
            marginTop: -(token2.spinDotSizeSM / 2) - 10
          }
        },
        "&-lg": {
          [`${token2.componentCls}-dot`]: {
            margin: -(token2.spinDotSizeLG / 2)
          },
          [`${token2.componentCls}-text`]: {
            paddingTop: (token2.spinDotSizeLG - token2.fontSize) / 2 + 2
          },
          [`&${token2.componentCls}-show-text ${token2.componentCls}-dot`]: {
            marginTop: -(token2.spinDotSizeLG / 2) - 10
          }
        }
      },
      [`${token2.componentCls}-container`]: {
        position: "relative",
        transition: `opacity ${token2.motionDurationSlow}`,
        "&::after": {
          position: "absolute",
          top: 0,
          insetInlineEnd: 0,
          bottom: 0,
          insetInlineStart: 0,
          zIndex: 10,
          width: "100%",
          height: "100%",
          background: token2.colorBgContainer,
          opacity: 0,
          transition: `all ${token2.motionDurationSlow}`,
          content: '""',
          pointerEvents: "none"
        }
      },
      [`${token2.componentCls}-blur`]: {
        clear: "both",
        opacity: 0.5,
        userSelect: "none",
        pointerEvents: "none",
        [`&::after`]: {
          opacity: 0.4,
          pointerEvents: "auto"
        }
      }
    },
    // tip
    // ------------------------------
    [`&-tip`]: {
      color: token2.spinDotDefault
    },
    // dots
    // ------------------------------
    [`${token2.componentCls}-dot`]: {
      position: "relative",
      display: "inline-block",
      fontSize: token2.spinDotSize,
      width: "1em",
      height: "1em",
      "&-item": {
        position: "absolute",
        display: "block",
        width: (token2.spinDotSize - token2.marginXXS / 2) / 2,
        height: (token2.spinDotSize - token2.marginXXS / 2) / 2,
        backgroundColor: token2.colorPrimary,
        borderRadius: "100%",
        transform: "scale(0.75)",
        transformOrigin: "50% 50%",
        opacity: 0.3,
        animationName: antSpinMove,
        animationDuration: "1s",
        animationIterationCount: "infinite",
        animationTimingFunction: "linear",
        animationDirection: "alternate",
        "&:nth-child(1)": {
          top: 0,
          insetInlineStart: 0
        },
        "&:nth-child(2)": {
          top: 0,
          insetInlineEnd: 0,
          animationDelay: "0.4s"
        },
        "&:nth-child(3)": {
          insetInlineEnd: 0,
          bottom: 0,
          animationDelay: "0.8s"
        },
        "&:nth-child(4)": {
          bottom: 0,
          insetInlineStart: 0,
          animationDelay: "1.2s"
        }
      },
      "&-spin": {
        transform: "rotate(45deg)",
        animationName: antRotate,
        animationDuration: "1.2s",
        animationIterationCount: "infinite",
        animationTimingFunction: "linear"
      }
    },
    // Sizes
    // ------------------------------
    // small
    [`&-sm ${token2.componentCls}-dot`]: {
      fontSize: token2.spinDotSizeSM,
      i: {
        width: (token2.spinDotSizeSM - token2.marginXXS / 2) / 2,
        height: (token2.spinDotSizeSM - token2.marginXXS / 2) / 2
      }
    },
    // large
    [`&-lg ${token2.componentCls}-dot`]: {
      fontSize: token2.spinDotSizeLG,
      i: {
        width: (token2.spinDotSizeLG - token2.marginXXS) / 2,
        height: (token2.spinDotSizeLG - token2.marginXXS) / 2
      }
    },
    [`&${token2.componentCls}-show-text ${token2.componentCls}-text`]: {
      display: "block"
    }
  })
});
const useStyle$d = genComponentStyleHook("Spin", (token2) => {
  const spinToken = merge(token2, {
    spinDotDefault: token2.colorTextDescription,
    spinDotSize: token2.controlHeightLG / 2,
    spinDotSizeSM: token2.controlHeightLG * 0.35,
    spinDotSizeLG: token2.controlHeight
  });
  return [genSpinStyle(spinToken)];
}, {
  contentHeight: 400
});
var __rest$r = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const spinProps = () => ({
  prefixCls: String,
  spinning: {
    type: Boolean,
    default: void 0
  },
  size: String,
  wrapperClassName: String,
  tip: PropTypes.any,
  delay: Number,
  indicator: PropTypes.any
});
let defaultIndicator = null;
function shouldDelay(spinning, delay) {
  return !!spinning && !!delay && !isNaN(Number(delay));
}
function setDefaultIndicator(Content2) {
  const Indicator = Content2.indicator;
  defaultIndicator = typeof Indicator === "function" ? Indicator : () => createVNode(Indicator, null, null);
}
const Spin = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ASpin",
  inheritAttrs: false,
  props: initDefaultProps(spinProps(), {
    size: "default",
    spinning: true,
    wrapperClassName: ""
  }),
  setup(props2, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const {
      prefixCls,
      size,
      direction
    } = useConfigInject("spin", props2);
    const [wrapSSR, hashId] = useStyle$d(prefixCls);
    const sSpinning = shallowRef(props2.spinning && !shouldDelay(props2.spinning, props2.delay));
    let updateSpinning;
    watch([() => props2.spinning, () => props2.delay], () => {
      updateSpinning === null || updateSpinning === void 0 ? void 0 : updateSpinning.cancel();
      updateSpinning = debounce(props2.delay, () => {
        sSpinning.value = props2.spinning;
      });
      updateSpinning === null || updateSpinning === void 0 ? void 0 : updateSpinning();
    }, {
      immediate: true,
      flush: "post"
    });
    onBeforeUnmount(() => {
      updateSpinning === null || updateSpinning === void 0 ? void 0 : updateSpinning.cancel();
    });
    return () => {
      var _a2, _b;
      const {
        class: cls
      } = attrs, divProps = __rest$r(attrs, ["class"]);
      const {
        tip = (_a2 = slots.tip) === null || _a2 === void 0 ? void 0 : _a2.call(slots)
      } = props2;
      const children = (_b = slots.default) === null || _b === void 0 ? void 0 : _b.call(slots);
      const spinClassName = {
        [hashId.value]: true,
        [prefixCls.value]: true,
        [`${prefixCls.value}-sm`]: size.value === "small",
        [`${prefixCls.value}-lg`]: size.value === "large",
        [`${prefixCls.value}-spinning`]: sSpinning.value,
        [`${prefixCls.value}-show-text`]: !!tip,
        [`${prefixCls.value}-rtl`]: direction.value === "rtl",
        [cls]: !!cls
      };
      function renderIndicator(prefixCls2) {
        const dotClassName = `${prefixCls2}-dot`;
        let indicator = getPropsSlot(slots, props2, "indicator");
        if (indicator === null) {
          return null;
        }
        if (Array.isArray(indicator)) {
          indicator = indicator.length === 1 ? indicator[0] : indicator;
        }
        if (isVNode(indicator)) {
          return cloneVNode(indicator, {
            class: dotClassName
          });
        }
        if (defaultIndicator && isVNode(defaultIndicator())) {
          return cloneVNode(defaultIndicator(), {
            class: dotClassName
          });
        }
        return createVNode("span", {
          "class": `${dotClassName} ${prefixCls2}-dot-spin`
        }, [createVNode("i", {
          "class": `${prefixCls2}-dot-item`
        }, null), createVNode("i", {
          "class": `${prefixCls2}-dot-item`
        }, null), createVNode("i", {
          "class": `${prefixCls2}-dot-item`
        }, null), createVNode("i", {
          "class": `${prefixCls2}-dot-item`
        }, null)]);
      }
      const spinElement = createVNode("div", _objectSpread2$1(_objectSpread2$1({}, divProps), {}, {
        "class": spinClassName,
        "aria-live": "polite",
        "aria-busy": sSpinning.value
      }), [renderIndicator(prefixCls.value), tip ? createVNode("div", {
        "class": `${prefixCls.value}-text`
      }, [tip]) : null]);
      if (children && filterEmpty(children).length) {
        const containerClassName = {
          [`${prefixCls.value}-container`]: true,
          [`${prefixCls.value}-blur`]: sSpinning.value
        };
        return wrapSSR(createVNode("div", {
          "class": [`${prefixCls.value}-nested-loading`, props2.wrapperClassName, hashId.value]
        }, [sSpinning.value && createVNode("div", {
          "key": "loading"
        }, [spinElement]), createVNode("div", {
          "class": containerClassName,
          "key": "container"
        }, [children])]));
      }
      return wrapSSR(spinElement);
    };
  }
});
Spin.setDefaultIndicator = setDefaultIndicator;
Spin.install = function(app) {
  app.component(Spin.name, Spin);
  return app;
};
const MiniSelect = defineComponent({
  name: "MiniSelect",
  compatConfig: {
    MODE: 3
  },
  inheritAttrs: false,
  props: selectProps(),
  Option: Select.Option,
  setup(props2, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    return () => {
      const selelctProps = _extends$1(_extends$1(_extends$1({}, props2), {
        size: "small"
      }), attrs);
      return createVNode(Select, selelctProps, slots);
    };
  }
});
const MiddleSelect = defineComponent({
  name: "MiddleSelect",
  inheritAttrs: false,
  props: selectProps(),
  Option: Select.Option,
  setup(props2, _ref2) {
    let {
      attrs,
      slots
    } = _ref2;
    return () => {
      const selelctProps = _extends$1(_extends$1(_extends$1({}, props2), {
        size: "middle"
      }), attrs);
      return createVNode(Select, selelctProps, slots);
    };
  }
});
const Pager = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Pager",
  inheritAttrs: false,
  props: {
    rootPrefixCls: String,
    page: Number,
    active: {
      type: Boolean,
      default: void 0
    },
    last: {
      type: Boolean,
      default: void 0
    },
    locale: PropTypes.object,
    showTitle: {
      type: Boolean,
      default: void 0
    },
    itemRender: {
      type: Function,
      default: () => {
      }
    },
    onClick: {
      type: Function
    },
    onKeypress: {
      type: Function
    }
  },
  eimt: ["click", "keypress"],
  setup(props2, _ref) {
    let {
      emit,
      attrs
    } = _ref;
    const handleClick = () => {
      emit("click", props2.page);
    };
    const handleKeyPress = (event) => {
      emit("keypress", event, handleClick, props2.page);
    };
    return () => {
      const {
        showTitle,
        page,
        itemRender
      } = props2;
      const {
        class: _cls,
        style
      } = attrs;
      const prefixCls = `${props2.rootPrefixCls}-item`;
      const cls = classNames(prefixCls, `${prefixCls}-${props2.page}`, {
        [`${prefixCls}-active`]: props2.active,
        [`${prefixCls}-disabled`]: !props2.page
      }, _cls);
      return createVNode("li", {
        "onClick": handleClick,
        "onKeypress": handleKeyPress,
        "title": showTitle ? String(page) : null,
        "tabindex": "0",
        "class": cls,
        "style": style
      }, [itemRender({
        page,
        type: "page",
        originalElement: createVNode("a", {
          "rel": "nofollow"
        }, [page])
      })]);
    };
  }
});
const KEYCODE = {
  ZERO: 48,
  NINE: 57,
  NUMPAD_ZERO: 96,
  NUMPAD_NINE: 105,
  BACKSPACE: 8,
  DELETE: 46,
  ENTER: 13,
  ARROW_UP: 38,
  ARROW_DOWN: 40
};
const Options = defineComponent({
  compatConfig: {
    MODE: 3
  },
  props: {
    disabled: {
      type: Boolean,
      default: void 0
    },
    changeSize: Function,
    quickGo: Function,
    selectComponentClass: PropTypes.any,
    current: Number,
    pageSizeOptions: PropTypes.array.def(["10", "20", "50", "100"]),
    pageSize: Number,
    buildOptionText: Function,
    locale: PropTypes.object,
    rootPrefixCls: String,
    selectPrefixCls: String,
    goButton: PropTypes.any
  },
  setup(props2) {
    const goInputText = ref("");
    const validValue = computed(() => {
      return !goInputText.value || isNaN(goInputText.value) ? void 0 : Number(goInputText.value);
    });
    const defaultBuildOptionText = (opt) => {
      return `${opt.value} ${props2.locale.items_per_page}`;
    };
    const handleChange = (e2) => {
      const {
        value
      } = e2.target;
      if (goInputText.value === value) return;
      goInputText.value = value;
    };
    const handleBlur = (e2) => {
      const {
        goButton,
        quickGo,
        rootPrefixCls
      } = props2;
      if (goButton || goInputText.value === "") {
        return;
      }
      if (e2.relatedTarget && (e2.relatedTarget.className.indexOf(`${rootPrefixCls}-item-link`) >= 0 || e2.relatedTarget.className.indexOf(`${rootPrefixCls}-item`) >= 0)) {
        goInputText.value = "";
        return;
      } else {
        quickGo(validValue.value);
        goInputText.value = "";
      }
    };
    const go = (e2) => {
      if (goInputText.value === "") {
        return;
      }
      if (e2.keyCode === KEYCODE.ENTER || e2.type === "click") {
        props2.quickGo(validValue.value);
        goInputText.value = "";
      }
    };
    const pageSizeOptions = computed(() => {
      const {
        pageSize,
        pageSizeOptions: pageSizeOptions2
      } = props2;
      if (pageSizeOptions2.some((option) => option.toString() === pageSize.toString())) {
        return pageSizeOptions2;
      }
      return pageSizeOptions2.concat([pageSize.toString()]).sort((a2, b2) => {
        const numberA = isNaN(Number(a2)) ? 0 : Number(a2);
        const numberB = isNaN(Number(b2)) ? 0 : Number(b2);
        return numberA - numberB;
      });
    });
    return () => {
      const {
        rootPrefixCls,
        locale: locale2,
        changeSize,
        quickGo,
        goButton,
        selectComponentClass: Select2,
        selectPrefixCls,
        pageSize,
        disabled
      } = props2;
      const prefixCls = `${rootPrefixCls}-options`;
      let changeSelect = null;
      let goInput = null;
      let gotoButton = null;
      if (!changeSize && !quickGo) {
        return null;
      }
      if (changeSize && Select2) {
        const buildOptionText = props2.buildOptionText || defaultBuildOptionText;
        const options = pageSizeOptions.value.map((opt, i2) => createVNode(Select2.Option, {
          "key": i2,
          "value": opt
        }, {
          default: () => [buildOptionText({
            value: opt
          })]
        }));
        changeSelect = createVNode(Select2, {
          "disabled": disabled,
          "prefixCls": selectPrefixCls,
          "showSearch": false,
          "class": `${prefixCls}-size-changer`,
          "optionLabelProp": "children",
          "value": (pageSize || pageSizeOptions.value[0]).toString(),
          "onChange": (value) => changeSize(Number(value)),
          "getPopupContainer": (triggerNode) => triggerNode.parentNode
        }, {
          default: () => [options]
        });
      }
      if (quickGo) {
        if (goButton) {
          gotoButton = typeof goButton === "boolean" ? createVNode("button", {
            "type": "button",
            "onClick": go,
            "onKeyup": go,
            "disabled": disabled,
            "class": `${prefixCls}-quick-jumper-button`
          }, [locale2.jump_to_confirm]) : createVNode("span", {
            "onClick": go,
            "onKeyup": go
          }, [goButton]);
        }
        goInput = createVNode("div", {
          "class": `${prefixCls}-quick-jumper`
        }, [locale2.jump_to, createVNode(BaseInput$1, {
          "disabled": disabled,
          "type": "text",
          "value": goInputText.value,
          "onInput": handleChange,
          "onChange": handleChange,
          "onKeyup": go,
          "onBlur": handleBlur
        }, null), locale2.page, gotoButton]);
      }
      return createVNode("li", {
        "class": `${prefixCls}`
      }, [changeSelect, goInput]);
    };
  }
});
const Pagination$2 = {
  // Options.jsx
  items_per_page: "条/页",
  jump_to: "跳至",
  jump_to_confirm: "确定",
  page: "页",
  // Pagination.jsx
  prev_page: "上一页",
  next_page: "下一页",
  prev_5: "向前 5 页",
  next_5: "向后 5 页",
  prev_3: "向前 3 页",
  next_3: "向后 3 页"
};
var __rest$q = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
function isInteger(value) {
  return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
}
function defaultItemRender(_ref) {
  let {
    originalElement
  } = _ref;
  return originalElement;
}
function calculatePage(p, state, props2) {
  const pageSize = typeof p === "undefined" ? state.statePageSize : p;
  return Math.floor((props2.total - 1) / pageSize) + 1;
}
const VcPagination = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Pagination",
  mixins: [BaseMixin],
  inheritAttrs: false,
  props: {
    disabled: {
      type: Boolean,
      default: void 0
    },
    prefixCls: PropTypes.string.def("rc-pagination"),
    selectPrefixCls: PropTypes.string.def("rc-select"),
    current: Number,
    defaultCurrent: PropTypes.number.def(1),
    total: PropTypes.number.def(0),
    pageSize: Number,
    defaultPageSize: PropTypes.number.def(10),
    hideOnSinglePage: {
      type: Boolean,
      default: false
    },
    showSizeChanger: {
      type: Boolean,
      default: void 0
    },
    showLessItems: {
      type: Boolean,
      default: false
    },
    // showSizeChange: PropTypes.func.def(noop),
    selectComponentClass: PropTypes.any,
    showPrevNextJumpers: {
      type: Boolean,
      default: true
    },
    showQuickJumper: PropTypes.oneOfType([PropTypes.looseBool, PropTypes.object]).def(false),
    showTitle: {
      type: Boolean,
      default: true
    },
    pageSizeOptions: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.number, PropTypes.string])),
    buildOptionText: Function,
    showTotal: Function,
    simple: {
      type: Boolean,
      default: void 0
    },
    locale: PropTypes.object.def(Pagination$2),
    itemRender: PropTypes.func.def(defaultItemRender),
    prevIcon: PropTypes.any,
    nextIcon: PropTypes.any,
    jumpPrevIcon: PropTypes.any,
    jumpNextIcon: PropTypes.any,
    totalBoundaryShowSizeChanger: PropTypes.number.def(50)
  },
  data() {
    const props2 = this.$props;
    let current = firstNotUndefined([this.current, this.defaultCurrent]);
    const pageSize = firstNotUndefined([this.pageSize, this.defaultPageSize]);
    current = Math.min(current, calculatePage(pageSize, void 0, props2));
    return {
      stateCurrent: current,
      stateCurrentInputValue: current,
      statePageSize: pageSize
    };
  },
  watch: {
    current(val) {
      this.setState({
        stateCurrent: val,
        stateCurrentInputValue: val
      });
    },
    pageSize(val) {
      const newState = {};
      let current = this.stateCurrent;
      const newCurrent = calculatePage(val, this.$data, this.$props);
      current = current > newCurrent ? newCurrent : current;
      if (!hasProp(this, "current")) {
        newState.stateCurrent = current;
        newState.stateCurrentInputValue = current;
      }
      newState.statePageSize = val;
      this.setState(newState);
    },
    stateCurrent(_val, oldValue) {
      this.$nextTick(() => {
        if (this.$refs.paginationNode) {
          const lastCurrentNode = this.$refs.paginationNode.querySelector(`.${this.prefixCls}-item-${oldValue}`);
          if (lastCurrentNode && document.activeElement === lastCurrentNode) {
            lastCurrentNode.blur();
          }
        }
      });
    },
    total() {
      const newState = {};
      const newCurrent = calculatePage(this.pageSize, this.$data, this.$props);
      if (hasProp(this, "current")) {
        const current = Math.min(this.current, newCurrent);
        newState.stateCurrent = current;
        newState.stateCurrentInputValue = current;
      } else {
        let current = this.stateCurrent;
        if (current === 0 && newCurrent > 0) {
          current = 1;
        } else {
          current = Math.min(this.stateCurrent, newCurrent);
        }
        newState.stateCurrent = current;
      }
      this.setState(newState);
    }
  },
  methods: {
    getJumpPrevPage() {
      return Math.max(1, this.stateCurrent - (this.showLessItems ? 3 : 5));
    },
    getJumpNextPage() {
      return Math.min(calculatePage(void 0, this.$data, this.$props), this.stateCurrent + (this.showLessItems ? 3 : 5));
    },
    getItemIcon(icon, label) {
      const {
        prefixCls
      } = this.$props;
      const iconNode = getComponent(this, icon, this.$props) || createVNode("button", {
        "type": "button",
        "aria-label": label,
        "class": `${prefixCls}-item-link`
      }, null);
      return iconNode;
    },
    getValidValue(e2) {
      const inputValue = e2.target.value;
      const allPages = calculatePage(void 0, this.$data, this.$props);
      const {
        stateCurrentInputValue
      } = this.$data;
      let value;
      if (inputValue === "") {
        value = inputValue;
      } else if (isNaN(Number(inputValue))) {
        value = stateCurrentInputValue;
      } else if (inputValue >= allPages) {
        value = allPages;
      } else {
        value = Number(inputValue);
      }
      return value;
    },
    isValid(page) {
      return isInteger(page) && page !== this.stateCurrent;
    },
    shouldDisplayQuickJumper() {
      const {
        showQuickJumper,
        pageSize,
        total
      } = this.$props;
      if (total <= pageSize) {
        return false;
      }
      return showQuickJumper;
    },
    // calculatePage (p) {
    //   let pageSize = p
    //   if (typeof pageSize === 'undefined') {
    //     pageSize = this.statePageSize
    //   }
    //   return Math.floor((this.total - 1) / pageSize) + 1
    // },
    handleKeyDown(event) {
      if (event.keyCode === KEYCODE.ARROW_UP || event.keyCode === KEYCODE.ARROW_DOWN) {
        event.preventDefault();
      }
    },
    handleKeyUp(e2) {
      const value = this.getValidValue(e2);
      const stateCurrentInputValue = this.stateCurrentInputValue;
      if (value !== stateCurrentInputValue) {
        this.setState({
          stateCurrentInputValue: value
        });
      }
      if (e2.keyCode === KEYCODE.ENTER) {
        this.handleChange(value);
      } else if (e2.keyCode === KEYCODE.ARROW_UP) {
        this.handleChange(value - 1);
      } else if (e2.keyCode === KEYCODE.ARROW_DOWN) {
        this.handleChange(value + 1);
      }
    },
    changePageSize(size) {
      let current = this.stateCurrent;
      const preCurrent = current;
      const newCurrent = calculatePage(size, this.$data, this.$props);
      current = current > newCurrent ? newCurrent : current;
      if (newCurrent === 0) {
        current = this.stateCurrent;
      }
      if (typeof size === "number") {
        if (!hasProp(this, "pageSize")) {
          this.setState({
            statePageSize: size
          });
        }
        if (!hasProp(this, "current")) {
          this.setState({
            stateCurrent: current,
            stateCurrentInputValue: current
          });
        }
      }
      this.__emit("update:pageSize", size);
      if (current !== preCurrent) {
        this.__emit("update:current", current);
      }
      this.__emit("showSizeChange", current, size);
      this.__emit("change", current, size);
    },
    handleChange(p) {
      const {
        disabled
      } = this.$props;
      let page = p;
      if (this.isValid(page) && !disabled) {
        const currentPage = calculatePage(void 0, this.$data, this.$props);
        if (page > currentPage) {
          page = currentPage;
        } else if (page < 1) {
          page = 1;
        }
        if (!hasProp(this, "current")) {
          this.setState({
            stateCurrent: page,
            stateCurrentInputValue: page
          });
        }
        this.__emit("update:current", page);
        this.__emit("change", page, this.statePageSize);
        return page;
      }
      return this.stateCurrent;
    },
    prev() {
      if (this.hasPrev()) {
        this.handleChange(this.stateCurrent - 1);
      }
    },
    next() {
      if (this.hasNext()) {
        this.handleChange(this.stateCurrent + 1);
      }
    },
    jumpPrev() {
      this.handleChange(this.getJumpPrevPage());
    },
    jumpNext() {
      this.handleChange(this.getJumpNextPage());
    },
    hasPrev() {
      return this.stateCurrent > 1;
    },
    hasNext() {
      return this.stateCurrent < calculatePage(void 0, this.$data, this.$props);
    },
    getShowSizeChanger() {
      const {
        showSizeChanger,
        total,
        totalBoundaryShowSizeChanger
      } = this.$props;
      if (typeof showSizeChanger !== "undefined") {
        return showSizeChanger;
      }
      return total > totalBoundaryShowSizeChanger;
    },
    runIfEnter(event, callback) {
      if (event.key === "Enter" || event.charCode === 13) {
        event.preventDefault();
        for (var _len = arguments.length, restParams = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          restParams[_key - 2] = arguments[_key];
        }
        callback(...restParams);
      }
    },
    runIfEnterPrev(event) {
      this.runIfEnter(event, this.prev);
    },
    runIfEnterNext(event) {
      this.runIfEnter(event, this.next);
    },
    runIfEnterJumpPrev(event) {
      this.runIfEnter(event, this.jumpPrev);
    },
    runIfEnterJumpNext(event) {
      this.runIfEnter(event, this.jumpNext);
    },
    handleGoTO(event) {
      if (event.keyCode === KEYCODE.ENTER || event.type === "click") {
        this.handleChange(this.stateCurrentInputValue);
      }
    },
    renderPrev(prevPage) {
      const {
        itemRender
      } = this.$props;
      const prevButton = itemRender({
        page: prevPage,
        type: "prev",
        originalElement: this.getItemIcon("prevIcon", "prev page")
      });
      const disabled = !this.hasPrev();
      return isValidElement(prevButton) ? cloneElement(prevButton, disabled ? {
        disabled
      } : {}) : prevButton;
    },
    renderNext(nextPage) {
      const {
        itemRender
      } = this.$props;
      const nextButton = itemRender({
        page: nextPage,
        type: "next",
        originalElement: this.getItemIcon("nextIcon", "next page")
      });
      const disabled = !this.hasNext();
      return isValidElement(nextButton) ? cloneElement(nextButton, disabled ? {
        disabled
      } : {}) : nextButton;
    }
  },
  render() {
    const {
      prefixCls,
      disabled,
      hideOnSinglePage,
      total,
      locale: locale2,
      showQuickJumper,
      showLessItems,
      showTitle,
      showTotal,
      simple,
      itemRender,
      showPrevNextJumpers,
      jumpPrevIcon,
      jumpNextIcon,
      selectComponentClass,
      selectPrefixCls,
      pageSizeOptions
    } = this.$props;
    const {
      stateCurrent,
      statePageSize
    } = this;
    const _a2 = splitAttrs(this.$attrs).extraAttrs, {
      class: className
    } = _a2, restAttrs = __rest$q(_a2, ["class"]);
    if (hideOnSinglePage === true && this.total <= statePageSize) {
      return null;
    }
    const allPages = calculatePage(void 0, this.$data, this.$props);
    const pagerList = [];
    let jumpPrev = null;
    let jumpNext = null;
    let firstPager = null;
    let lastPager = null;
    let gotoButton = null;
    const goButton = showQuickJumper && showQuickJumper.goButton;
    const pageBufferSize = showLessItems ? 1 : 2;
    const prevPage = stateCurrent - 1 > 0 ? stateCurrent - 1 : 0;
    const nextPage = stateCurrent + 1 < allPages ? stateCurrent + 1 : allPages;
    const hasPrev = this.hasPrev();
    const hasNext = this.hasNext();
    if (simple) {
      if (goButton) {
        if (typeof goButton === "boolean") {
          gotoButton = createVNode("button", {
            "type": "button",
            "onClick": this.handleGoTO,
            "onKeyup": this.handleGoTO
          }, [locale2.jump_to_confirm]);
        } else {
          gotoButton = createVNode("span", {
            "onClick": this.handleGoTO,
            "onKeyup": this.handleGoTO
          }, [goButton]);
        }
        gotoButton = createVNode("li", {
          "title": showTitle ? `${locale2.jump_to}${stateCurrent}/${allPages}` : null,
          "class": `${prefixCls}-simple-pager`
        }, [gotoButton]);
      }
      return createVNode("ul", _objectSpread2$1({
        "class": classNames(`${prefixCls} ${prefixCls}-simple`, {
          [`${prefixCls}-disabled`]: disabled
        }, className)
      }, restAttrs), [createVNode("li", {
        "title": showTitle ? locale2.prev_page : null,
        "onClick": this.prev,
        "tabindex": hasPrev ? 0 : null,
        "onKeypress": this.runIfEnterPrev,
        "class": classNames(`${prefixCls}-prev`, {
          [`${prefixCls}-disabled`]: !hasPrev
        }),
        "aria-disabled": !hasPrev
      }, [this.renderPrev(prevPage)]), createVNode("li", {
        "title": showTitle ? `${stateCurrent}/${allPages}` : null,
        "class": `${prefixCls}-simple-pager`
      }, [createVNode(BaseInput$1, {
        "type": "text",
        "value": this.stateCurrentInputValue,
        "disabled": disabled,
        "onKeydown": this.handleKeyDown,
        "onKeyup": this.handleKeyUp,
        "onInput": this.handleKeyUp,
        "onChange": this.handleKeyUp,
        "size": "3"
      }, null), createVNode("span", {
        "class": `${prefixCls}-slash`
      }, [createTextVNode("／")]), allPages]), createVNode("li", {
        "title": showTitle ? locale2.next_page : null,
        "onClick": this.next,
        "tabindex": hasNext ? 0 : null,
        "onKeypress": this.runIfEnterNext,
        "class": classNames(`${prefixCls}-next`, {
          [`${prefixCls}-disabled`]: !hasNext
        }),
        "aria-disabled": !hasNext
      }, [this.renderNext(nextPage)]), gotoButton]);
    }
    if (allPages <= 3 + pageBufferSize * 2) {
      const pagerProps = {
        locale: locale2,
        rootPrefixCls: prefixCls,
        showTitle,
        itemRender,
        onClick: this.handleChange,
        onKeypress: this.runIfEnter
      };
      if (!allPages) {
        pagerList.push(createVNode(Pager, _objectSpread2$1(_objectSpread2$1({}, pagerProps), {}, {
          "key": "noPager",
          "page": 1,
          "class": `${prefixCls}-item-disabled`
        }), null));
      }
      for (let i2 = 1; i2 <= allPages; i2 += 1) {
        const active = stateCurrent === i2;
        pagerList.push(createVNode(Pager, _objectSpread2$1(_objectSpread2$1({}, pagerProps), {}, {
          "key": i2,
          "page": i2,
          "active": active
        }), null));
      }
    } else {
      const prevItemTitle = showLessItems ? locale2.prev_3 : locale2.prev_5;
      const nextItemTitle = showLessItems ? locale2.next_3 : locale2.next_5;
      if (showPrevNextJumpers) {
        jumpPrev = createVNode("li", {
          "title": this.showTitle ? prevItemTitle : null,
          "key": "prev",
          "onClick": this.jumpPrev,
          "tabindex": "0",
          "onKeypress": this.runIfEnterJumpPrev,
          "class": classNames(`${prefixCls}-jump-prev`, {
            [`${prefixCls}-jump-prev-custom-icon`]: !!jumpPrevIcon
          })
        }, [itemRender({
          page: this.getJumpPrevPage(),
          type: "jump-prev",
          originalElement: this.getItemIcon("jumpPrevIcon", "prev page")
        })]);
        jumpNext = createVNode("li", {
          "title": this.showTitle ? nextItemTitle : null,
          "key": "next",
          "tabindex": "0",
          "onClick": this.jumpNext,
          "onKeypress": this.runIfEnterJumpNext,
          "class": classNames(`${prefixCls}-jump-next`, {
            [`${prefixCls}-jump-next-custom-icon`]: !!jumpNextIcon
          })
        }, [itemRender({
          page: this.getJumpNextPage(),
          type: "jump-next",
          originalElement: this.getItemIcon("jumpNextIcon", "next page")
        })]);
      }
      lastPager = createVNode(Pager, {
        "locale": locale2,
        "last": true,
        "rootPrefixCls": prefixCls,
        "onClick": this.handleChange,
        "onKeypress": this.runIfEnter,
        "key": allPages,
        "page": allPages,
        "active": false,
        "showTitle": showTitle,
        "itemRender": itemRender
      }, null);
      firstPager = createVNode(Pager, {
        "locale": locale2,
        "rootPrefixCls": prefixCls,
        "onClick": this.handleChange,
        "onKeypress": this.runIfEnter,
        "key": 1,
        "page": 1,
        "active": false,
        "showTitle": showTitle,
        "itemRender": itemRender
      }, null);
      let left = Math.max(1, stateCurrent - pageBufferSize);
      let right = Math.min(stateCurrent + pageBufferSize, allPages);
      if (stateCurrent - 1 <= pageBufferSize) {
        right = 1 + pageBufferSize * 2;
      }
      if (allPages - stateCurrent <= pageBufferSize) {
        left = allPages - pageBufferSize * 2;
      }
      for (let i2 = left; i2 <= right; i2 += 1) {
        const active = stateCurrent === i2;
        pagerList.push(createVNode(Pager, {
          "locale": locale2,
          "rootPrefixCls": prefixCls,
          "onClick": this.handleChange,
          "onKeypress": this.runIfEnter,
          "key": i2,
          "page": i2,
          "active": active,
          "showTitle": showTitle,
          "itemRender": itemRender
        }, null));
      }
      if (stateCurrent - 1 >= pageBufferSize * 2 && stateCurrent !== 1 + 2) {
        pagerList[0] = createVNode(Pager, {
          "locale": locale2,
          "rootPrefixCls": prefixCls,
          "onClick": this.handleChange,
          "onKeypress": this.runIfEnter,
          "key": left,
          "page": left,
          "class": `${prefixCls}-item-after-jump-prev`,
          "active": false,
          "showTitle": this.showTitle,
          "itemRender": itemRender
        }, null);
        pagerList.unshift(jumpPrev);
      }
      if (allPages - stateCurrent >= pageBufferSize * 2 && stateCurrent !== allPages - 2) {
        pagerList[pagerList.length - 1] = createVNode(Pager, {
          "locale": locale2,
          "rootPrefixCls": prefixCls,
          "onClick": this.handleChange,
          "onKeypress": this.runIfEnter,
          "key": right,
          "page": right,
          "class": `${prefixCls}-item-before-jump-next`,
          "active": false,
          "showTitle": this.showTitle,
          "itemRender": itemRender
        }, null);
        pagerList.push(jumpNext);
      }
      if (left !== 1) {
        pagerList.unshift(firstPager);
      }
      if (right !== allPages) {
        pagerList.push(lastPager);
      }
    }
    let totalText = null;
    if (showTotal) {
      totalText = createVNode("li", {
        "class": `${prefixCls}-total-text`
      }, [showTotal(total, [total === 0 ? 0 : (stateCurrent - 1) * statePageSize + 1, stateCurrent * statePageSize > total ? total : stateCurrent * statePageSize])]);
    }
    const prevDisabled = !hasPrev || !allPages;
    const nextDisabled = !hasNext || !allPages;
    const buildOptionText = this.buildOptionText || this.$slots.buildOptionText;
    return createVNode("ul", _objectSpread2$1(_objectSpread2$1({
      "unselectable": "on",
      "ref": "paginationNode"
    }, restAttrs), {}, {
      "class": classNames({
        [`${prefixCls}`]: true,
        [`${prefixCls}-disabled`]: disabled
      }, className)
    }), [totalText, createVNode("li", {
      "title": showTitle ? locale2.prev_page : null,
      "onClick": this.prev,
      "tabindex": prevDisabled ? null : 0,
      "onKeypress": this.runIfEnterPrev,
      "class": classNames(`${prefixCls}-prev`, {
        [`${prefixCls}-disabled`]: prevDisabled
      }),
      "aria-disabled": prevDisabled
    }, [this.renderPrev(prevPage)]), pagerList, createVNode("li", {
      "title": showTitle ? locale2.next_page : null,
      "onClick": this.next,
      "tabindex": nextDisabled ? null : 0,
      "onKeypress": this.runIfEnterNext,
      "class": classNames(`${prefixCls}-next`, {
        [`${prefixCls}-disabled`]: nextDisabled
      }),
      "aria-disabled": nextDisabled
    }, [this.renderNext(nextPage)]), createVNode(Options, {
      "disabled": disabled,
      "locale": locale2,
      "rootPrefixCls": prefixCls,
      "selectComponentClass": selectComponentClass,
      "selectPrefixCls": selectPrefixCls,
      "changeSize": this.getShowSizeChanger() ? this.changePageSize : null,
      "current": stateCurrent,
      "pageSize": statePageSize,
      "pageSizeOptions": pageSizeOptions,
      "buildOptionText": buildOptionText || null,
      "quickGo": this.shouldDisplayQuickJumper() ? this.handleChange : null,
      "goButton": goButton
    }, null)]);
  }
});
const genPaginationDisabledStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-disabled`]: {
      "&, &:hover": {
        cursor: "not-allowed",
        [`${componentCls}-item-link`]: {
          color: token2.colorTextDisabled,
          cursor: "not-allowed"
        }
      },
      "&:focus-visible": {
        cursor: "not-allowed",
        [`${componentCls}-item-link`]: {
          color: token2.colorTextDisabled,
          cursor: "not-allowed"
        }
      }
    },
    [`&${componentCls}-disabled`]: {
      cursor: "not-allowed",
      [`&${componentCls}-mini`]: {
        [`
          &:hover ${componentCls}-item:not(${componentCls}-item-active),
          &:active ${componentCls}-item:not(${componentCls}-item-active),
          &:hover ${componentCls}-item-link,
          &:active ${componentCls}-item-link
        `]: {
          backgroundColor: "transparent"
        }
      },
      [`${componentCls}-item`]: {
        cursor: "not-allowed",
        "&:hover, &:active": {
          backgroundColor: "transparent"
        },
        a: {
          color: token2.colorTextDisabled,
          backgroundColor: "transparent",
          border: "none",
          cursor: "not-allowed"
        },
        "&-active": {
          borderColor: token2.colorBorder,
          backgroundColor: token2.paginationItemDisabledBgActive,
          "&:hover, &:active": {
            backgroundColor: token2.paginationItemDisabledBgActive
          },
          a: {
            color: token2.paginationItemDisabledColorActive
          }
        }
      },
      [`${componentCls}-item-link`]: {
        color: token2.colorTextDisabled,
        cursor: "not-allowed",
        "&:hover, &:active": {
          backgroundColor: "transparent"
        },
        [`${componentCls}-simple&`]: {
          backgroundColor: "transparent",
          "&:hover, &:active": {
            backgroundColor: "transparent"
          }
        }
      },
      [`${componentCls}-simple-pager`]: {
        color: token2.colorTextDisabled
      },
      [`${componentCls}-jump-prev, ${componentCls}-jump-next`]: {
        [`${componentCls}-item-link-icon`]: {
          opacity: 0
        },
        [`${componentCls}-item-ellipsis`]: {
          opacity: 1
        }
      }
    },
    [`&${componentCls}-simple`]: {
      [`${componentCls}-prev, ${componentCls}-next`]: {
        [`&${componentCls}-disabled ${componentCls}-item-link`]: {
          "&:hover, &:active": {
            backgroundColor: "transparent"
          }
        }
      }
    }
  };
};
const genPaginationMiniStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`&${componentCls}-mini ${componentCls}-total-text, &${componentCls}-mini ${componentCls}-simple-pager`]: {
      height: token2.paginationItemSizeSM,
      lineHeight: `${token2.paginationItemSizeSM}px`
    },
    [`&${componentCls}-mini ${componentCls}-item`]: {
      minWidth: token2.paginationItemSizeSM,
      height: token2.paginationItemSizeSM,
      margin: 0,
      lineHeight: `${token2.paginationItemSizeSM - 2}px`
    },
    [`&${componentCls}-mini ${componentCls}-item:not(${componentCls}-item-active)`]: {
      backgroundColor: "transparent",
      borderColor: "transparent",
      "&:hover": {
        backgroundColor: token2.colorBgTextHover
      },
      "&:active": {
        backgroundColor: token2.colorBgTextActive
      }
    },
    [`&${componentCls}-mini ${componentCls}-prev, &${componentCls}-mini ${componentCls}-next`]: {
      minWidth: token2.paginationItemSizeSM,
      height: token2.paginationItemSizeSM,
      margin: 0,
      lineHeight: `${token2.paginationItemSizeSM}px`,
      [`&:hover ${componentCls}-item-link`]: {
        backgroundColor: token2.colorBgTextHover
      },
      [`&:active ${componentCls}-item-link`]: {
        backgroundColor: token2.colorBgTextActive
      },
      [`&${componentCls}-disabled:hover ${componentCls}-item-link`]: {
        backgroundColor: "transparent"
      }
    },
    [`
    &${componentCls}-mini ${componentCls}-prev ${componentCls}-item-link,
    &${componentCls}-mini ${componentCls}-next ${componentCls}-item-link
    `]: {
      backgroundColor: "transparent",
      borderColor: "transparent",
      "&::after": {
        height: token2.paginationItemSizeSM,
        lineHeight: `${token2.paginationItemSizeSM}px`
      }
    },
    [`&${componentCls}-mini ${componentCls}-jump-prev, &${componentCls}-mini ${componentCls}-jump-next`]: {
      height: token2.paginationItemSizeSM,
      marginInlineEnd: 0,
      lineHeight: `${token2.paginationItemSizeSM}px`
    },
    [`&${componentCls}-mini ${componentCls}-options`]: {
      marginInlineStart: token2.paginationMiniOptionsMarginInlineStart,
      [`&-size-changer`]: {
        top: token2.paginationMiniOptionsSizeChangerTop
      },
      [`&-quick-jumper`]: {
        height: token2.paginationItemSizeSM,
        lineHeight: `${token2.paginationItemSizeSM}px`,
        input: _extends$1(_extends$1({}, genInputSmallStyle(token2)), {
          width: token2.paginationMiniQuickJumperInputWidth,
          height: token2.controlHeightSM
        })
      }
    }
  };
};
const genPaginationSimpleStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`
    &${componentCls}-simple ${componentCls}-prev,
    &${componentCls}-simple ${componentCls}-next
    `]: {
      height: token2.paginationItemSizeSM,
      lineHeight: `${token2.paginationItemSizeSM}px`,
      verticalAlign: "top",
      [`${componentCls}-item-link`]: {
        height: token2.paginationItemSizeSM,
        backgroundColor: "transparent",
        border: 0,
        "&:hover": {
          backgroundColor: token2.colorBgTextHover
        },
        "&:active": {
          backgroundColor: token2.colorBgTextActive
        },
        "&::after": {
          height: token2.paginationItemSizeSM,
          lineHeight: `${token2.paginationItemSizeSM}px`
        }
      }
    },
    [`&${componentCls}-simple ${componentCls}-simple-pager`]: {
      display: "inline-block",
      height: token2.paginationItemSizeSM,
      marginInlineEnd: token2.marginXS,
      input: {
        boxSizing: "border-box",
        height: "100%",
        marginInlineEnd: token2.marginXS,
        padding: `0 ${token2.paginationItemPaddingInline}px`,
        textAlign: "center",
        backgroundColor: token2.paginationItemInputBg,
        border: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`,
        borderRadius: token2.borderRadius,
        outline: "none",
        transition: `border-color ${token2.motionDurationMid}`,
        color: "inherit",
        "&:hover": {
          borderColor: token2.colorPrimary
        },
        "&:focus": {
          borderColor: token2.colorPrimaryHover,
          boxShadow: `${token2.inputOutlineOffset}px 0 ${token2.controlOutlineWidth}px ${token2.controlOutline}`
        },
        "&[disabled]": {
          color: token2.colorTextDisabled,
          backgroundColor: token2.colorBgContainerDisabled,
          borderColor: token2.colorBorder,
          cursor: "not-allowed"
        }
      }
    }
  };
};
const genPaginationJumpStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-jump-prev, ${componentCls}-jump-next`]: {
      outline: 0,
      [`${componentCls}-item-container`]: {
        position: "relative",
        [`${componentCls}-item-link-icon`]: {
          color: token2.colorPrimary,
          fontSize: token2.fontSizeSM,
          opacity: 0,
          transition: `all ${token2.motionDurationMid}`,
          "&-svg": {
            top: 0,
            insetInlineEnd: 0,
            bottom: 0,
            insetInlineStart: 0,
            margin: "auto"
          }
        },
        [`${componentCls}-item-ellipsis`]: {
          position: "absolute",
          top: 0,
          insetInlineEnd: 0,
          bottom: 0,
          insetInlineStart: 0,
          display: "block",
          margin: "auto",
          color: token2.colorTextDisabled,
          fontFamily: "Arial, Helvetica, sans-serif",
          letterSpacing: token2.paginationEllipsisLetterSpacing,
          textAlign: "center",
          textIndent: token2.paginationEllipsisTextIndent,
          opacity: 1,
          transition: `all ${token2.motionDurationMid}`
        }
      },
      "&:hover": {
        [`${componentCls}-item-link-icon`]: {
          opacity: 1
        },
        [`${componentCls}-item-ellipsis`]: {
          opacity: 0
        }
      },
      "&:focus-visible": _extends$1({
        [`${componentCls}-item-link-icon`]: {
          opacity: 1
        },
        [`${componentCls}-item-ellipsis`]: {
          opacity: 0
        }
      }, genFocusOutline(token2))
    },
    [`
    ${componentCls}-prev,
    ${componentCls}-jump-prev,
    ${componentCls}-jump-next
    `]: {
      marginInlineEnd: token2.marginXS
    },
    [`
    ${componentCls}-prev,
    ${componentCls}-next,
    ${componentCls}-jump-prev,
    ${componentCls}-jump-next
    `]: {
      display: "inline-block",
      minWidth: token2.paginationItemSize,
      height: token2.paginationItemSize,
      color: token2.colorText,
      fontFamily: token2.paginationFontFamily,
      lineHeight: `${token2.paginationItemSize}px`,
      textAlign: "center",
      verticalAlign: "middle",
      listStyle: "none",
      borderRadius: token2.borderRadius,
      cursor: "pointer",
      transition: `all ${token2.motionDurationMid}`
    },
    [`${componentCls}-prev, ${componentCls}-next`]: {
      fontFamily: "Arial, Helvetica, sans-serif",
      outline: 0,
      button: {
        color: token2.colorText,
        cursor: "pointer",
        userSelect: "none"
      },
      [`${componentCls}-item-link`]: {
        display: "block",
        width: "100%",
        height: "100%",
        padding: 0,
        fontSize: token2.fontSizeSM,
        textAlign: "center",
        backgroundColor: "transparent",
        border: `${token2.lineWidth}px ${token2.lineType} transparent`,
        borderRadius: token2.borderRadius,
        outline: "none",
        transition: `all ${token2.motionDurationMid}`
      },
      [`&:focus-visible ${componentCls}-item-link`]: _extends$1({}, genFocusOutline(token2)),
      [`&:hover ${componentCls}-item-link`]: {
        backgroundColor: token2.colorBgTextHover
      },
      [`&:active ${componentCls}-item-link`]: {
        backgroundColor: token2.colorBgTextActive
      },
      [`&${componentCls}-disabled:hover`]: {
        [`${componentCls}-item-link`]: {
          backgroundColor: "transparent"
        }
      }
    },
    [`${componentCls}-slash`]: {
      marginInlineEnd: token2.paginationSlashMarginInlineEnd,
      marginInlineStart: token2.paginationSlashMarginInlineStart
    },
    [`${componentCls}-options`]: {
      display: "inline-block",
      marginInlineStart: token2.margin,
      verticalAlign: "middle",
      "&-size-changer.-select": {
        display: "inline-block",
        width: "auto"
      },
      "&-quick-jumper": {
        display: "inline-block",
        height: token2.controlHeight,
        marginInlineStart: token2.marginXS,
        lineHeight: `${token2.controlHeight}px`,
        verticalAlign: "top",
        input: _extends$1(_extends$1({}, genBasicInputStyle(token2)), {
          width: token2.controlHeightLG * 1.25,
          height: token2.controlHeight,
          boxSizing: "border-box",
          margin: 0,
          marginInlineStart: token2.marginXS,
          marginInlineEnd: token2.marginXS
        })
      }
    }
  };
};
const genPaginationItemStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-item`]: _extends$1(_extends$1({
      display: "inline-block",
      minWidth: token2.paginationItemSize,
      height: token2.paginationItemSize,
      marginInlineEnd: token2.marginXS,
      fontFamily: token2.paginationFontFamily,
      lineHeight: `${token2.paginationItemSize - 2}px`,
      textAlign: "center",
      verticalAlign: "middle",
      listStyle: "none",
      backgroundColor: "transparent",
      border: `${token2.lineWidth}px ${token2.lineType} transparent`,
      borderRadius: token2.borderRadius,
      outline: 0,
      cursor: "pointer",
      userSelect: "none",
      a: {
        display: "block",
        padding: `0 ${token2.paginationItemPaddingInline}px`,
        color: token2.colorText,
        transition: "none",
        "&:hover": {
          textDecoration: "none"
        }
      },
      [`&:not(${componentCls}-item-active)`]: {
        "&:hover": {
          transition: `all ${token2.motionDurationMid}`,
          backgroundColor: token2.colorBgTextHover
        },
        "&:active": {
          backgroundColor: token2.colorBgTextActive
        }
      }
    }, genFocusStyle(token2)), {
      "&-active": {
        fontWeight: token2.paginationFontWeightActive,
        backgroundColor: token2.paginationItemBgActive,
        borderColor: token2.colorPrimary,
        a: {
          color: token2.colorPrimary
        },
        "&:hover": {
          borderColor: token2.colorPrimaryHover
        },
        "&:hover a": {
          color: token2.colorPrimaryHover
        }
      }
    })
  };
};
const genPaginationStyle$1 = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [componentCls]: _extends$1(_extends$1(_extends$1(_extends$1(_extends$1(_extends$1(_extends$1(_extends$1({}, resetComponent(token2)), {
      "ul, ol": {
        margin: 0,
        padding: 0,
        listStyle: "none"
      },
      "&::after": {
        display: "block",
        clear: "both",
        height: 0,
        overflow: "hidden",
        visibility: "hidden",
        content: '""'
      },
      [`${componentCls}-total-text`]: {
        display: "inline-block",
        height: token2.paginationItemSize,
        marginInlineEnd: token2.marginXS,
        lineHeight: `${token2.paginationItemSize - 2}px`,
        verticalAlign: "middle"
      }
    }), genPaginationItemStyle(token2)), genPaginationJumpStyle(token2)), genPaginationSimpleStyle(token2)), genPaginationMiniStyle(token2)), genPaginationDisabledStyle(token2)), {
      // media query style
      [`@media only screen and (max-width: ${token2.screenLG}px)`]: {
        [`${componentCls}-item`]: {
          "&-after-jump-prev, &-before-jump-next": {
            display: "none"
          }
        }
      },
      [`@media only screen and (max-width: ${token2.screenSM}px)`]: {
        [`${componentCls}-options`]: {
          display: "none"
        }
      }
    }),
    // rtl style
    [`&${token2.componentCls}-rtl`]: {
      direction: "rtl"
    }
  };
};
const genBorderedStyle$2 = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}${componentCls}-disabled`]: {
      "&, &:hover": {
        [`${componentCls}-item-link`]: {
          borderColor: token2.colorBorder
        }
      },
      "&:focus-visible": {
        [`${componentCls}-item-link`]: {
          borderColor: token2.colorBorder
        }
      },
      [`${componentCls}-item, ${componentCls}-item-link`]: {
        backgroundColor: token2.colorBgContainerDisabled,
        borderColor: token2.colorBorder,
        [`&:hover:not(${componentCls}-item-active)`]: {
          backgroundColor: token2.colorBgContainerDisabled,
          borderColor: token2.colorBorder,
          a: {
            color: token2.colorTextDisabled
          }
        },
        [`&${componentCls}-item-active`]: {
          backgroundColor: token2.paginationItemDisabledBgActive
        }
      },
      [`${componentCls}-prev, ${componentCls}-next`]: {
        "&:hover button": {
          backgroundColor: token2.colorBgContainerDisabled,
          borderColor: token2.colorBorder,
          color: token2.colorTextDisabled
        },
        [`${componentCls}-item-link`]: {
          backgroundColor: token2.colorBgContainerDisabled,
          borderColor: token2.colorBorder
        }
      }
    },
    [componentCls]: {
      [`${componentCls}-prev, ${componentCls}-next`]: {
        "&:hover button": {
          borderColor: token2.colorPrimaryHover,
          backgroundColor: token2.paginationItemBg
        },
        [`${componentCls}-item-link`]: {
          backgroundColor: token2.paginationItemLinkBg,
          borderColor: token2.colorBorder
        },
        [`&:hover ${componentCls}-item-link`]: {
          borderColor: token2.colorPrimary,
          backgroundColor: token2.paginationItemBg,
          color: token2.colorPrimary
        },
        [`&${componentCls}-disabled`]: {
          [`${componentCls}-item-link`]: {
            borderColor: token2.colorBorder,
            color: token2.colorTextDisabled
          }
        }
      },
      [`${componentCls}-item`]: {
        backgroundColor: token2.paginationItemBg,
        border: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`,
        [`&:hover:not(${componentCls}-item-active)`]: {
          borderColor: token2.colorPrimary,
          backgroundColor: token2.paginationItemBg,
          a: {
            color: token2.colorPrimary
          }
        },
        "&-active": {
          borderColor: token2.colorPrimary
        }
      }
    }
  };
};
const useStyle$c = genComponentStyleHook("Pagination", (token2) => {
  const paginationToken = merge(token2, {
    paginationItemSize: token2.controlHeight,
    paginationFontFamily: token2.fontFamily,
    paginationItemBg: token2.colorBgContainer,
    paginationItemBgActive: token2.colorBgContainer,
    paginationFontWeightActive: token2.fontWeightStrong,
    paginationItemSizeSM: token2.controlHeightSM,
    paginationItemInputBg: token2.colorBgContainer,
    paginationMiniOptionsSizeChangerTop: 0,
    paginationItemDisabledBgActive: token2.controlItemBgActiveDisabled,
    paginationItemDisabledColorActive: token2.colorTextDisabled,
    paginationItemLinkBg: token2.colorBgContainer,
    inputOutlineOffset: "0 0",
    paginationMiniOptionsMarginInlineStart: token2.marginXXS / 2,
    paginationMiniQuickJumperInputWidth: token2.controlHeightLG * 1.1,
    paginationItemPaddingInline: token2.marginXXS * 1.5,
    paginationEllipsisLetterSpacing: token2.marginXXS / 2,
    paginationSlashMarginInlineStart: token2.marginXXS,
    paginationSlashMarginInlineEnd: token2.marginSM,
    paginationEllipsisTextIndent: "0.13em"
    // magic for ui experience
  }, initInputToken(token2));
  return [genPaginationStyle$1(paginationToken), token2.wireframe && genBorderedStyle$2(paginationToken)];
});
var __rest$p = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const paginationProps = () => ({
  total: Number,
  defaultCurrent: Number,
  disabled: booleanType(),
  current: Number,
  defaultPageSize: Number,
  pageSize: Number,
  hideOnSinglePage: booleanType(),
  showSizeChanger: booleanType(),
  pageSizeOptions: arrayType(),
  buildOptionText: functionType(),
  showQuickJumper: someType([Boolean, Object]),
  showTotal: functionType(),
  size: stringType(),
  simple: booleanType(),
  locale: Object,
  prefixCls: String,
  selectPrefixCls: String,
  totalBoundaryShowSizeChanger: Number,
  selectComponentClass: String,
  itemRender: functionType(),
  role: String,
  responsive: Boolean,
  showLessItems: booleanType(),
  onChange: functionType(),
  onShowSizeChange: functionType(),
  "onUpdate:current": functionType(),
  "onUpdate:pageSize": functionType()
});
const Pagination$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "APagination",
  inheritAttrs: false,
  props: paginationProps(),
  // emits: ['change', 'showSizeChange', 'update:current', 'update:pageSize'],
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const {
      prefixCls,
      configProvider,
      direction,
      size
    } = useConfigInject("pagination", props2);
    const [wrapSSR, hashId] = useStyle$c(prefixCls);
    const selectPrefixCls = computed(() => configProvider.getPrefixCls("select", props2.selectPrefixCls));
    const breakpoint = useBreakpoint();
    const [locale2] = useLocaleReceiver("Pagination", enUS, toRef(props2, "locale"));
    const getIconsProps = (pre) => {
      const ellipsis = createVNode("span", {
        "class": `${pre}-item-ellipsis`
      }, [createTextVNode("•••")]);
      const prevIcon = createVNode("button", {
        "class": `${pre}-item-link`,
        "type": "button",
        "tabindex": -1
      }, [direction.value === "rtl" ? createVNode(RightOutlined, null, null) : createVNode(LeftOutlined, null, null)]);
      const nextIcon = createVNode("button", {
        "class": `${pre}-item-link`,
        "type": "button",
        "tabindex": -1
      }, [direction.value === "rtl" ? createVNode(LeftOutlined, null, null) : createVNode(RightOutlined, null, null)]);
      const jumpPrevIcon = createVNode("a", {
        "rel": "nofollow",
        "class": `${pre}-item-link`
      }, [createVNode("div", {
        "class": `${pre}-item-container`
      }, [direction.value === "rtl" ? createVNode(DoubleRightOutlined, {
        "class": `${pre}-item-link-icon`
      }, null) : createVNode(DoubleLeftOutlined, {
        "class": `${pre}-item-link-icon`
      }, null), ellipsis])]);
      const jumpNextIcon = createVNode("a", {
        "rel": "nofollow",
        "class": `${pre}-item-link`
      }, [createVNode("div", {
        "class": `${pre}-item-container`
      }, [direction.value === "rtl" ? createVNode(DoubleLeftOutlined, {
        "class": `${pre}-item-link-icon`
      }, null) : createVNode(DoubleRightOutlined, {
        "class": `${pre}-item-link-icon`
      }, null), ellipsis])]);
      return {
        prevIcon,
        nextIcon,
        jumpPrevIcon,
        jumpNextIcon
      };
    };
    return () => {
      var _a2;
      const {
        itemRender = slots.itemRender,
        buildOptionText = slots.buildOptionText,
        selectComponentClass,
        responsive
      } = props2, restProps = __rest$p(props2, ["itemRender", "buildOptionText", "selectComponentClass", "responsive"]);
      const isSmall = size.value === "small" || !!(((_a2 = breakpoint.value) === null || _a2 === void 0 ? void 0 : _a2.xs) && !size.value && responsive);
      const paginationProps2 = _extends$1(_extends$1(_extends$1(_extends$1(_extends$1({}, restProps), getIconsProps(prefixCls.value)), {
        prefixCls: prefixCls.value,
        selectPrefixCls: selectPrefixCls.value,
        selectComponentClass: selectComponentClass || (isSmall ? MiniSelect : MiddleSelect),
        locale: locale2.value,
        buildOptionText
      }), attrs), {
        class: classNames({
          [`${prefixCls.value}-mini`]: isSmall,
          [`${prefixCls.value}-rtl`]: direction.value === "rtl"
        }, attrs.class, hashId.value),
        itemRender
      });
      return wrapSSR(createVNode(VcPagination, paginationProps2, null));
    };
  }
});
const Pagination = withInstall(Pagination$1);
const listItemMetaProps = () => ({
  avatar: PropTypes.any,
  description: PropTypes.any,
  prefixCls: String,
  title: PropTypes.any
});
const ListItemMeta = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AListItemMeta",
  props: listItemMetaProps(),
  displayName: "AListItemMeta",
  __ANT_LIST_ITEM_META: true,
  slots: Object,
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      prefixCls
    } = useConfigInject("list", props2);
    return () => {
      var _a2, _b, _c, _d, _e, _f;
      const classString = `${prefixCls.value}-item-meta`;
      const title = (_a2 = props2.title) !== null && _a2 !== void 0 ? _a2 : (_b = slots.title) === null || _b === void 0 ? void 0 : _b.call(slots);
      const description = (_c = props2.description) !== null && _c !== void 0 ? _c : (_d = slots.description) === null || _d === void 0 ? void 0 : _d.call(slots);
      const avatar = (_e = props2.avatar) !== null && _e !== void 0 ? _e : (_f = slots.avatar) === null || _f === void 0 ? void 0 : _f.call(slots);
      const content = createVNode("div", {
        "class": `${prefixCls.value}-item-meta-content`
      }, [title && createVNode("h4", {
        "class": `${prefixCls.value}-item-meta-title`
      }, [title]), description && createVNode("div", {
        "class": `${prefixCls.value}-item-meta-description`
      }, [description])]);
      return createVNode("div", {
        "class": classString
      }, [avatar && createVNode("div", {
        "class": `${prefixCls.value}-item-meta-avatar`
      }, [avatar]), (title || description) && content]);
    };
  }
});
const ListContextKey = Symbol("ListContextKey");
var __rest$o = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const listItemProps$1 = () => ({
  prefixCls: String,
  extra: PropTypes.any,
  actions: PropTypes.array,
  grid: Object,
  colStyle: {
    type: Object,
    default: void 0
  }
});
const ListItem$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AListItem",
  inheritAttrs: false,
  Meta: ListItemMeta,
  props: listItemProps$1(),
  slots: Object,
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const {
      itemLayout,
      grid
    } = inject(ListContextKey, {
      grid: ref(),
      itemLayout: ref()
    });
    const {
      prefixCls
    } = useConfigInject("list", props2);
    const isItemContainsTextNodeAndNotSingular = () => {
      var _a2;
      const children = ((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)) || [];
      let result;
      children.forEach((element) => {
        if (isStringElement(element) && !isEmptyElement(element)) {
          result = true;
        }
      });
      return result && children.length > 1;
    };
    const isFlexMode = () => {
      var _a2, _b;
      const extra = (_a2 = props2.extra) !== null && _a2 !== void 0 ? _a2 : (_b = slots.extra) === null || _b === void 0 ? void 0 : _b.call(slots);
      if (itemLayout.value === "vertical") {
        return !!extra;
      }
      return !isItemContainsTextNodeAndNotSingular();
    };
    return () => {
      var _a2, _b, _c, _d, _e;
      const {
        class: className
      } = attrs, restAttrs = __rest$o(attrs, ["class"]);
      const pre = prefixCls.value;
      const extra = (_a2 = props2.extra) !== null && _a2 !== void 0 ? _a2 : (_b = slots.extra) === null || _b === void 0 ? void 0 : _b.call(slots);
      const children = (_c = slots.default) === null || _c === void 0 ? void 0 : _c.call(slots);
      let actions = (_d = props2.actions) !== null && _d !== void 0 ? _d : flattenChildren((_e = slots.actions) === null || _e === void 0 ? void 0 : _e.call(slots));
      actions = actions && !Array.isArray(actions) ? [actions] : actions;
      const actionsContent = actions && actions.length > 0 && createVNode("ul", {
        "class": `${pre}-item-action`,
        "key": "actions"
      }, [actions.map((action, i2) => createVNode("li", {
        "key": `${pre}-item-action-${i2}`
      }, [action, i2 !== actions.length - 1 && createVNode("em", {
        "class": `${pre}-item-action-split`
      }, null)]))]);
      const Element2 = grid.value ? "div" : "li";
      const itemChildren = createVNode(Element2, _objectSpread2$1(_objectSpread2$1({}, restAttrs), {}, {
        "class": classNames(`${pre}-item`, {
          [`${pre}-item-no-flex`]: !isFlexMode()
        }, className)
      }), {
        default: () => [itemLayout.value === "vertical" && extra ? [createVNode("div", {
          "class": `${pre}-item-main`,
          "key": "content"
        }, [children, actionsContent]), createVNode("div", {
          "class": `${pre}-item-extra`,
          "key": "extra"
        }, [extra])] : [children, actionsContent, cloneElement(extra, {
          key: "extra"
        })]]
      });
      return grid.value ? createVNode(Col$1, {
        "flex": 1,
        "style": props2.colStyle
      }, {
        default: () => [itemChildren]
      }) : itemChildren;
    };
  }
});
const genBorderedStyle$1 = (token2) => {
  const {
    listBorderedCls,
    componentCls,
    paddingLG,
    margin,
    padding,
    listItemPaddingSM,
    marginLG,
    borderRadiusLG
  } = token2;
  return {
    [`${listBorderedCls}`]: {
      border: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`,
      borderRadius: borderRadiusLG,
      [`${componentCls}-header,${componentCls}-footer,${componentCls}-item`]: {
        paddingInline: paddingLG
      },
      [`${componentCls}-pagination`]: {
        margin: `${margin}px ${marginLG}px`
      }
    },
    [`${listBorderedCls}${componentCls}-sm`]: {
      [`${componentCls}-item,${componentCls}-header,${componentCls}-footer`]: {
        padding: listItemPaddingSM
      }
    },
    [`${listBorderedCls}${componentCls}-lg`]: {
      [`${componentCls}-item,${componentCls}-header,${componentCls}-footer`]: {
        padding: `${padding}px ${paddingLG}px`
      }
    }
  };
};
const genResponsiveStyle = (token2) => {
  const {
    componentCls,
    screenSM,
    screenMD,
    marginLG,
    marginSM,
    margin
  } = token2;
  return {
    [`@media screen and (max-width:${screenMD})`]: {
      [`${componentCls}`]: {
        [`${componentCls}-item`]: {
          [`${componentCls}-item-action`]: {
            marginInlineStart: marginLG
          }
        }
      },
      [`${componentCls}-vertical`]: {
        [`${componentCls}-item`]: {
          [`${componentCls}-item-extra`]: {
            marginInlineStart: marginLG
          }
        }
      }
    },
    [`@media screen and (max-width: ${screenSM})`]: {
      [`${componentCls}`]: {
        [`${componentCls}-item`]: {
          flexWrap: "wrap",
          [`${componentCls}-action`]: {
            marginInlineStart: marginSM
          }
        }
      },
      [`${componentCls}-vertical`]: {
        [`${componentCls}-item`]: {
          flexWrap: "wrap-reverse",
          [`${componentCls}-item-main`]: {
            minWidth: token2.contentWidth
          },
          [`${componentCls}-item-extra`]: {
            margin: `auto auto ${margin}px`
          }
        }
      }
    }
  };
};
const genBaseStyle$7 = (token2) => {
  const {
    componentCls,
    antCls,
    controlHeight,
    minHeight,
    paddingSM,
    marginLG,
    padding,
    listItemPadding,
    colorPrimary,
    listItemPaddingSM,
    listItemPaddingLG,
    paddingXS,
    margin,
    colorText,
    colorTextDescription,
    motionDurationSlow,
    lineWidth
  } = token2;
  return {
    [`${componentCls}`]: _extends$1(_extends$1({}, resetComponent(token2)), {
      position: "relative",
      "*": {
        outline: "none"
      },
      [`${componentCls}-header, ${componentCls}-footer`]: {
        background: "transparent",
        paddingBlock: paddingSM
      },
      [`${componentCls}-pagination`]: {
        marginBlockStart: marginLG,
        textAlign: "end",
        // https://github.com/ant-design/ant-design/issues/20037
        [`${antCls}-pagination-options`]: {
          textAlign: "start"
        }
      },
      [`${componentCls}-spin`]: {
        minHeight,
        textAlign: "center"
      },
      [`${componentCls}-items`]: {
        margin: 0,
        padding: 0,
        listStyle: "none"
      },
      [`${componentCls}-item`]: {
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
        padding: listItemPadding,
        color: colorText,
        [`${componentCls}-item-meta`]: {
          display: "flex",
          flex: 1,
          alignItems: "flex-start",
          maxWidth: "100%",
          [`${componentCls}-item-meta-avatar`]: {
            marginInlineEnd: padding
          },
          [`${componentCls}-item-meta-content`]: {
            flex: "1 0",
            width: 0,
            color: colorText
          },
          [`${componentCls}-item-meta-title`]: {
            marginBottom: token2.marginXXS,
            color: colorText,
            fontSize: token2.fontSize,
            lineHeight: token2.lineHeight,
            "> a": {
              color: colorText,
              transition: `all ${motionDurationSlow}`,
              [`&:hover`]: {
                color: colorPrimary
              }
            }
          },
          [`${componentCls}-item-meta-description`]: {
            color: colorTextDescription,
            fontSize: token2.fontSize,
            lineHeight: token2.lineHeight
          }
        },
        [`${componentCls}-item-action`]: {
          flex: "0 0 auto",
          marginInlineStart: token2.marginXXL,
          padding: 0,
          fontSize: 0,
          listStyle: "none",
          [`& > li`]: {
            position: "relative",
            display: "inline-block",
            padding: `0 ${paddingXS}px`,
            color: colorTextDescription,
            fontSize: token2.fontSize,
            lineHeight: token2.lineHeight,
            textAlign: "center",
            [`&:first-child`]: {
              paddingInlineStart: 0
            }
          },
          [`${componentCls}-item-action-split`]: {
            position: "absolute",
            insetBlockStart: "50%",
            insetInlineEnd: 0,
            width: lineWidth,
            height: Math.ceil(token2.fontSize * token2.lineHeight) - token2.marginXXS * 2,
            transform: "translateY(-50%)",
            backgroundColor: token2.colorSplit
          }
        }
      },
      [`${componentCls}-empty`]: {
        padding: `${padding}px 0`,
        color: colorTextDescription,
        fontSize: token2.fontSizeSM,
        textAlign: "center"
      },
      [`${componentCls}-empty-text`]: {
        padding,
        color: token2.colorTextDisabled,
        fontSize: token2.fontSize,
        textAlign: "center"
      },
      // ============================ without flex ============================
      [`${componentCls}-item-no-flex`]: {
        display: "block"
      }
    }),
    [`${componentCls}-grid ${antCls}-col > ${componentCls}-item`]: {
      display: "block",
      maxWidth: "100%",
      marginBlockEnd: margin,
      paddingBlock: 0,
      borderBlockEnd: "none"
    },
    [`${componentCls}-vertical ${componentCls}-item`]: {
      alignItems: "initial",
      [`${componentCls}-item-main`]: {
        display: "block",
        flex: 1
      },
      [`${componentCls}-item-extra`]: {
        marginInlineStart: marginLG
      },
      [`${componentCls}-item-meta`]: {
        marginBlockEnd: padding,
        [`${componentCls}-item-meta-title`]: {
          marginBlockEnd: paddingSM,
          color: colorText,
          fontSize: token2.fontSizeLG,
          lineHeight: token2.lineHeightLG
        }
      },
      [`${componentCls}-item-action`]: {
        marginBlockStart: padding,
        marginInlineStart: "auto",
        "> li": {
          padding: `0 ${padding}px`,
          [`&:first-child`]: {
            paddingInlineStart: 0
          }
        }
      }
    },
    [`${componentCls}-split ${componentCls}-item`]: {
      borderBlockEnd: `${token2.lineWidth}px ${token2.lineType} ${token2.colorSplit}`,
      [`&:last-child`]: {
        borderBlockEnd: "none"
      }
    },
    [`${componentCls}-split ${componentCls}-header`]: {
      borderBlockEnd: `${token2.lineWidth}px ${token2.lineType} ${token2.colorSplit}`
    },
    [`${componentCls}-split${componentCls}-empty ${componentCls}-footer`]: {
      borderTop: `${token2.lineWidth}px ${token2.lineType} ${token2.colorSplit}`
    },
    [`${componentCls}-loading ${componentCls}-spin-nested-loading`]: {
      minHeight: controlHeight
    },
    [`${componentCls}-split${componentCls}-something-after-last-item ${antCls}-spin-container > ${componentCls}-items > ${componentCls}-item:last-child`]: {
      borderBlockEnd: `${token2.lineWidth}px ${token2.lineType} ${token2.colorSplit}`
    },
    [`${componentCls}-lg ${componentCls}-item`]: {
      padding: listItemPaddingLG
    },
    [`${componentCls}-sm ${componentCls}-item`]: {
      padding: listItemPaddingSM
    },
    // Horizontal
    [`${componentCls}:not(${componentCls}-vertical)`]: {
      [`${componentCls}-item-no-flex`]: {
        [`${componentCls}-item-action`]: {
          float: "right"
        }
      }
    }
  };
};
const useStyle$b = genComponentStyleHook("List", (token2) => {
  const listToken = merge(token2, {
    listBorderedCls: `${token2.componentCls}-bordered`,
    minHeight: token2.controlHeightLG,
    listItemPadding: `${token2.paddingContentVertical}px ${token2.paddingContentHorizontalLG}px`,
    listItemPaddingSM: `${token2.paddingContentVerticalSM}px ${token2.paddingContentHorizontal}px`,
    listItemPaddingLG: `${token2.paddingContentVerticalLG}px ${token2.paddingContentHorizontalLG}px`
  });
  return [genBaseStyle$7(listToken), genBorderedStyle$1(listToken), genResponsiveStyle(listToken)];
}, {
  contentWidth: 220
});
const listProps = () => ({
  bordered: booleanType(),
  dataSource: arrayType(),
  extra: vNodeType(),
  grid: objectType(),
  itemLayout: String,
  loading: someType([Boolean, Object]),
  loadMore: vNodeType(),
  pagination: someType([Boolean, Object]),
  prefixCls: String,
  rowKey: someType([String, Number, Function]),
  renderItem: functionType(),
  size: String,
  split: booleanType(),
  header: vNodeType(),
  footer: vNodeType(),
  locale: objectType()
});
const List = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AList",
  inheritAttrs: false,
  Item: ListItem$1,
  props: initDefaultProps(listProps(), {
    dataSource: [],
    bordered: false,
    split: true,
    loading: false,
    pagination: false
  }),
  slots: Object,
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    var _a2, _b;
    provide(ListContextKey, {
      grid: toRef(props2, "grid"),
      itemLayout: toRef(props2, "itemLayout")
    });
    const defaultPaginationProps = {
      current: 1,
      total: 0
    };
    const {
      prefixCls,
      direction,
      renderEmpty: renderEmpty2
    } = useConfigInject("list", props2);
    const [wrapSSR, hashId] = useStyle$b(prefixCls);
    const paginationObj = computed(() => props2.pagination && typeof props2.pagination === "object" ? props2.pagination : {});
    const paginationCurrent = ref((_a2 = paginationObj.value.defaultCurrent) !== null && _a2 !== void 0 ? _a2 : 1);
    const paginationSize = ref((_b = paginationObj.value.defaultPageSize) !== null && _b !== void 0 ? _b : 10);
    watch(paginationObj, () => {
      if ("current" in paginationObj.value) {
        paginationCurrent.value = paginationObj.value.current;
      }
      if ("pageSize" in paginationObj.value) {
        paginationSize.value = paginationObj.value.pageSize;
      }
    });
    const listItemsKeys = [];
    const triggerPaginationEvent = (eventName) => (page, pageSize) => {
      paginationCurrent.value = page;
      paginationSize.value = pageSize;
      if (paginationObj.value[eventName]) {
        paginationObj.value[eventName](page, pageSize);
      }
    };
    const onPaginationChange = triggerPaginationEvent("onChange");
    const onPaginationShowSizeChange = triggerPaginationEvent("onShowSizeChange");
    const loadingProp = computed(() => {
      if (typeof props2.loading === "boolean") {
        return {
          spinning: props2.loading
        };
      } else {
        return props2.loading;
      }
    });
    const isLoading = computed(() => loadingProp.value && loadingProp.value.spinning);
    const sizeCls = computed(() => {
      let size = "";
      switch (props2.size) {
        case "large":
          size = "lg";
          break;
        case "small":
          size = "sm";
          break;
      }
      return size;
    });
    const classObj = computed(() => ({
      [`${prefixCls.value}`]: true,
      [`${prefixCls.value}-vertical`]: props2.itemLayout === "vertical",
      [`${prefixCls.value}-${sizeCls.value}`]: sizeCls.value,
      [`${prefixCls.value}-split`]: props2.split,
      [`${prefixCls.value}-bordered`]: props2.bordered,
      [`${prefixCls.value}-loading`]: isLoading.value,
      [`${prefixCls.value}-grid`]: !!props2.grid,
      [`${prefixCls.value}-rtl`]: direction.value === "rtl"
    }));
    const paginationProps2 = computed(() => {
      const pp = _extends$1(_extends$1(_extends$1({}, defaultPaginationProps), {
        total: props2.dataSource.length,
        current: paginationCurrent.value,
        pageSize: paginationSize.value
      }), props2.pagination || {});
      const largestPage = Math.ceil(pp.total / pp.pageSize);
      if (pp.current > largestPage) {
        pp.current = largestPage;
      }
      return pp;
    });
    const splitDataSource = computed(() => {
      let dd = [...props2.dataSource];
      if (props2.pagination) {
        if (props2.dataSource.length > (paginationProps2.value.current - 1) * paginationProps2.value.pageSize) {
          dd = [...props2.dataSource].splice((paginationProps2.value.current - 1) * paginationProps2.value.pageSize, paginationProps2.value.pageSize);
        }
      }
      return dd;
    });
    const screens = useBreakpoint();
    const currentBreakpoint = eagerComputed(() => {
      for (let i2 = 0; i2 < responsiveArray.length; i2 += 1) {
        const breakpoint = responsiveArray[i2];
        if (screens.value[breakpoint]) {
          return breakpoint;
        }
      }
      return void 0;
    });
    const colStyle = computed(() => {
      if (!props2.grid) {
        return void 0;
      }
      const columnCount = currentBreakpoint.value && props2.grid[currentBreakpoint.value] ? props2.grid[currentBreakpoint.value] : props2.grid.column;
      if (columnCount) {
        return {
          width: `${100 / columnCount}%`,
          maxWidth: `${100 / columnCount}%`
        };
      }
      return void 0;
    });
    const renderInnerItem = (item, index2) => {
      var _a3;
      const renderItem = (_a3 = props2.renderItem) !== null && _a3 !== void 0 ? _a3 : slots.renderItem;
      if (!renderItem) return null;
      let key2;
      const rowKeyType = typeof props2.rowKey;
      if (rowKeyType === "function") {
        key2 = props2.rowKey(item);
      } else if (rowKeyType === "string" || rowKeyType === "number") {
        key2 = item[props2.rowKey];
      } else {
        key2 = item.key;
      }
      if (!key2) {
        key2 = `list-item-${index2}`;
      }
      listItemsKeys[index2] = key2;
      return renderItem({
        item,
        index: index2
      });
    };
    return () => {
      var _a3, _b2, _c, _d, _e, _f, _g, _h;
      const loadMore = (_a3 = props2.loadMore) !== null && _a3 !== void 0 ? _a3 : (_b2 = slots.loadMore) === null || _b2 === void 0 ? void 0 : _b2.call(slots);
      const footer = (_c = props2.footer) !== null && _c !== void 0 ? _c : (_d = slots.footer) === null || _d === void 0 ? void 0 : _d.call(slots);
      const header = (_e = props2.header) !== null && _e !== void 0 ? _e : (_f = slots.header) === null || _f === void 0 ? void 0 : _f.call(slots);
      const children = flattenChildren((_g = slots.default) === null || _g === void 0 ? void 0 : _g.call(slots));
      const isSomethingAfterLastItem = !!(loadMore || props2.pagination || footer);
      const classString = classNames(_extends$1(_extends$1({}, classObj.value), {
        [`${prefixCls.value}-something-after-last-item`]: isSomethingAfterLastItem
      }), attrs.class, hashId.value);
      const paginationContent = props2.pagination ? createVNode("div", {
        "class": `${prefixCls.value}-pagination`
      }, [createVNode(Pagination, _objectSpread2$1(_objectSpread2$1({}, paginationProps2.value), {}, {
        "onChange": onPaginationChange,
        "onShowSizeChange": onPaginationShowSizeChange
      }), null)]) : null;
      let childrenContent = isLoading.value && createVNode("div", {
        "style": {
          minHeight: "53px"
        }
      }, null);
      if (splitDataSource.value.length > 0) {
        listItemsKeys.length = 0;
        const items = splitDataSource.value.map((item, index2) => renderInnerItem(item, index2));
        const childrenList = items.map((child, index2) => createVNode("div", {
          "key": listItemsKeys[index2],
          "style": colStyle.value
        }, [child]));
        childrenContent = props2.grid ? createVNode(ARow, {
          "gutter": props2.grid.gutter
        }, {
          default: () => [childrenList]
        }) : createVNode("ul", {
          "class": `${prefixCls.value}-items`
        }, [items]);
      } else if (!children.length && !isLoading.value) {
        childrenContent = createVNode("div", {
          "class": `${prefixCls.value}-empty-text`
        }, [((_h = props2.locale) === null || _h === void 0 ? void 0 : _h.emptyText) || renderEmpty2("List")]);
      }
      const paginationPosition = paginationProps2.value.position || "bottom";
      return wrapSSR(createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "class": classString
      }), [(paginationPosition === "top" || paginationPosition === "both") && paginationContent, header && createVNode("div", {
        "class": `${prefixCls.value}-header`
      }, [header]), createVNode(Spin, loadingProp.value, {
        default: () => [childrenContent, children]
      }), footer && createVNode("div", {
        "class": `${prefixCls.value}-footer`
      }, [footer]), loadMore || (paginationPosition === "bottom" || paginationPosition === "both") && paginationContent]));
    };
  }
});
List.install = function(app) {
  app.component(List.name, List);
  app.component(List.Item.name, List.Item);
  app.component(List.Item.Meta.name, List.Item.Meta);
  return app;
};
var __rest$n = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
let mousePosition;
const getClickPosition = (e2) => {
  mousePosition = {
    x: e2.pageX,
    y: e2.pageY
  };
  setTimeout(() => mousePosition = null, 100);
};
if (canUseDocElement()) {
  addEventListenerWrap(document.documentElement, "click", getClickPosition, true);
}
const modalProps = () => ({
  prefixCls: String,
  /** @deprecated Please use `open` instead. */
  visible: {
    type: Boolean,
    default: void 0
  },
  open: {
    type: Boolean,
    default: void 0
  },
  confirmLoading: {
    type: Boolean,
    default: void 0
  },
  title: PropTypes.any,
  closable: {
    type: Boolean,
    default: void 0
  },
  closeIcon: PropTypes.any,
  onOk: Function,
  onCancel: Function,
  "onUpdate:visible": Function,
  "onUpdate:open": Function,
  onChange: Function,
  afterClose: Function,
  centered: {
    type: Boolean,
    default: void 0
  },
  width: [String, Number],
  footer: PropTypes.any,
  okText: PropTypes.any,
  okType: String,
  cancelText: PropTypes.any,
  icon: PropTypes.any,
  maskClosable: {
    type: Boolean,
    default: void 0
  },
  forceRender: {
    type: Boolean,
    default: void 0
  },
  okButtonProps: objectType(),
  cancelButtonProps: objectType(),
  destroyOnClose: {
    type: Boolean,
    default: void 0
  },
  wrapClassName: String,
  maskTransitionName: String,
  transitionName: String,
  getContainer: {
    type: [String, Function, Boolean, Object],
    default: void 0
  },
  zIndex: Number,
  bodyStyle: objectType(),
  maskStyle: objectType(),
  mask: {
    type: Boolean,
    default: void 0
  },
  keyboard: {
    type: Boolean,
    default: void 0
  },
  wrapProps: Object,
  focusTriggerAfterClose: {
    type: Boolean,
    default: void 0
  },
  modalRender: Function,
  mousePosition: objectType()
});
const Modal = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AModal",
  inheritAttrs: false,
  props: initDefaultProps(modalProps(), {
    width: 520,
    confirmLoading: false,
    okType: "primary"
  }),
  setup(props2, _ref) {
    let {
      emit,
      slots,
      attrs
    } = _ref;
    const [locale2] = useLocaleReceiver("Modal");
    const {
      prefixCls,
      rootPrefixCls,
      direction,
      getPopupContainer
    } = useConfigInject("modal", props2);
    const [wrapSSR, hashId] = useStyle$h(prefixCls);
    warning$1(props2.visible === void 0);
    const handleCancel = (e2) => {
      emit("update:visible", false);
      emit("update:open", false);
      emit("cancel", e2);
      emit("change", false);
    };
    const handleOk = (e2) => {
      emit("ok", e2);
    };
    const renderFooter = () => {
      var _a2, _b;
      const {
        okText = (_a2 = slots.okText) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
        okType,
        cancelText = (_b = slots.cancelText) === null || _b === void 0 ? void 0 : _b.call(slots),
        confirmLoading
      } = props2;
      return createVNode(Fragment, null, [createVNode(Button$1, _objectSpread2$1({
        "onClick": handleCancel
      }, props2.cancelButtonProps), {
        default: () => [cancelText || locale2.value.cancelText]
      }), createVNode(Button$1, _objectSpread2$1(_objectSpread2$1({}, convertLegacyProps(okType)), {}, {
        "loading": confirmLoading,
        "onClick": handleOk
      }, props2.okButtonProps), {
        default: () => [okText || locale2.value.okText]
      })]);
    };
    return () => {
      var _a2, _b;
      const {
        prefixCls: customizePrefixCls,
        visible,
        open: open2,
        wrapClassName,
        centered,
        getContainer: getContainer2,
        closeIcon = (_a2 = slots.closeIcon) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
        focusTriggerAfterClose = true
      } = props2, restProps = __rest$n(props2, ["prefixCls", "visible", "open", "wrapClassName", "centered", "getContainer", "closeIcon", "focusTriggerAfterClose"]);
      const wrapClassNameExtended = classNames(wrapClassName, {
        [`${prefixCls.value}-centered`]: !!centered,
        [`${prefixCls.value}-wrap-rtl`]: direction.value === "rtl"
      });
      return wrapSSR(createVNode(DialogWrap, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, restProps), attrs), {}, {
        "rootClassName": hashId.value,
        "class": classNames(hashId.value, attrs.class),
        "getContainer": getContainer2 || (getPopupContainer === null || getPopupContainer === void 0 ? void 0 : getPopupContainer.value),
        "prefixCls": prefixCls.value,
        "wrapClassName": wrapClassNameExtended,
        "visible": open2 !== null && open2 !== void 0 ? open2 : visible,
        "onClose": handleCancel,
        "focusTriggerAfterClose": focusTriggerAfterClose,
        "transitionName": getTransitionName(rootPrefixCls.value, "zoom", props2.transitionName),
        "maskTransitionName": getTransitionName(rootPrefixCls.value, "fade", props2.maskTransitionName),
        "mousePosition": (_b = restProps.mousePosition) !== null && _b !== void 0 ? _b : mousePosition
      }), _extends$1(_extends$1({}, slots), {
        footer: slots.footer || renderFooter,
        closeIcon: () => {
          return createVNode("span", {
            "class": `${prefixCls.value}-close-x`
          }, [closeIcon || createVNode(CloseOutlined, {
            "class": `${prefixCls.value}-close-icon`
          }, null)]);
        }
      })));
    };
  }
});
const useDestroyed = () => {
  const destroyed = shallowRef(false);
  onBeforeUnmount(() => {
    destroyed.value = true;
  });
  return destroyed;
};
const actionButtonProps = {
  type: {
    type: String
  },
  actionFn: Function,
  close: Function,
  autofocus: Boolean,
  prefixCls: String,
  buttonProps: objectType(),
  emitEvent: Boolean,
  quitOnNullishReturnValue: Boolean
};
function isThenable(thing) {
  return !!(thing && thing.then);
}
const ActionButton = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ActionButton",
  props: actionButtonProps,
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const clickedRef = shallowRef(false);
    const buttonRef = shallowRef();
    const loading = shallowRef(false);
    let timeoutId;
    const isDestroyed = useDestroyed();
    onMounted(() => {
      if (props2.autofocus) {
        timeoutId = setTimeout(() => {
          var _a2, _b;
          return (_b = (_a2 = findDOMNode(buttonRef.value)) === null || _a2 === void 0 ? void 0 : _a2.focus) === null || _b === void 0 ? void 0 : _b.call(_a2);
        });
      }
    });
    onBeforeUnmount(() => {
      clearTimeout(timeoutId);
    });
    const onInternalClose = function() {
      var _a2;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      (_a2 = props2.close) === null || _a2 === void 0 ? void 0 : _a2.call(props2, ...args);
    };
    const handlePromiseOnOk = (returnValueOfOnOk) => {
      if (!isThenable(returnValueOfOnOk)) {
        return;
      }
      loading.value = true;
      returnValueOfOnOk.then(function() {
        if (!isDestroyed.value) {
          loading.value = false;
        }
        onInternalClose(...arguments);
        clickedRef.value = false;
      }, (e2) => {
        if (!isDestroyed.value) {
          loading.value = false;
        }
        clickedRef.value = false;
        return Promise.reject(e2);
      });
    };
    const onClick = (e2) => {
      const {
        actionFn
      } = props2;
      if (clickedRef.value) {
        return;
      }
      clickedRef.value = true;
      if (!actionFn) {
        onInternalClose();
        return;
      }
      let returnValueOfOnOk;
      if (props2.emitEvent) {
        returnValueOfOnOk = actionFn(e2);
        if (props2.quitOnNullishReturnValue && !isThenable(returnValueOfOnOk)) {
          clickedRef.value = false;
          onInternalClose(e2);
          return;
        }
      } else if (actionFn.length) {
        returnValueOfOnOk = actionFn(props2.close);
        clickedRef.value = false;
      } else {
        returnValueOfOnOk = actionFn();
        if (!returnValueOfOnOk) {
          onInternalClose();
          return;
        }
      }
      handlePromiseOnOk(returnValueOfOnOk);
    };
    return () => {
      const {
        type: type4,
        prefixCls,
        buttonProps: buttonProps2
      } = props2;
      return createVNode(Button$1, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, convertLegacyProps(type4)), {}, {
        "onClick": onClick,
        "loading": loading.value,
        "prefixCls": prefixCls
      }, buttonProps2), {}, {
        "ref": buttonRef
      }), slots);
    };
  }
});
function renderSomeContent(someContent) {
  if (typeof someContent === "function") {
    return someContent();
  }
  return someContent;
}
const ConfirmDialog = defineComponent({
  name: "ConfirmDialog",
  inheritAttrs: false,
  props: ["icon", "onCancel", "onOk", "close", "closable", "zIndex", "afterClose", "visible", "open", "keyboard", "centered", "getContainer", "maskStyle", "okButtonProps", "cancelButtonProps", "okType", "prefixCls", "okCancel", "width", "mask", "maskClosable", "okText", "cancelText", "autoFocusButton", "transitionName", "maskTransitionName", "type", "title", "content", "direction", "rootPrefixCls", "bodyStyle", "closeIcon", "modalRender", "focusTriggerAfterClose", "wrapClassName", "confirmPrefixCls", "footer"],
  setup(props2, _ref) {
    let {
      attrs
    } = _ref;
    const [locale2] = useLocaleReceiver("Modal");
    return () => {
      const {
        icon,
        onCancel,
        onOk,
        close,
        okText,
        closable = false,
        zIndex,
        afterClose,
        keyboard,
        centered,
        getContainer: getContainer2,
        maskStyle,
        okButtonProps,
        cancelButtonProps,
        okCancel,
        width = 416,
        mask = true,
        maskClosable = false,
        type: type4,
        open: open2,
        title,
        content,
        direction,
        closeIcon,
        modalRender,
        focusTriggerAfterClose,
        rootPrefixCls,
        bodyStyle,
        wrapClassName,
        footer
      } = props2;
      let mergedIcon = icon;
      if (!icon && icon !== null) {
        switch (type4) {
          case "info":
            mergedIcon = createVNode(InfoCircleFilled, null, null);
            break;
          case "success":
            mergedIcon = createVNode(CheckCircleFilled, null, null);
            break;
          case "error":
            mergedIcon = createVNode(CloseCircleFilled, null, null);
            break;
          default:
            mergedIcon = createVNode(ExclamationCircleFilled, null, null);
        }
      }
      const okType = props2.okType || "primary";
      const prefixCls = props2.prefixCls || "ant-modal";
      const contentPrefixCls = `${prefixCls}-confirm`;
      const style = attrs.style || {};
      const mergedOkCancel = okCancel !== null && okCancel !== void 0 ? okCancel : type4 === "confirm";
      const autoFocusButton = props2.autoFocusButton === null ? false : props2.autoFocusButton || "ok";
      const confirmPrefixCls = `${prefixCls}-confirm`;
      const classString = classNames(confirmPrefixCls, `${confirmPrefixCls}-${props2.type}`, {
        [`${confirmPrefixCls}-rtl`]: direction === "rtl"
      }, attrs.class);
      const mergedLocal = locale2.value;
      const cancelButton = mergedOkCancel && createVNode(ActionButton, {
        "actionFn": onCancel,
        "close": close,
        "autofocus": autoFocusButton === "cancel",
        "buttonProps": cancelButtonProps,
        "prefixCls": `${rootPrefixCls}-btn`
      }, {
        default: () => [renderSomeContent(props2.cancelText) || mergedLocal.cancelText]
      });
      return createVNode(Modal, {
        "prefixCls": prefixCls,
        "class": classString,
        "wrapClassName": classNames({
          [`${confirmPrefixCls}-centered`]: !!centered
        }, wrapClassName),
        "onCancel": (e2) => close === null || close === void 0 ? void 0 : close({
          triggerCancel: true
        }, e2),
        "open": open2,
        "title": "",
        "footer": "",
        "transitionName": getTransitionName(rootPrefixCls, "zoom", props2.transitionName),
        "maskTransitionName": getTransitionName(rootPrefixCls, "fade", props2.maskTransitionName),
        "mask": mask,
        "maskClosable": maskClosable,
        "maskStyle": maskStyle,
        "style": style,
        "bodyStyle": bodyStyle,
        "width": width,
        "zIndex": zIndex,
        "afterClose": afterClose,
        "keyboard": keyboard,
        "centered": centered,
        "getContainer": getContainer2,
        "closable": closable,
        "closeIcon": closeIcon,
        "modalRender": modalRender,
        "focusTriggerAfterClose": focusTriggerAfterClose
      }, {
        default: () => [createVNode("div", {
          "class": `${contentPrefixCls}-body-wrapper`
        }, [createVNode("div", {
          "class": `${contentPrefixCls}-body`
        }, [renderSomeContent(mergedIcon), title === void 0 ? null : createVNode("span", {
          "class": `${contentPrefixCls}-title`
        }, [renderSomeContent(title)]), createVNode("div", {
          "class": `${contentPrefixCls}-content`
        }, [renderSomeContent(content)])]), footer !== void 0 ? renderSomeContent(footer) : createVNode("div", {
          "class": `${contentPrefixCls}-btns`
        }, [cancelButton, createVNode(ActionButton, {
          "type": okType,
          "actionFn": onOk,
          "close": close,
          "autofocus": autoFocusButton === "ok",
          "buttonProps": okButtonProps,
          "prefixCls": `${rootPrefixCls}-btn`
        }, {
          default: () => [renderSomeContent(okText) || (mergedOkCancel ? mergedLocal.okText : mergedLocal.justOkText)]
        })])])]
      });
    };
  }
});
const destroyFns = [];
const confirm = (config) => {
  const container = document.createDocumentFragment();
  let currentConfig = _extends$1(_extends$1({}, omit$1(config, ["parentContext", "appContext"])), {
    close,
    open: true
  });
  let confirmDialogInstance = null;
  function destroy() {
    if (confirmDialogInstance) {
      render(null, container);
      confirmDialogInstance = null;
    }
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    const triggerCancel = args.some((param) => param && param.triggerCancel);
    if (config.onCancel && triggerCancel) {
      config.onCancel(() => {
      }, ...args.slice(1));
    }
    for (let i2 = 0; i2 < destroyFns.length; i2++) {
      const fn = destroyFns[i2];
      if (fn === close) {
        destroyFns.splice(i2, 1);
        break;
      }
    }
  }
  function close() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    currentConfig = _extends$1(_extends$1({}, currentConfig), {
      open: false,
      afterClose: () => {
        if (typeof config.afterClose === "function") {
          config.afterClose();
        }
        destroy.apply(this, args);
      }
    });
    if (currentConfig.visible) {
      delete currentConfig.visible;
    }
    update(currentConfig);
  }
  function update(configUpdate) {
    if (typeof configUpdate === "function") {
      currentConfig = configUpdate(currentConfig);
    } else {
      currentConfig = _extends$1(_extends$1({}, currentConfig), configUpdate);
    }
    if (confirmDialogInstance) {
      triggerVNodeUpdate(confirmDialogInstance, currentConfig, container);
    }
  }
  const Wrapper = (p) => {
    const global2 = globalConfigForApi;
    const rootPrefixCls = global2.prefixCls;
    const prefixCls = p.prefixCls || `${rootPrefixCls}-modal`;
    const iconPrefixCls = global2.iconPrefixCls;
    const runtimeLocale2 = getConfirmLocale();
    return createVNode(ConfigProvider, _objectSpread2$1(_objectSpread2$1({}, global2), {}, {
      "prefixCls": rootPrefixCls
    }), {
      default: () => [createVNode(ConfirmDialog, _objectSpread2$1(_objectSpread2$1({}, p), {}, {
        "rootPrefixCls": rootPrefixCls,
        "prefixCls": prefixCls,
        "iconPrefixCls": iconPrefixCls,
        "locale": runtimeLocale2,
        "cancelText": p.cancelText || runtimeLocale2.cancelText
      }), null)]
    });
  };
  function render$1(props2) {
    const vm = createVNode(Wrapper, _extends$1({}, props2));
    vm.appContext = config.parentContext || config.appContext || vm.appContext;
    render(vm, container);
    return vm;
  }
  confirmDialogInstance = render$1(currentConfig);
  destroyFns.push(close);
  return {
    destroy: close,
    update
  };
};
function withWarn(props2) {
  return _extends$1(_extends$1({}, props2), {
    type: "warning"
  });
}
function withInfo(props2) {
  return _extends$1(_extends$1({}, props2), {
    type: "info"
  });
}
function withSuccess(props2) {
  return _extends$1(_extends$1({}, props2), {
    type: "success"
  });
}
function withError(props2) {
  return _extends$1(_extends$1({}, props2), {
    type: "error"
  });
}
function withConfirm(props2) {
  return _extends$1(_extends$1({}, props2), {
    type: "confirm"
  });
}
const comfirmFuncProps = () => ({
  config: Object,
  afterClose: Function,
  destroyAction: Function,
  open: Boolean
});
const HookModal = defineComponent({
  name: "HookModal",
  inheritAttrs: false,
  props: initDefaultProps(comfirmFuncProps(), {
    config: {
      width: 520,
      okType: "primary"
    }
  }),
  setup(props2, _ref) {
    let {
      expose
    } = _ref;
    var _a2;
    const open2 = computed(() => props2.open);
    const innerConfig = computed(() => props2.config);
    const {
      direction,
      getPrefixCls
    } = useConfigContextInject();
    const prefixCls = getPrefixCls("modal");
    const rootPrefixCls = getPrefixCls();
    const afterClose = () => {
      var _a3, _b;
      props2 === null || props2 === void 0 ? void 0 : props2.afterClose();
      (_b = (_a3 = innerConfig.value).afterClose) === null || _b === void 0 ? void 0 : _b.call(_a3);
    };
    const close = function() {
      props2.destroyAction(...arguments);
    };
    expose({
      destroy: close
    });
    const mergedOkCancel = (_a2 = innerConfig.value.okCancel) !== null && _a2 !== void 0 ? _a2 : innerConfig.value.type === "confirm";
    const [contextLocale] = useLocaleReceiver("Modal", localeValues.Modal);
    return () => createVNode(ConfirmDialog, _objectSpread2$1(_objectSpread2$1({
      "prefixCls": prefixCls,
      "rootPrefixCls": rootPrefixCls
    }, innerConfig.value), {}, {
      "close": close,
      "open": open2.value,
      "afterClose": afterClose,
      "okText": innerConfig.value.okText || (mergedOkCancel ? contextLocale === null || contextLocale === void 0 ? void 0 : contextLocale.value.okText : contextLocale === null || contextLocale === void 0 ? void 0 : contextLocale.value.justOkText),
      "direction": innerConfig.value.direction || direction.value,
      "cancelText": innerConfig.value.cancelText || (contextLocale === null || contextLocale === void 0 ? void 0 : contextLocale.value.cancelText)
    }), null);
  }
});
let uuid = 0;
const ElementsHolder = defineComponent({
  name: "ElementsHolder",
  inheritAttrs: false,
  setup(_2, _ref) {
    let {
      expose
    } = _ref;
    const modals = shallowRef([]);
    const addModal = (modal) => {
      modals.value.push(modal);
      modals.value = modals.value.slice();
      return () => {
        modals.value = modals.value.filter((currentModal) => currentModal !== modal);
      };
    };
    expose({
      addModal
    });
    return () => {
      return modals.value.map((modal) => modal());
    };
  }
});
function useModal() {
  const holderRef = shallowRef(null);
  const actionQueue = shallowRef([]);
  watch(actionQueue, () => {
    if (actionQueue.value.length) {
      const cloneQueue = [...actionQueue.value];
      cloneQueue.forEach((action) => {
        action();
      });
      actionQueue.value = [];
    }
  }, {
    immediate: true
  });
  const getConfirmFunc = (withFunc) => function hookConfirm(config) {
    var _a2;
    uuid += 1;
    const open2 = shallowRef(true);
    const modalRef = shallowRef(null);
    const configRef = shallowRef(unref(config));
    const updateConfig = shallowRef({});
    watch(() => config, (val) => {
      updateAction(_extends$1(_extends$1({}, isRef(val) ? val.value : val), updateConfig.value));
    });
    const destroyAction = function() {
      open2.value = false;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      const triggerCancel = args.some((param) => param && param.triggerCancel);
      if (configRef.value.onCancel && triggerCancel) {
        configRef.value.onCancel(() => {
        }, ...args.slice(1));
      }
    };
    let closeFunc;
    const modal = () => createVNode(HookModal, {
      "key": `modal-${uuid}`,
      "config": withFunc(configRef.value),
      "ref": modalRef,
      "open": open2.value,
      "destroyAction": destroyAction,
      "afterClose": () => {
        closeFunc === null || closeFunc === void 0 ? void 0 : closeFunc();
      }
    }, null);
    closeFunc = (_a2 = holderRef.value) === null || _a2 === void 0 ? void 0 : _a2.addModal(modal);
    if (closeFunc) {
      destroyFns.push(closeFunc);
    }
    const updateAction = (newConfig) => {
      configRef.value = _extends$1(_extends$1({}, configRef.value), newConfig);
    };
    const destroy = () => {
      if (modalRef.value) {
        destroyAction();
      } else {
        actionQueue.value = [...actionQueue.value, destroyAction];
      }
    };
    const update = (newConfig) => {
      updateConfig.value = newConfig;
      if (modalRef.value) {
        updateAction(newConfig);
      } else {
        actionQueue.value = [...actionQueue.value, () => updateAction(newConfig)];
      }
    };
    return {
      destroy,
      update
    };
  };
  const fns = computed(() => ({
    info: getConfirmFunc(withInfo),
    success: getConfirmFunc(withSuccess),
    error: getConfirmFunc(withError),
    warning: getConfirmFunc(withWarn),
    confirm: getConfirmFunc(withConfirm)
  }));
  const holderKey = Symbol("modalHolderKey");
  return [fns.value, () => createVNode(ElementsHolder, {
    "key": holderKey,
    "ref": holderRef
  }, null)];
}
function modalWarn(props2) {
  return confirm(withWarn(props2));
}
Modal.useModal = useModal;
Modal.info = function infoFn(props2) {
  return confirm(withInfo(props2));
};
Modal.success = function successFn(props2) {
  return confirm(withSuccess(props2));
};
Modal.error = function errorFn(props2) {
  return confirm(withError(props2));
};
Modal.warning = modalWarn;
Modal.warn = modalWarn;
Modal.confirm = function confirmFn(props2) {
  return confirm(withConfirm(props2));
};
Modal.destroyAll = function destroyAllFn() {
  while (destroyFns.length) {
    const close = destroyFns.pop();
    if (close) {
      close();
    }
  }
};
Modal.install = function(app) {
  app.component(Modal.name, Modal);
  return app;
};
var __rest$m = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const inlineStyle = {
  border: 0,
  background: "transparent",
  padding: 0,
  lineHeight: "inherit",
  display: "inline-block"
};
const TransButton = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "TransButton",
  inheritAttrs: false,
  props: {
    noStyle: {
      type: Boolean,
      default: void 0
    },
    onClick: Function,
    disabled: {
      type: Boolean,
      default: void 0
    },
    autofocus: {
      type: Boolean,
      default: void 0
    }
  },
  setup(props2, _ref) {
    let {
      slots,
      emit,
      attrs,
      expose
    } = _ref;
    const domRef = shallowRef();
    const onKeyDown2 = (event) => {
      const {
        keyCode
      } = event;
      if (keyCode === KeyCode.ENTER) {
        event.preventDefault();
      }
    };
    const onKeyUp = (event) => {
      const {
        keyCode
      } = event;
      if (keyCode === KeyCode.ENTER) {
        emit("click", event);
      }
    };
    const onClick = (e2) => {
      emit("click", e2);
    };
    const focus = () => {
      if (domRef.value) {
        domRef.value.focus();
      }
    };
    const blur = () => {
      if (domRef.value) {
        domRef.value.blur();
      }
    };
    onMounted(() => {
      if (props2.autofocus) {
        focus();
      }
    });
    expose({
      focus,
      blur
    });
    return () => {
      var _a2;
      const {
        noStyle,
        disabled
      } = props2, restProps = __rest$m(props2, ["noStyle", "disabled"]);
      let mergedStyle = {};
      if (!noStyle) {
        mergedStyle = _extends$1({}, inlineStyle);
      }
      if (disabled) {
        mergedStyle.pointerEvents = "none";
      }
      return createVNode("div", _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
        "role": "button",
        "tabindex": 0,
        "ref": domRef
      }, restProps), attrs), {}, {
        "onClick": onClick,
        "onKeydown": onKeyDown2,
        "onKeyup": onKeyUp,
        "style": _extends$1(_extends$1({}, mergedStyle), attrs.style || {})
      }), [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]);
    };
  }
});
const spaceSize = {
  small: 8,
  middle: 16,
  large: 24
};
const spaceProps = () => ({
  prefixCls: String,
  size: {
    type: [String, Number, Array]
  },
  direction: PropTypes.oneOf(tuple$1("horizontal", "vertical")).def("horizontal"),
  align: PropTypes.oneOf(tuple$1("start", "end", "center", "baseline")),
  wrap: booleanType()
});
function getNumberSize(size) {
  return typeof size === "string" ? spaceSize[size] : size || 0;
}
const Space = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ASpace",
  inheritAttrs: false,
  props: spaceProps(),
  slots: Object,
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const {
      prefixCls,
      space,
      direction: directionConfig
    } = useConfigInject("space", props2);
    const [wrapSSR, hashId] = useStyle$H(prefixCls);
    const supportFlexGap = useFlexGapSupport();
    const size = computed(() => {
      var _a2, _b, _c;
      return (_c = (_a2 = props2.size) !== null && _a2 !== void 0 ? _a2 : (_b = space === null || space === void 0 ? void 0 : space.value) === null || _b === void 0 ? void 0 : _b.size) !== null && _c !== void 0 ? _c : "small";
    });
    const horizontalSize = ref();
    const verticalSize = ref();
    watch(size, () => {
      [horizontalSize.value, verticalSize.value] = (Array.isArray(size.value) ? size.value : [size.value, size.value]).map((item) => getNumberSize(item));
    }, {
      immediate: true
    });
    const mergedAlign = computed(() => props2.align === void 0 && props2.direction === "horizontal" ? "center" : props2.align);
    const cn = computed(() => {
      return classNames(prefixCls.value, hashId.value, `${prefixCls.value}-${props2.direction}`, {
        [`${prefixCls.value}-rtl`]: directionConfig.value === "rtl",
        [`${prefixCls.value}-align-${mergedAlign.value}`]: mergedAlign.value
      });
    });
    const marginDirection = computed(() => directionConfig.value === "rtl" ? "marginLeft" : "marginRight");
    const style = computed(() => {
      const gapStyle = {};
      if (supportFlexGap.value) {
        gapStyle.columnGap = `${horizontalSize.value}px`;
        gapStyle.rowGap = `${verticalSize.value}px`;
      }
      return _extends$1(_extends$1({}, gapStyle), props2.wrap && {
        flexWrap: "wrap",
        marginBottom: `${-verticalSize.value}px`
      });
    });
    return () => {
      var _a2, _b;
      const {
        wrap,
        direction = "horizontal"
      } = props2;
      const children = (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
      const items = filterEmpty(children);
      const len = items.length;
      if (len === 0) {
        return null;
      }
      const split = (_b = slots.split) === null || _b === void 0 ? void 0 : _b.call(slots);
      const itemClassName = `${prefixCls.value}-item`;
      const horizontalSizeVal = horizontalSize.value;
      const latestIndex = len - 1;
      return createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "class": [cn.value, attrs.class],
        "style": [style.value, attrs.style]
      }), [items.map((child, index2) => {
        let originIndex = children.indexOf(child);
        if (originIndex === -1) {
          originIndex = `$$space-${index2}`;
        }
        let itemStyle = {};
        if (!supportFlexGap.value) {
          if (direction === "vertical") {
            if (index2 < latestIndex) {
              itemStyle = {
                marginBottom: `${horizontalSizeVal / (split ? 2 : 1)}px`
              };
            }
          } else {
            itemStyle = _extends$1(_extends$1({}, index2 < latestIndex && {
              [marginDirection.value]: `${horizontalSizeVal / (split ? 2 : 1)}px`
            }), wrap && {
              paddingBottom: `${verticalSize.value}px`
            });
          }
        }
        return wrapSSR(createVNode(Fragment, {
          "key": originIndex
        }, [createVNode("div", {
          "class": itemClassName,
          "style": itemStyle
        }, [child]), index2 < latestIndex && split && createVNode("span", {
          "class": `${itemClassName}-split`,
          "style": itemStyle
        }, [split])]));
      })]);
    };
  }
});
Space.Compact = Compact;
Space.install = function(app) {
  app.component(Space.name, Space);
  app.component(Compact.name, Compact);
  return app;
};
const genBaseStyle$6 = (token2) => {
  const {
    componentCls,
    iconCls,
    zIndexPopup,
    colorText,
    colorWarning,
    marginXS,
    fontSize,
    fontWeightStrong,
    lineHeight
  } = token2;
  return {
    [componentCls]: {
      zIndex: zIndexPopup,
      [`${componentCls}-inner-content`]: {
        color: colorText
      },
      [`${componentCls}-message`]: {
        position: "relative",
        marginBottom: marginXS,
        color: colorText,
        fontSize,
        display: "flex",
        flexWrap: "nowrap",
        alignItems: "start",
        [`> ${componentCls}-message-icon ${iconCls}`]: {
          color: colorWarning,
          fontSize,
          flex: "none",
          lineHeight: 1,
          paddingTop: (Math.round(fontSize * lineHeight) - fontSize) / 2
        },
        "&-title": {
          flex: "auto",
          marginInlineStart: marginXS
        },
        "&-title-only": {
          fontWeight: fontWeightStrong
        }
      },
      [`${componentCls}-description`]: {
        position: "relative",
        marginInlineStart: fontSize + marginXS,
        marginBottom: marginXS,
        color: colorText,
        fontSize
      },
      [`${componentCls}-buttons`]: {
        textAlign: "end",
        button: {
          marginInlineStart: marginXS
        }
      }
    }
  };
};
const usePopconfirmStyle = genComponentStyleHook("Popconfirm", (token2) => genBaseStyle$6(token2), (token2) => {
  const {
    zIndexPopupBase
  } = token2;
  return {
    zIndexPopup: zIndexPopupBase + 60
  };
});
var __rest$l = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const popconfirmProps = () => _extends$1(_extends$1({}, abstractTooltipProps()), {
  prefixCls: String,
  content: anyType(),
  title: anyType(),
  description: anyType(),
  okType: stringType("primary"),
  disabled: {
    type: Boolean,
    default: false
  },
  okText: anyType(),
  cancelText: anyType(),
  icon: anyType(),
  okButtonProps: objectType(),
  cancelButtonProps: objectType(),
  showCancel: {
    type: Boolean,
    default: true
  },
  onConfirm: Function,
  onCancel: Function
});
const Popconfirm = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "APopconfirm",
  inheritAttrs: false,
  props: initDefaultProps(popconfirmProps(), _extends$1(_extends$1({}, tooltipDefaultProps()), {
    trigger: "click",
    placement: "top",
    mouseEnterDelay: 0.1,
    mouseLeaveDelay: 0.1,
    arrowPointAtCenter: false,
    autoAdjustOverflow: true,
    okType: "primary",
    disabled: false
  })),
  slots: Object,
  // emits: ['update:open', 'visibleChange'],
  setup(props2, _ref) {
    let {
      slots,
      emit,
      expose,
      attrs
    } = _ref;
    const rootRef = ref();
    warning$1(props2.visible === void 0);
    expose({
      getPopupDomNode: () => {
        var _a2, _b;
        return (_b = (_a2 = rootRef.value) === null || _a2 === void 0 ? void 0 : _a2.getPopupDomNode) === null || _b === void 0 ? void 0 : _b.call(_a2);
      }
    });
    const [open2, setOpen] = useMergedState(false, {
      value: toRef(props2, "open")
    });
    const settingOpen = (value, e2) => {
      if (props2.open === void 0) {
        setOpen(value);
      }
      emit("update:open", value);
      emit("openChange", value, e2);
    };
    const close = (e2) => {
      settingOpen(false, e2);
    };
    const onConfirm = (e2) => {
      var _a2;
      return (_a2 = props2.onConfirm) === null || _a2 === void 0 ? void 0 : _a2.call(props2, e2);
    };
    const onCancel = (e2) => {
      var _a2;
      settingOpen(false, e2);
      (_a2 = props2.onCancel) === null || _a2 === void 0 ? void 0 : _a2.call(props2, e2);
    };
    const onKeyDown2 = (e2) => {
      if (e2.keyCode === KeyCode.ESC && open2) {
        settingOpen(false, e2);
      }
    };
    const onOpenChange = (value) => {
      const {
        disabled
      } = props2;
      if (disabled) {
        return;
      }
      settingOpen(value);
    };
    const {
      prefixCls: prefixClsConfirm,
      getPrefixCls
    } = useConfigInject("popconfirm", props2);
    const rootPrefixCls = computed(() => getPrefixCls());
    const btnPrefixCls = computed(() => getPrefixCls("btn"));
    const [wrapSSR] = usePopconfirmStyle(prefixClsConfirm);
    const [popconfirmLocale] = useLocaleReceiver("Popconfirm", localeValues.Popconfirm);
    const renderOverlay = () => {
      var _a2, _b, _c, _d, _e;
      const {
        okButtonProps,
        cancelButtonProps,
        title = (_a2 = slots.title) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
        description = (_b = slots.description) === null || _b === void 0 ? void 0 : _b.call(slots),
        cancelText = (_c = slots.cancel) === null || _c === void 0 ? void 0 : _c.call(slots),
        okText = (_d = slots.okText) === null || _d === void 0 ? void 0 : _d.call(slots),
        okType,
        icon = ((_e = slots.icon) === null || _e === void 0 ? void 0 : _e.call(slots)) || createVNode(ExclamationCircleFilled, null, null),
        showCancel = true
      } = props2;
      const {
        cancelButton,
        okButton
      } = slots;
      const cancelProps = _extends$1({
        onClick: onCancel,
        size: "small"
      }, cancelButtonProps);
      const okProps = _extends$1(_extends$1(_extends$1({
        onClick: onConfirm
      }, convertLegacyProps(okType)), {
        size: "small"
      }), okButtonProps);
      return createVNode("div", {
        "class": `${prefixClsConfirm.value}-inner-content`
      }, [createVNode("div", {
        "class": `${prefixClsConfirm.value}-message`
      }, [icon && createVNode("span", {
        "class": `${prefixClsConfirm.value}-message-icon`
      }, [icon]), createVNode("div", {
        "class": [`${prefixClsConfirm.value}-message-title`, {
          [`${prefixClsConfirm.value}-message-title-only`]: !!description
        }]
      }, [title])]), description && createVNode("div", {
        "class": `${prefixClsConfirm.value}-description`
      }, [description]), createVNode("div", {
        "class": `${prefixClsConfirm.value}-buttons`
      }, [showCancel ? cancelButton ? cancelButton(cancelProps) : createVNode(Button$1, cancelProps, {
        default: () => [cancelText || popconfirmLocale.value.cancelText]
      }) : null, okButton ? okButton(okProps) : createVNode(ActionButton, {
        "buttonProps": _extends$1(_extends$1({
          size: "small"
        }, convertLegacyProps(okType)), okButtonProps),
        "actionFn": onConfirm,
        "close": close,
        "prefixCls": btnPrefixCls.value,
        "quitOnNullishReturnValue": true,
        "emitEvent": true
      }, {
        default: () => [okText || popconfirmLocale.value.okText]
      })])]);
    };
    return () => {
      var _a2;
      const {
        placement,
        overlayClassName,
        trigger = "click"
      } = props2, restProps = __rest$l(props2, ["placement", "overlayClassName", "trigger"]);
      const otherProps = omit$1(restProps, ["title", "content", "cancelText", "okText", "onUpdate:open", "onConfirm", "onCancel", "prefixCls"]);
      const overlayClassNames = classNames(prefixClsConfirm.value, overlayClassName);
      return wrapSSR(createVNode(Popover$1, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, otherProps), attrs), {}, {
        "trigger": trigger,
        "placement": placement,
        "onOpenChange": onOpenChange,
        "open": open2.value,
        "overlayClassName": overlayClassNames,
        "transitionName": getTransitionName(rootPrefixCls.value, "zoom-big", props2.transitionName),
        "ref": rootRef,
        "data-popover-inject": true
      }), {
        default: () => [cloneVNodes(((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)) || [], {
          onKeydown: (e2) => {
            onKeyDown2(e2);
          }
        }, false)],
        content: renderOverlay
      }));
    };
  }
});
const Popconfirm$1 = withInstall(Popconfirm);
const progressStatuses = ["normal", "exception", "active", "success"];
const progressProps = () => ({
  prefixCls: String,
  type: stringType(),
  percent: Number,
  format: functionType(),
  status: stringType(),
  showInfo: booleanType(),
  strokeWidth: Number,
  strokeLinecap: stringType(),
  strokeColor: anyType(),
  trailColor: String,
  /** @deprecated Use `size` instead */
  width: Number,
  success: objectType(),
  gapDegree: Number,
  gapPosition: stringType(),
  size: someType([String, Number, Array]),
  steps: Number,
  /** @deprecated Use `success` instead */
  successPercent: Number,
  title: String,
  progressStatus: stringType()
});
function validProgress(progress) {
  if (!progress || progress < 0) {
    return 0;
  }
  if (progress > 100) {
    return 100;
  }
  return progress;
}
function getSuccessPercent(_ref) {
  let {
    success,
    successPercent
  } = _ref;
  let percent = successPercent;
  if (success && "progress" in success) {
    devWarning(false, "Progress", "`success.progress` is deprecated. Please use `success.percent` instead.");
    percent = success.progress;
  }
  if (success && "percent" in success) {
    percent = success.percent;
  }
  return percent;
}
function getPercentage(_ref2) {
  let {
    percent,
    success,
    successPercent
  } = _ref2;
  const realSuccessPercent = validProgress(getSuccessPercent({
    success,
    successPercent
  }));
  return [realSuccessPercent, validProgress(validProgress(percent) - realSuccessPercent)];
}
function getStrokeColor(_ref3) {
  let {
    success = {},
    strokeColor
  } = _ref3;
  const {
    strokeColor: successColor
  } = success;
  return [successColor || presetPrimaryColors.green, strokeColor || null];
}
const getSize = (size, type4, extra) => {
  var _a2, _b, _c, _d;
  let width = -1;
  let height = -1;
  if (type4 === "step") {
    const steps = extra.steps;
    const strokeWidth = extra.strokeWidth;
    if (typeof size === "string" || typeof size === "undefined") {
      width = size === "small" ? 2 : 14;
      height = strokeWidth !== null && strokeWidth !== void 0 ? strokeWidth : 8;
    } else if (typeof size === "number") {
      [width, height] = [size, size];
    } else {
      [width = 14, height = 8] = size;
    }
    width *= steps;
  } else if (type4 === "line") {
    const strokeWidth = extra === null || extra === void 0 ? void 0 : extra.strokeWidth;
    if (typeof size === "string" || typeof size === "undefined") {
      height = strokeWidth || (size === "small" ? 6 : 8);
    } else if (typeof size === "number") {
      [width, height] = [size, size];
    } else {
      [width = -1, height = 8] = size;
    }
  } else if (type4 === "circle" || type4 === "dashboard") {
    if (typeof size === "string" || typeof size === "undefined") {
      [width, height] = size === "small" ? [60, 60] : [120, 120];
    } else if (typeof size === "number") {
      [width, height] = [size, size];
    } else {
      width = (_b = (_a2 = size[0]) !== null && _a2 !== void 0 ? _a2 : size[1]) !== null && _b !== void 0 ? _b : 120;
      height = (_d = (_c = size[0]) !== null && _c !== void 0 ? _c : size[1]) !== null && _d !== void 0 ? _d : 120;
    }
  }
  return {
    width,
    height
  };
};
var __rest$k = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const lineProps = () => _extends$1(_extends$1({}, progressProps()), {
  strokeColor: anyType(),
  direction: stringType()
});
const sortGradient = (gradients) => {
  let tempArr = [];
  Object.keys(gradients).forEach((key2) => {
    const formattedKey = parseFloat(key2.replace(/%/g, ""));
    if (!isNaN(formattedKey)) {
      tempArr.push({
        key: formattedKey,
        value: gradients[key2]
      });
    }
  });
  tempArr = tempArr.sort((a2, b2) => a2.key - b2.key);
  return tempArr.map((_ref) => {
    let {
      key: key2,
      value
    } = _ref;
    return `${value} ${key2}%`;
  }).join(", ");
};
const handleGradient = (strokeColor, directionConfig) => {
  const {
    from: from2 = presetPrimaryColors.blue,
    to = presetPrimaryColors.blue,
    direction = directionConfig === "rtl" ? "to left" : "to right"
  } = strokeColor, rest = __rest$k(strokeColor, ["from", "to", "direction"]);
  if (Object.keys(rest).length !== 0) {
    const sortedGradients = sortGradient(rest);
    return {
      backgroundImage: `linear-gradient(${direction}, ${sortedGradients})`
    };
  }
  return {
    backgroundImage: `linear-gradient(${direction}, ${from2}, ${to})`
  };
};
const Line = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ProgressLine",
  inheritAttrs: false,
  props: lineProps(),
  setup(props2, _ref2) {
    let {
      slots,
      attrs
    } = _ref2;
    const backgroundProps = computed(() => {
      const {
        strokeColor,
        direction
      } = props2;
      return strokeColor && typeof strokeColor !== "string" ? handleGradient(strokeColor, direction) : {
        backgroundColor: strokeColor
      };
    });
    const borderRadius = computed(() => props2.strokeLinecap === "square" || props2.strokeLinecap === "butt" ? 0 : void 0);
    const trailStyle = computed(() => props2.trailColor ? {
      backgroundColor: props2.trailColor
    } : void 0);
    const mergedSize = computed(() => {
      var _a2;
      return (_a2 = props2.size) !== null && _a2 !== void 0 ? _a2 : [-1, props2.strokeWidth || (props2.size === "small" ? 6 : 8)];
    });
    const sizeRef = computed(() => getSize(mergedSize.value, "line", {
      strokeWidth: props2.strokeWidth
    }));
    const percentStyle = computed(() => {
      const {
        percent
      } = props2;
      return _extends$1({
        width: `${validProgress(percent)}%`,
        height: `${sizeRef.value.height}px`,
        borderRadius: borderRadius.value
      }, backgroundProps.value);
    });
    const successPercent = computed(() => {
      return getSuccessPercent(props2);
    });
    const successPercentStyle = computed(() => {
      const {
        success
      } = props2;
      return {
        width: `${validProgress(successPercent.value)}%`,
        height: `${sizeRef.value.height}px`,
        borderRadius: borderRadius.value,
        backgroundColor: success === null || success === void 0 ? void 0 : success.strokeColor
      };
    });
    const outerStyle = {
      width: sizeRef.value.width < 0 ? "100%" : sizeRef.value.width,
      height: `${sizeRef.value.height}px`
    };
    return () => {
      var _a2;
      return createVNode(Fragment, null, [createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "class": [`${props2.prefixCls}-outer`, attrs.class],
        "style": [attrs.style, outerStyle]
      }), [createVNode("div", {
        "class": `${props2.prefixCls}-inner`,
        "style": trailStyle.value
      }, [createVNode("div", {
        "class": `${props2.prefixCls}-bg`,
        "style": percentStyle.value
      }, null), successPercent.value !== void 0 ? createVNode("div", {
        "class": `${props2.prefixCls}-success-bg`,
        "style": successPercentStyle.value
      }, null) : null])]), (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]);
    };
  }
});
const defaultProps = {
  percent: 0,
  prefixCls: "vc-progress",
  strokeColor: "#2db7f5",
  strokeLinecap: "round",
  strokeWidth: 1,
  trailColor: "#D9D9D9",
  trailWidth: 1
};
const useTransitionDuration = (paths) => {
  const prevTimeStamp = ref(null);
  onUpdated(() => {
    const now2 = Date.now();
    let updated = false;
    paths.value.forEach((val) => {
      const path2 = (val === null || val === void 0 ? void 0 : val.$el) || val;
      if (!path2) {
        return;
      }
      updated = true;
      const pathStyle = path2.style;
      pathStyle.transitionDuration = ".3s, .3s, .3s, .06s";
      if (prevTimeStamp.value && now2 - prevTimeStamp.value < 100) {
        pathStyle.transitionDuration = "0s, 0s";
      }
    });
    if (updated) {
      prevTimeStamp.value = Date.now();
    }
  });
  return paths;
};
const propTypes = {
  gapDegree: Number,
  gapPosition: {
    type: String
  },
  percent: {
    type: [Array, Number]
  },
  prefixCls: String,
  strokeColor: {
    type: [Object, String, Array]
  },
  strokeLinecap: {
    type: String
  },
  strokeWidth: Number,
  trailColor: String,
  trailWidth: Number,
  transition: String
};
var __rest$j = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ProgressLine",
  props: initDefaultProps(propTypes, defaultProps),
  setup(props2) {
    const percentList = computed(() => {
      const {
        percent
      } = props2;
      return Array.isArray(percent) ? percent : [percent];
    });
    const percentListProps = computed(() => {
      const {
        prefixCls,
        strokeLinecap,
        strokeWidth,
        transition
      } = props2;
      let stackPtg = 0;
      return percentList.value.map((ptg, index2) => {
        let dashPercent = 1;
        switch (strokeLinecap) {
          case "round":
            dashPercent = 1 - strokeWidth / 100;
            break;
          case "square":
            dashPercent = 1 - strokeWidth / 2 / 100;
            break;
          default:
            dashPercent = 1;
            break;
        }
        const pathStyle = {
          strokeDasharray: `${ptg * dashPercent}px, 100px`,
          strokeDashoffset: `-${stackPtg}px`,
          transition: transition || "stroke-dashoffset 0.3s ease 0s, stroke-dasharray .3s ease 0s, stroke 0.3s linear"
        };
        const color = strokeColorList.value[index2] || strokeColorList.value[strokeColorList.value.length - 1];
        stackPtg += ptg;
        const pathProps = {
          key: index2,
          d: pathString.value,
          "stroke-linecap": strokeLinecap,
          stroke: color,
          "stroke-width": strokeWidth,
          "fill-opacity": "0",
          class: `${prefixCls}-line-path`,
          style: pathStyle
        };
        return pathProps;
      });
    });
    const strokeColorList = computed(() => {
      const {
        strokeColor
      } = props2;
      return Array.isArray(strokeColor) ? strokeColor : [strokeColor];
    });
    const [setRef, paths] = useRefs();
    useTransitionDuration(paths);
    const center = computed(() => props2.strokeWidth / 2);
    const right = computed(() => 100 - props2.strokeWidth / 2);
    const pathString = computed(() => `M ${props2.strokeLinecap === "round" ? center.value : 0},${center.value}
    L ${props2.strokeLinecap === "round" ? right.value : 100},${center.value}`);
    const viewBoxString = computed(() => `0 0 100 ${props2.strokeWidth}`);
    const pathFirst = computed(() => ({
      d: pathString.value,
      "stroke-linecap": props2.strokeLinecap,
      stroke: props2.trailColor,
      "stroke-width": props2.trailWidth || props2.strokeWidth,
      "fill-opacity": "0",
      class: `${props2.prefixCls}-line-trail`
    }));
    return () => {
      const {
        percent,
        prefixCls,
        strokeColor,
        strokeLinecap,
        strokeWidth,
        trailColor,
        trailWidth,
        transition
      } = props2, restProps = __rest$j(props2, ["percent", "prefixCls", "strokeColor", "strokeLinecap", "strokeWidth", "trailColor", "trailWidth", "transition"]);
      delete restProps.gapPosition;
      return createVNode("svg", _objectSpread2$1({
        "class": `${prefixCls}-line`,
        "viewBox": viewBoxString.value,
        "preserveAspectRatio": "none"
      }, restProps), [createVNode("path", pathFirst.value, null), percentListProps.value.map((pathProps, index2) => {
        return createVNode("path", _objectSpread2$1({
          "ref": setRef(index2)
        }, pathProps), null);
      })]);
    };
  }
});
var __rest$i = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
let gradientSeed = 0;
function stripPercentToNumber(percent) {
  return +percent.replace("%", "");
}
function toArray$1(value) {
  return Array.isArray(value) ? value : [value];
}
function getPathStyles(offset3, percent, strokeColor, strokeWidth) {
  let gapDegree = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
  let gapPosition = arguments.length > 5 ? arguments[5] : void 0;
  const radius = 50 - strokeWidth / 2;
  let beginPositionX = 0;
  let beginPositionY = -radius;
  let endPositionX = 0;
  let endPositionY = -2 * radius;
  switch (gapPosition) {
    case "left":
      beginPositionX = -radius;
      beginPositionY = 0;
      endPositionX = 2 * radius;
      endPositionY = 0;
      break;
    case "right":
      beginPositionX = radius;
      beginPositionY = 0;
      endPositionX = -2 * radius;
      endPositionY = 0;
      break;
    case "bottom":
      beginPositionY = radius;
      endPositionY = 2 * radius;
      break;
  }
  const pathString = `M 50,50 m ${beginPositionX},${beginPositionY}
   a ${radius},${radius} 0 1 1 ${endPositionX},${-endPositionY}
   a ${radius},${radius} 0 1 1 ${-endPositionX},${endPositionY}`;
  const len = Math.PI * 2 * radius;
  const pathStyle = {
    stroke: strokeColor,
    strokeDasharray: `${percent / 100 * (len - gapDegree)}px ${len}px`,
    strokeDashoffset: `-${gapDegree / 2 + offset3 / 100 * (len - gapDegree)}px`,
    transition: "stroke-dashoffset .3s ease 0s, stroke-dasharray .3s ease 0s, stroke .3s, stroke-width .06s ease .3s, opacity .3s ease 0s"
    // eslint-disable-line
  };
  return {
    pathString,
    pathStyle
  };
}
const VCCircle = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "VCCircle",
  props: initDefaultProps(propTypes, defaultProps),
  setup(props2) {
    gradientSeed += 1;
    const gradientId = ref(gradientSeed);
    const percentList = computed(() => toArray$1(props2.percent));
    const strokeColorList = computed(() => toArray$1(props2.strokeColor));
    const [setRef, paths] = useRefs();
    useTransitionDuration(paths);
    const getStokeList = () => {
      const {
        prefixCls,
        strokeWidth,
        strokeLinecap,
        gapDegree,
        gapPosition
      } = props2;
      let stackPtg = 0;
      return percentList.value.map((ptg, index2) => {
        const color = strokeColorList.value[index2] || strokeColorList.value[strokeColorList.value.length - 1];
        const stroke = Object.prototype.toString.call(color) === "[object Object]" ? `url(#${prefixCls}-gradient-${gradientId.value})` : "";
        const {
          pathString,
          pathStyle
        } = getPathStyles(stackPtg, ptg, color, strokeWidth, gapDegree, gapPosition);
        stackPtg += ptg;
        const pathProps = {
          key: index2,
          d: pathString,
          stroke,
          "stroke-linecap": strokeLinecap,
          "stroke-width": strokeWidth,
          opacity: ptg === 0 ? 0 : 1,
          "fill-opacity": "0",
          class: `${prefixCls}-circle-path`,
          style: pathStyle
        };
        return createVNode("path", _objectSpread2$1({
          "ref": setRef(index2)
        }, pathProps), null);
      });
    };
    return () => {
      const {
        prefixCls,
        strokeWidth,
        trailWidth,
        gapDegree,
        gapPosition,
        trailColor,
        strokeLinecap,
        strokeColor
      } = props2, restProps = __rest$i(props2, ["prefixCls", "strokeWidth", "trailWidth", "gapDegree", "gapPosition", "trailColor", "strokeLinecap", "strokeColor"]);
      const {
        pathString,
        pathStyle
      } = getPathStyles(0, 100, trailColor, strokeWidth, gapDegree, gapPosition);
      delete restProps.percent;
      const gradient = strokeColorList.value.find((color) => Object.prototype.toString.call(color) === "[object Object]");
      const pathFirst = {
        d: pathString,
        stroke: trailColor,
        "stroke-linecap": strokeLinecap,
        "stroke-width": trailWidth || strokeWidth,
        "fill-opacity": "0",
        class: `${prefixCls}-circle-trail`,
        style: pathStyle
      };
      return createVNode("svg", _objectSpread2$1({
        "class": `${prefixCls}-circle`,
        "viewBox": "0 0 100 100"
      }, restProps), [gradient && createVNode("defs", null, [createVNode("linearGradient", {
        "id": `${prefixCls}-gradient-${gradientId.value}`,
        "x1": "100%",
        "y1": "0%",
        "x2": "0%",
        "y2": "0%"
      }, [Object.keys(gradient).sort((a2, b2) => stripPercentToNumber(a2) - stripPercentToNumber(b2)).map((key2, index2) => createVNode("stop", {
        "key": index2,
        "offset": key2,
        "stop-color": gradient[key2]
      }, null))])]), createVNode("path", pathFirst, null), getStokeList().reverse()]);
    };
  }
});
const circleProps = () => _extends$1(_extends$1({}, progressProps()), {
  strokeColor: anyType()
});
const CIRCLE_MIN_STROKE_WIDTH = 3;
const getMinPercent = (width) => CIRCLE_MIN_STROKE_WIDTH / width * 100;
const Circle = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ProgressCircle",
  inheritAttrs: false,
  props: initDefaultProps(circleProps(), {
    trailColor: null
  }),
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const originWidth = computed(() => {
      var _a2;
      return (_a2 = props2.width) !== null && _a2 !== void 0 ? _a2 : 120;
    });
    const mergedSize = computed(() => {
      var _a2;
      return (_a2 = props2.size) !== null && _a2 !== void 0 ? _a2 : [originWidth.value, originWidth.value];
    });
    const sizeRef = computed(() => getSize(mergedSize.value, "circle"));
    const gapDeg = computed(() => {
      if (props2.gapDegree || props2.gapDegree === 0) {
        return props2.gapDegree;
      }
      if (props2.type === "dashboard") {
        return 75;
      }
      return void 0;
    });
    const circleStyle = computed(() => {
      return {
        width: `${sizeRef.value.width}px`,
        height: `${sizeRef.value.height}px`,
        fontSize: `${sizeRef.value.width * 0.15 + 6}px`
      };
    });
    const circleWidth = computed(() => {
      var _a2;
      return (_a2 = props2.strokeWidth) !== null && _a2 !== void 0 ? _a2 : Math.max(getMinPercent(sizeRef.value.width), 6);
    });
    const gapPos = computed(() => props2.gapPosition || props2.type === "dashboard" && "bottom" || void 0);
    const percent = computed(() => getPercentage(props2));
    const isGradient = computed(() => Object.prototype.toString.call(props2.strokeColor) === "[object Object]");
    const strokeColor = computed(() => getStrokeColor({
      success: props2.success,
      strokeColor: props2.strokeColor
    }));
    const wrapperClassName = computed(() => ({
      [`${props2.prefixCls}-inner`]: true,
      [`${props2.prefixCls}-circle-gradient`]: isGradient.value
    }));
    return () => {
      var _a2;
      const circleContent = createVNode(VCCircle, {
        "percent": percent.value,
        "strokeWidth": circleWidth.value,
        "trailWidth": circleWidth.value,
        "strokeColor": strokeColor.value,
        "strokeLinecap": props2.strokeLinecap,
        "trailColor": props2.trailColor,
        "prefixCls": props2.prefixCls,
        "gapDegree": gapDeg.value,
        "gapPosition": gapPos.value
      }, null);
      return createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "class": [wrapperClassName.value, attrs.class],
        "style": [attrs.style, circleStyle.value]
      }), [sizeRef.value.width <= 20 ? createVNode(Tooltip, null, {
        default: () => [createVNode("span", null, [circleContent])],
        title: slots.default
      }) : createVNode(Fragment, null, [circleContent, (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)])]);
    };
  }
});
const stepsProps = () => _extends$1(_extends$1({}, progressProps()), {
  steps: Number,
  strokeColor: someType(),
  trailColor: String
});
const Steps$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Steps",
  props: stepsProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const current = computed(() => Math.round(props2.steps * ((props2.percent || 0) / 100)));
    const mergedSize = computed(() => {
      var _a2;
      return (_a2 = props2.size) !== null && _a2 !== void 0 ? _a2 : [props2.size === "small" ? 2 : 14, props2.strokeWidth || 8];
    });
    const sizeRef = computed(() => getSize(mergedSize.value, "step", {
      steps: props2.steps,
      strokeWidth: props2.strokeWidth || 8
    }));
    const styledSteps = computed(() => {
      const {
        steps,
        strokeColor,
        trailColor,
        prefixCls
      } = props2;
      const temp = [];
      for (let i2 = 0; i2 < steps; i2 += 1) {
        const color = Array.isArray(strokeColor) ? strokeColor[i2] : strokeColor;
        const cls = {
          [`${prefixCls}-steps-item`]: true,
          [`${prefixCls}-steps-item-active`]: i2 <= current.value - 1
        };
        temp.push(createVNode("div", {
          "key": i2,
          "class": cls,
          "style": {
            backgroundColor: i2 <= current.value - 1 ? color : trailColor,
            width: `${sizeRef.value.width / steps}px`,
            height: `${sizeRef.value.height}px`
          }
        }, null));
      }
      return temp;
    });
    return () => {
      var _a2;
      return createVNode("div", {
        "class": `${props2.prefixCls}-steps-outer`
      }, [styledSteps.value, (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]);
    };
  }
});
const antProgressActive = new Keyframe("antProgressActive", {
  "0%": {
    transform: "translateX(-100%) scaleX(0)",
    opacity: 0.1
  },
  "20%": {
    transform: "translateX(-100%) scaleX(0)",
    opacity: 0.5
  },
  to: {
    transform: "translateX(0) scaleX(1)",
    opacity: 0
  }
});
const genBaseStyle$5 = (token2) => {
  const {
    componentCls: progressCls,
    iconCls: iconPrefixCls
  } = token2;
  return {
    [progressCls]: _extends$1(_extends$1({}, resetComponent(token2)), {
      display: "inline-block",
      "&-rtl": {
        direction: "rtl"
      },
      "&-line": {
        position: "relative",
        width: "100%",
        fontSize: token2.fontSize,
        marginInlineEnd: token2.marginXS,
        marginBottom: token2.marginXS
      },
      [`${progressCls}-outer`]: {
        display: "inline-block",
        width: "100%"
      },
      [`&${progressCls}-show-info`]: {
        [`${progressCls}-outer`]: {
          marginInlineEnd: `calc(-2em - ${token2.marginXS}px)`,
          paddingInlineEnd: `calc(2em + ${token2.paddingXS}px)`
        }
      },
      [`${progressCls}-inner`]: {
        position: "relative",
        display: "inline-block",
        width: "100%",
        overflow: "hidden",
        verticalAlign: "middle",
        backgroundColor: token2.progressRemainingColor,
        borderRadius: token2.progressLineRadius
      },
      [`${progressCls}-inner:not(${progressCls}-circle-gradient)`]: {
        [`${progressCls}-circle-path`]: {
          stroke: token2.colorInfo
        }
      },
      [`${progressCls}-success-bg, ${progressCls}-bg`]: {
        position: "relative",
        backgroundColor: token2.colorInfo,
        borderRadius: token2.progressLineRadius,
        transition: `all ${token2.motionDurationSlow} ${token2.motionEaseInOutCirc}`
      },
      [`${progressCls}-success-bg`]: {
        position: "absolute",
        insetBlockStart: 0,
        insetInlineStart: 0,
        backgroundColor: token2.colorSuccess
      },
      [`${progressCls}-text`]: {
        display: "inline-block",
        width: "2em",
        marginInlineStart: token2.marginXS,
        color: token2.progressInfoTextColor,
        lineHeight: 1,
        whiteSpace: "nowrap",
        textAlign: "start",
        verticalAlign: "middle",
        wordBreak: "normal",
        [iconPrefixCls]: {
          fontSize: token2.fontSize
        }
      },
      [`&${progressCls}-status-active`]: {
        [`${progressCls}-bg::before`]: {
          position: "absolute",
          inset: 0,
          backgroundColor: token2.colorBgContainer,
          borderRadius: token2.progressLineRadius,
          opacity: 0,
          animationName: antProgressActive,
          animationDuration: token2.progressActiveMotionDuration,
          animationTimingFunction: token2.motionEaseOutQuint,
          animationIterationCount: "infinite",
          content: '""'
        }
      },
      [`&${progressCls}-status-exception`]: {
        [`${progressCls}-bg`]: {
          backgroundColor: token2.colorError
        },
        [`${progressCls}-text`]: {
          color: token2.colorError
        }
      },
      [`&${progressCls}-status-exception ${progressCls}-inner:not(${progressCls}-circle-gradient)`]: {
        [`${progressCls}-circle-path`]: {
          stroke: token2.colorError
        }
      },
      [`&${progressCls}-status-success`]: {
        [`${progressCls}-bg`]: {
          backgroundColor: token2.colorSuccess
        },
        [`${progressCls}-text`]: {
          color: token2.colorSuccess
        }
      },
      [`&${progressCls}-status-success ${progressCls}-inner:not(${progressCls}-circle-gradient)`]: {
        [`${progressCls}-circle-path`]: {
          stroke: token2.colorSuccess
        }
      }
    })
  };
};
const genCircleStyle = (token2) => {
  const {
    componentCls: progressCls,
    iconCls: iconPrefixCls
  } = token2;
  return {
    [progressCls]: {
      [`${progressCls}-circle-trail`]: {
        stroke: token2.progressRemainingColor
      },
      [`&${progressCls}-circle ${progressCls}-inner`]: {
        position: "relative",
        lineHeight: 1,
        backgroundColor: "transparent"
      },
      [`&${progressCls}-circle ${progressCls}-text`]: {
        position: "absolute",
        insetBlockStart: "50%",
        insetInlineStart: 0,
        width: "100%",
        margin: 0,
        padding: 0,
        color: token2.colorText,
        lineHeight: 1,
        whiteSpace: "normal",
        textAlign: "center",
        transform: "translateY(-50%)",
        [iconPrefixCls]: {
          fontSize: `${token2.fontSize / token2.fontSizeSM}em`
        }
      },
      [`${progressCls}-circle&-status-exception`]: {
        [`${progressCls}-text`]: {
          color: token2.colorError
        }
      },
      [`${progressCls}-circle&-status-success`]: {
        [`${progressCls}-text`]: {
          color: token2.colorSuccess
        }
      }
    },
    [`${progressCls}-inline-circle`]: {
      lineHeight: 1,
      [`${progressCls}-inner`]: {
        verticalAlign: "bottom"
      }
    }
  };
};
const genStepStyle = (token2) => {
  const {
    componentCls: progressCls
  } = token2;
  return {
    [progressCls]: {
      [`${progressCls}-steps`]: {
        display: "inline-block",
        "&-outer": {
          display: "flex",
          flexDirection: "row",
          alignItems: "center"
        },
        "&-item": {
          flexShrink: 0,
          minWidth: token2.progressStepMinWidth,
          marginInlineEnd: token2.progressStepMarginInlineEnd,
          backgroundColor: token2.progressRemainingColor,
          transition: `all ${token2.motionDurationSlow}`,
          "&-active": {
            backgroundColor: token2.colorInfo
          }
        }
      }
    }
  };
};
const genSmallLine = (token2) => {
  const {
    componentCls: progressCls,
    iconCls: iconPrefixCls
  } = token2;
  return {
    [progressCls]: {
      [`${progressCls}-small&-line, ${progressCls}-small&-line ${progressCls}-text ${iconPrefixCls}`]: {
        fontSize: token2.fontSizeSM
      }
    }
  };
};
const useStyle$a = genComponentStyleHook("Progress", (token2) => {
  const progressStepMarginInlineEnd = token2.marginXXS / 2;
  const progressToken = merge(token2, {
    progressLineRadius: 100,
    progressInfoTextColor: token2.colorText,
    progressDefaultColor: token2.colorInfo,
    progressRemainingColor: token2.colorFillSecondary,
    progressStepMarginInlineEnd,
    progressStepMinWidth: progressStepMarginInlineEnd,
    progressActiveMotionDuration: "2.4s"
  });
  return [genBaseStyle$5(progressToken), genCircleStyle(progressToken), genStepStyle(progressToken), genSmallLine(progressToken)];
});
var __rest$h = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const Progress$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AProgress",
  inheritAttrs: false,
  props: initDefaultProps(progressProps(), {
    type: "line",
    percent: 0,
    showInfo: true,
    // null for different theme definition
    trailColor: null,
    size: "default",
    strokeLinecap: "round"
  }),
  slots: Object,
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const {
      prefixCls,
      direction
    } = useConfigInject("progress", props2);
    const [wrapSSR, hashId] = useStyle$a(prefixCls);
    const strokeColorNotArray = computed(() => Array.isArray(props2.strokeColor) ? props2.strokeColor[0] : props2.strokeColor);
    const percentNumber = computed(() => {
      const {
        percent = 0
      } = props2;
      const successPercent = getSuccessPercent(props2);
      return parseInt(successPercent !== void 0 ? successPercent.toString() : percent.toString(), 10);
    });
    const progressStatus = computed(() => {
      const {
        status
      } = props2;
      if (!progressStatuses.includes(status) && percentNumber.value >= 100) {
        return "success";
      }
      return status || "normal";
    });
    const classString = computed(() => {
      const {
        type: type4,
        showInfo,
        size
      } = props2;
      const pre = prefixCls.value;
      return {
        [pre]: true,
        [`${pre}-inline-circle`]: type4 === "circle" && getSize(size, "circle").width <= 20,
        [`${pre}-${type4 === "dashboard" && "circle" || type4}`]: true,
        [`${pre}-status-${progressStatus.value}`]: true,
        [`${pre}-show-info`]: showInfo,
        [`${pre}-${size}`]: size,
        [`${pre}-rtl`]: direction.value === "rtl",
        [hashId.value]: true
      };
    });
    const strokeColorNotGradient = computed(() => typeof props2.strokeColor === "string" || Array.isArray(props2.strokeColor) ? props2.strokeColor : void 0);
    const renderProcessInfo = () => {
      const {
        showInfo,
        format: format2,
        type: type4,
        percent,
        title
      } = props2;
      const successPercent = getSuccessPercent(props2);
      if (!showInfo) return null;
      let text;
      const textFormatter = format2 || (slots === null || slots === void 0 ? void 0 : slots.format) || ((val) => `${val}%`);
      const isLineType = type4 === "line";
      if (format2 || (slots === null || slots === void 0 ? void 0 : slots.format) || progressStatus.value !== "exception" && progressStatus.value !== "success") {
        text = textFormatter(validProgress(percent), validProgress(successPercent));
      } else if (progressStatus.value === "exception") {
        text = isLineType ? createVNode(CloseCircleFilled, null, null) : createVNode(CloseOutlined, null, null);
      } else if (progressStatus.value === "success") {
        text = isLineType ? createVNode(CheckCircleFilled, null, null) : createVNode(CheckOutlined, null, null);
      }
      return createVNode("span", {
        "class": `${prefixCls.value}-text`,
        "title": title === void 0 && typeof text === "string" ? text : void 0
      }, [text]);
    };
    return () => {
      const {
        type: type4,
        steps,
        title
      } = props2;
      const {
        class: cls
      } = attrs, restAttrs = __rest$h(attrs, ["class"]);
      const progressInfo = renderProcessInfo();
      let progress;
      if (type4 === "line") {
        progress = steps ? createVNode(Steps$1, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
          "strokeColor": strokeColorNotGradient.value,
          "prefixCls": prefixCls.value,
          "steps": steps
        }), {
          default: () => [progressInfo]
        }) : createVNode(Line, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
          "strokeColor": strokeColorNotArray.value,
          "prefixCls": prefixCls.value,
          "direction": direction.value
        }), {
          default: () => [progressInfo]
        });
      } else if (type4 === "circle" || type4 === "dashboard") {
        progress = createVNode(Circle, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
          "prefixCls": prefixCls.value,
          "strokeColor": strokeColorNotArray.value,
          "progressStatus": progressStatus.value
        }), {
          default: () => [progressInfo]
        });
      }
      return wrapSSR(createVNode("div", _objectSpread2$1(_objectSpread2$1({
        "role": "progressbar"
      }, restAttrs), {}, {
        "class": [classString.value, cls],
        "title": title
      }), [progress]));
    };
  }
});
const Progress = withInstall(Progress$1);
const NoFound = () => {
  return createVNode("svg", {
    "width": "252",
    "height": "294"
  }, [createVNode("defs", null, [createVNode("path", {
    "d": "M0 .387h251.772v251.772H0z"
  }, null)]), createVNode("g", {
    "fill": "none",
    "fill-rule": "evenodd"
  }, [createVNode("g", {
    "transform": "translate(0 .012)"
  }, [createVNode("mask", {
    "fill": "#fff"
  }, null), createVNode("path", {
    "d": "M0 127.32v-2.095C0 56.279 55.892.387 124.838.387h2.096c68.946 0 124.838 55.892 124.838 124.838v2.096c0 68.946-55.892 124.838-124.838 124.838h-2.096C55.892 252.16 0 196.267 0 127.321",
    "fill": "#E4EBF7",
    "mask": "url(#b)"
  }, null)]), createVNode("path", {
    "d": "M39.755 130.84a8.276 8.276 0 1 1-16.468-1.66 8.276 8.276 0 0 1 16.468 1.66",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M36.975 134.297l10.482 5.943M48.373 146.508l-12.648 10.788",
    "stroke": "#FFF",
    "stroke-width": "2"
  }, null), createVNode("path", {
    "d": "M39.875 159.352a5.667 5.667 0 1 1-11.277-1.136 5.667 5.667 0 0 1 11.277 1.136M57.588 143.247a5.708 5.708 0 1 1-11.358-1.145 5.708 5.708 0 0 1 11.358 1.145M99.018 26.875l29.82-.014a4.587 4.587 0 1 0-.003-9.175l-29.82.013a4.587 4.587 0 1 0 .003 9.176M110.424 45.211l29.82-.013a4.588 4.588 0 0 0-.004-9.175l-29.82.013a4.587 4.587 0 1 0 .004 9.175",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M112.798 26.861v-.002l15.784-.006a4.588 4.588 0 1 0 .003 9.175l-15.783.007v-.002a4.586 4.586 0 0 0-.004-9.172M184.523 135.668c-.553 5.485-5.447 9.483-10.931 8.93-5.485-.553-9.483-5.448-8.93-10.932.552-5.485 5.447-9.483 10.932-8.93 5.485.553 9.483 5.447 8.93 10.932",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M179.26 141.75l12.64 7.167M193.006 156.477l-15.255 13.011",
    "stroke": "#FFF",
    "stroke-width": "2"
  }, null), createVNode("path", {
    "d": "M184.668 170.057a6.835 6.835 0 1 1-13.6-1.372 6.835 6.835 0 0 1 13.6 1.372M203.34 153.325a6.885 6.885 0 1 1-13.7-1.382 6.885 6.885 0 0 1 13.7 1.382",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M151.931 192.324a2.222 2.222 0 1 1-4.444 0 2.222 2.222 0 0 1 4.444 0zM225.27 116.056a2.222 2.222 0 1 1-4.445 0 2.222 2.222 0 0 1 4.444 0zM216.38 151.08a2.223 2.223 0 1 1-4.446-.001 2.223 2.223 0 0 1 4.446 0zM176.917 107.636a2.223 2.223 0 1 1-4.445 0 2.223 2.223 0 0 1 4.445 0zM195.291 92.165a2.223 2.223 0 1 1-4.445 0 2.223 2.223 0 0 1 4.445 0zM202.058 180.711a2.223 2.223 0 1 1-4.446 0 2.223 2.223 0 0 1 4.446 0z",
    "stroke": "#FFF",
    "stroke-width": "2"
  }, null), createVNode("path", {
    "stroke": "#FFF",
    "stroke-width": "2",
    "d": "M214.404 153.302l-1.912 20.184-10.928 5.99M173.661 174.792l-6.356 9.814h-11.36l-4.508 6.484M174.941 125.168v-15.804M220.824 117.25l-12.84 7.901-15.31-7.902V94.39"
  }, null), createVNode("path", {
    "d": "M166.588 65.936h-3.951a4.756 4.756 0 0 1-4.743-4.742 4.756 4.756 0 0 1 4.743-4.743h3.951a4.756 4.756 0 0 1 4.743 4.743 4.756 4.756 0 0 1-4.743 4.742",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M174.823 30.03c0-16.281 13.198-29.48 29.48-29.48 16.28 0 29.48 13.199 29.48 29.48 0 16.28-13.2 29.48-29.48 29.48-16.282 0-29.48-13.2-29.48-29.48",
    "fill": "#1890FF"
  }, null), createVNode("path", {
    "d": "M205.952 38.387c.5.5.785 1.142.785 1.928s-.286 1.465-.785 1.964c-.572.5-1.214.75-2 .75-.785 0-1.429-.285-1.929-.785-.572-.5-.82-1.143-.82-1.929s.248-1.428.82-1.928c.5-.5 1.144-.75 1.93-.75.785 0 1.462.25 1.999.75m4.285-19.463c1.428 1.249 2.143 2.963 2.143 5.142 0 1.712-.427 3.13-1.219 4.25-.067.096-.137.18-.218.265-.416.429-1.41 1.346-2.956 2.699a5.07 5.07 0 0 0-1.428 1.75 5.207 5.207 0 0 0-.536 2.357v.5h-4.107v-.5c0-1.357.215-2.536.714-3.5.464-.964 1.857-2.464 4.178-4.536l.43-.5c.643-.785.964-1.643.964-2.535 0-1.18-.358-2.108-1-2.785-.678-.68-1.643-1.001-2.858-1.001-1.536 0-2.642.464-3.357 1.43-.37.5-.621 1.135-.76 1.904a1.999 1.999 0 0 1-1.971 1.63h-.004c-1.277 0-2.257-1.183-1.98-2.43.337-1.518 1.02-2.78 2.073-3.784 1.536-1.5 3.607-2.25 6.25-2.25 2.32 0 4.214.607 5.642 1.894",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M52.04 76.131s21.81 5.36 27.307 15.945c5.575 10.74-6.352 9.26-15.73 4.935-10.86-5.008-24.7-11.822-11.577-20.88",
    "fill": "#FFB594"
  }, null), createVNode("path", {
    "d": "M90.483 67.504l-.449 2.893c-.753.49-4.748-2.663-4.748-2.663l-1.645.748-1.346-5.684s6.815-4.589 8.917-5.018c2.452-.501 9.884.94 10.7 2.278 0 0 1.32.486-2.227.69-3.548.203-5.043.447-6.79 3.132-1.747 2.686-2.412 3.624-2.412 3.624",
    "fill": "#FFC6A0"
  }, null), createVNode("path", {
    "d": "M128.055 111.367c-2.627-7.724-6.15-13.18-8.917-15.478-3.5-2.906-9.34-2.225-11.366-4.187-1.27-1.231-3.215-1.197-3.215-1.197s-14.98-3.158-16.828-3.479c-2.37-.41-2.124-.714-6.054-1.405-1.57-1.907-2.917-1.122-2.917-1.122l-7.11-1.383c-.853-1.472-2.423-1.023-2.423-1.023l-2.468-.897c-1.645 9.976-7.74 13.796-7.74 13.796 1.795 1.122 15.703 8.3 15.703 8.3l5.107 37.11s-3.321 5.694 1.346 9.109c0 0 19.883-3.743 34.921-.329 0 0 3.047-2.546.972-8.806.523-3.01 1.394-8.263 1.736-11.622.385.772 2.019 1.918 3.14 3.477 0 0 9.407-7.365 11.052-14.012-.832-.723-1.598-1.585-2.267-2.453-.567-.736-.358-2.056-.765-2.717-.669-1.084-1.804-1.378-1.907-1.682",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M101.09 289.998s4.295 2.041 7.354 1.021c2.821-.94 4.53.668 7.08 1.178 2.55.51 6.874 1.1 11.686-1.26-.103-5.51-6.889-3.98-11.96-6.713-2.563-1.38-3.784-4.722-3.598-8.799h-9.402s-1.392 10.52-1.16 14.573",
    "fill": "#CBD1D1"
  }, null), createVNode("path", {
    "d": "M101.067 289.826s2.428 1.271 6.759.653c3.058-.437 3.712.481 7.423 1.031 3.712.55 10.724-.069 11.823-.894.413 1.1-.343 2.063-.343 2.063s-1.512.603-4.812.824c-2.03.136-5.8.291-7.607-.503-1.787-1.375-5.247-1.903-5.728-.241-3.918.95-7.355-.286-7.355-.286l-.16-2.647z",
    "fill": "#2B0849"
  }, null), createVNode("path", {
    "d": "M108.341 276.044h3.094s-.103 6.702 4.536 8.558c-4.64.618-8.558-2.303-7.63-8.558",
    "fill": "#A4AABA"
  }, null), createVNode("path", {
    "d": "M57.542 272.401s-2.107 7.416-4.485 12.306c-1.798 3.695-4.225 7.492 5.465 7.492 6.648 0 8.953-.48 7.423-6.599-1.53-6.12.266-13.199.266-13.199h-8.669z",
    "fill": "#CBD1D1"
  }, null), createVNode("path", {
    "d": "M51.476 289.793s2.097 1.169 6.633 1.169c6.083 0 8.249-1.65 8.249-1.65s.602 1.114-.619 2.165c-.993.855-3.597 1.591-7.39 1.546-4.145-.048-5.832-.566-6.736-1.168-.825-.55-.687-1.58-.137-2.062",
    "fill": "#2B0849"
  }, null), createVNode("path", {
    "d": "M58.419 274.304s.033 1.519-.314 2.93c-.349 1.42-1.078 3.104-1.13 4.139-.058 1.151 4.537 1.58 5.155.034.62-1.547 1.294-6.427 1.913-7.252.619-.825-4.903-2.119-5.624.15",
    "fill": "#A4AABA"
  }, null), createVNode("path", {
    "d": "M99.66 278.514l13.378.092s1.298-54.52 1.853-64.403c.554-9.882 3.776-43.364 1.002-63.128l-12.547-.644-22.849.78s-.434 3.966-1.195 9.976c-.063.496-.682.843-.749 1.365-.075.585.423 1.354.32 1.966-2.364 14.08-6.377 33.104-8.744 46.677-.116.666-1.234 1.009-1.458 2.691-.04.302.211 1.525.112 1.795-6.873 18.744-10.949 47.842-14.277 61.885l14.607-.014s2.197-8.57 4.03-16.97c2.811-12.886 23.111-85.01 23.111-85.01l3.016-.521 1.043 46.35s-.224 1.234.337 2.02c.56.785-.56 1.123-.392 2.244l.392 1.794s-.449 7.178-.898 11.89c-.448 4.71-.092 39.165-.092 39.165",
    "fill": "#7BB2F9"
  }, null), createVNode("path", {
    "d": "M76.085 221.626c1.153.094 4.038-2.019 6.955-4.935M106.36 225.142s2.774-1.11 6.103-3.883",
    "stroke": "#648BD8",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M107.275 222.1s2.773-1.11 6.102-3.884",
    "stroke": "#648BD8",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M74.74 224.767s2.622-.591 6.505-3.365M86.03 151.634c-.27 3.106.3 8.525-4.336 9.123M103.625 149.88s.11 14.012-1.293 15.065c-2.219 1.664-2.99 1.944-2.99 1.944M99.79 150.438s.035 12.88-1.196 24.377M93.673 175.911s7.212-1.664 9.431-1.664M74.31 205.861a212.013 212.013 0 0 1-.979 4.56s-1.458 1.832-1.009 3.776c.449 1.944-.947 2.045-4.985 15.355-1.696 5.59-4.49 18.591-6.348 27.597l-.231 1.12M75.689 197.807a320.934 320.934 0 0 1-.882 4.754M82.591 152.233L81.395 162.7s-1.097.15-.5 2.244c.113 1.346-2.674 15.775-5.18 30.43M56.12 274.418h13.31",
    "stroke": "#648BD8",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M116.241 148.22s-17.047-3.104-35.893.2c.158 2.514-.003 4.15-.003 4.15s14.687-2.818 35.67-.312c.252-2.355.226-4.038.226-4.038",
    "fill": "#192064"
  }, null), createVNode("path", {
    "d": "M106.322 151.165l.003-4.911a.81.81 0 0 0-.778-.815c-2.44-.091-5.066-.108-7.836-.014a.818.818 0 0 0-.789.815l-.003 4.906a.81.81 0 0 0 .831.813c2.385-.06 4.973-.064 7.73.017a.815.815 0 0 0 .842-.81",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M105.207 150.233l.002-3.076a.642.642 0 0 0-.619-.646 94.321 94.321 0 0 0-5.866-.01.65.65 0 0 0-.63.647v3.072a.64.64 0 0 0 .654.644 121.12 121.12 0 0 1 5.794.011c.362.01.665-.28.665-.642",
    "fill": "#192064"
  }, null), createVNode("path", {
    "d": "M100.263 275.415h12.338M101.436 270.53c.006 3.387.042 5.79.111 6.506M101.451 264.548a915.75 915.75 0 0 0-.015 4.337M100.986 174.965l.898 44.642s.673 1.57-.225 2.692c-.897 1.122 2.468.673.898 2.243-1.57 1.57.897 1.122 0 3.365-.596 1.489-.994 21.1-1.096 35.146",
    "stroke": "#648BD8",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M46.876 83.427s-.516 6.045 7.223 5.552c11.2-.712 9.218-9.345 31.54-21.655-.786-2.708-2.447-4.744-2.447-4.744s-11.068 3.11-22.584 8.046c-6.766 2.9-13.395 6.352-13.732 12.801M104.46 91.057l.941-5.372-8.884-11.43-5.037 5.372-1.74 7.834a.321.321 0 0 0 .108.32c.965.8 6.5 5.013 14.347 3.544a.332.332 0 0 0 .264-.268",
    "fill": "#FFC6A0"
  }, null), createVNode("path", {
    "d": "M93.942 79.387s-4.533-2.853-2.432-6.855c1.623-3.09 4.513 1.133 4.513 1.133s.52-3.642 3.121-3.642c.52-1.04 1.561-4.162 1.561-4.162s11.445 2.601 13.526 3.121c0 5.203-2.304 19.424-7.84 19.861-8.892.703-12.449-9.456-12.449-9.456",
    "fill": "#FFC6A0"
  }, null), createVNode("path", {
    "d": "M113.874 73.446c2.601-2.081 3.47-9.722 3.47-9.722s-2.479-.49-6.64-2.05c-4.683-2.081-12.798-4.747-17.48.976-9.668 3.223-2.05 19.823-2.05 19.823l2.713-3.021s-3.935-3.287-2.08-6.243c2.17-3.462 3.92 1.073 3.92 1.073s.637-2.387 3.581-3.342c.355-.71 1.036-2.674 1.432-3.85a1.073 1.073 0 0 1 1.263-.704c2.4.558 8.677 2.019 11.356 2.662.522.125.871.615.82 1.15l-.305 3.248z",
    "fill": "#520038"
  }, null), createVNode("path", {
    "d": "M104.977 76.064c-.103.61-.582 1.038-1.07.956-.489-.083-.801-.644-.698-1.254.103-.61.582-1.038 1.07-.956.488.082.8.644.698 1.254M112.132 77.694c-.103.61-.582 1.038-1.07.956-.488-.083-.8-.644-.698-1.254.103-.61.582-1.038 1.07-.956.488.082.8.643.698 1.254",
    "fill": "#552950"
  }, null), createVNode("path", {
    "stroke": "#DB836E",
    "stroke-width": "1.118",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "d": "M110.13 74.84l-.896 1.61-.298 4.357h-2.228"
  }, null), createVNode("path", {
    "d": "M110.846 74.481s1.79-.716 2.506.537",
    "stroke": "#5C2552",
    "stroke-width": "1.118",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M92.386 74.282s.477-1.114 1.113-.716c.637.398 1.274 1.433.558 1.99-.717.556.159 1.67.159 1.67",
    "stroke": "#DB836E",
    "stroke-width": "1.118",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M103.287 72.93s1.83 1.113 4.137.954",
    "stroke": "#5C2552",
    "stroke-width": "1.118",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M103.685 81.762s2.227 1.193 4.376 1.193M104.64 84.308s.954.398 1.511.318M94.693 81.205s2.308 7.4 10.424 7.639",
    "stroke": "#DB836E",
    "stroke-width": "1.118",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M81.45 89.384s.45 5.647-4.935 12.787M69 82.654s-.726 9.282-8.204 14.206",
    "stroke": "#E4EBF7",
    "stroke-width": "1.101",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M129.405 122.865s-5.272 7.403-9.422 10.768",
    "stroke": "#E4EBF7",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M119.306 107.329s.452 4.366-2.127 32.062",
    "stroke": "#E4EBF7",
    "stroke-width": "1.101",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M150.028 151.232h-49.837a1.01 1.01 0 0 1-1.01-1.01v-31.688c0-.557.452-1.01 1.01-1.01h49.837c.558 0 1.01.453 1.01 1.01v31.688a1.01 1.01 0 0 1-1.01 1.01",
    "fill": "#F2D7AD"
  }, null), createVNode("path", {
    "d": "M150.29 151.232h-19.863v-33.707h20.784v32.786a.92.92 0 0 1-.92.92",
    "fill": "#F4D19D"
  }, null), createVNode("path", {
    "d": "M123.554 127.896H92.917a.518.518 0 0 1-.425-.816l6.38-9.113c.193-.277.51-.442.85-.442h31.092l-7.26 10.371z",
    "fill": "#F2D7AD"
  }, null), createVNode("path", {
    "fill": "#CC9B6E",
    "d": "M123.689 128.447H99.25v-.519h24.169l7.183-10.26.424.298z"
  }, null), createVNode("path", {
    "d": "M158.298 127.896h-18.669a2.073 2.073 0 0 1-1.659-.83l-7.156-9.541h19.965c.49 0 .95.23 1.244.622l6.69 8.92a.519.519 0 0 1-.415.83",
    "fill": "#F4D19D"
  }, null), createVNode("path", {
    "fill": "#CC9B6E",
    "d": "M157.847 128.479h-19.384l-7.857-10.475.415-.31 7.7 10.266h19.126zM130.554 150.685l-.032-8.177.519-.002.032 8.177z"
  }, null), createVNode("path", {
    "fill": "#CC9B6E",
    "d": "M130.511 139.783l-.08-21.414.519-.002.08 21.414zM111.876 140.932l-.498-.143 1.479-5.167.498.143zM108.437 141.06l-2.679-2.935 2.665-3.434.41.318-2.397 3.089 2.384 2.612zM116.607 141.06l-.383-.35 2.383-2.612-2.397-3.089.41-.318 2.665 3.434z"
  }, null), createVNode("path", {
    "d": "M154.316 131.892l-3.114-1.96.038 3.514-1.043.092c-1.682.115-3.634.23-4.789.23-1.902 0-2.693 2.258 2.23 2.648l-2.645-.596s-2.168 1.317.504 2.3c0 0-1.58 1.217.561 2.58-.584 3.504 5.247 4.058 7.122 3.59 1.876-.47 4.233-2.359 4.487-5.16.28-3.085-.89-5.432-3.35-7.238",
    "fill": "#FFC6A0"
  }, null), createVNode("path", {
    "d": "M153.686 133.577s-6.522.47-8.36.372c-1.836-.098-1.904 2.19 2.359 2.264 3.739.15 5.451-.044 5.451-.044",
    "stroke": "#DB836E",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M145.16 135.877c-1.85 1.346.561 2.355.561 2.355s3.478.898 6.73.617",
    "stroke": "#DB836E",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M151.89 141.71s-6.28.111-6.73-2.132c-.223-1.346.45-1.402.45-1.402M146.114 140.868s-1.103 3.16 5.44 3.533M151.202 129.932v3.477M52.838 89.286c3.533-.337 8.423-1.248 13.582-7.754",
    "stroke": "#DB836E",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M168.567 248.318a6.647 6.647 0 0 1-6.647-6.647v-66.466a6.647 6.647 0 1 1 13.294 0v66.466a6.647 6.647 0 0 1-6.647 6.647",
    "fill": "#5BA02E"
  }, null), createVNode("path", {
    "d": "M176.543 247.653a6.647 6.647 0 0 1-6.646-6.647v-33.232a6.647 6.647 0 1 1 13.293 0v33.232a6.647 6.647 0 0 1-6.647 6.647",
    "fill": "#92C110"
  }, null), createVNode("path", {
    "d": "M186.443 293.613H158.92a3.187 3.187 0 0 1-3.187-3.187v-46.134a3.187 3.187 0 0 1 3.187-3.187h27.524a3.187 3.187 0 0 1 3.187 3.187v46.134a3.187 3.187 0 0 1-3.187 3.187",
    "fill": "#F2D7AD"
  }, null), createVNode("path", {
    "d": "M88.979 89.48s7.776 5.384 16.6 2.842",
    "stroke": "#E4EBF7",
    "stroke-width": "1.101",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null)])]);
};
const ServerError = () => {
  return createVNode("svg", {
    "width": "254",
    "height": "294"
  }, [createVNode("defs", null, [createVNode("path", {
    "d": "M0 .335h253.49v253.49H0z"
  }, null), createVNode("path", {
    "d": "M0 293.665h253.49V.401H0z"
  }, null)]), createVNode("g", {
    "fill": "none",
    "fill-rule": "evenodd"
  }, [createVNode("g", {
    "transform": "translate(0 .067)"
  }, [createVNode("mask", {
    "fill": "#fff"
  }, null), createVNode("path", {
    "d": "M0 128.134v-2.11C0 56.608 56.273.334 125.69.334h2.11c69.416 0 125.69 56.274 125.69 125.69v2.11c0 69.417-56.274 125.69-125.69 125.69h-2.11C56.273 253.824 0 197.551 0 128.134",
    "fill": "#E4EBF7",
    "mask": "url(#b)"
  }, null)]), createVNode("path", {
    "d": "M39.989 132.108a8.332 8.332 0 1 1-16.581-1.671 8.332 8.332 0 0 1 16.58 1.671",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M37.19 135.59l10.553 5.983M48.665 147.884l-12.734 10.861",
    "stroke": "#FFF",
    "stroke-width": "2"
  }, null), createVNode("path", {
    "d": "M40.11 160.816a5.706 5.706 0 1 1-11.354-1.145 5.706 5.706 0 0 1 11.354 1.145M57.943 144.6a5.747 5.747 0 1 1-11.436-1.152 5.747 5.747 0 0 1 11.436 1.153M99.656 27.434l30.024-.013a4.619 4.619 0 1 0-.004-9.238l-30.024.013a4.62 4.62 0 0 0 .004 9.238M111.14 45.896l30.023-.013a4.62 4.62 0 1 0-.004-9.238l-30.024.013a4.619 4.619 0 1 0 .004 9.238",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M113.53 27.421v-.002l15.89-.007a4.619 4.619 0 1 0 .005 9.238l-15.892.007v-.002a4.618 4.618 0 0 0-.004-9.234M150.167 70.091h-3.979a4.789 4.789 0 0 1-4.774-4.775 4.788 4.788 0 0 1 4.774-4.774h3.979a4.789 4.789 0 0 1 4.775 4.774 4.789 4.789 0 0 1-4.775 4.775",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M171.687 30.234c0-16.392 13.289-29.68 29.681-29.68 16.392 0 29.68 13.288 29.68 29.68 0 16.393-13.288 29.681-29.68 29.681s-29.68-13.288-29.68-29.68",
    "fill": "#FF603B"
  }, null), createVNode("path", {
    "d": "M203.557 19.435l-.676 15.035a1.514 1.514 0 0 1-3.026 0l-.675-15.035a2.19 2.19 0 1 1 4.377 0m-.264 19.378c.513.477.77 1.1.77 1.87s-.257 1.393-.77 1.907c-.55.476-1.21.733-1.943.733a2.545 2.545 0 0 1-1.87-.77c-.55-.514-.806-1.136-.806-1.87 0-.77.256-1.393.806-1.87.513-.513 1.137-.733 1.87-.733.77 0 1.43.22 1.943.733",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M119.3 133.275c4.426-.598 3.612-1.204 4.079-4.778.675-5.18-3.108-16.935-8.262-25.118-1.088-10.72-12.598-11.24-12.598-11.24s4.312 4.895 4.196 16.199c1.398 5.243.804 14.45.804 14.45s5.255 11.369 11.78 10.487",
    "fill": "#FFB594"
  }, null), createVNode("path", {
    "d": "M100.944 91.61s1.463-.583 3.211.582c8.08 1.398 10.368 6.706 11.3 11.368 1.864 1.282 1.864 2.33 1.864 3.496.365.777 1.515 3.03 1.515 3.03s-7.225 1.748-10.954 6.758c-1.399-6.41-6.936-25.235-6.936-25.235",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M94.008 90.5l1.019-5.815-9.23-11.874-5.233 5.581-2.593 9.863s8.39 5.128 16.037 2.246",
    "fill": "#FFB594"
  }, null), createVNode("path", {
    "d": "M82.931 78.216s-4.557-2.868-2.445-6.892c1.632-3.107 4.537 1.139 4.537 1.139s.524-3.662 3.139-3.662c.523-1.046 1.569-4.184 1.569-4.184s11.507 2.615 13.6 3.138c-.001 5.23-2.317 19.529-7.884 19.969-8.94.706-12.516-9.508-12.516-9.508",
    "fill": "#FFC6A0"
  }, null), createVNode("path", {
    "d": "M102.971 72.243c2.616-2.093 3.489-9.775 3.489-9.775s-2.492-.492-6.676-2.062c-4.708-2.092-12.867-4.771-17.575.982-9.54 4.41-2.062 19.93-2.062 19.93l2.729-3.037s-3.956-3.304-2.092-6.277c2.183-3.48 3.943 1.08 3.943 1.08s.64-2.4 3.6-3.36c.356-.714 1.04-2.69 1.44-3.872a1.08 1.08 0 0 1 1.27-.707c2.41.56 8.723 2.03 11.417 2.676.524.126.876.619.825 1.156l-.308 3.266z",
    "fill": "#520038"
  }, null), createVNode("path", {
    "d": "M101.22 76.514c-.104.613-.585 1.044-1.076.96-.49-.082-.805-.646-.702-1.26.104-.613.585-1.044 1.076-.961.491.083.805.647.702 1.26M94.26 75.074c-.104.613-.585 1.044-1.076.96-.49-.082-.805-.646-.702-1.26.104-.613.585-1.044 1.076-.96.491.082.805.646.702 1.26",
    "fill": "#552950"
  }, null), createVNode("path", {
    "stroke": "#DB836E",
    "stroke-width": "1.063",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "d": "M99.206 73.644l-.9 1.62-.3 4.38h-2.24"
  }, null), createVNode("path", {
    "d": "M99.926 73.284s1.8-.72 2.52.54",
    "stroke": "#5C2552",
    "stroke-width": "1.117",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M81.367 73.084s.48-1.12 1.12-.72c.64.4 1.28 1.44.56 2s.16 1.68.16 1.68",
    "stroke": "#DB836E",
    "stroke-width": "1.117",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M92.326 71.724s1.84 1.12 4.16.96",
    "stroke": "#5C2552",
    "stroke-width": "1.117",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M92.726 80.604s2.24 1.2 4.4 1.2M93.686 83.164s.96.4 1.52.32M83.687 80.044s1.786 6.547 9.262 7.954",
    "stroke": "#DB836E",
    "stroke-width": "1.063",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M95.548 91.663s-1.068 2.821-8.298 2.105c-7.23-.717-10.29-5.044-10.29-5.044",
    "stroke": "#E4EBF7",
    "stroke-width": "1.136",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M78.126 87.478s6.526 4.972 16.47 2.486c0 0 9.577 1.02 11.536 5.322 5.36 11.77.543 36.835 0 39.962 3.496 4.055-.466 8.483-.466 8.483-15.624-3.548-35.81-.6-35.81-.6-4.849-3.546-1.223-9.044-1.223-9.044L62.38 110.32c-2.485-15.227.833-19.803 3.549-20.743 3.03-1.049 8.04-1.282 8.04-1.282.496-.058 1.08-.076 1.37-.233 2.36-1.282 2.787-.583 2.787-.583",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M65.828 89.81s-6.875.465-7.59 8.156c-.466 8.857 3.03 10.954 3.03 10.954s6.075 22.102 16.796 22.957c8.39-2.176 4.758-6.702 4.661-11.42-.233-11.304-7.108-16.897-7.108-16.897s-4.212-13.75-9.789-13.75",
    "fill": "#FFC6A0"
  }, null), createVNode("path", {
    "d": "M71.716 124.225s.855 11.264 9.828 6.486c4.765-2.536 7.581-13.828 9.789-22.568 1.456-5.768 2.58-12.197 2.58-12.197l-4.973-1.709s-2.408 5.516-7.769 12.275c-4.335 5.467-9.144 11.11-9.455 17.713",
    "fill": "#FFC6A0"
  }, null), createVNode("path", {
    "d": "M108.463 105.191s1.747 2.724-2.331 30.535c2.376 2.216 1.053 6.012-.233 7.51",
    "stroke": "#E4EBF7",
    "stroke-width": "1.085",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M123.262 131.527s-.427 2.732-11.77 1.981c-15.187-1.006-25.326-3.25-25.326-3.25l.933-5.8s.723.215 9.71-.068c11.887-.373 18.714-6.07 24.964-1.022 4.039 3.263 1.489 8.16 1.489 8.16",
    "fill": "#FFC6A0"
  }, null), createVNode("path", {
    "d": "M70.24 90.974s-5.593-4.739-11.054 2.68c-3.318 7.223.517 15.284 2.664 19.578-.31 3.729 2.33 4.311 2.33 4.311s.108.895 1.516 2.68c4.078-7.03 6.72-9.166 13.711-12.546-.328-.656-1.877-3.265-1.825-3.767.175-1.69-1.282-2.623-1.282-2.623s-.286-.156-1.165-2.738c-.788-2.313-2.036-5.177-4.895-7.575",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M90.232 288.027s4.855 2.308 8.313 1.155c3.188-1.063 5.12.755 8.002 1.331 2.881.577 7.769 1.243 13.207-1.424-.117-6.228-7.786-4.499-13.518-7.588-2.895-1.56-4.276-5.336-4.066-9.944H91.544s-1.573 11.89-1.312 16.47",
    "fill": "#CBD1D1"
  }, null), createVNode("path", {
    "d": "M90.207 287.833s2.745 1.437 7.639.738c3.456-.494 3.223.66 7.418 1.282 4.195.621 13.092-.194 14.334-1.126.466 1.242-.388 2.33-.388 2.33s-1.709.682-5.438.932c-2.295.154-8.098.276-10.14-.621-2.02-1.554-4.894-1.515-6.06-.234-4.427 1.075-7.184-.31-7.184-.31l-.181-2.991z",
    "fill": "#2B0849"
  }, null), createVNode("path", {
    "d": "M98.429 272.257h3.496s-.117 7.574 5.127 9.671c-5.244.7-9.672-2.602-8.623-9.671",
    "fill": "#A4AABA"
  }, null), createVNode("path", {
    "d": "M44.425 272.046s-2.208 7.774-4.702 12.899c-1.884 3.874-4.428 7.854 5.729 7.854 6.97 0 9.385-.503 7.782-6.917-1.604-6.415.279-13.836.279-13.836h-9.088z",
    "fill": "#CBD1D1"
  }, null), createVNode("path", {
    "d": "M38.066 290.277s2.198 1.225 6.954 1.225c6.376 0 8.646-1.73 8.646-1.73s.63 1.168-.649 2.27c-1.04.897-3.77 1.668-7.745 1.621-4.347-.05-6.115-.593-7.062-1.224-.864-.577-.72-1.657-.144-2.162",
    "fill": "#2B0849"
  }, null), createVNode("path", {
    "d": "M45.344 274.041s.035 1.592-.329 3.07c-.365 1.49-1.13 3.255-1.184 4.34-.061 1.206 4.755 1.657 5.403.036.65-1.622 1.357-6.737 2.006-7.602.648-.865-5.14-2.222-5.896.156",
    "fill": "#A4AABA"
  }, null), createVNode("path", {
    "d": "M89.476 277.57l13.899.095s1.349-56.643 1.925-66.909c.576-10.267 3.923-45.052 1.042-65.585l-13.037-.669-23.737.81s-.452 4.12-1.243 10.365c-.065.515-.708.874-.777 1.417-.078.608.439 1.407.332 2.044-2.455 14.627-5.797 32.736-8.256 46.837-.121.693-1.282 1.048-1.515 2.796-.042.314.22 1.584.116 1.865-7.14 19.473-12.202 52.601-15.66 67.19l15.176-.015s2.282-10.145 4.185-18.871c2.922-13.389 24.012-88.32 24.012-88.32l3.133-.954-.158 48.568s-.233 1.282.35 2.098c.583.815-.581 1.167-.408 2.331l.408 1.864s-.466 7.458-.932 12.352c-.467 4.895 1.145 40.69 1.145 40.69",
    "fill": "#7BB2F9"
  }, null), createVNode("path", {
    "d": "M64.57 218.881c1.197.099 4.195-2.097 7.225-5.127M96.024 222.534s2.881-1.152 6.34-4.034",
    "stroke": "#648BD8",
    "stroke-width": "1.085",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M96.973 219.373s2.882-1.153 6.34-4.034",
    "stroke": "#648BD8",
    "stroke-width": "1.032",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M63.172 222.144s2.724-.614 6.759-3.496M74.903 146.166c-.281 3.226.31 8.856-4.506 9.478M93.182 144.344s.115 14.557-1.344 15.65c-2.305 1.73-3.107 2.02-3.107 2.02M89.197 144.923s.269 13.144-1.01 25.088M83.525 170.71s6.81-1.051 9.116-1.051M46.026 270.045l-.892 4.538M46.937 263.289l-.815 4.157M62.725 202.503c-.33 1.618-.102 1.904-.449 3.438 0 0-2.756 1.903-2.29 3.923.466 2.02-.31 3.424-4.505 17.252-1.762 5.807-4.233 18.922-6.165 28.278-.03.144-.521 2.646-1.14 5.8M64.158 194.136c-.295 1.658-.6 3.31-.917 4.938M71.33 146.787l-1.244 10.877s-1.14.155-.519 2.33c.117 1.399-2.778 16.39-5.382 31.615M44.242 273.727H58.07",
    "stroke": "#648BD8",
    "stroke-width": "1.085",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M106.18 142.117c-3.028-.489-18.825-2.744-36.219.2a.625.625 0 0 0-.518.644c.063 1.307.044 2.343.015 2.995a.617.617 0 0 0 .716.636c3.303-.534 17.037-2.412 35.664-.266.347.04.66-.214.692-.56.124-1.347.16-2.425.17-3.029a.616.616 0 0 0-.52-.62",
    "fill": "#192064"
  }, null), createVNode("path", {
    "d": "M96.398 145.264l.003-5.102a.843.843 0 0 0-.809-.847 114.104 114.104 0 0 0-8.141-.014.85.85 0 0 0-.82.847l-.003 5.097c0 .476.388.857.864.845 2.478-.064 5.166-.067 8.03.017a.848.848 0 0 0 .876-.843",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M95.239 144.296l.002-3.195a.667.667 0 0 0-.643-.672c-1.9-.061-3.941-.073-6.094-.01a.675.675 0 0 0-.654.672l-.002 3.192c0 .376.305.677.68.669 1.859-.042 3.874-.043 6.02.012.376.01.69-.291.691-.668",
    "fill": "#192064"
  }, null), createVNode("path", {
    "d": "M90.102 273.522h12.819M91.216 269.761c.006 3.519-.072 5.55 0 6.292M90.923 263.474c-.009 1.599-.016 2.558-.016 4.505M90.44 170.404l.932 46.38s.7 1.631-.233 2.796c-.932 1.166 2.564.7.932 2.33-1.63 1.633.933 1.166 0 3.497-.618 1.546-1.031 21.921-1.138 36.513",
    "stroke": "#648BD8",
    "stroke-width": "1.085",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M73.736 98.665l2.214 4.312s2.098.816 1.865 2.68l.816 2.214M64.297 116.611c.233-.932 2.176-7.147 12.585-10.488M77.598 90.042s7.691 6.137 16.547 2.72",
    "stroke": "#E4EBF7",
    "stroke-width": "1.085",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M91.974 86.954s5.476-.816 7.574-4.545c1.297-.345.72 2.212-.33 3.671-.7.971-1.01 1.554-1.01 1.554s.194.31.155.816c-.053.697-.175.653-.272 1.048-.081.335.108.657 0 1.049-.046.17-.198.5-.382.878-.12.249-.072.687-.2.948-.231.469-1.562 1.87-2.622 2.855-3.826 3.554-5.018 1.644-6.001-.408-.894-1.865-.661-5.127-.874-6.875-.35-2.914-2.622-3.03-1.923-4.429.343-.685 2.87.69 3.263 1.748.757 2.04 2.952 1.807 2.622 1.69",
    "fill": "#FFC6A0"
  }, null), createVNode("path", {
    "d": "M99.8 82.429c-.465.077-.35.272-.97 1.243-.622.971-4.817 2.932-6.39 3.224-2.589.48-2.278-1.56-4.254-2.855-1.69-1.107-3.562-.638-1.398 1.398.99.932.932 1.107 1.398 3.205.335 1.506-.64 3.67.7 5.593",
    "stroke": "#DB836E",
    "stroke-width": ".774",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M79.543 108.673c-2.1 2.926-4.266 6.175-5.557 8.762",
    "stroke": "#E59788",
    "stroke-width": ".774",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M87.72 124.768s-2.098-1.942-5.127-2.719c-3.03-.777-3.574-.155-5.516.078-1.942.233-3.885-.932-3.652.7.233 1.63 5.05 1.01 5.206 2.097.155 1.087-6.37 2.796-8.313 2.175-.777.777.466 1.864 2.02 2.175.233 1.554 2.253 1.554 2.253 1.554s.699 1.01 2.641 1.088c2.486 1.32 8.934-.7 10.954-1.554 2.02-.855-.466-5.594-.466-5.594",
    "fill": "#FFC6A0"
  }, null), createVNode("path", {
    "d": "M73.425 122.826s.66 1.127 3.167 1.418c2.315.27 2.563.583 2.563.583s-2.545 2.894-9.07 2.272M72.416 129.274s3.826.097 4.933-.718M74.98 130.75s1.961.136 3.36-.505M77.232 131.916s1.748.019 2.914-.505M73.328 122.321s-.595-1.032 1.262-.427c1.671.544 2.833.055 5.128.155 1.389.061 3.067-.297 3.982.15 1.606.784 3.632 2.181 3.632 2.181s10.526 1.204 19.033-1.127M78.864 108.104s-8.39 2.758-13.168 12.12",
    "stroke": "#E59788",
    "stroke-width": ".774",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M109.278 112.533s3.38-3.613 7.575-4.662",
    "stroke": "#E4EBF7",
    "stroke-width": "1.085",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M107.375 123.006s9.697-2.745 11.445-.88",
    "stroke": "#E59788",
    "stroke-width": ".774",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M194.605 83.656l3.971-3.886M187.166 90.933l3.736-3.655M191.752 84.207l-4.462-4.56M198.453 91.057l-4.133-4.225M129.256 163.074l3.718-3.718M122.291 170.039l3.498-3.498M126.561 163.626l-4.27-4.27M132.975 170.039l-3.955-3.955",
    "stroke": "#BFCDDD",
    "stroke-width": "2",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M190.156 211.779h-1.604a4.023 4.023 0 0 1-4.011-4.011V175.68a4.023 4.023 0 0 1 4.01-4.01h1.605a4.023 4.023 0 0 1 4.011 4.01v32.088a4.023 4.023 0 0 1-4.01 4.01",
    "fill": "#A3B4C6"
  }, null), createVNode("path", {
    "d": "M237.824 212.977a4.813 4.813 0 0 1-4.813 4.813h-86.636a4.813 4.813 0 0 1 0-9.626h86.636a4.813 4.813 0 0 1 4.813 4.813",
    "fill": "#A3B4C6"
  }, null), createVNode("mask", {
    "fill": "#fff"
  }, null), createVNode("path", {
    "fill": "#A3B4C6",
    "mask": "url(#d)",
    "d": "M154.098 190.096h70.513v-84.617h-70.513z"
  }, null), createVNode("path", {
    "d": "M224.928 190.096H153.78a3.219 3.219 0 0 1-3.208-3.209V167.92a3.219 3.219 0 0 1 3.208-3.21h71.148a3.219 3.219 0 0 1 3.209 3.21v18.967a3.219 3.219 0 0 1-3.21 3.209M224.928 130.832H153.78a3.218 3.218 0 0 1-3.208-3.208v-18.968a3.219 3.219 0 0 1 3.208-3.209h71.148a3.219 3.219 0 0 1 3.209 3.21v18.967a3.218 3.218 0 0 1-3.21 3.208",
    "fill": "#BFCDDD",
    "mask": "url(#d)"
  }, null), createVNode("path", {
    "d": "M159.563 120.546a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M166.98 120.546a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M174.397 120.546a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M222.539 120.546h-22.461a.802.802 0 0 1-.802-.802v-3.208c0-.443.359-.803.802-.803h22.46c.444 0 .803.36.803.803v3.208c0 .443-.36.802-.802.802",
    "fill": "#FFF",
    "mask": "url(#d)"
  }, null), createVNode("path", {
    "d": "M224.928 160.464H153.78a3.218 3.218 0 0 1-3.208-3.209v-18.967a3.219 3.219 0 0 1 3.208-3.209h71.148a3.219 3.219 0 0 1 3.209 3.209v18.967a3.218 3.218 0 0 1-3.21 3.209",
    "fill": "#BFCDDD",
    "mask": "url(#d)"
  }, null), createVNode("path", {
    "d": "M173.455 130.832h49.301M164.984 130.832h6.089M155.952 130.832h6.75M173.837 160.613h49.3M165.365 160.613h6.089M155.57 160.613h6.751",
    "stroke": "#7C90A5",
    "stroke-width": "1.124",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "mask": "url(#d)"
  }, null), createVNode("path", {
    "d": "M159.563 151.038a2.407 2.407 0 1 1 0-4.814 2.407 2.407 0 0 1 0 4.814M166.98 151.038a2.407 2.407 0 1 1 0-4.814 2.407 2.407 0 0 1 0 4.814M174.397 151.038a2.407 2.407 0 1 1 .001-4.814 2.407 2.407 0 0 1 0 4.814M222.539 151.038h-22.461a.802.802 0 0 1-.802-.802v-3.209c0-.443.359-.802.802-.802h22.46c.444 0 .803.36.803.802v3.209c0 .443-.36.802-.802.802M159.563 179.987a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M166.98 179.987a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M174.397 179.987a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M222.539 179.987h-22.461a.802.802 0 0 1-.802-.802v-3.209c0-.443.359-.802.802-.802h22.46c.444 0 .803.36.803.802v3.209c0 .443-.36.802-.802.802",
    "fill": "#FFF",
    "mask": "url(#d)"
  }, null), createVNode("path", {
    "d": "M203.04 221.108h-27.372a2.413 2.413 0 0 1-2.406-2.407v-11.448a2.414 2.414 0 0 1 2.406-2.407h27.372a2.414 2.414 0 0 1 2.407 2.407V218.7a2.413 2.413 0 0 1-2.407 2.407",
    "fill": "#BFCDDD",
    "mask": "url(#d)"
  }, null), createVNode("path", {
    "d": "M177.259 207.217v11.52M201.05 207.217v11.52",
    "stroke": "#A3B4C6",
    "stroke-width": "1.124",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "mask": "url(#d)"
  }, null), createVNode("path", {
    "d": "M162.873 267.894a9.422 9.422 0 0 1-9.422-9.422v-14.82a9.423 9.423 0 0 1 18.845 0v14.82a9.423 9.423 0 0 1-9.423 9.422",
    "fill": "#5BA02E",
    "mask": "url(#d)"
  }, null), createVNode("path", {
    "d": "M171.22 267.83a9.422 9.422 0 0 1-9.422-9.423v-3.438a9.423 9.423 0 0 1 18.845 0v3.438a9.423 9.423 0 0 1-9.422 9.423",
    "fill": "#92C110",
    "mask": "url(#d)"
  }, null), createVNode("path", {
    "d": "M181.31 293.666h-27.712a3.209 3.209 0 0 1-3.209-3.21V269.79a3.209 3.209 0 0 1 3.209-3.21h27.711a3.209 3.209 0 0 1 3.209 3.21v20.668a3.209 3.209 0 0 1-3.209 3.209",
    "fill": "#F2D7AD",
    "mask": "url(#d)"
  }, null)])]);
};
const Unauthorized = () => {
  return createVNode("svg", {
    "width": "251",
    "height": "294"
  }, [createVNode("g", {
    "fill": "none",
    "fill-rule": "evenodd"
  }, [createVNode("path", {
    "d": "M0 129.023v-2.084C0 58.364 55.591 2.774 124.165 2.774h2.085c68.574 0 124.165 55.59 124.165 124.165v2.084c0 68.575-55.59 124.166-124.165 124.166h-2.085C55.591 253.189 0 197.598 0 129.023",
    "fill": "#E4EBF7"
  }, null), createVNode("path", {
    "d": "M41.417 132.92a8.231 8.231 0 1 1-16.38-1.65 8.231 8.231 0 0 1 16.38 1.65",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M38.652 136.36l10.425 5.91M49.989 148.505l-12.58 10.73",
    "stroke": "#FFF",
    "stroke-width": "2"
  }, null), createVNode("path", {
    "d": "M41.536 161.28a5.636 5.636 0 1 1-11.216-1.13 5.636 5.636 0 0 1 11.216 1.13M59.154 145.261a5.677 5.677 0 1 1-11.297-1.138 5.677 5.677 0 0 1 11.297 1.138M100.36 29.516l29.66-.013a4.562 4.562 0 1 0-.004-9.126l-29.66.013a4.563 4.563 0 0 0 .005 9.126M111.705 47.754l29.659-.013a4.563 4.563 0 1 0-.004-9.126l-29.66.013a4.563 4.563 0 1 0 .005 9.126",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M114.066 29.503V29.5l15.698-.007a4.563 4.563 0 1 0 .004 9.126l-15.698.007v-.002a4.562 4.562 0 0 0-.004-9.122M185.405 137.723c-.55 5.455-5.418 9.432-10.873 8.882-5.456-.55-9.432-5.418-8.882-10.873.55-5.455 5.418-9.432 10.873-8.882 5.455.55 9.432 5.418 8.882 10.873",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M180.17 143.772l12.572 7.129M193.841 158.42L178.67 171.36",
    "stroke": "#FFF",
    "stroke-width": "2"
  }, null), createVNode("path", {
    "d": "M185.55 171.926a6.798 6.798 0 1 1-13.528-1.363 6.798 6.798 0 0 1 13.527 1.363M204.12 155.285a6.848 6.848 0 1 1-13.627-1.375 6.848 6.848 0 0 1 13.626 1.375",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M152.988 194.074a2.21 2.21 0 1 1-4.42 0 2.21 2.21 0 0 1 4.42 0zM225.931 118.217a2.21 2.21 0 1 1-4.421 0 2.21 2.21 0 0 1 4.421 0zM217.09 153.051a2.21 2.21 0 1 1-4.421 0 2.21 2.21 0 0 1 4.42 0zM177.84 109.842a2.21 2.21 0 1 1-4.422 0 2.21 2.21 0 0 1 4.421 0zM196.114 94.454a2.21 2.21 0 1 1-4.421 0 2.21 2.21 0 0 1 4.421 0zM202.844 182.523a2.21 2.21 0 1 1-4.42 0 2.21 2.21 0 0 1 4.42 0z",
    "stroke": "#FFF",
    "stroke-width": "2"
  }, null), createVNode("path", {
    "stroke": "#FFF",
    "stroke-width": "2",
    "d": "M215.125 155.262l-1.902 20.075-10.87 5.958M174.601 176.636l-6.322 9.761H156.98l-4.484 6.449M175.874 127.28V111.56M221.51 119.404l-12.77 7.859-15.228-7.86V96.668"
  }, null), createVNode("path", {
    "d": "M180.68 29.32C180.68 13.128 193.806 0 210 0c16.193 0 29.32 13.127 29.32 29.32 0 16.194-13.127 29.322-29.32 29.322-16.193 0-29.32-13.128-29.32-29.321",
    "fill": "#A26EF4"
  }, null), createVNode("path", {
    "d": "M221.45 41.706l-21.563-.125a1.744 1.744 0 0 1-1.734-1.754l.071-12.23a1.744 1.744 0 0 1 1.754-1.734l21.562.125c.964.006 1.74.791 1.735 1.755l-.071 12.229a1.744 1.744 0 0 1-1.754 1.734",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M215.106 29.192c-.015 2.577-2.049 4.654-4.543 4.64-2.494-.014-4.504-2.115-4.489-4.693l.04-6.925c.016-2.577 2.05-4.654 4.543-4.64 2.494.015 4.504 2.116 4.49 4.693l-.04 6.925zm-4.53-14.074a6.877 6.877 0 0 0-6.916 6.837l-.043 7.368a6.877 6.877 0 0 0 13.754.08l.042-7.368a6.878 6.878 0 0 0-6.837-6.917zM167.566 68.367h-3.93a4.73 4.73 0 0 1-4.717-4.717 4.73 4.73 0 0 1 4.717-4.717h3.93a4.73 4.73 0 0 1 4.717 4.717 4.73 4.73 0 0 1-4.717 4.717",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M168.214 248.838a6.611 6.611 0 0 1-6.61-6.611v-66.108a6.611 6.611 0 0 1 13.221 0v66.108a6.611 6.611 0 0 1-6.61 6.61",
    "fill": "#5BA02E"
  }, null), createVNode("path", {
    "d": "M176.147 248.176a6.611 6.611 0 0 1-6.61-6.61v-33.054a6.611 6.611 0 1 1 13.221 0v33.053a6.611 6.611 0 0 1-6.61 6.611",
    "fill": "#92C110"
  }, null), createVNode("path", {
    "d": "M185.994 293.89h-27.376a3.17 3.17 0 0 1-3.17-3.17v-45.887a3.17 3.17 0 0 1 3.17-3.17h27.376a3.17 3.17 0 0 1 3.17 3.17v45.886a3.17 3.17 0 0 1-3.17 3.17",
    "fill": "#F2D7AD"
  }, null), createVNode("path", {
    "d": "M81.972 147.673s6.377-.927 17.566-1.28c11.729-.371 17.57 1.086 17.57 1.086s3.697-3.855.968-8.424c1.278-12.077 5.982-32.827.335-48.273-1.116-1.339-3.743-1.512-7.536-.62-1.337.315-7.147-.149-7.983-.1l-15.311-.347s-3.487-.17-8.035-.508c-1.512-.113-4.227-1.683-5.458-.338-.406.443-2.425 5.669-1.97 16.077l8.635 35.642s-3.141 3.61 1.219 7.085",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M75.768 73.325l-.9-6.397 11.982-6.52s7.302-.118 8.038 1.205c.737 1.324-5.616.993-5.616.993s-1.836 1.388-2.615 2.5c-1.654 2.363-.986 6.471-8.318 5.986-1.708.284-2.57 2.233-2.57 2.233",
    "fill": "#FFC6A0"
  }, null), createVNode("path", {
    "d": "M52.44 77.672s14.217 9.406 24.973 14.444c1.061.497-2.094 16.183-11.892 11.811-7.436-3.318-20.162-8.44-21.482-14.496-.71-3.258 2.543-7.643 8.401-11.76M141.862 80.113s-6.693 2.999-13.844 6.876c-3.894 2.11-10.137 4.704-12.33 7.988-6.224 9.314 3.536 11.22 12.947 7.503 6.71-2.651 28.999-12.127 13.227-22.367",
    "fill": "#FFB594"
  }, null), createVNode("path", {
    "d": "M76.166 66.36l3.06 3.881s-2.783 2.67-6.31 5.747c-7.103 6.195-12.803 14.296-15.995 16.44-3.966 2.662-9.754 3.314-12.177-.118-3.553-5.032.464-14.628 31.422-25.95",
    "fill": "#FFC6A0"
  }, null), createVNode("path", {
    "d": "M64.674 85.116s-2.34 8.413-8.912 14.447c.652.548 18.586 10.51 22.144 10.056 5.238-.669 6.417-18.968 1.145-20.531-.702-.208-5.901-1.286-8.853-2.167-.87-.26-1.611-1.71-3.545-.936l-1.98-.869zM128.362 85.826s5.318 1.956 7.325 13.734c-.546.274-17.55 12.35-21.829 7.805-6.534-6.94-.766-17.393 4.275-18.61 4.646-1.121 5.03-1.37 10.23-2.929",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M78.18 94.656s.911 7.41-4.914 13.078",
    "stroke": "#E4EBF7",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M87.397 94.68s3.124 2.572 10.263 2.572c7.14 0 9.074-3.437 9.074-3.437",
    "stroke": "#E4EBF7",
    "stroke-width": ".932",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M117.184 68.639l-6.781-6.177s-5.355-4.314-9.223-.893c-3.867 3.422 4.463 2.083 5.653 4.165 1.19 2.082.848 1.143-2.083.446-5.603-1.331-2.082.893 2.975 5.355 2.091 1.845 6.992.955 6.992.955l2.467-3.851z",
    "fill": "#FFC6A0"
  }, null), createVNode("path", {
    "d": "M105.282 91.315l-.297-10.937-15.918-.027-.53 10.45c-.026.403.17.788.515.999 2.049 1.251 9.387 5.093 15.799.424.287-.21.443-.554.431-.91",
    "fill": "#FFB594"
  }, null), createVNode("path", {
    "d": "M107.573 74.24c.817-1.147.982-9.118 1.015-11.928a1.046 1.046 0 0 0-.965-1.055l-4.62-.365c-7.71-1.044-17.071.624-18.253 6.346-5.482 5.813-.421 13.244-.421 13.244s1.963 3.566 4.305 6.791c.756 1.041.398-3.731 3.04-5.929 5.524-4.594 15.899-7.103 15.899-7.103",
    "fill": "#5C2552"
  }, null), createVNode("path", {
    "d": "M88.426 83.206s2.685 6.202 11.602 6.522c7.82.28 8.973-7.008 7.434-17.505l-.909-5.483c-6.118-2.897-15.478.54-15.478.54s-.576 2.044-.19 5.504c-2.276 2.066-1.824 5.618-1.824 5.618s-.905-1.922-1.98-2.321c-.86-.32-1.897.089-2.322 1.98-1.04 4.632 3.667 5.145 3.667 5.145",
    "fill": "#FFC6A0"
  }, null), createVNode("path", {
    "stroke": "#DB836E",
    "stroke-width": "1.145",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "d": "M100.843 77.099l1.701-.928-1.015-4.324.674-1.406"
  }, null), createVNode("path", {
    "d": "M105.546 74.092c-.022.713-.452 1.279-.96 1.263-.51-.016-.904-.607-.882-1.32.021-.713.452-1.278.96-1.263.51.016.904.607.882 1.32M97.592 74.349c-.022.713-.452 1.278-.961 1.263-.509-.016-.904-.607-.882-1.32.022-.713.452-1.279.961-1.263.51.016.904.606.882 1.32",
    "fill": "#552950"
  }, null), createVNode("path", {
    "d": "M91.132 86.786s5.269 4.957 12.679 2.327",
    "stroke": "#DB836E",
    "stroke-width": "1.145",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M99.776 81.903s-3.592.232-1.44-2.79c1.59-1.496 4.897-.46 4.897-.46s1.156 3.906-3.457 3.25",
    "fill": "#DB836E"
  }, null), createVNode("path", {
    "d": "M102.88 70.6s2.483.84 3.402.715M93.883 71.975s2.492-1.144 4.778-1.073",
    "stroke": "#5C2552",
    "stroke-width": "1.526",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M86.32 77.374s.961.879 1.458 2.106c-.377.48-1.033 1.152-.236 1.809M99.337 83.719s1.911.151 2.509-.254",
    "stroke": "#DB836E",
    "stroke-width": "1.145",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M87.782 115.821l15.73-3.012M100.165 115.821l10.04-2.008",
    "stroke": "#E4EBF7",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M66.508 86.763s-1.598 8.83-6.697 14.078",
    "stroke": "#E4EBF7",
    "stroke-width": "1.114",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M128.31 87.934s3.013 4.121 4.06 11.785",
    "stroke": "#E4EBF7",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M64.09 84.816s-6.03 9.912-13.607 9.903",
    "stroke": "#DB836E",
    "stroke-width": ".795",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M112.366 65.909l-.142 5.32s5.993 4.472 11.945 9.202c4.482 3.562 8.888 7.455 10.985 8.662 4.804 2.766 8.9 3.355 11.076 1.808 4.071-2.894 4.373-9.878-8.136-15.263-4.271-1.838-16.144-6.36-25.728-9.73",
    "fill": "#FFC6A0"
  }, null), createVNode("path", {
    "d": "M130.532 85.488s4.588 5.757 11.619 6.214",
    "stroke": "#DB836E",
    "stroke-width": ".75",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M121.708 105.73s-.393 8.564-1.34 13.612",
    "stroke": "#E4EBF7",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M115.784 161.512s-3.57-1.488-2.678-7.14",
    "stroke": "#648BD8",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M101.52 290.246s4.326 2.057 7.408 1.03c2.842-.948 4.564.673 7.132 1.186 2.57.514 6.925 1.108 11.772-1.269-.104-5.551-6.939-4.01-12.048-6.763-2.582-1.39-3.812-4.757-3.625-8.863h-9.471s-1.402 10.596-1.169 14.68",
    "fill": "#CBD1D1"
  }, null), createVNode("path", {
    "d": "M101.496 290.073s2.447 1.281 6.809.658c3.081-.44 3.74.485 7.479 1.039 3.739.554 10.802-.07 11.91-.9.415 1.108-.347 2.077-.347 2.077s-1.523.608-4.847.831c-2.045.137-5.843.293-7.663-.507-1.8-1.385-5.286-1.917-5.77-.243-3.947.958-7.41-.288-7.41-.288l-.16-2.667z",
    "fill": "#2B0849"
  }, null), createVNode("path", {
    "d": "M108.824 276.19h3.116s-.103 6.751 4.57 8.62c-4.673.624-8.62-2.32-7.686-8.62",
    "fill": "#A4AABA"
  }, null), createVNode("path", {
    "d": "M57.65 272.52s-2.122 7.47-4.518 12.396c-1.811 3.724-4.255 7.548 5.505 7.548 6.698 0 9.02-.483 7.479-6.648-1.541-6.164.268-13.296.268-13.296H57.65z",
    "fill": "#CBD1D1"
  }, null), createVNode("path", {
    "d": "M51.54 290.04s2.111 1.178 6.682 1.178c6.128 0 8.31-1.662 8.31-1.662s.605 1.122-.624 2.18c-1 .862-3.624 1.603-7.444 1.559-4.177-.049-5.876-.57-6.786-1.177-.831-.554-.692-1.593-.138-2.078",
    "fill": "#2B0849"
  }, null), createVNode("path", {
    "d": "M58.533 274.438s.034 1.529-.315 2.95c-.352 1.431-1.087 3.127-1.139 4.17-.058 1.16 4.57 1.592 5.194.035.623-1.559 1.303-6.475 1.927-7.306.622-.831-4.94-2.135-5.667.15",
    "fill": "#A4AABA"
  }, null), createVNode("path", {
    "d": "M100.885 277.015l13.306.092s1.291-54.228 1.843-64.056c.552-9.828 3.756-43.13.997-62.788l-12.48-.64-22.725.776s-.433 3.944-1.19 9.921c-.062.493-.677.838-.744 1.358-.075.582.42 1.347.318 1.956-2.35 14.003-6.343 32.926-8.697 46.425-.116.663-1.227 1.004-1.45 2.677-.04.3.21 1.516.112 1.785-6.836 18.643-10.89 47.584-14.2 61.551l14.528-.014s2.185-8.524 4.008-16.878c2.796-12.817 22.987-84.553 22.987-84.553l3-.517 1.037 46.1s-.223 1.228.334 2.008c.558.782-.556 1.117-.39 2.233l.39 1.784s-.446 7.14-.892 11.826c-.446 4.685-.092 38.954-.092 38.954",
    "fill": "#7BB2F9"
  }, null), createVNode("path", {
    "d": "M77.438 220.434c1.146.094 4.016-2.008 6.916-4.91M107.55 223.931s2.758-1.103 6.069-3.862",
    "stroke": "#648BD8",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M108.459 220.905s2.759-1.104 6.07-3.863",
    "stroke": "#648BD8",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M76.099 223.557s2.608-.587 6.47-3.346M87.33 150.82c-.27 3.088.297 8.478-4.315 9.073M104.829 149.075s.11 13.936-1.286 14.983c-2.207 1.655-2.975 1.934-2.975 1.934M101.014 149.63s.035 12.81-1.19 24.245M94.93 174.965s7.174-1.655 9.38-1.655M75.671 204.754c-.316 1.55-.64 3.067-.973 4.535 0 0-1.45 1.822-1.003 3.756.446 1.934-.943 2.034-4.96 15.273-1.686 5.559-4.464 18.49-6.313 27.447-.078.38-4.018 18.06-4.093 18.423M77.043 196.743a313.269 313.269 0 0 1-.877 4.729M83.908 151.414l-1.19 10.413s-1.091.148-.496 2.23c.111 1.34-2.66 15.692-5.153 30.267M57.58 272.94h13.238",
    "stroke": "#648BD8",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M117.377 147.423s-16.955-3.087-35.7.199c.157 2.501-.002 4.128-.002 4.128s14.607-2.802 35.476-.31c.251-2.342.226-4.017.226-4.017",
    "fill": "#192064"
  }, null), createVNode("path", {
    "d": "M107.511 150.353l.004-4.885a.807.807 0 0 0-.774-.81c-2.428-.092-5.04-.108-7.795-.014a.814.814 0 0 0-.784.81l-.003 4.88c0 .456.371.82.827.808a140.76 140.76 0 0 1 7.688.017.81.81 0 0 0 .837-.806",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M106.402 149.426l.002-3.06a.64.64 0 0 0-.616-.643 94.135 94.135 0 0 0-5.834-.009.647.647 0 0 0-.626.643l-.001 3.056c0 .36.291.648.651.64 1.78-.04 3.708-.041 5.762.012.36.009.662-.279.662-.64",
    "fill": "#192064"
  }, null), createVNode("path", {
    "d": "M101.485 273.933h12.272M102.652 269.075c.006 3.368.04 5.759.11 6.47M102.667 263.125c-.009 1.53-.015 2.98-.016 4.313M102.204 174.024l.893 44.402s.669 1.561-.224 2.677c-.892 1.116 2.455.67.893 2.231-1.562 1.562.893 1.116 0 3.347-.592 1.48-.988 20.987-1.09 34.956",
    "stroke": "#648BD8",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null)])]);
};
const genBaseStyle$4 = (token2) => {
  const {
    componentCls,
    lineHeightHeading3,
    iconCls,
    padding,
    paddingXL,
    paddingXS,
    paddingLG,
    marginXS,
    lineHeight
  } = token2;
  return {
    // Result
    [componentCls]: {
      padding: `${paddingLG * 2}px ${paddingXL}px`,
      // RTL
      "&-rtl": {
        direction: "rtl"
      }
    },
    // Exception Status image
    [`${componentCls} ${componentCls}-image`]: {
      width: token2.imageWidth,
      height: token2.imageHeight,
      margin: "auto"
    },
    [`${componentCls} ${componentCls}-icon`]: {
      marginBottom: paddingLG,
      textAlign: "center",
      [`& > ${iconCls}`]: {
        fontSize: token2.resultIconFontSize
      }
    },
    [`${componentCls} ${componentCls}-title`]: {
      color: token2.colorTextHeading,
      fontSize: token2.resultTitleFontSize,
      lineHeight: lineHeightHeading3,
      marginBlock: marginXS,
      textAlign: "center"
    },
    [`${componentCls} ${componentCls}-subtitle`]: {
      color: token2.colorTextDescription,
      fontSize: token2.resultSubtitleFontSize,
      lineHeight,
      textAlign: "center"
    },
    [`${componentCls} ${componentCls}-content`]: {
      marginTop: paddingLG,
      padding: `${paddingLG}px ${padding * 2.5}px`,
      backgroundColor: token2.colorFillAlter
    },
    [`${componentCls} ${componentCls}-extra`]: {
      margin: token2.resultExtraMargin,
      textAlign: "center",
      "& > *": {
        marginInlineEnd: paddingXS,
        "&:last-child": {
          marginInlineEnd: 0
        }
      }
    }
  };
};
const genStatusIconStyle = (token2) => {
  const {
    componentCls,
    iconCls
  } = token2;
  return {
    [`${componentCls}-success ${componentCls}-icon > ${iconCls}`]: {
      color: token2.resultSuccessIconColor
    },
    [`${componentCls}-error ${componentCls}-icon > ${iconCls}`]: {
      color: token2.resultErrorIconColor
    },
    [`${componentCls}-info ${componentCls}-icon > ${iconCls}`]: {
      color: token2.resultInfoIconColor
    },
    [`${componentCls}-warning ${componentCls}-icon > ${iconCls}`]: {
      color: token2.resultWarningIconColor
    }
  };
};
const genResultStyle = (token2) => [genBaseStyle$4(token2), genStatusIconStyle(token2)];
const getStyle = (token2) => genResultStyle(token2);
const useStyle$9 = genComponentStyleHook("Result", (token2) => {
  const {
    paddingLG,
    fontSizeHeading3
  } = token2;
  const resultSubtitleFontSize = token2.fontSize;
  const resultExtraMargin = `${paddingLG}px 0 0 0`;
  const resultInfoIconColor = token2.colorInfo;
  const resultErrorIconColor = token2.colorError;
  const resultSuccessIconColor = token2.colorSuccess;
  const resultWarningIconColor = token2.colorWarning;
  const resultToken = merge(token2, {
    resultTitleFontSize: fontSizeHeading3,
    resultSubtitleFontSize,
    resultIconFontSize: fontSizeHeading3 * 3,
    resultExtraMargin,
    resultInfoIconColor,
    resultErrorIconColor,
    resultSuccessIconColor,
    resultWarningIconColor
  });
  return [getStyle(resultToken)];
}, {
  imageWidth: 250,
  imageHeight: 295
});
const IconMap = {
  success: CheckCircleFilled,
  error: CloseCircleFilled,
  info: ExclamationCircleFilled,
  warning: WarningFilled
};
const ExceptionMap = {
  "404": NoFound,
  "500": ServerError,
  "403": Unauthorized
};
const ExceptionStatus = Object.keys(ExceptionMap);
const resultProps = () => ({
  prefixCls: String,
  icon: PropTypes.any,
  status: {
    type: [Number, String],
    default: "info"
  },
  title: PropTypes.any,
  subTitle: PropTypes.any,
  extra: PropTypes.any
});
const renderIcon = (prefixCls, _ref) => {
  let {
    status,
    icon
  } = _ref;
  if (ExceptionStatus.includes(`${status}`)) {
    const SVGComponent = ExceptionMap[status];
    return createVNode("div", {
      "class": `${prefixCls}-icon ${prefixCls}-image`
    }, [createVNode(SVGComponent, null, null)]);
  }
  const IconComponent = IconMap[status];
  const iconNode = icon || createVNode(IconComponent, null, null);
  return createVNode("div", {
    "class": `${prefixCls}-icon`
  }, [iconNode]);
};
const renderExtra = (prefixCls, extra) => extra && createVNode("div", {
  "class": `${prefixCls}-extra`
}, [extra]);
const Result = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AResult",
  inheritAttrs: false,
  props: resultProps(),
  slots: Object,
  setup(props2, _ref2) {
    let {
      slots,
      attrs
    } = _ref2;
    const {
      prefixCls,
      direction
    } = useConfigInject("result", props2);
    const [wrapSSR, hashId] = useStyle$9(prefixCls);
    const className = computed(() => classNames(prefixCls.value, hashId.value, `${prefixCls.value}-${props2.status}`, {
      [`${prefixCls.value}-rtl`]: direction.value === "rtl"
    }));
    return () => {
      var _a2, _b, _c, _d, _e, _f, _g, _h;
      const title = (_a2 = props2.title) !== null && _a2 !== void 0 ? _a2 : (_b = slots.title) === null || _b === void 0 ? void 0 : _b.call(slots);
      const subTitle = (_c = props2.subTitle) !== null && _c !== void 0 ? _c : (_d = slots.subTitle) === null || _d === void 0 ? void 0 : _d.call(slots);
      const icon = (_e = props2.icon) !== null && _e !== void 0 ? _e : (_f = slots.icon) === null || _f === void 0 ? void 0 : _f.call(slots);
      const extra = (_g = props2.extra) !== null && _g !== void 0 ? _g : (_h = slots.extra) === null || _h === void 0 ? void 0 : _h.call(slots);
      const pre = prefixCls.value;
      return wrapSSR(createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "class": [className.value, attrs.class]
      }), [renderIcon(pre, {
        status: props2.status,
        icon
      }), createVNode("div", {
        "class": `${pre}-title`
      }, [title]), subTitle && createVNode("div", {
        "class": `${pre}-subtitle`
      }, [subTitle]), renderExtra(pre, extra), slots.default && createVNode("div", {
        "class": `${pre}-content`
      }, [slots.default()])]));
    };
  }
});
Result.PRESENTED_IMAGE_403 = ExceptionMap[403];
Result.PRESENTED_IMAGE_404 = ExceptionMap[404];
Result.PRESENTED_IMAGE_500 = ExceptionMap[500];
Result.install = function(app) {
  app.component(Result.name, Result);
  return app;
};
const Row = withInstall(ARow);
const Track = (_2, _ref) => {
  let {
    attrs
  } = _ref;
  const {
    included,
    vertical,
    style,
    class: className
  } = attrs;
  let {
    length: length2,
    offset: offset3,
    reverse
  } = attrs;
  if (length2 < 0) {
    reverse = !reverse;
    length2 = Math.abs(length2);
    offset3 = 100 - offset3;
  }
  const positionStyle = vertical ? {
    [reverse ? "top" : "bottom"]: `${offset3}%`,
    [reverse ? "bottom" : "top"]: "auto",
    height: `${length2}%`
  } : {
    [reverse ? "right" : "left"]: `${offset3}%`,
    [reverse ? "left" : "right"]: "auto",
    width: `${length2}%`
  };
  const elStyle = _extends$1(_extends$1({}, style), positionStyle);
  return included ? createVNode("div", {
    "class": className,
    "style": elStyle
  }, null) : null;
};
Track.inheritAttrs = false;
const calcPoints = (_vertical, marks, dots, step, min, max) => {
  const points = Object.keys(marks).map(parseFloat).sort((a2, b2) => a2 - b2);
  if (dots && step) {
    for (let i2 = min; i2 <= max; i2 += step) {
      if (points.indexOf(i2) === -1) {
        points.push(i2);
      }
    }
  }
  return points;
};
const Steps = (_2, _ref) => {
  let {
    attrs
  } = _ref;
  const {
    prefixCls,
    vertical,
    reverse,
    marks,
    dots,
    step,
    included,
    lowerBound,
    upperBound,
    max,
    min,
    dotStyle,
    activeDotStyle
  } = attrs;
  const range3 = max - min;
  const elements = calcPoints(vertical, marks, dots, step, min, max).map((point) => {
    const offset3 = `${Math.abs(point - min) / range3 * 100}%`;
    const isActived = !included && point === upperBound || included && point <= upperBound && point >= lowerBound;
    let style = vertical ? _extends$1(_extends$1({}, dotStyle), {
      [reverse ? "top" : "bottom"]: offset3
    }) : _extends$1(_extends$1({}, dotStyle), {
      [reverse ? "right" : "left"]: offset3
    });
    if (isActived) {
      style = _extends$1(_extends$1({}, style), activeDotStyle);
    }
    const pointClassName = classNames({
      [`${prefixCls}-dot`]: true,
      [`${prefixCls}-dot-active`]: isActived,
      [`${prefixCls}-dot-reverse`]: reverse
    });
    return createVNode("span", {
      "class": pointClassName,
      "style": style,
      "key": point
    }, null);
  });
  return createVNode("div", {
    "class": `${prefixCls}-step`
  }, [elements]);
};
Steps.inheritAttrs = false;
const Marks = (_2, _ref) => {
  let {
    attrs,
    slots
  } = _ref;
  const {
    class: className,
    vertical,
    reverse,
    marks,
    included,
    upperBound,
    lowerBound,
    max,
    min,
    onClickLabel
  } = attrs;
  const marksKeys = Object.keys(marks);
  const customMark = slots.mark;
  const range3 = max - min;
  const elements = marksKeys.map(parseFloat).sort((a2, b2) => a2 - b2).map((point) => {
    const markPoint = typeof marks[point] === "function" ? marks[point]() : marks[point];
    const markPointIsObject = typeof markPoint === "object" && !isValidElement(markPoint);
    let markLabel = markPointIsObject ? markPoint.label : markPoint;
    if (!markLabel && markLabel !== 0) {
      return null;
    }
    if (customMark) {
      markLabel = customMark({
        point,
        label: markLabel
      });
    }
    const isActive = !included && point === upperBound || included && point <= upperBound && point >= lowerBound;
    const markClassName = classNames({
      [`${className}-text`]: true,
      [`${className}-text-active`]: isActive
    });
    const bottomStyle = {
      marginBottom: "-50%",
      [reverse ? "top" : "bottom"]: `${(point - min) / range3 * 100}%`
    };
    const leftStyle = {
      transform: `translateX(${reverse ? `50%` : `-50%`})`,
      msTransform: `translateX(${reverse ? `50%` : `-50%`})`,
      [reverse ? "right" : "left"]: `${(point - min) / range3 * 100}%`
    };
    const style = vertical ? bottomStyle : leftStyle;
    const markStyle = markPointIsObject ? _extends$1(_extends$1({}, style), markPoint.style) : style;
    const touchEvents = {
      [supportsPassive ? "onTouchstartPassive" : "onTouchstart"]: (e2) => onClickLabel(e2, point)
    };
    return createVNode("span", _objectSpread2$1({
      "class": markClassName,
      "style": markStyle,
      "key": point,
      "onMousedown": (e2) => onClickLabel(e2, point)
    }, touchEvents), [markLabel]);
  });
  return createVNode("div", {
    "class": className
  }, [elements]);
};
Marks.inheritAttrs = false;
const VcHandle = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Handle",
  inheritAttrs: false,
  props: {
    prefixCls: String,
    vertical: {
      type: Boolean,
      default: void 0
    },
    offset: Number,
    disabled: {
      type: Boolean,
      default: void 0
    },
    min: Number,
    max: Number,
    value: Number,
    tabindex: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    reverse: {
      type: Boolean,
      default: void 0
    },
    ariaLabel: String,
    ariaLabelledBy: String,
    ariaValueTextFormatter: Function,
    onMouseenter: {
      type: Function
    },
    onMouseleave: {
      type: Function
    },
    onMousedown: {
      type: Function
    }
  },
  setup(props2, _ref) {
    let {
      attrs,
      emit,
      expose
    } = _ref;
    const clickFocused = shallowRef(false);
    const handle = shallowRef();
    const handleMouseUp = () => {
      if (document.activeElement === handle.value) {
        clickFocused.value = true;
      }
    };
    const handleBlur = (e2) => {
      clickFocused.value = false;
      emit("blur", e2);
    };
    const handleKeyDown = () => {
      clickFocused.value = false;
    };
    const focus = () => {
      var _a2;
      (_a2 = handle.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
    };
    const blur = () => {
      var _a2;
      (_a2 = handle.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
    };
    const clickFocus = () => {
      clickFocused.value = true;
      focus();
    };
    const handleMousedown = (e2) => {
      e2.preventDefault();
      focus();
      emit("mousedown", e2);
    };
    expose({
      focus,
      blur,
      clickFocus,
      ref: handle
    });
    let onMouseUpListener = null;
    onMounted(() => {
      onMouseUpListener = addEventListenerWrap(document, "mouseup", handleMouseUp);
    });
    onBeforeUnmount(() => {
      onMouseUpListener === null || onMouseUpListener === void 0 ? void 0 : onMouseUpListener.remove();
    });
    const positionStyle = computed(() => {
      const {
        vertical,
        offset: offset3,
        reverse
      } = props2;
      return vertical ? {
        [reverse ? "top" : "bottom"]: `${offset3}%`,
        [reverse ? "bottom" : "top"]: "auto",
        transform: reverse ? null : `translateY(+50%)`
      } : {
        [reverse ? "right" : "left"]: `${offset3}%`,
        [reverse ? "left" : "right"]: "auto",
        transform: `translateX(${reverse ? "+" : "-"}50%)`
      };
    });
    return () => {
      const {
        prefixCls,
        disabled,
        min,
        max,
        value,
        tabindex,
        ariaLabel,
        ariaLabelledBy,
        ariaValueTextFormatter,
        onMouseenter,
        onMouseleave
      } = props2;
      const className = classNames(attrs.class, {
        [`${prefixCls}-handle-click-focused`]: clickFocused.value
      });
      const ariaProps = {
        "aria-valuemin": min,
        "aria-valuemax": max,
        "aria-valuenow": value,
        "aria-disabled": !!disabled
      };
      const elStyle = [attrs.style, positionStyle.value];
      let mergedTabIndex = tabindex || 0;
      if (disabled || tabindex === null) {
        mergedTabIndex = null;
      }
      let ariaValueText;
      if (ariaValueTextFormatter) {
        ariaValueText = ariaValueTextFormatter(value);
      }
      const handleProps = _extends$1(_extends$1(_extends$1(_extends$1({}, attrs), {
        role: "slider",
        tabindex: mergedTabIndex
      }), ariaProps), {
        class: className,
        onBlur: handleBlur,
        onKeydown: handleKeyDown,
        onMousedown: handleMousedown,
        onMouseenter,
        onMouseleave,
        ref: handle,
        style: elStyle
      });
      return createVNode("div", _objectSpread2$1(_objectSpread2$1({}, handleProps), {}, {
        "aria-label": ariaLabel,
        "aria-labelledby": ariaLabelledBy,
        "aria-valuetext": ariaValueText
      }), null);
    };
  }
});
function isEventFromHandle(e2, handles) {
  try {
    return Object.keys(handles).some((key2) => e2.target === handles[key2].ref);
  } catch (error) {
    return false;
  }
}
function isValueOutOfRange(value, _ref) {
  let {
    min,
    max
  } = _ref;
  return value < min || value > max;
}
function isNotTouchEvent(e2) {
  return e2.touches.length > 1 || e2.type.toLowerCase() === "touchend" && e2.touches.length > 0;
}
function getClosestPoint(val, _ref2) {
  let {
    marks,
    step,
    min,
    max
  } = _ref2;
  const points = Object.keys(marks).map(parseFloat);
  if (step !== null) {
    const baseNum = Math.pow(10, getPrecision(step));
    const maxSteps = Math.floor((max * baseNum - min * baseNum) / (step * baseNum));
    const steps = Math.min((val - min) / step, maxSteps);
    const closestStep = Math.round(steps) * step + min;
    points.push(closestStep);
  }
  const diffs = points.map((point) => Math.abs(val - point));
  return points[diffs.indexOf(Math.min(...diffs))];
}
function getPrecision(step) {
  const stepString = step.toString();
  let precision = 0;
  if (stepString.indexOf(".") >= 0) {
    precision = stepString.length - stepString.indexOf(".") - 1;
  }
  return precision;
}
function getMousePosition(vertical, e2) {
  let zoom = 1;
  if (window.visualViewport) {
    zoom = +(window.visualViewport.width / document.body.getBoundingClientRect().width).toFixed(2);
  }
  return (vertical ? e2.clientY : e2.pageX) / zoom;
}
function getTouchPosition(vertical, e2) {
  let zoom = 1;
  if (window.visualViewport) {
    zoom = +(window.visualViewport.width / document.body.getBoundingClientRect().width).toFixed(2);
  }
  return (vertical ? e2.touches[0].clientY : e2.touches[0].pageX) / zoom;
}
function getHandleCenterPosition(vertical, handle) {
  const coords = handle.getBoundingClientRect();
  return vertical ? coords.top + coords.height * 0.5 : window.scrollX + coords.left + coords.width * 0.5;
}
function ensureValueInRange(val, _ref3) {
  let {
    max,
    min
  } = _ref3;
  if (val <= min) {
    return min;
  }
  if (val >= max) {
    return max;
  }
  return val;
}
function ensureValuePrecision(val, props2) {
  const {
    step
  } = props2;
  const closestPoint = isFinite(getClosestPoint(val, props2)) ? getClosestPoint(val, props2) : 0;
  return step === null ? closestPoint : parseFloat(closestPoint.toFixed(getPrecision(step)));
}
function pauseEvent(e2) {
  e2.stopPropagation();
  e2.preventDefault();
}
function calculateNextValue(func, value, props2) {
  const operations = {
    increase: (a2, b2) => a2 + b2,
    decrease: (a2, b2) => a2 - b2
  };
  const indexToGet = operations[func](Object.keys(props2.marks).indexOf(JSON.stringify(value)), 1);
  const keyToGet = Object.keys(props2.marks)[indexToGet];
  if (props2.step) {
    return operations[func](value, props2.step);
  }
  if (!!Object.keys(props2.marks).length && !!props2.marks[keyToGet]) {
    return props2.marks[keyToGet];
  }
  return value;
}
function getKeyboardValueMutator(e2, vertical, reverse) {
  const increase = "increase";
  const decrease = "decrease";
  let method4 = increase;
  switch (e2.keyCode) {
    case KeyCode.UP:
      method4 = vertical && reverse ? decrease : increase;
      break;
    case KeyCode.RIGHT:
      method4 = !vertical && reverse ? decrease : increase;
      break;
    case KeyCode.DOWN:
      method4 = vertical && reverse ? increase : decrease;
      break;
    case KeyCode.LEFT:
      method4 = !vertical && reverse ? increase : decrease;
      break;
    case KeyCode.END:
      return (_value, props2) => props2.max;
    case KeyCode.HOME:
      return (_value, props2) => props2.min;
    case KeyCode.PAGE_UP:
      return (value, props2) => value + props2.step * 2;
    case KeyCode.PAGE_DOWN:
      return (value, props2) => value - props2.step * 2;
    default:
      return void 0;
  }
  return (value, props2) => calculateNextValue(method4, value, props2);
}
var __rest$g = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
function noop$1() {
}
function createSlider(Component) {
  const propTypes2 = {
    id: String,
    min: Number,
    max: Number,
    step: Number,
    marks: PropTypes.object,
    included: {
      type: Boolean,
      default: void 0
    },
    prefixCls: String,
    disabled: {
      type: Boolean,
      default: void 0
    },
    handle: Function,
    dots: {
      type: Boolean,
      default: void 0
    },
    vertical: {
      type: Boolean,
      default: void 0
    },
    reverse: {
      type: Boolean,
      default: void 0
    },
    minimumTrackStyle: PropTypes.object,
    maximumTrackStyle: PropTypes.object,
    handleStyle: PropTypes.oneOfType([PropTypes.object, PropTypes.arrayOf(PropTypes.object)]),
    trackStyle: PropTypes.oneOfType([PropTypes.object, PropTypes.arrayOf(PropTypes.object)]),
    railStyle: PropTypes.object,
    dotStyle: PropTypes.object,
    activeDotStyle: PropTypes.object,
    autofocus: {
      type: Boolean,
      default: void 0
    },
    draggableTrack: {
      type: Boolean,
      default: void 0
    }
  };
  return defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "CreateSlider",
    mixins: [BaseMixin, Component],
    inheritAttrs: false,
    props: initDefaultProps(propTypes2, {
      prefixCls: "rc-slider",
      min: 0,
      max: 100,
      step: 1,
      marks: {},
      included: true,
      disabled: false,
      dots: false,
      vertical: false,
      reverse: false,
      trackStyle: [{}],
      handleStyle: [{}],
      railStyle: {},
      dotStyle: {},
      activeDotStyle: {}
    }),
    emits: ["change", "blur", "focus"],
    data() {
      this.handlesRefs = {};
      return {};
    },
    mounted() {
      this.$nextTick(() => {
        this.document = this.sliderRef && this.sliderRef.ownerDocument;
        const {
          autofocus,
          disabled
        } = this;
        if (autofocus && !disabled) {
          this.focus();
        }
      });
    },
    beforeUnmount() {
      this.$nextTick(() => {
        this.removeDocumentEvents();
      });
    },
    methods: {
      defaultHandle(_a2) {
        var {
          index: index2,
          directives,
          className,
          style
        } = _a2, restProps = __rest$g(_a2, ["index", "directives", "className", "style"]);
        delete restProps.dragging;
        if (restProps.value === null) {
          return null;
        }
        const handleProps = _extends$1(_extends$1({}, restProps), {
          class: className,
          style,
          key: index2
        });
        return createVNode(VcHandle, handleProps, null);
      },
      onDown(e2, position2) {
        let p = position2;
        const {
          draggableTrack,
          vertical: isVertical
        } = this.$props;
        const {
          bounds
        } = this.$data;
        const value = draggableTrack && this.positionGetValue ? this.positionGetValue(p) || [] : [];
        const inPoint = isEventFromHandle(e2, this.handlesRefs);
        this.dragTrack = draggableTrack && bounds.length >= 2 && !inPoint && !value.map((n2, i2) => {
          const v2 = !i2 ? n2 >= bounds[i2] : true;
          return i2 === value.length - 1 ? n2 <= bounds[i2] : v2;
        }).some((c2) => !c2);
        if (this.dragTrack) {
          this.dragOffset = p;
          this.startBounds = [...bounds];
        } else {
          if (!inPoint) {
            this.dragOffset = 0;
          } else {
            const handlePosition = getHandleCenterPosition(isVertical, e2.target);
            this.dragOffset = p - handlePosition;
            p = handlePosition;
          }
          this.onStart(p);
        }
      },
      onMouseDown(e2) {
        if (e2.button !== 0) {
          return;
        }
        this.removeDocumentEvents();
        const isVertical = this.$props.vertical;
        const position2 = getMousePosition(isVertical, e2);
        this.onDown(e2, position2);
        this.addDocumentMouseEvents();
      },
      onTouchStart(e2) {
        if (isNotTouchEvent(e2)) return;
        const isVertical = this.vertical;
        const position2 = getTouchPosition(isVertical, e2);
        this.onDown(e2, position2);
        this.addDocumentTouchEvents();
        pauseEvent(e2);
      },
      onFocus(e2) {
        const {
          vertical
        } = this;
        if (isEventFromHandle(e2, this.handlesRefs) && !this.dragTrack) {
          const handlePosition = getHandleCenterPosition(vertical, e2.target);
          this.dragOffset = 0;
          this.onStart(handlePosition);
          pauseEvent(e2);
          this.$emit("focus", e2);
        }
      },
      onBlur(e2) {
        if (!this.dragTrack) {
          this.onEnd();
        }
        this.$emit("blur", e2);
      },
      onMouseUp() {
        if (this.handlesRefs[this.prevMovedHandleIndex]) {
          this.handlesRefs[this.prevMovedHandleIndex].clickFocus();
        }
      },
      onMouseMove(e2) {
        if (!this.sliderRef) {
          this.onEnd();
          return;
        }
        const position2 = getMousePosition(this.vertical, e2);
        this.onMove(e2, position2 - this.dragOffset, this.dragTrack, this.startBounds);
      },
      onTouchMove(e2) {
        if (isNotTouchEvent(e2) || !this.sliderRef) {
          this.onEnd();
          return;
        }
        const position2 = getTouchPosition(this.vertical, e2);
        this.onMove(e2, position2 - this.dragOffset, this.dragTrack, this.startBounds);
      },
      onKeyDown(e2) {
        if (this.sliderRef && isEventFromHandle(e2, this.handlesRefs)) {
          this.onKeyboard(e2);
        }
      },
      onClickMarkLabel(e2, value) {
        e2.stopPropagation();
        this.onChange({
          sValue: value
        });
        this.setState({
          sValue: value
        }, () => this.onEnd(true));
      },
      getSliderStart() {
        const slider = this.sliderRef;
        const {
          vertical,
          reverse
        } = this;
        const rect = slider.getBoundingClientRect();
        if (vertical) {
          return reverse ? rect.bottom : rect.top;
        }
        return window.scrollX + (reverse ? rect.right : rect.left);
      },
      getSliderLength() {
        const slider = this.sliderRef;
        if (!slider) {
          return 0;
        }
        const coords = slider.getBoundingClientRect();
        return this.vertical ? coords.height : coords.width;
      },
      addDocumentTouchEvents() {
        this.onTouchMoveListener = addEventListenerWrap(this.document, "touchmove", this.onTouchMove);
        this.onTouchUpListener = addEventListenerWrap(this.document, "touchend", this.onEnd);
      },
      addDocumentMouseEvents() {
        this.onMouseMoveListener = addEventListenerWrap(this.document, "mousemove", this.onMouseMove);
        this.onMouseUpListener = addEventListenerWrap(this.document, "mouseup", this.onEnd);
      },
      removeDocumentEvents() {
        this.onTouchMoveListener && this.onTouchMoveListener.remove();
        this.onTouchUpListener && this.onTouchUpListener.remove();
        this.onMouseMoveListener && this.onMouseMoveListener.remove();
        this.onMouseUpListener && this.onMouseUpListener.remove();
      },
      focus() {
        var _a2;
        if (this.$props.disabled) {
          return;
        }
        (_a2 = this.handlesRefs[0]) === null || _a2 === void 0 ? void 0 : _a2.focus();
      },
      blur() {
        if (this.$props.disabled) {
          return;
        }
        Object.keys(this.handlesRefs).forEach((key2) => {
          var _a2, _b;
          (_b = (_a2 = this.handlesRefs[key2]) === null || _a2 === void 0 ? void 0 : _a2.blur) === null || _b === void 0 ? void 0 : _b.call(_a2);
        });
      },
      calcValue(offset3) {
        const {
          vertical,
          min,
          max
        } = this;
        const ratio = Math.abs(Math.max(offset3, 0) / this.getSliderLength());
        const value = vertical ? (1 - ratio) * (max - min) + min : ratio * (max - min) + min;
        return value;
      },
      calcValueByPos(position2) {
        const sign = this.reverse ? -1 : 1;
        const pixelOffset = sign * (position2 - this.getSliderStart());
        const nextValue = this.trimAlignValue(this.calcValue(pixelOffset));
        return nextValue;
      },
      calcOffset(value) {
        const {
          min,
          max
        } = this;
        const ratio = (value - min) / (max - min);
        return Math.max(0, ratio * 100);
      },
      saveSlider(slider) {
        this.sliderRef = slider;
      },
      saveHandle(index2, handle) {
        this.handlesRefs[index2] = handle;
      }
    },
    render() {
      const {
        prefixCls,
        marks,
        dots,
        step,
        included,
        disabled,
        vertical,
        reverse,
        min,
        max,
        maximumTrackStyle,
        railStyle,
        dotStyle,
        activeDotStyle,
        id
      } = this;
      const {
        class: className,
        style
      } = this.$attrs;
      const {
        tracks,
        handles
      } = this.renderSlider();
      const sliderClassName = classNames(prefixCls, className, {
        [`${prefixCls}-with-marks`]: Object.keys(marks).length,
        [`${prefixCls}-disabled`]: disabled,
        [`${prefixCls}-vertical`]: vertical,
        [`${prefixCls}-horizontal`]: !vertical
      });
      const markProps = {
        vertical,
        marks,
        included,
        lowerBound: this.getLowerBound(),
        upperBound: this.getUpperBound(),
        max,
        min,
        reverse,
        class: `${prefixCls}-mark`,
        onClickLabel: disabled ? noop$1 : this.onClickMarkLabel
      };
      const touchEvents = {
        [supportsPassive ? "onTouchstartPassive" : "onTouchstart"]: disabled ? noop$1 : this.onTouchStart
      };
      return createVNode("div", _objectSpread2$1(_objectSpread2$1({
        "id": id,
        "ref": this.saveSlider,
        "tabindex": "-1",
        "class": sliderClassName
      }, touchEvents), {}, {
        "onMousedown": disabled ? noop$1 : this.onMouseDown,
        "onMouseup": disabled ? noop$1 : this.onMouseUp,
        "onKeydown": disabled ? noop$1 : this.onKeyDown,
        "onFocus": disabled ? noop$1 : this.onFocus,
        "onBlur": disabled ? noop$1 : this.onBlur,
        "style": style
      }), [createVNode("div", {
        "class": `${prefixCls}-rail`,
        "style": _extends$1(_extends$1({}, maximumTrackStyle), railStyle)
      }, null), tracks, createVNode(Steps, {
        "prefixCls": prefixCls,
        "vertical": vertical,
        "reverse": reverse,
        "marks": marks,
        "dots": dots,
        "step": step,
        "included": included,
        "lowerBound": this.getLowerBound(),
        "upperBound": this.getUpperBound(),
        "max": max,
        "min": min,
        "dotStyle": dotStyle,
        "activeDotStyle": activeDotStyle
      }, null), handles, createVNode(Marks, markProps, {
        mark: this.$slots.mark
      }), getSlot(this)]);
    }
  });
}
const Slider$2 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Slider",
  mixins: [BaseMixin],
  inheritAttrs: false,
  props: {
    defaultValue: Number,
    value: Number,
    disabled: {
      type: Boolean,
      default: void 0
    },
    autofocus: {
      type: Boolean,
      default: void 0
    },
    tabindex: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    reverse: {
      type: Boolean,
      default: void 0
    },
    min: Number,
    max: Number,
    ariaLabelForHandle: String,
    ariaLabelledByForHandle: String,
    ariaValueTextFormatterForHandle: String,
    startPoint: Number
  },
  emits: ["beforeChange", "afterChange", "change"],
  data() {
    const defaultValue = this.defaultValue !== void 0 ? this.defaultValue : this.min;
    const value = this.value !== void 0 ? this.value : defaultValue;
    return {
      sValue: this.trimAlignValue(value),
      dragging: false
    };
  },
  watch: {
    value: {
      handler(val) {
        this.setChangeValue(val);
      },
      deep: true
    },
    min() {
      const {
        sValue
      } = this;
      this.setChangeValue(sValue);
    },
    max() {
      const {
        sValue
      } = this;
      this.setChangeValue(sValue);
    }
  },
  methods: {
    setChangeValue(value) {
      const newValue = value !== void 0 ? value : this.sValue;
      const nextValue = this.trimAlignValue(newValue, this.$props);
      if (nextValue === this.sValue) return;
      this.setState({
        sValue: nextValue
      });
      if (isValueOutOfRange(newValue, this.$props)) {
        this.$emit("change", nextValue);
      }
    },
    onChange(state) {
      const isNotControlled = !hasProp(this, "value");
      const nextState = state.sValue > this.max ? _extends$1(_extends$1({}, state), {
        sValue: this.max
      }) : state;
      if (isNotControlled) {
        this.setState(nextState);
      }
      const changedValue = nextState.sValue;
      this.$emit("change", changedValue);
    },
    onStart(position2) {
      this.setState({
        dragging: true
      });
      const {
        sValue
      } = this;
      this.$emit("beforeChange", sValue);
      const value = this.calcValueByPos(position2);
      this.startValue = value;
      this.startPosition = position2;
      if (value === sValue) return;
      this.prevMovedHandleIndex = 0;
      this.onChange({
        sValue: value
      });
    },
    onEnd(force) {
      const {
        dragging
      } = this;
      this.removeDocumentEvents();
      if (dragging || force) {
        this.$emit("afterChange", this.sValue);
      }
      this.setState({
        dragging: false
      });
    },
    onMove(e2, position2) {
      pauseEvent(e2);
      const {
        sValue
      } = this;
      const value = this.calcValueByPos(position2);
      if (value === sValue) return;
      this.onChange({
        sValue: value
      });
    },
    onKeyboard(e2) {
      const {
        reverse,
        vertical
      } = this.$props;
      const valueMutator = getKeyboardValueMutator(e2, vertical, reverse);
      if (valueMutator) {
        pauseEvent(e2);
        const {
          sValue
        } = this;
        const mutatedValue = valueMutator(sValue, this.$props);
        const value = this.trimAlignValue(mutatedValue);
        if (value === sValue) return;
        this.onChange({
          sValue: value
        });
        this.$emit("afterChange", value);
        this.onEnd();
      }
    },
    getLowerBound() {
      const minPoint = this.$props.startPoint || this.$props.min;
      return this.$data.sValue > minPoint ? minPoint : this.$data.sValue;
    },
    getUpperBound() {
      if (this.$data.sValue < this.$props.startPoint) {
        return this.$props.startPoint;
      }
      return this.$data.sValue;
    },
    trimAlignValue(v2) {
      let nextProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (v2 === null) {
        return null;
      }
      const mergedProps = _extends$1(_extends$1({}, this.$props), nextProps);
      const val = ensureValueInRange(v2, mergedProps);
      return ensureValuePrecision(val, mergedProps);
    },
    getTrack(_ref) {
      let {
        prefixCls,
        reverse,
        vertical,
        included,
        minimumTrackStyle,
        mergedTrackStyle,
        length: length2,
        offset: offset3
      } = _ref;
      return createVNode(Track, {
        "class": `${prefixCls}-track`,
        "vertical": vertical,
        "included": included,
        "offset": offset3,
        "reverse": reverse,
        "length": length2,
        "style": _extends$1(_extends$1({}, minimumTrackStyle), mergedTrackStyle)
      }, null);
    },
    renderSlider() {
      const {
        prefixCls,
        vertical,
        included,
        disabled,
        minimumTrackStyle,
        trackStyle,
        handleStyle,
        tabindex,
        ariaLabelForHandle,
        ariaLabelledByForHandle,
        ariaValueTextFormatterForHandle,
        min,
        max,
        startPoint,
        reverse,
        handle,
        defaultHandle
      } = this;
      const handleGenerator = handle || defaultHandle;
      const {
        sValue,
        dragging
      } = this;
      const offset3 = this.calcOffset(sValue);
      const handles = handleGenerator({
        class: `${prefixCls}-handle`,
        prefixCls,
        vertical,
        offset: offset3,
        value: sValue,
        dragging,
        disabled,
        min,
        max,
        reverse,
        index: 0,
        tabindex,
        ariaLabel: ariaLabelForHandle,
        ariaLabelledBy: ariaLabelledByForHandle,
        ariaValueTextFormatter: ariaValueTextFormatterForHandle,
        style: handleStyle[0] || handleStyle,
        ref: (h2) => this.saveHandle(0, h2),
        onFocus: this.onFocus,
        onBlur: this.onBlur
      });
      const trackOffset = startPoint !== void 0 ? this.calcOffset(startPoint) : 0;
      const mergedTrackStyle = trackStyle[0] || trackStyle;
      return {
        tracks: this.getTrack({
          prefixCls,
          reverse,
          vertical,
          included,
          offset: trackOffset,
          minimumTrackStyle,
          mergedTrackStyle,
          length: offset3 - trackOffset
        }),
        handles
      };
    }
  }
});
const VcSlider = createSlider(Slider$2);
const trimAlignValue = (_ref) => {
  let {
    value,
    handle,
    bounds,
    props: props2
  } = _ref;
  const {
    allowCross,
    pushable
  } = props2;
  const thershold = Number(pushable);
  const valInRange = ensureValueInRange(value, props2);
  let valNotConflict = valInRange;
  if (!allowCross && handle != null && bounds !== void 0) {
    if (handle > 0 && valInRange <= bounds[handle - 1] + thershold) {
      valNotConflict = bounds[handle - 1] + thershold;
    }
    if (handle < bounds.length - 1 && valInRange >= bounds[handle + 1] - thershold) {
      valNotConflict = bounds[handle + 1] - thershold;
    }
  }
  return ensureValuePrecision(valNotConflict, props2);
};
const rangeProps = {
  defaultValue: PropTypes.arrayOf(PropTypes.number),
  value: PropTypes.arrayOf(PropTypes.number),
  count: Number,
  pushable: withUndefined(PropTypes.oneOfType([PropTypes.looseBool, PropTypes.number])),
  allowCross: {
    type: Boolean,
    default: void 0
  },
  disabled: {
    type: Boolean,
    default: void 0
  },
  reverse: {
    type: Boolean,
    default: void 0
  },
  tabindex: PropTypes.arrayOf(PropTypes.number),
  prefixCls: String,
  min: Number,
  max: Number,
  autofocus: {
    type: Boolean,
    default: void 0
  },
  ariaLabelGroupForHandles: Array,
  ariaLabelledByGroupForHandles: Array,
  ariaValueTextFormatterGroupForHandles: Array,
  draggableTrack: {
    type: Boolean,
    default: void 0
  }
};
const Range = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Range",
  mixins: [BaseMixin],
  inheritAttrs: false,
  props: initDefaultProps(rangeProps, {
    count: 1,
    allowCross: true,
    pushable: false,
    tabindex: [],
    draggableTrack: false,
    ariaLabelGroupForHandles: [],
    ariaLabelledByGroupForHandles: [],
    ariaValueTextFormatterGroupForHandles: []
  }),
  emits: ["beforeChange", "afterChange", "change"],
  displayName: "Range",
  data() {
    const {
      count,
      min,
      max
    } = this;
    const initialValue = Array(...Array(count + 1)).map(() => min);
    const defaultValue = hasProp(this, "defaultValue") ? this.defaultValue : initialValue;
    let {
      value
    } = this;
    if (value === void 0) {
      value = defaultValue;
    }
    const bounds = value.map((v2, i2) => trimAlignValue({
      value: v2,
      handle: i2,
      props: this.$props
    }));
    const recent = bounds[0] === max ? 0 : bounds.length - 1;
    return {
      sHandle: null,
      recent,
      bounds
    };
  },
  watch: {
    value: {
      handler(val) {
        const {
          bounds
        } = this;
        this.setChangeValue(val || bounds);
      },
      deep: true
    },
    min() {
      const {
        value
      } = this;
      this.setChangeValue(value || this.bounds);
    },
    max() {
      const {
        value
      } = this;
      this.setChangeValue(value || this.bounds);
    }
  },
  methods: {
    setChangeValue(value) {
      const {
        bounds
      } = this;
      let nextBounds = value.map((v2, i2) => trimAlignValue({
        value: v2,
        handle: i2,
        bounds,
        props: this.$props
      }));
      if (bounds.length === nextBounds.length) {
        if (nextBounds.every((v2, i2) => v2 === bounds[i2])) {
          return null;
        }
      } else {
        nextBounds = value.map((v2, i2) => trimAlignValue({
          value: v2,
          handle: i2,
          props: this.$props
        }));
      }
      this.setState({
        bounds: nextBounds
      });
      if (value.some((v2) => isValueOutOfRange(v2, this.$props))) {
        const newValues = value.map((v2) => {
          return ensureValueInRange(v2, this.$props);
        });
        this.$emit("change", newValues);
      }
    },
    onChange(state) {
      const isNotControlled = !hasProp(this, "value");
      if (isNotControlled) {
        this.setState(state);
      } else {
        const controlledState = {};
        ["sHandle", "recent"].forEach((item) => {
          if (state[item] !== void 0) {
            controlledState[item] = state[item];
          }
        });
        if (Object.keys(controlledState).length) {
          this.setState(controlledState);
        }
      }
      const data = _extends$1(_extends$1({}, this.$data), state);
      const changedValue = data.bounds;
      this.$emit("change", changedValue);
    },
    positionGetValue(position2) {
      const bounds = this.getValue();
      const value = this.calcValueByPos(position2);
      const closestBound = this.getClosestBound(value);
      const index2 = this.getBoundNeedMoving(value, closestBound);
      const prevValue = bounds[index2];
      if (value === prevValue) return null;
      const nextBounds = [...bounds];
      nextBounds[index2] = value;
      return nextBounds;
    },
    onStart(position2) {
      const {
        bounds
      } = this;
      this.$emit("beforeChange", bounds);
      const value = this.calcValueByPos(position2);
      this.startValue = value;
      this.startPosition = position2;
      const closestBound = this.getClosestBound(value);
      this.prevMovedHandleIndex = this.getBoundNeedMoving(value, closestBound);
      this.setState({
        sHandle: this.prevMovedHandleIndex,
        recent: this.prevMovedHandleIndex
      });
      const prevValue = bounds[this.prevMovedHandleIndex];
      if (value === prevValue) return;
      const nextBounds = [...bounds];
      nextBounds[this.prevMovedHandleIndex] = value;
      this.onChange({
        bounds: nextBounds
      });
    },
    onEnd(force) {
      const {
        sHandle
      } = this;
      this.removeDocumentEvents();
      if (!sHandle) {
        this.dragTrack = false;
      }
      if (sHandle !== null || force) {
        this.$emit("afterChange", this.bounds);
      }
      this.setState({
        sHandle: null
      });
    },
    onMove(e2, position2, dragTrack, startBounds) {
      pauseEvent(e2);
      const {
        $data: state,
        $props: props2
      } = this;
      const maxValue = props2.max || 100;
      const minValue = props2.min || 0;
      if (dragTrack) {
        let pos = props2.vertical ? -position2 : position2;
        pos = props2.reverse ? -pos : pos;
        const max = maxValue - Math.max(...startBounds);
        const min = minValue - Math.min(...startBounds);
        const ratio = Math.min(Math.max(pos / (this.getSliderLength() / 100), min), max);
        const nextBounds = startBounds.map((v2) => Math.floor(Math.max(Math.min(v2 + ratio, maxValue), minValue)));
        if (state.bounds.map((c2, i2) => c2 === nextBounds[i2]).some((c2) => !c2)) {
          this.onChange({
            bounds: nextBounds
          });
        }
        return;
      }
      const {
        bounds,
        sHandle
      } = this;
      const value = this.calcValueByPos(position2);
      const oldValue = bounds[sHandle];
      if (value === oldValue) return;
      this.moveTo(value);
    },
    onKeyboard(e2) {
      const {
        reverse,
        vertical
      } = this.$props;
      const valueMutator = getKeyboardValueMutator(e2, vertical, reverse);
      if (valueMutator) {
        pauseEvent(e2);
        const {
          bounds,
          sHandle
        } = this;
        const oldValue = bounds[sHandle === null ? this.recent : sHandle];
        const mutatedValue = valueMutator(oldValue, this.$props);
        const value = trimAlignValue({
          value: mutatedValue,
          handle: sHandle,
          bounds,
          props: this.$props
        });
        if (value === oldValue) return;
        const isFromKeyboardEvent = true;
        this.moveTo(value, isFromKeyboardEvent);
      }
    },
    getClosestBound(value) {
      const {
        bounds
      } = this;
      let closestBound = 0;
      for (let i2 = 1; i2 < bounds.length - 1; i2 += 1) {
        if (value >= bounds[i2]) {
          closestBound = i2;
        }
      }
      if (Math.abs(bounds[closestBound + 1] - value) < Math.abs(bounds[closestBound] - value)) {
        closestBound += 1;
      }
      return closestBound;
    },
    getBoundNeedMoving(value, closestBound) {
      const {
        bounds,
        recent
      } = this;
      let boundNeedMoving = closestBound;
      const isAtTheSamePoint = bounds[closestBound + 1] === bounds[closestBound];
      if (isAtTheSamePoint && bounds[recent] === bounds[closestBound]) {
        boundNeedMoving = recent;
      }
      if (isAtTheSamePoint && value !== bounds[closestBound + 1]) {
        boundNeedMoving = value < bounds[closestBound + 1] ? closestBound : closestBound + 1;
      }
      return boundNeedMoving;
    },
    getLowerBound() {
      return this.bounds[0];
    },
    getUpperBound() {
      const {
        bounds
      } = this;
      return bounds[bounds.length - 1];
    },
    /**
     * Returns an array of possible slider points, taking into account both
     * `marks` and `step`. The result is cached.
     */
    getPoints() {
      const {
        marks,
        step,
        min,
        max
      } = this;
      const cache = this.internalPointsCache;
      if (!cache || cache.marks !== marks || cache.step !== step) {
        const pointsObject = _extends$1({}, marks);
        if (step !== null) {
          for (let point = min; point <= max; point += step) {
            pointsObject[point] = point;
          }
        }
        const points = Object.keys(pointsObject).map(parseFloat);
        points.sort((a2, b2) => a2 - b2);
        this.internalPointsCache = {
          marks,
          step,
          points
        };
      }
      return this.internalPointsCache.points;
    },
    moveTo(value, isFromKeyboardEvent) {
      const nextBounds = [...this.bounds];
      const {
        sHandle,
        recent
      } = this;
      const handle = sHandle === null ? recent : sHandle;
      nextBounds[handle] = value;
      let nextHandle = handle;
      if (this.$props.pushable !== false) {
        this.pushSurroundingHandles(nextBounds, nextHandle);
      } else if (this.$props.allowCross) {
        nextBounds.sort((a2, b2) => a2 - b2);
        nextHandle = nextBounds.indexOf(value);
      }
      this.onChange({
        recent: nextHandle,
        sHandle: nextHandle,
        bounds: nextBounds
      });
      if (isFromKeyboardEvent) {
        this.$emit("afterChange", nextBounds);
        this.setState({}, () => {
          this.handlesRefs[nextHandle].focus();
        });
        this.onEnd();
      }
    },
    pushSurroundingHandles(bounds, handle) {
      const value = bounds[handle];
      const {
        pushable
      } = this;
      const threshold = Number(pushable);
      let direction = 0;
      if (bounds[handle + 1] - value < threshold) {
        direction = 1;
      }
      if (value - bounds[handle - 1] < threshold) {
        direction = -1;
      }
      if (direction === 0) {
        return;
      }
      const nextHandle = handle + direction;
      const diffToNext = direction * (bounds[nextHandle] - value);
      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {
        bounds[handle] = bounds[nextHandle] - direction * threshold;
      }
    },
    pushHandle(bounds, handle, direction, amount) {
      const originalValue = bounds[handle];
      let currentValue = bounds[handle];
      while (direction * (currentValue - originalValue) < amount) {
        if (!this.pushHandleOnePoint(bounds, handle, direction)) {
          bounds[handle] = originalValue;
          return false;
        }
        currentValue = bounds[handle];
      }
      return true;
    },
    pushHandleOnePoint(bounds, handle, direction) {
      const points = this.getPoints();
      const pointIndex = points.indexOf(bounds[handle]);
      const nextPointIndex = pointIndex + direction;
      if (nextPointIndex >= points.length || nextPointIndex < 0) {
        return false;
      }
      const nextHandle = handle + direction;
      const nextValue = points[nextPointIndex];
      const {
        pushable
      } = this;
      const threshold = Number(pushable);
      const diffToNext = direction * (bounds[nextHandle] - nextValue);
      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {
        return false;
      }
      bounds[handle] = nextValue;
      return true;
    },
    trimAlignValue(value) {
      const {
        sHandle,
        bounds
      } = this;
      return trimAlignValue({
        value,
        handle: sHandle,
        bounds,
        props: this.$props
      });
    },
    ensureValueNotConflict(handle, val, _ref2) {
      let {
        allowCross,
        pushable: thershold
      } = _ref2;
      const state = this.$data || {};
      const {
        bounds
      } = state;
      handle = handle === void 0 ? state.sHandle : handle;
      thershold = Number(thershold);
      if (!allowCross && handle != null && bounds !== void 0) {
        if (handle > 0 && val <= bounds[handle - 1] + thershold) {
          return bounds[handle - 1] + thershold;
        }
        if (handle < bounds.length - 1 && val >= bounds[handle + 1] - thershold) {
          return bounds[handle + 1] - thershold;
        }
      }
      return val;
    },
    getTrack(_ref3) {
      let {
        bounds,
        prefixCls,
        reverse,
        vertical,
        included,
        offsets,
        trackStyle
      } = _ref3;
      return bounds.slice(0, -1).map((_2, index2) => {
        const i2 = index2 + 1;
        const trackClassName = classNames({
          [`${prefixCls}-track`]: true,
          [`${prefixCls}-track-${i2}`]: true
        });
        return createVNode(Track, {
          "class": trackClassName,
          "vertical": vertical,
          "reverse": reverse,
          "included": included,
          "offset": offsets[i2 - 1],
          "length": offsets[i2] - offsets[i2 - 1],
          "style": trackStyle[index2],
          "key": i2
        }, null);
      });
    },
    renderSlider() {
      const {
        sHandle,
        bounds,
        prefixCls,
        vertical,
        included,
        disabled,
        min,
        max,
        reverse,
        handle,
        defaultHandle,
        trackStyle,
        handleStyle,
        tabindex,
        ariaLabelGroupForHandles,
        ariaLabelledByGroupForHandles,
        ariaValueTextFormatterGroupForHandles
      } = this;
      const handleGenerator = handle || defaultHandle;
      const offsets = bounds.map((v2) => this.calcOffset(v2));
      const handleClassName = `${prefixCls}-handle`;
      const handles = bounds.map((v2, i2) => {
        let mergedTabIndex = tabindex[i2] || 0;
        if (disabled || tabindex[i2] === null) {
          mergedTabIndex = null;
        }
        const dragging = sHandle === i2;
        return handleGenerator({
          class: classNames({
            [handleClassName]: true,
            [`${handleClassName}-${i2 + 1}`]: true,
            [`${handleClassName}-dragging`]: dragging
          }),
          prefixCls,
          vertical,
          dragging,
          offset: offsets[i2],
          value: v2,
          index: i2,
          tabindex: mergedTabIndex,
          min,
          max,
          reverse,
          disabled,
          style: handleStyle[i2],
          ref: (h2) => this.saveHandle(i2, h2),
          onFocus: this.onFocus,
          onBlur: this.onBlur,
          ariaLabel: ariaLabelGroupForHandles[i2],
          ariaLabelledBy: ariaLabelledByGroupForHandles[i2],
          ariaValueTextFormatter: ariaValueTextFormatterGroupForHandles[i2]
        });
      });
      return {
        tracks: this.getTrack({
          bounds,
          prefixCls,
          reverse,
          vertical,
          included,
          offsets,
          trackStyle
        }),
        handles
      };
    }
  }
});
const VcRange = createSlider(Range);
const SliderTooltip = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "SliderTooltip",
  inheritAttrs: false,
  props: tooltipProps(),
  setup(props2, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const innerRef = ref(null);
    const rafRef = ref(null);
    function cancelKeepAlign() {
      wrapperRaf.cancel(rafRef.value);
      rafRef.value = null;
    }
    function keepAlign() {
      rafRef.value = wrapperRaf(() => {
        var _a2;
        (_a2 = innerRef.value) === null || _a2 === void 0 ? void 0 : _a2.forcePopupAlign();
        rafRef.value = null;
      });
    }
    const align = () => {
      cancelKeepAlign();
      if (props2.open) {
        keepAlign();
      }
    };
    watch([() => props2.open, () => props2.title], () => {
      align();
    }, {
      flush: "post",
      immediate: true
    });
    onActivated(() => {
      align();
    });
    onBeforeUnmount(() => {
      cancelKeepAlign();
    });
    return () => {
      return createVNode(Tooltip, _objectSpread2$1(_objectSpread2$1({
        "ref": innerRef
      }, props2), attrs), slots);
    };
  }
});
const genBaseStyle$3 = (token2) => {
  const {
    componentCls,
    controlSize,
    dotSize,
    marginFull,
    marginPart,
    colorFillContentHover
  } = token2;
  return {
    [componentCls]: _extends$1(_extends$1({}, resetComponent(token2)), {
      position: "relative",
      height: controlSize,
      margin: `${marginPart}px ${marginFull}px`,
      padding: 0,
      cursor: "pointer",
      touchAction: "none",
      [`&-vertical`]: {
        margin: `${marginFull}px ${marginPart}px`
      },
      [`${componentCls}-rail`]: {
        position: "absolute",
        backgroundColor: token2.colorFillTertiary,
        borderRadius: token2.borderRadiusXS,
        transition: `background-color ${token2.motionDurationMid}`
      },
      [`${componentCls}-track`]: {
        position: "absolute",
        backgroundColor: token2.colorPrimaryBorder,
        borderRadius: token2.borderRadiusXS,
        transition: `background-color ${token2.motionDurationMid}`
      },
      "&:hover": {
        [`${componentCls}-rail`]: {
          backgroundColor: token2.colorFillSecondary
        },
        [`${componentCls}-track`]: {
          backgroundColor: token2.colorPrimaryBorderHover
        },
        [`${componentCls}-dot`]: {
          borderColor: colorFillContentHover
        },
        [`${componentCls}-handle::after`]: {
          boxShadow: `0 0 0 ${token2.handleLineWidth}px ${token2.colorPrimaryBorderHover}`
        },
        [`${componentCls}-dot-active`]: {
          borderColor: token2.colorPrimary
        }
      },
      [`${componentCls}-handle`]: {
        position: "absolute",
        width: token2.handleSize,
        height: token2.handleSize,
        outline: "none",
        [`${componentCls}-dragging`]: {
          zIndex: 1
        },
        // 扩大选区
        "&::before": {
          content: '""',
          position: "absolute",
          insetInlineStart: -token2.handleLineWidth,
          insetBlockStart: -token2.handleLineWidth,
          width: token2.handleSize + token2.handleLineWidth * 2,
          height: token2.handleSize + token2.handleLineWidth * 2,
          backgroundColor: "transparent"
        },
        "&::after": {
          content: '""',
          position: "absolute",
          insetBlockStart: 0,
          insetInlineStart: 0,
          width: token2.handleSize,
          height: token2.handleSize,
          backgroundColor: token2.colorBgElevated,
          boxShadow: `0 0 0 ${token2.handleLineWidth}px ${token2.colorPrimaryBorder}`,
          borderRadius: "50%",
          cursor: "pointer",
          transition: `
            inset-inline-start ${token2.motionDurationMid},
            inset-block-start ${token2.motionDurationMid},
            width ${token2.motionDurationMid},
            height ${token2.motionDurationMid},
            box-shadow ${token2.motionDurationMid}
          `
        },
        "&:hover, &:active, &:focus": {
          "&::before": {
            insetInlineStart: -((token2.handleSizeHover - token2.handleSize) / 2 + token2.handleLineWidthHover),
            insetBlockStart: -((token2.handleSizeHover - token2.handleSize) / 2 + token2.handleLineWidthHover),
            width: token2.handleSizeHover + token2.handleLineWidthHover * 2,
            height: token2.handleSizeHover + token2.handleLineWidthHover * 2
          },
          "&::after": {
            boxShadow: `0 0 0 ${token2.handleLineWidthHover}px ${token2.colorPrimary}`,
            width: token2.handleSizeHover,
            height: token2.handleSizeHover,
            insetInlineStart: (token2.handleSize - token2.handleSizeHover) / 2,
            insetBlockStart: (token2.handleSize - token2.handleSizeHover) / 2
          }
        }
      },
      [`${componentCls}-mark`]: {
        position: "absolute",
        fontSize: token2.fontSize
      },
      [`${componentCls}-mark-text`]: {
        position: "absolute",
        display: "inline-block",
        color: token2.colorTextDescription,
        textAlign: "center",
        wordBreak: "keep-all",
        cursor: "pointer",
        userSelect: "none",
        "&-active": {
          color: token2.colorText
        }
      },
      [`${componentCls}-step`]: {
        position: "absolute",
        background: "transparent",
        pointerEvents: "none"
      },
      [`${componentCls}-dot`]: {
        position: "absolute",
        width: dotSize,
        height: dotSize,
        backgroundColor: token2.colorBgElevated,
        border: `${token2.handleLineWidth}px solid ${token2.colorBorderSecondary}`,
        borderRadius: "50%",
        cursor: "pointer",
        transition: `border-color ${token2.motionDurationSlow}`,
        "&-active": {
          borderColor: token2.colorPrimaryBorder
        }
      },
      [`&${componentCls}-disabled`]: {
        cursor: "not-allowed",
        [`${componentCls}-rail`]: {
          backgroundColor: `${token2.colorFillSecondary} !important`
        },
        [`${componentCls}-track`]: {
          backgroundColor: `${token2.colorTextDisabled} !important`
        },
        [`
          ${componentCls}-dot
        `]: {
          backgroundColor: token2.colorBgElevated,
          borderColor: token2.colorTextDisabled,
          boxShadow: "none",
          cursor: "not-allowed"
        },
        [`${componentCls}-handle::after`]: {
          backgroundColor: token2.colorBgElevated,
          cursor: "not-allowed",
          width: token2.handleSize,
          height: token2.handleSize,
          boxShadow: `0 0 0 ${token2.handleLineWidth}px ${new TinyColor(token2.colorTextDisabled).onBackground(token2.colorBgContainer).toHexString()}`,
          insetInlineStart: 0,
          insetBlockStart: 0
        },
        [`
          ${componentCls}-mark-text,
          ${componentCls}-dot
        `]: {
          cursor: `not-allowed !important`
        }
      }
    })
  };
};
const genDirectionStyle = (token2, horizontal) => {
  const {
    componentCls,
    railSize,
    handleSize,
    dotSize
  } = token2;
  const railPadding = horizontal ? "paddingBlock" : "paddingInline";
  const full = horizontal ? "width" : "height";
  const part = horizontal ? "height" : "width";
  const handlePos = horizontal ? "insetBlockStart" : "insetInlineStart";
  const markInset = horizontal ? "top" : "insetInlineStart";
  return {
    [railPadding]: railSize,
    [part]: railSize * 3,
    [`${componentCls}-rail`]: {
      [full]: "100%",
      [part]: railSize
    },
    [`${componentCls}-track`]: {
      [part]: railSize
    },
    [`${componentCls}-handle`]: {
      [handlePos]: (railSize * 3 - handleSize) / 2
    },
    [`${componentCls}-mark`]: {
      // Reset all
      insetInlineStart: 0,
      top: 0,
      [markInset]: handleSize,
      [full]: "100%"
    },
    [`${componentCls}-step`]: {
      // Reset all
      insetInlineStart: 0,
      top: 0,
      [markInset]: railSize,
      [full]: "100%",
      [part]: railSize
    },
    [`${componentCls}-dot`]: {
      position: "absolute",
      [handlePos]: (railSize - dotSize) / 2
    }
  };
};
const genHorizontalStyle = (token2) => {
  const {
    componentCls,
    marginPartWithMark
  } = token2;
  return {
    [`${componentCls}-horizontal`]: _extends$1(_extends$1({}, genDirectionStyle(token2, true)), {
      [`&${componentCls}-with-marks`]: {
        marginBottom: marginPartWithMark
      }
    })
  };
};
const genVerticalStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-vertical`]: _extends$1(_extends$1({}, genDirectionStyle(token2, false)), {
      height: "100%"
    })
  };
};
const useStyle$8 = genComponentStyleHook("Slider", (token2) => {
  const sliderToken = merge(token2, {
    marginPart: (token2.controlHeight - token2.controlSize) / 2,
    marginFull: token2.controlSize / 2,
    marginPartWithMark: token2.controlHeightLG - token2.controlSize
  });
  return [genBaseStyle$3(sliderToken), genHorizontalStyle(sliderToken), genVerticalStyle(sliderToken)];
}, (token2) => {
  const increaseHandleWidth = 1;
  const controlSize = token2.controlHeightLG / 4;
  const controlSizeHover = token2.controlHeightSM / 2;
  const handleLineWidth = token2.lineWidth + increaseHandleWidth;
  const handleLineWidthHover = token2.lineWidth + increaseHandleWidth * 3;
  return {
    controlSize,
    railSize: 4,
    handleSize: controlSize,
    handleSizeHover: controlSizeHover,
    dotSize: 8,
    handleLineWidth,
    handleLineWidthHover
  };
});
var __rest$f = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const defaultTipFormatter = (value) => typeof value === "number" ? value.toString() : "";
const sliderProps = () => ({
  id: String,
  prefixCls: String,
  tooltipPrefixCls: String,
  range: someType([Boolean, Object]),
  reverse: booleanType(),
  min: Number,
  max: Number,
  step: someType([Object, Number]),
  marks: objectType(),
  dots: booleanType(),
  value: someType([Array, Number]),
  defaultValue: someType([Array, Number]),
  included: booleanType(),
  disabled: booleanType(),
  vertical: booleanType(),
  tipFormatter: someType([Function, Object], () => defaultTipFormatter),
  tooltipOpen: booleanType(),
  /** @deprecated `tooltipVisible` is deprecated. Please use `tooltipOpen` instead. */
  tooltipVisible: booleanType(),
  tooltipPlacement: stringType(),
  getTooltipPopupContainer: functionType(),
  autofocus: booleanType(),
  handleStyle: someType([Array, Object]),
  trackStyle: someType([Array, Object]),
  onChange: functionType(),
  onAfterChange: functionType(),
  onFocus: functionType(),
  onBlur: functionType(),
  "onUpdate:value": functionType()
});
const Slider = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ASlider",
  inheritAttrs: false,
  props: sliderProps(),
  // emits: ['update:value', 'change', 'afterChange', 'blur'],
  slots: Object,
  setup(props2, _ref) {
    let {
      attrs,
      slots,
      emit,
      expose
    } = _ref;
    const {
      prefixCls,
      rootPrefixCls,
      direction,
      getPopupContainer,
      configProvider
    } = useConfigInject("slider", props2);
    const [wrapSSR, hashId] = useStyle$8(prefixCls);
    const formItemContext = useInjectFormItemContext();
    const sliderRef = ref();
    const visibles = ref({});
    const toggleTooltipOpen = (index2, visible) => {
      visibles.value[index2] = visible;
    };
    const tooltipPlacement = computed(() => {
      if (props2.tooltipPlacement) {
        return props2.tooltipPlacement;
      }
      if (!props2.vertical) {
        return "top";
      }
      return direction.value === "rtl" ? "left" : "right";
    });
    const focus = () => {
      var _a2;
      (_a2 = sliderRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
    };
    const blur = () => {
      var _a2;
      (_a2 = sliderRef.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
    };
    const handleChange = (val) => {
      emit("update:value", val);
      emit("change", val);
      formItemContext.onFieldChange();
    };
    const handleBlur = (e2) => {
      emit("blur", e2);
    };
    expose({
      focus,
      blur
    });
    const handleWithTooltip = (_a2) => {
      var {
        tooltipPrefixCls
      } = _a2, _b = _a2.info, {
        value,
        dragging,
        index: index2
      } = _b, restProps = __rest$f(_b, ["value", "dragging", "index"]);
      const {
        tipFormatter,
        tooltipOpen = props2.tooltipVisible,
        getTooltipPopupContainer
      } = props2;
      const isTipFormatter = tipFormatter ? visibles.value[index2] || dragging : false;
      const open2 = tooltipOpen || tooltipOpen === void 0 && isTipFormatter;
      return createVNode(SliderTooltip, {
        "prefixCls": tooltipPrefixCls,
        "title": tipFormatter ? tipFormatter(value) : "",
        "open": open2,
        "placement": tooltipPlacement.value,
        "transitionName": `${rootPrefixCls.value}-zoom-down`,
        "key": index2,
        "overlayClassName": `${prefixCls.value}-tooltip`,
        "getPopupContainer": getTooltipPopupContainer || (getPopupContainer === null || getPopupContainer === void 0 ? void 0 : getPopupContainer.value)
      }, {
        default: () => [createVNode(VcHandle, _objectSpread2$1(_objectSpread2$1({}, restProps), {}, {
          "value": value,
          "onMouseenter": () => toggleTooltipOpen(index2, true),
          "onMouseleave": () => toggleTooltipOpen(index2, false)
        }), null)]
      });
    };
    return () => {
      const {
        tooltipPrefixCls: customizeTooltipPrefixCls,
        range: range3,
        id = formItemContext.id.value
      } = props2, restProps = __rest$f(props2, ["tooltipPrefixCls", "range", "id"]);
      const tooltipPrefixCls = configProvider.getPrefixCls("tooltip", customizeTooltipPrefixCls);
      const cls = classNames(attrs.class, {
        [`${prefixCls.value}-rtl`]: direction.value === "rtl"
      }, hashId.value);
      if (direction.value === "rtl" && !restProps.vertical) {
        restProps.reverse = !restProps.reverse;
      }
      let draggableTrack;
      if (typeof range3 === "object") {
        draggableTrack = range3.draggableTrack;
      }
      if (range3) {
        return wrapSSR(createVNode(VcRange, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, attrs), restProps), {}, {
          "step": restProps.step,
          "draggableTrack": draggableTrack,
          "class": cls,
          "ref": sliderRef,
          "handle": (info) => handleWithTooltip({
            tooltipPrefixCls,
            prefixCls: prefixCls.value,
            info
          }),
          "prefixCls": prefixCls.value,
          "onChange": handleChange,
          "onBlur": handleBlur
        }), {
          mark: slots.mark
        }));
      }
      return wrapSSR(createVNode(VcSlider, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, attrs), restProps), {}, {
        "id": id,
        "step": restProps.step,
        "class": cls,
        "ref": sliderRef,
        "handle": (info) => handleWithTooltip({
          tooltipPrefixCls,
          prefixCls: prefixCls.value,
          info
        }),
        "prefixCls": prefixCls.value,
        "onChange": handleChange,
        "onBlur": handleBlur
      }), {
        mark: slots.mark
      }));
    };
  }
});
const Slider$1 = withInstall(Slider);
const genSwitchSmallStyle = (token2) => {
  const {
    componentCls
  } = token2;
  const switchInnerCls = `${componentCls}-inner`;
  return {
    [componentCls]: {
      [`&${componentCls}-small`]: {
        minWidth: token2.switchMinWidthSM,
        height: token2.switchHeightSM,
        lineHeight: `${token2.switchHeightSM}px`,
        [`${componentCls}-inner`]: {
          paddingInlineStart: token2.switchInnerMarginMaxSM,
          paddingInlineEnd: token2.switchInnerMarginMinSM,
          [`${switchInnerCls}-checked`]: {
            marginInlineStart: `calc(-100% + ${token2.switchPinSizeSM + token2.switchPadding * 2}px - ${token2.switchInnerMarginMaxSM * 2}px)`,
            marginInlineEnd: `calc(100% - ${token2.switchPinSizeSM + token2.switchPadding * 2}px + ${token2.switchInnerMarginMaxSM * 2}px)`
          },
          [`${switchInnerCls}-unchecked`]: {
            marginTop: -token2.switchHeightSM,
            marginInlineStart: 0,
            marginInlineEnd: 0
          }
        },
        [`${componentCls}-handle`]: {
          width: token2.switchPinSizeSM,
          height: token2.switchPinSizeSM
        },
        [`${componentCls}-loading-icon`]: {
          top: (token2.switchPinSizeSM - token2.switchLoadingIconSize) / 2,
          fontSize: token2.switchLoadingIconSize
        },
        [`&${componentCls}-checked`]: {
          [`${componentCls}-inner`]: {
            paddingInlineStart: token2.switchInnerMarginMinSM,
            paddingInlineEnd: token2.switchInnerMarginMaxSM,
            [`${switchInnerCls}-checked`]: {
              marginInlineStart: 0,
              marginInlineEnd: 0
            },
            [`${switchInnerCls}-unchecked`]: {
              marginInlineStart: `calc(100% - ${token2.switchPinSizeSM + token2.switchPadding * 2}px + ${token2.switchInnerMarginMaxSM * 2}px)`,
              marginInlineEnd: `calc(-100% + ${token2.switchPinSizeSM + token2.switchPadding * 2}px - ${token2.switchInnerMarginMaxSM * 2}px)`
            }
          },
          [`${componentCls}-handle`]: {
            insetInlineStart: `calc(100% - ${token2.switchPinSizeSM + token2.switchPadding}px)`
          }
        },
        [`&:not(${componentCls}-disabled):active`]: {
          [`&:not(${componentCls}-checked) ${switchInnerCls}`]: {
            [`${switchInnerCls}-unchecked`]: {
              marginInlineStart: token2.marginXXS / 2,
              marginInlineEnd: -token2.marginXXS / 2
            }
          },
          [`&${componentCls}-checked ${switchInnerCls}`]: {
            [`${switchInnerCls}-checked`]: {
              marginInlineStart: -token2.marginXXS / 2,
              marginInlineEnd: token2.marginXXS / 2
            }
          }
        }
      }
    }
  };
};
const genSwitchLoadingStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [componentCls]: {
      [`${componentCls}-loading-icon${token2.iconCls}`]: {
        position: "relative",
        top: (token2.switchPinSize - token2.fontSize) / 2,
        color: token2.switchLoadingIconColor,
        verticalAlign: "top"
      },
      [`&${componentCls}-checked ${componentCls}-loading-icon`]: {
        color: token2.switchColor
      }
    }
  };
};
const genSwitchHandleStyle = (token2) => {
  const {
    componentCls
  } = token2;
  const switchHandleCls = `${componentCls}-handle`;
  return {
    [componentCls]: {
      [switchHandleCls]: {
        position: "absolute",
        top: token2.switchPadding,
        insetInlineStart: token2.switchPadding,
        width: token2.switchPinSize,
        height: token2.switchPinSize,
        transition: `all ${token2.switchDuration} ease-in-out`,
        "&::before": {
          position: "absolute",
          top: 0,
          insetInlineEnd: 0,
          bottom: 0,
          insetInlineStart: 0,
          backgroundColor: token2.colorWhite,
          borderRadius: token2.switchPinSize / 2,
          boxShadow: token2.switchHandleShadow,
          transition: `all ${token2.switchDuration} ease-in-out`,
          content: '""'
        }
      },
      [`&${componentCls}-checked ${switchHandleCls}`]: {
        insetInlineStart: `calc(100% - ${token2.switchPinSize + token2.switchPadding}px)`
      },
      [`&:not(${componentCls}-disabled):active`]: {
        [`${switchHandleCls}::before`]: {
          insetInlineEnd: token2.switchHandleActiveInset,
          insetInlineStart: 0
        },
        [`&${componentCls}-checked ${switchHandleCls}::before`]: {
          insetInlineEnd: 0,
          insetInlineStart: token2.switchHandleActiveInset
        }
      }
    }
  };
};
const genSwitchInnerStyle = (token2) => {
  const {
    componentCls
  } = token2;
  const switchInnerCls = `${componentCls}-inner`;
  return {
    [componentCls]: {
      [switchInnerCls]: {
        display: "block",
        overflow: "hidden",
        borderRadius: 100,
        height: "100%",
        paddingInlineStart: token2.switchInnerMarginMax,
        paddingInlineEnd: token2.switchInnerMarginMin,
        transition: `padding-inline-start ${token2.switchDuration} ease-in-out, padding-inline-end ${token2.switchDuration} ease-in-out`,
        [`${switchInnerCls}-checked, ${switchInnerCls}-unchecked`]: {
          display: "block",
          color: token2.colorTextLightSolid,
          fontSize: token2.fontSizeSM,
          transition: `margin-inline-start ${token2.switchDuration} ease-in-out, margin-inline-end ${token2.switchDuration} ease-in-out`,
          pointerEvents: "none"
        },
        [`${switchInnerCls}-checked`]: {
          marginInlineStart: `calc(-100% + ${token2.switchPinSize + token2.switchPadding * 2}px - ${token2.switchInnerMarginMax * 2}px)`,
          marginInlineEnd: `calc(100% - ${token2.switchPinSize + token2.switchPadding * 2}px + ${token2.switchInnerMarginMax * 2}px)`
        },
        [`${switchInnerCls}-unchecked`]: {
          marginTop: -token2.switchHeight,
          marginInlineStart: 0,
          marginInlineEnd: 0
        }
      },
      [`&${componentCls}-checked ${switchInnerCls}`]: {
        paddingInlineStart: token2.switchInnerMarginMin,
        paddingInlineEnd: token2.switchInnerMarginMax,
        [`${switchInnerCls}-checked`]: {
          marginInlineStart: 0,
          marginInlineEnd: 0
        },
        [`${switchInnerCls}-unchecked`]: {
          marginInlineStart: `calc(100% - ${token2.switchPinSize + token2.switchPadding * 2}px + ${token2.switchInnerMarginMax * 2}px)`,
          marginInlineEnd: `calc(-100% + ${token2.switchPinSize + token2.switchPadding * 2}px - ${token2.switchInnerMarginMax * 2}px)`
        }
      },
      [`&:not(${componentCls}-disabled):active`]: {
        [`&:not(${componentCls}-checked) ${switchInnerCls}`]: {
          [`${switchInnerCls}-unchecked`]: {
            marginInlineStart: token2.switchPadding * 2,
            marginInlineEnd: -token2.switchPadding * 2
          }
        },
        [`&${componentCls}-checked ${switchInnerCls}`]: {
          [`${switchInnerCls}-checked`]: {
            marginInlineStart: -token2.switchPadding * 2,
            marginInlineEnd: token2.switchPadding * 2
          }
        }
      }
    }
  };
};
const genSwitchStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [componentCls]: _extends$1(_extends$1(_extends$1(_extends$1({}, resetComponent(token2)), {
      position: "relative",
      display: "inline-block",
      boxSizing: "border-box",
      minWidth: token2.switchMinWidth,
      height: token2.switchHeight,
      lineHeight: `${token2.switchHeight}px`,
      verticalAlign: "middle",
      background: token2.colorTextQuaternary,
      border: "0",
      borderRadius: 100,
      cursor: "pointer",
      transition: `all ${token2.motionDurationMid}`,
      userSelect: "none",
      [`&:hover:not(${componentCls}-disabled)`]: {
        background: token2.colorTextTertiary
      }
    }), genFocusStyle(token2)), {
      [`&${componentCls}-checked`]: {
        background: token2.switchColor,
        [`&:hover:not(${componentCls}-disabled)`]: {
          background: token2.colorPrimaryHover
        }
      },
      [`&${componentCls}-loading, &${componentCls}-disabled`]: {
        cursor: "not-allowed",
        opacity: token2.switchDisabledOpacity,
        "*": {
          boxShadow: "none",
          cursor: "not-allowed"
        }
      },
      // rtl style
      [`&${componentCls}-rtl`]: {
        direction: "rtl"
      }
    })
  };
};
const useStyle$7 = genComponentStyleHook("Switch", (token2) => {
  const switchHeight = token2.fontSize * token2.lineHeight;
  const switchHeightSM = token2.controlHeight / 2;
  const switchPadding = 2;
  const switchPinSize = switchHeight - switchPadding * 2;
  const switchPinSizeSM = switchHeightSM - switchPadding * 2;
  const switchToken = merge(token2, {
    switchMinWidth: switchPinSize * 2 + switchPadding * 4,
    switchHeight,
    switchDuration: token2.motionDurationMid,
    switchColor: token2.colorPrimary,
    switchDisabledOpacity: token2.opacityLoading,
    switchInnerMarginMin: switchPinSize / 2,
    switchInnerMarginMax: switchPinSize + switchPadding + switchPadding * 2,
    switchPadding,
    switchPinSize,
    switchBg: token2.colorBgContainer,
    switchMinWidthSM: switchPinSizeSM * 2 + switchPadding * 2,
    switchHeightSM,
    switchInnerMarginMinSM: switchPinSizeSM / 2,
    switchInnerMarginMaxSM: switchPinSizeSM + switchPadding + switchPadding * 2,
    switchPinSizeSM,
    switchHandleShadow: `0 2px 4px 0 ${new TinyColor("#00230b").setAlpha(0.2).toRgbString()}`,
    switchLoadingIconSize: token2.fontSizeIcon * 0.75,
    switchLoadingIconColor: `rgba(0, 0, 0, ${token2.opacityLoading})`,
    switchHandleActiveInset: "-30%"
  });
  return [
    genSwitchStyle(switchToken),
    // inner style
    genSwitchInnerStyle(switchToken),
    // handle style
    genSwitchHandleStyle(switchToken),
    // loading style
    genSwitchLoadingStyle(switchToken),
    // small style
    genSwitchSmallStyle(switchToken)
  ];
});
const SwitchSizes = tuple$1("small", "default");
const switchProps = () => ({
  id: String,
  prefixCls: String,
  size: PropTypes.oneOf(SwitchSizes),
  disabled: {
    type: Boolean,
    default: void 0
  },
  checkedChildren: PropTypes.any,
  unCheckedChildren: PropTypes.any,
  tabindex: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  autofocus: {
    type: Boolean,
    default: void 0
  },
  loading: {
    type: Boolean,
    default: void 0
  },
  checked: PropTypes.oneOfType([PropTypes.string, PropTypes.number, PropTypes.looseBool]),
  checkedValue: PropTypes.oneOfType([PropTypes.string, PropTypes.number, PropTypes.looseBool]).def(true),
  unCheckedValue: PropTypes.oneOfType([PropTypes.string, PropTypes.number, PropTypes.looseBool]).def(false),
  onChange: {
    type: Function
  },
  onClick: {
    type: Function
  },
  onKeydown: {
    type: Function
  },
  onMouseup: {
    type: Function
  },
  "onUpdate:checked": {
    type: Function
  },
  onBlur: Function,
  onFocus: Function
});
const Switch = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ASwitch",
  __ANT_SWITCH: true,
  inheritAttrs: false,
  props: switchProps(),
  slots: Object,
  // emits: ['update:checked', 'mouseup', 'change', 'click', 'keydown', 'blur'],
  setup(props2, _ref) {
    let {
      attrs,
      slots,
      expose,
      emit
    } = _ref;
    const formItemContext = useInjectFormItemContext();
    const disabledContext = useInjectDisabled();
    const mergedDisabled = computed(() => {
      var _a2;
      return (_a2 = props2.disabled) !== null && _a2 !== void 0 ? _a2 : disabledContext.value;
    });
    onBeforeMount(() => {
    });
    const checked = ref(props2.checked !== void 0 ? props2.checked : attrs.defaultChecked);
    const checkedStatus = computed(() => checked.value === props2.checkedValue);
    watch(() => props2.checked, () => {
      checked.value = props2.checked;
    });
    const {
      prefixCls,
      direction,
      size
    } = useConfigInject("switch", props2);
    const [wrapSSR, hashId] = useStyle$7(prefixCls);
    const refSwitchNode = ref();
    const focus = () => {
      var _a2;
      (_a2 = refSwitchNode.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
    };
    const blur = () => {
      var _a2;
      (_a2 = refSwitchNode.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
    };
    expose({
      focus,
      blur
    });
    onMounted(() => {
      nextTick(() => {
        if (props2.autofocus && !mergedDisabled.value) {
          refSwitchNode.value.focus();
        }
      });
    });
    const setChecked = (check, e2) => {
      if (mergedDisabled.value) {
        return;
      }
      emit("update:checked", check);
      emit("change", check, e2);
      formItemContext.onFieldChange();
    };
    const handleBlur = (e2) => {
      emit("blur", e2);
    };
    const handleClick = (e2) => {
      focus();
      const newChecked = checkedStatus.value ? props2.unCheckedValue : props2.checkedValue;
      setChecked(newChecked, e2);
      emit("click", newChecked, e2);
    };
    const handleKeyDown = (e2) => {
      if (e2.keyCode === KeyCode.LEFT) {
        setChecked(props2.unCheckedValue, e2);
      } else if (e2.keyCode === KeyCode.RIGHT) {
        setChecked(props2.checkedValue, e2);
      }
      emit("keydown", e2);
    };
    const handleMouseUp = (e2) => {
      var _a2;
      (_a2 = refSwitchNode.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
      emit("mouseup", e2);
    };
    const classNames2 = computed(() => ({
      [`${prefixCls.value}-small`]: size.value === "small",
      [`${prefixCls.value}-loading`]: props2.loading,
      [`${prefixCls.value}-checked`]: checkedStatus.value,
      [`${prefixCls.value}-disabled`]: mergedDisabled.value,
      [prefixCls.value]: true,
      [`${prefixCls.value}-rtl`]: direction.value === "rtl",
      [hashId.value]: true
    }));
    return () => {
      var _a2;
      return wrapSSR(createVNode(Wave, null, {
        default: () => [createVNode("button", _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, omit$1(props2, ["prefixCls", "checkedChildren", "unCheckedChildren", "checked", "autofocus", "checkedValue", "unCheckedValue", "id", "onChange", "onUpdate:checked"])), attrs), {}, {
          "id": (_a2 = props2.id) !== null && _a2 !== void 0 ? _a2 : formItemContext.id.value,
          "onKeydown": handleKeyDown,
          "onClick": handleClick,
          "onBlur": handleBlur,
          "onMouseup": handleMouseUp,
          "type": "button",
          "role": "switch",
          "aria-checked": checked.value,
          "disabled": mergedDisabled.value || props2.loading,
          "class": [attrs.class, classNames2.value],
          "ref": refSwitchNode
        }), [createVNode("div", {
          "class": `${prefixCls.value}-handle`
        }, [props2.loading ? createVNode(LoadingOutlined, {
          "class": `${prefixCls.value}-loading-icon`
        }, null) : null]), createVNode("span", {
          "class": `${prefixCls.value}-inner`
        }, [createVNode("span", {
          "class": `${prefixCls.value}-inner-checked`
        }, [getPropsSlot(slots, props2, "checkedChildren")]), createVNode("span", {
          "class": `${prefixCls.value}-inner-unchecked`
        }, [getPropsSlot(slots, props2, "unCheckedChildren")])])])]
      }));
    };
  }
});
const Switch$1 = withInstall(Switch);
const TableContextKey = Symbol("TableContextProps");
const useProvideTable = (props2) => {
  provide(TableContextKey, props2);
};
const useInjectTable = () => {
  return inject(TableContextKey, {});
};
const INTERNAL_KEY_PREFIX = "RC_TABLE_KEY";
function toArray(arr) {
  if (arr === void 0 || arr === null) {
    return [];
  }
  return Array.isArray(arr) ? arr : [arr];
}
function getPathValue(record, path2) {
  if (!path2 && typeof path2 !== "number") {
    return record;
  }
  const pathList = toArray(path2);
  let current = record;
  for (let i2 = 0; i2 < pathList.length; i2 += 1) {
    if (!current) {
      return null;
    }
    const prop = pathList[i2];
    current = current[prop];
  }
  return current;
}
function getColumnsKey(columns) {
  const columnKeys = [];
  const keys2 = {};
  columns.forEach((column2) => {
    const {
      key: key2,
      dataIndex
    } = column2 || {};
    let mergedKey = key2 || toArray(dataIndex).join("-") || INTERNAL_KEY_PREFIX;
    while (keys2[mergedKey]) {
      mergedKey = `${mergedKey}_next`;
    }
    keys2[mergedKey] = true;
    columnKeys.push(mergedKey);
  });
  return columnKeys;
}
function mergeObject() {
  const merged = {};
  function fillProps(obj, clone2) {
    if (clone2) {
      Object.keys(clone2).forEach((key2) => {
        const value = clone2[key2];
        if (value && typeof value === "object") {
          obj[key2] = obj[key2] || {};
          fillProps(obj[key2], value);
        } else {
          obj[key2] = value;
        }
      });
    }
  }
  for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {
    objects[_key] = arguments[_key];
  }
  objects.forEach((clone2) => {
    fillProps(merged, clone2);
  });
  return merged;
}
function validateValue(val) {
  return val !== null && val !== void 0;
}
const SlotsContextKey = Symbol("SlotsContextProps");
const useProvideSlots = (props2) => {
  provide(SlotsContextKey, props2);
};
const useInjectSlots = () => {
  return inject(SlotsContextKey, computed(() => ({})));
};
const ContextKey = Symbol("ContextProps");
const useProvideTableContext = (props2) => {
  provide(ContextKey, props2);
};
const useInjectTableContext = () => {
  return inject(ContextKey, {
    onResizeColumn: () => {
    }
  });
};
const INTERNAL_COL_DEFINE = "RC_TABLE_INTERNAL_COL_DEFINE";
const HoverContextKey = Symbol("HoverContextProps");
const useProvideHover = (props2) => {
  provide(HoverContextKey, props2);
};
const useInjectHover = () => {
  return inject(HoverContextKey, {
    startRow: shallowRef(-1),
    endRow: shallowRef(-1),
    onHover() {
    }
  });
};
const supportSticky = shallowRef(false);
const useProvideSticky = () => {
  onMounted(() => {
    supportSticky.value = supportSticky.value || isStyleSupport("position", "sticky");
  });
};
const useInjectSticky = () => {
  return supportSticky;
};
var __rest$e = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
function inHoverRange(cellStartRow, cellRowSpan, startRow, endRow) {
  const cellEndRow = cellStartRow + cellRowSpan - 1;
  return cellStartRow <= endRow && cellEndRow >= startRow;
}
function isRenderCell(data) {
  return data && typeof data === "object" && !Array.isArray(data) && !isVNode(data);
}
const Cell = defineComponent({
  name: "Cell",
  props: ["prefixCls", "record", "index", "renderIndex", "dataIndex", "customRender", "component", "colSpan", "rowSpan", "fixLeft", "fixRight", "firstFixLeft", "lastFixLeft", "firstFixRight", "lastFixRight", "appendNode", "additionalProps", "ellipsis", "align", "rowType", "isSticky", "column", "cellType", "transformCellText"],
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const contextSlots = useInjectSlots();
    const {
      onHover,
      startRow,
      endRow
    } = useInjectHover();
    const colSpan = computed(() => {
      var _a2, _b, _c, _d;
      return (_c = (_a2 = props2.colSpan) !== null && _a2 !== void 0 ? _a2 : (_b = props2.additionalProps) === null || _b === void 0 ? void 0 : _b.colSpan) !== null && _c !== void 0 ? _c : (_d = props2.additionalProps) === null || _d === void 0 ? void 0 : _d.colspan;
    });
    const rowSpan = computed(() => {
      var _a2, _b, _c, _d;
      return (_c = (_a2 = props2.rowSpan) !== null && _a2 !== void 0 ? _a2 : (_b = props2.additionalProps) === null || _b === void 0 ? void 0 : _b.rowSpan) !== null && _c !== void 0 ? _c : (_d = props2.additionalProps) === null || _d === void 0 ? void 0 : _d.rowspan;
    });
    const hovering = eagerComputed(() => {
      const {
        index: index2
      } = props2;
      return inHoverRange(index2, rowSpan.value || 1, startRow.value, endRow.value);
    });
    const supportSticky2 = useInjectSticky();
    const onMouseenter = (event, mergedRowSpan) => {
      var _a2;
      const {
        record,
        index: index2,
        additionalProps
      } = props2;
      if (record) {
        onHover(index2, index2 + mergedRowSpan - 1);
      }
      (_a2 = additionalProps === null || additionalProps === void 0 ? void 0 : additionalProps.onMouseenter) === null || _a2 === void 0 ? void 0 : _a2.call(additionalProps, event);
    };
    const onMouseleave = (event) => {
      var _a2;
      const {
        record,
        additionalProps
      } = props2;
      if (record) {
        onHover(-1, -1);
      }
      (_a2 = additionalProps === null || additionalProps === void 0 ? void 0 : additionalProps.onMouseleave) === null || _a2 === void 0 ? void 0 : _a2.call(additionalProps, event);
    };
    const getTitle = (vnodes) => {
      const vnode = filterEmpty(vnodes)[0];
      if (isVNode(vnode)) {
        if (vnode.type === Text$1) {
          return vnode.children;
        } else {
          return Array.isArray(vnode.children) ? getTitle(vnode.children) : void 0;
        }
      } else {
        return vnode;
      }
    };
    const hoverRef = shallowRef(null);
    watch([hovering, () => props2.prefixCls, hoverRef], () => {
      const cellDom = findDOMNode(hoverRef.value);
      if (!cellDom) return;
      if (hovering.value) {
        addClass(cellDom, `${props2.prefixCls}-cell-row-hover`);
      } else {
        removeClass(cellDom, `${props2.prefixCls}-cell-row-hover`);
      }
    });
    return () => {
      var _a2, _b, _c, _d, _e, _f;
      const {
        prefixCls,
        record,
        index: index2,
        renderIndex,
        dataIndex,
        customRender,
        component: Component = "td",
        fixLeft,
        fixRight,
        firstFixLeft,
        lastFixLeft,
        firstFixRight,
        lastFixRight,
        appendNode = (_a2 = slots.appendNode) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
        additionalProps = {},
        ellipsis,
        align,
        rowType,
        isSticky,
        column: column2 = {},
        cellType
      } = props2;
      const cellPrefixCls = `${prefixCls}-cell`;
      let cellProps;
      let childNode;
      const children = (_b = slots.default) === null || _b === void 0 ? void 0 : _b.call(slots);
      if (validateValue(children) || cellType === "header") {
        childNode = children;
      } else {
        const value = getPathValue(record, dataIndex);
        childNode = value;
        if (customRender) {
          const renderData = customRender({
            text: value,
            value,
            record,
            index: index2,
            renderIndex,
            column: column2.__originColumn__
          });
          if (isRenderCell(renderData)) {
            childNode = renderData.children;
            cellProps = renderData.props;
          } else {
            childNode = renderData;
          }
        }
        if (!(INTERNAL_COL_DEFINE in column2) && cellType === "body" && contextSlots.value.bodyCell && !((_c = column2.slots) === null || _c === void 0 ? void 0 : _c.customRender)) {
          const child = customRenderSlot(contextSlots.value, "bodyCell", {
            text: value,
            value,
            record,
            index: index2,
            column: column2.__originColumn__
          }, () => {
            const fallback = childNode === void 0 ? value : childNode;
            return [typeof fallback === "object" && isValidElement(fallback) || typeof fallback !== "object" ? fallback : null];
          });
          childNode = flattenChildren(child);
        }
        if (props2.transformCellText) {
          childNode = props2.transformCellText({
            text: childNode,
            record,
            index: index2,
            column: column2.__originColumn__
          });
        }
      }
      if (typeof childNode === "object" && !Array.isArray(childNode) && !isVNode(childNode)) {
        childNode = null;
      }
      if (ellipsis && (lastFixLeft || firstFixRight)) {
        childNode = createVNode("span", {
          "class": `${cellPrefixCls}-content`
        }, [childNode]);
      }
      if (Array.isArray(childNode) && childNode.length === 1) {
        childNode = childNode[0];
      }
      const _g = cellProps || {}, {
        colSpan: cellColSpan,
        rowSpan: cellRowSpan,
        style: cellStyle,
        class: cellClassName
      } = _g, restCellProps = __rest$e(_g, ["colSpan", "rowSpan", "style", "class"]);
      const mergedColSpan = (_d = cellColSpan !== void 0 ? cellColSpan : colSpan.value) !== null && _d !== void 0 ? _d : 1;
      const mergedRowSpan = (_e = cellRowSpan !== void 0 ? cellRowSpan : rowSpan.value) !== null && _e !== void 0 ? _e : 1;
      if (mergedColSpan === 0 || mergedRowSpan === 0) {
        return null;
      }
      const fixedStyle = {};
      const isFixLeft = typeof fixLeft === "number" && supportSticky2.value;
      const isFixRight = typeof fixRight === "number" && supportSticky2.value;
      if (isFixLeft) {
        fixedStyle.position = "sticky";
        fixedStyle.left = `${fixLeft}px`;
      }
      if (isFixRight) {
        fixedStyle.position = "sticky";
        fixedStyle.right = `${fixRight}px`;
      }
      const alignStyle = {};
      if (align) {
        alignStyle.textAlign = align;
      }
      let title;
      const ellipsisConfig = ellipsis === true ? {
        showTitle: true
      } : ellipsis;
      if (ellipsisConfig && (ellipsisConfig.showTitle || rowType === "header")) {
        if (typeof childNode === "string" || typeof childNode === "number") {
          title = childNode.toString();
        } else if (isVNode(childNode)) {
          title = getTitle([childNode]);
        }
      }
      const componentProps = _extends$1(_extends$1(_extends$1({
        title
      }, restCellProps), additionalProps), {
        colSpan: mergedColSpan !== 1 ? mergedColSpan : null,
        rowSpan: mergedRowSpan !== 1 ? mergedRowSpan : null,
        class: classNames(cellPrefixCls, {
          [`${cellPrefixCls}-fix-left`]: isFixLeft && supportSticky2.value,
          [`${cellPrefixCls}-fix-left-first`]: firstFixLeft && supportSticky2.value,
          [`${cellPrefixCls}-fix-left-last`]: lastFixLeft && supportSticky2.value,
          [`${cellPrefixCls}-fix-right`]: isFixRight && supportSticky2.value,
          [`${cellPrefixCls}-fix-right-first`]: firstFixRight && supportSticky2.value,
          [`${cellPrefixCls}-fix-right-last`]: lastFixRight && supportSticky2.value,
          [`${cellPrefixCls}-ellipsis`]: ellipsis,
          [`${cellPrefixCls}-with-append`]: appendNode,
          [`${cellPrefixCls}-fix-sticky`]: (isFixLeft || isFixRight) && isSticky && supportSticky2.value
        }, additionalProps.class, cellClassName),
        onMouseenter: (e2) => {
          onMouseenter(e2, mergedRowSpan);
        },
        onMouseleave,
        style: [additionalProps.style, alignStyle, fixedStyle, cellStyle]
      });
      return createVNode(Component, _objectSpread2$1(_objectSpread2$1({}, componentProps), {}, {
        "ref": hoverRef
      }), {
        default: () => [appendNode, childNode, (_f = slots.dragHandle) === null || _f === void 0 ? void 0 : _f.call(slots)]
      });
    };
  }
});
function getCellFixedInfo(colStart, colEnd, columns, stickyOffsets, direction) {
  const startColumn = columns[colStart] || {};
  const endColumn = columns[colEnd] || {};
  let fixLeft;
  let fixRight;
  if (startColumn.fixed === "left") {
    fixLeft = stickyOffsets.left[colStart];
  } else if (endColumn.fixed === "right") {
    fixRight = stickyOffsets.right[colEnd];
  }
  let lastFixLeft = false;
  let firstFixRight = false;
  let lastFixRight = false;
  let firstFixLeft = false;
  const nextColumn = columns[colEnd + 1];
  const prevColumn = columns[colStart - 1];
  if (direction === "rtl") {
    if (fixLeft !== void 0) {
      const prevFixLeft = prevColumn && prevColumn.fixed === "left";
      firstFixLeft = !prevFixLeft;
    } else if (fixRight !== void 0) {
      const nextFixRight = nextColumn && nextColumn.fixed === "right";
      lastFixRight = !nextFixRight;
    }
  } else if (fixLeft !== void 0) {
    const nextFixLeft = nextColumn && nextColumn.fixed === "left";
    lastFixLeft = !nextFixLeft;
  } else if (fixRight !== void 0) {
    const prevFixRight = prevColumn && prevColumn.fixed === "right";
    firstFixRight = !prevFixRight;
  }
  return {
    fixLeft,
    fixRight,
    lastFixLeft,
    firstFixRight,
    lastFixRight,
    firstFixLeft,
    isSticky: stickyOffsets.isSticky
  };
}
const events = {
  mouse: {
    start: "mousedown",
    move: "mousemove",
    stop: "mouseup"
  },
  touch: {
    start: "touchstart",
    move: "touchmove",
    stop: "touchend"
  }
};
const defaultMinWidth = 50;
const DragHandleVue = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "DragHandle",
  props: {
    prefixCls: String,
    width: {
      type: Number,
      required: true
    },
    minWidth: {
      type: Number,
      default: defaultMinWidth
    },
    maxWidth: {
      type: Number,
      default: Infinity
    },
    column: {
      type: Object,
      default: void 0
    }
  },
  setup(props2) {
    let startX = 0;
    let moveEvent = {
      remove: () => {
      }
    };
    let stopEvent = {
      remove: () => {
      }
    };
    const removeEvents = () => {
      moveEvent.remove();
      stopEvent.remove();
    };
    onUnmounted(() => {
      removeEvents();
    });
    watchEffect(() => {
      devWarning(!isNaN(props2.width), "Table", "width must be a number when use resizable");
    });
    const {
      onResizeColumn
    } = useInjectTableContext();
    const minWidth = computed(() => {
      return typeof props2.minWidth === "number" && !isNaN(props2.minWidth) ? props2.minWidth : defaultMinWidth;
    });
    const maxWidth = computed(() => {
      return typeof props2.maxWidth === "number" && !isNaN(props2.maxWidth) ? props2.maxWidth : Infinity;
    });
    const instance = getCurrentInstance();
    let baseWidth = 0;
    const dragging = shallowRef(false);
    let rafId;
    const updateWidth = (e2) => {
      let pageX = 0;
      if (e2.touches) {
        if (e2.touches.length) {
          pageX = e2.touches[0].pageX;
        } else {
          pageX = e2.changedTouches[0].pageX;
        }
      } else {
        pageX = e2.pageX;
      }
      const tmpDeltaX = startX - pageX;
      let w2 = Math.max(baseWidth - tmpDeltaX, minWidth.value);
      w2 = Math.min(w2, maxWidth.value);
      wrapperRaf.cancel(rafId);
      rafId = wrapperRaf(() => {
        onResizeColumn(w2, props2.column.__originColumn__);
      });
    };
    const handleMove = (e2) => {
      updateWidth(e2);
    };
    const handleStop = (e2) => {
      dragging.value = false;
      updateWidth(e2);
      removeEvents();
    };
    const handleStart = (e2, eventsFor) => {
      dragging.value = true;
      removeEvents();
      baseWidth = instance.vnode.el.parentNode.getBoundingClientRect().width;
      if (e2 instanceof MouseEvent && e2.which !== 1) {
        return;
      }
      if (e2.stopPropagation) e2.stopPropagation();
      startX = e2.touches ? e2.touches[0].pageX : e2.pageX;
      moveEvent = addEventListenerWrap(document.documentElement, eventsFor.move, handleMove);
      stopEvent = addEventListenerWrap(document.documentElement, eventsFor.stop, handleStop);
    };
    const handleDown = (e2) => {
      e2.stopPropagation();
      e2.preventDefault();
      handleStart(e2, events.mouse);
    };
    const handleTouchDown = (e2) => {
      e2.stopPropagation();
      e2.preventDefault();
      handleStart(e2, events.touch);
    };
    const handleClick = (e2) => {
      e2.stopPropagation();
      e2.preventDefault();
    };
    return () => {
      const {
        prefixCls
      } = props2;
      const touchEvents = {
        [supportsPassive ? "onTouchstartPassive" : "onTouchstart"]: (e2) => handleTouchDown(e2)
      };
      return createVNode("div", _objectSpread2$1(_objectSpread2$1({
        "class": `${prefixCls}-resize-handle ${dragging.value ? "dragging" : ""}`,
        "onMousedown": handleDown
      }, touchEvents), {}, {
        "onClick": handleClick
      }), [createVNode("div", {
        "class": `${prefixCls}-resize-handle-line`
      }, null)]);
    };
  }
});
const HeaderRow = defineComponent({
  name: "HeaderRow",
  props: ["cells", "stickyOffsets", "flattenColumns", "rowComponent", "cellComponent", "index", "customHeaderRow"],
  setup(props2) {
    const tableContext = useInjectTable();
    return () => {
      const {
        prefixCls,
        direction
      } = tableContext;
      const {
        cells,
        stickyOffsets,
        flattenColumns,
        rowComponent: RowComponent,
        cellComponent: CellComponent,
        customHeaderRow,
        index: index2
      } = props2;
      let rowProps2;
      if (customHeaderRow) {
        rowProps2 = customHeaderRow(cells.map((cell) => cell.column), index2);
      }
      const columnsKey = getColumnsKey(cells.map((cell) => cell.column));
      return createVNode(RowComponent, rowProps2, {
        default: () => [cells.map((cell, cellIndex) => {
          const {
            column: column2
          } = cell;
          const fixedInfo = getCellFixedInfo(cell.colStart, cell.colEnd, flattenColumns, stickyOffsets, direction);
          let additionalProps;
          if (column2 && column2.customHeaderCell) {
            additionalProps = cell.column.customHeaderCell(column2);
          }
          const col = column2;
          return createVNode(Cell, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, cell), {}, {
            "cellType": "header",
            "ellipsis": column2.ellipsis,
            "align": column2.align,
            "component": CellComponent,
            "prefixCls": prefixCls,
            "key": columnsKey[cellIndex]
          }, fixedInfo), {}, {
            "additionalProps": additionalProps,
            "rowType": "header",
            "column": column2
          }), {
            default: () => column2.title,
            dragHandle: () => col.resizable ? createVNode(DragHandleVue, {
              "prefixCls": prefixCls,
              "width": col.width,
              "minWidth": col.minWidth,
              "maxWidth": col.maxWidth,
              "column": col
            }, null) : null
          });
        })]
      });
    };
  }
});
function parseHeaderRows(rootColumns) {
  const rows = [];
  function fillRowCells(columns, colIndex) {
    let rowIndex = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    rows[rowIndex] = rows[rowIndex] || [];
    let currentColIndex = colIndex;
    const colSpans = columns.filter(Boolean).map((column2) => {
      const cell = {
        key: column2.key,
        class: classNames(column2.className, column2.class),
        // children: column.title,
        column: column2,
        colStart: currentColIndex
      };
      let colSpan = 1;
      const subColumns = column2.children;
      if (subColumns && subColumns.length > 0) {
        colSpan = fillRowCells(subColumns, currentColIndex, rowIndex + 1).reduce((total, count) => total + count, 0);
        cell.hasSubColumns = true;
      }
      if ("colSpan" in column2) {
        ({
          colSpan
        } = column2);
      }
      if ("rowSpan" in column2) {
        cell.rowSpan = column2.rowSpan;
      }
      cell.colSpan = colSpan;
      cell.colEnd = cell.colStart + colSpan - 1;
      rows[rowIndex].push(cell);
      currentColIndex += colSpan;
      return colSpan;
    });
    return colSpans;
  }
  fillRowCells(rootColumns, 0);
  const rowCount = rows.length;
  for (let rowIndex = 0; rowIndex < rowCount; rowIndex += 1) {
    rows[rowIndex].forEach((cell) => {
      if (!("rowSpan" in cell) && !cell.hasSubColumns) {
        cell.rowSpan = rowCount - rowIndex;
      }
    });
  }
  return rows;
}
const Header = defineComponent({
  name: "TableHeader",
  inheritAttrs: false,
  props: ["columns", "flattenColumns", "stickyOffsets", "customHeaderRow"],
  setup(props2) {
    const tableContext = useInjectTable();
    const rows = computed(() => parseHeaderRows(props2.columns));
    return () => {
      const {
        prefixCls,
        getComponent: getComponent2
      } = tableContext;
      const {
        stickyOffsets,
        flattenColumns,
        customHeaderRow
      } = props2;
      const WrapperComponent = getComponent2(["header", "wrapper"], "thead");
      const trComponent = getComponent2(["header", "row"], "tr");
      const thComponent = getComponent2(["header", "cell"], "th");
      return createVNode(WrapperComponent, {
        "class": `${prefixCls}-thead`
      }, {
        default: () => [rows.value.map((row, rowIndex) => {
          const rowNode = createVNode(HeaderRow, {
            "key": rowIndex,
            "flattenColumns": flattenColumns,
            "cells": row,
            "stickyOffsets": stickyOffsets,
            "rowComponent": trComponent,
            "cellComponent": thComponent,
            "customHeaderRow": customHeaderRow,
            "index": rowIndex
          }, null);
          return rowNode;
        })]
      });
    };
  }
});
const ExpandedRowContextKey = Symbol("ExpandedRowProps");
const useProvideExpandedRow = (props2) => {
  provide(ExpandedRowContextKey, props2);
};
const useInjectExpandedRow = () => {
  return inject(ExpandedRowContextKey, {});
};
const ExpandedRow = defineComponent({
  name: "ExpandedRow",
  inheritAttrs: false,
  props: ["prefixCls", "component", "cellComponent", "expanded", "colSpan", "isEmpty"],
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const tableContext = useInjectTable();
    const expandedRowContext = useInjectExpandedRow();
    const {
      fixHeader,
      fixColumn,
      componentWidth,
      horizonScroll
    } = expandedRowContext;
    return () => {
      const {
        prefixCls,
        component: Component,
        cellComponent,
        expanded,
        colSpan,
        isEmpty: isEmpty2
      } = props2;
      return createVNode(Component, {
        "class": attrs.class,
        "style": {
          display: expanded ? null : "none"
        }
      }, {
        default: () => [createVNode(Cell, {
          "component": cellComponent,
          "prefixCls": prefixCls,
          "colSpan": colSpan
        }, {
          default: () => {
            var _a2;
            let contentNode = (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
            if (isEmpty2 ? horizonScroll.value : fixColumn.value) {
              contentNode = createVNode("div", {
                "style": {
                  width: `${componentWidth.value - (fixHeader.value ? tableContext.scrollbarSize : 0)}px`,
                  position: "sticky",
                  left: 0,
                  overflow: "hidden"
                },
                "class": `${prefixCls}-expanded-row-fixed`
              }, [contentNode]);
            }
            return contentNode;
          }
        })]
      });
    };
  }
});
const MeasureCell = defineComponent({
  name: "MeasureCell",
  props: ["columnKey"],
  setup(props2, _ref) {
    let {
      emit
    } = _ref;
    const tdRef = ref();
    onMounted(() => {
      if (tdRef.value) {
        emit("columnResize", props2.columnKey, tdRef.value.offsetWidth);
      }
    });
    return () => {
      return createVNode(ResizeObserver$1, {
        "onResize": (_ref2) => {
          let {
            offsetWidth
          } = _ref2;
          emit("columnResize", props2.columnKey, offsetWidth);
        }
      }, {
        default: () => [createVNode("td", {
          "ref": tdRef,
          "style": {
            padding: 0,
            border: 0,
            height: 0
          }
        }, [createVNode("div", {
          "style": {
            height: 0,
            overflow: "hidden"
          }
        }, [createTextVNode(" ")])])]
      });
    };
  }
});
const BodyContextKey = Symbol("BodyContextProps");
const useProvideBody = (props2) => {
  provide(BodyContextKey, props2);
};
const useInjectBody = () => {
  return inject(BodyContextKey, {});
};
const BodyRow = defineComponent({
  name: "BodyRow",
  inheritAttrs: false,
  props: ["record", "index", "renderIndex", "recordKey", "expandedKeys", "rowComponent", "cellComponent", "customRow", "rowExpandable", "indent", "rowKey", "getRowKey", "childrenColumnName"],
  setup(props2, _ref) {
    let {
      attrs
    } = _ref;
    const tableContext = useInjectTable();
    const bodyContext = useInjectBody();
    const expandRended = shallowRef(false);
    const expanded = computed(() => props2.expandedKeys && props2.expandedKeys.has(props2.recordKey));
    watchEffect(() => {
      if (expanded.value) {
        expandRended.value = true;
      }
    });
    const rowSupportExpand = computed(() => bodyContext.expandableType === "row" && (!props2.rowExpandable || props2.rowExpandable(props2.record)));
    const nestExpandable = computed(() => bodyContext.expandableType === "nest");
    const hasNestChildren = computed(() => props2.childrenColumnName && props2.record && props2.record[props2.childrenColumnName]);
    const mergedExpandable = computed(() => rowSupportExpand.value || nestExpandable.value);
    const onInternalTriggerExpand = (record, event) => {
      bodyContext.onTriggerExpand(record, event);
    };
    const additionalProps = computed(() => {
      var _a2;
      return ((_a2 = props2.customRow) === null || _a2 === void 0 ? void 0 : _a2.call(props2, props2.record, props2.index)) || {};
    });
    const onClick = function(event) {
      var _a2, _b;
      if (bodyContext.expandRowByClick && mergedExpandable.value) {
        onInternalTriggerExpand(props2.record, event);
      }
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      (_b = (_a2 = additionalProps.value) === null || _a2 === void 0 ? void 0 : _a2.onClick) === null || _b === void 0 ? void 0 : _b.call(_a2, event, ...args);
    };
    const computeRowClassName = computed(() => {
      const {
        record,
        index: index2,
        indent
      } = props2;
      const {
        rowClassName
      } = bodyContext;
      if (typeof rowClassName === "string") {
        return rowClassName;
      } else if (typeof rowClassName === "function") {
        return rowClassName(record, index2, indent);
      }
      return "";
    });
    const columnsKey = computed(() => getColumnsKey(bodyContext.flattenColumns));
    return () => {
      const {
        class: className,
        style
      } = attrs;
      const {
        record,
        index: index2,
        rowKey,
        indent = 0,
        rowComponent: RowComponent,
        cellComponent
      } = props2;
      const {
        prefixCls,
        fixedInfoList,
        transformCellText
      } = tableContext;
      const {
        flattenColumns,
        expandedRowClassName,
        indentSize,
        expandIcon,
        expandedRowRender,
        expandIconColumnIndex
      } = bodyContext;
      const baseRowNode = createVNode(RowComponent, _objectSpread2$1(_objectSpread2$1({}, additionalProps.value), {}, {
        "data-row-key": rowKey,
        "class": classNames(className, `${prefixCls}-row`, `${prefixCls}-row-level-${indent}`, computeRowClassName.value, additionalProps.value.class),
        "style": [style, additionalProps.value.style],
        "onClick": onClick
      }), {
        default: () => [flattenColumns.map((column2, colIndex) => {
          const {
            customRender,
            dataIndex,
            className: columnClassName
          } = column2;
          const key2 = columnsKey[colIndex];
          const fixedInfo = fixedInfoList[colIndex];
          let additionalCellProps;
          if (column2.customCell) {
            additionalCellProps = column2.customCell(record, index2, column2);
          }
          const appendNode = colIndex === (expandIconColumnIndex || 0) && nestExpandable.value ? createVNode(Fragment, null, [createVNode("span", {
            "style": {
              paddingLeft: `${indentSize * indent}px`
            },
            "class": `${prefixCls}-row-indent indent-level-${indent}`
          }, null), expandIcon({
            prefixCls,
            expanded: expanded.value,
            expandable: hasNestChildren.value,
            record,
            onExpand: onInternalTriggerExpand
          })]) : null;
          return createVNode(Cell, _objectSpread2$1(_objectSpread2$1({
            "cellType": "body",
            "class": columnClassName,
            "ellipsis": column2.ellipsis,
            "align": column2.align,
            "component": cellComponent,
            "prefixCls": prefixCls,
            "key": key2,
            "record": record,
            "index": index2,
            "renderIndex": props2.renderIndex,
            "dataIndex": dataIndex,
            "customRender": customRender
          }, fixedInfo), {}, {
            "additionalProps": additionalCellProps,
            "column": column2,
            "transformCellText": transformCellText,
            "appendNode": appendNode
          }), null);
        })]
      });
      let expandRowNode;
      if (rowSupportExpand.value && (expandRended.value || expanded.value)) {
        const expandContent = expandedRowRender({
          record,
          index: index2,
          indent: indent + 1,
          expanded: expanded.value
        });
        const computedExpandedRowClassName = expandedRowClassName && expandedRowClassName(record, index2, indent);
        expandRowNode = createVNode(ExpandedRow, {
          "expanded": expanded.value,
          "class": classNames(`${prefixCls}-expanded-row`, `${prefixCls}-expanded-row-level-${indent + 1}`, computedExpandedRowClassName),
          "prefixCls": prefixCls,
          "component": RowComponent,
          "cellComponent": cellComponent,
          "colSpan": flattenColumns.length,
          "isEmpty": false
        }, {
          default: () => [expandContent]
        });
      }
      return createVNode(Fragment, null, [baseRowNode, expandRowNode]);
    };
  }
});
function flatRecord(record, indent, childrenColumnName, expandedKeys, getRowKey, index2) {
  const arr = [];
  arr.push({
    record,
    indent,
    index: index2
  });
  const key2 = getRowKey(record);
  const expanded = expandedKeys === null || expandedKeys === void 0 ? void 0 : expandedKeys.has(key2);
  if (record && Array.isArray(record[childrenColumnName]) && expanded) {
    for (let i2 = 0; i2 < record[childrenColumnName].length; i2 += 1) {
      const tempArr = flatRecord(record[childrenColumnName][i2], indent + 1, childrenColumnName, expandedKeys, getRowKey, i2);
      arr.push(...tempArr);
    }
  }
  return arr;
}
function useFlattenRecords(dataRef, childrenColumnNameRef, expandedKeysRef, getRowKey) {
  const arr = computed(() => {
    const childrenColumnName = childrenColumnNameRef.value;
    const expandedKeys = expandedKeysRef.value;
    const data = dataRef.value;
    if (expandedKeys === null || expandedKeys === void 0 ? void 0 : expandedKeys.size) {
      const temp = [];
      for (let i2 = 0; i2 < (data === null || data === void 0 ? void 0 : data.length); i2 += 1) {
        const record = data[i2];
        temp.push(...flatRecord(record, 0, childrenColumnName, expandedKeys, getRowKey.value, i2));
      }
      return temp;
    }
    return data === null || data === void 0 ? void 0 : data.map((item, index2) => {
      return {
        record: item,
        indent: 0,
        index: index2
      };
    });
  });
  return arr;
}
const ResizeContextKey = Symbol("ResizeContextProps");
const useProvideResize = (props2) => {
  provide(ResizeContextKey, props2);
};
const useInjectResize = () => {
  return inject(ResizeContextKey, {
    onColumnResize: () => {
    }
  });
};
const Body = defineComponent({
  name: "TableBody",
  props: ["data", "getRowKey", "measureColumnWidth", "expandedKeys", "customRow", "rowExpandable", "childrenColumnName"],
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const resizeContext = useInjectResize();
    const tableContext = useInjectTable();
    const bodyContext = useInjectBody();
    const flattenData2 = useFlattenRecords(toRef(props2, "data"), toRef(props2, "childrenColumnName"), toRef(props2, "expandedKeys"), toRef(props2, "getRowKey"));
    const startRow = shallowRef(-1);
    const endRow = shallowRef(-1);
    let timeoutId;
    useProvideHover({
      startRow,
      endRow,
      onHover: (start, end) => {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => {
          startRow.value = start;
          endRow.value = end;
        }, 100);
      }
    });
    return () => {
      var _a2;
      const {
        data,
        getRowKey,
        measureColumnWidth,
        expandedKeys,
        customRow,
        rowExpandable,
        childrenColumnName
      } = props2;
      const {
        onColumnResize
      } = resizeContext;
      const {
        prefixCls,
        getComponent: getComponent2
      } = tableContext;
      const {
        flattenColumns
      } = bodyContext;
      const WrapperComponent = getComponent2(["body", "wrapper"], "tbody");
      const trComponent = getComponent2(["body", "row"], "tr");
      const tdComponent = getComponent2(["body", "cell"], "td");
      let rows;
      if (data.length) {
        rows = flattenData2.value.map((item, idx) => {
          const {
            record,
            indent,
            index: renderIndex
          } = item;
          const key2 = getRowKey(record, idx);
          return createVNode(BodyRow, {
            "key": key2,
            "rowKey": key2,
            "record": record,
            "recordKey": key2,
            "index": idx,
            "renderIndex": renderIndex,
            "rowComponent": trComponent,
            "cellComponent": tdComponent,
            "expandedKeys": expandedKeys,
            "customRow": customRow,
            "getRowKey": getRowKey,
            "rowExpandable": rowExpandable,
            "childrenColumnName": childrenColumnName,
            "indent": indent
          }, null);
        });
      } else {
        rows = createVNode(ExpandedRow, {
          "expanded": true,
          "class": `${prefixCls}-placeholder`,
          "prefixCls": prefixCls,
          "component": trComponent,
          "cellComponent": tdComponent,
          "colSpan": flattenColumns.length,
          "isEmpty": true
        }, {
          default: () => [(_a2 = slots.emptyNode) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]
        });
      }
      const columnsKey = getColumnsKey(flattenColumns);
      return createVNode(WrapperComponent, {
        "class": `${prefixCls}-tbody`
      }, {
        default: () => [measureColumnWidth && createVNode("tr", {
          "aria-hidden": "true",
          "class": `${prefixCls}-measure-row`,
          "style": {
            height: 0,
            fontSize: 0
          }
        }, [columnsKey.map((columnKey) => createVNode(MeasureCell, {
          "key": columnKey,
          "columnKey": columnKey,
          "onColumnResize": onColumnResize
        }, null))]), rows]
      });
    };
  }
});
const EXPAND_COLUMN = {};
var __rest$d = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
function flatColumns(columns) {
  return columns.reduce((list, column2) => {
    const {
      fixed
    } = column2;
    const parsedFixed = fixed === true ? "left" : fixed;
    const subColumns = column2.children;
    if (subColumns && subColumns.length > 0) {
      return [...list, ...flatColumns(subColumns).map((subColum) => _extends$1({
        fixed: parsedFixed
      }, subColum))];
    }
    return [...list, _extends$1(_extends$1({}, column2), {
      fixed: parsedFixed
    })];
  }, []);
}
function revertForRtl(columns) {
  return columns.map((column2) => {
    const {
      fixed
    } = column2, restProps = __rest$d(column2, ["fixed"]);
    let parsedFixed = fixed;
    if (fixed === "left") {
      parsedFixed = "right";
    } else if (fixed === "right") {
      parsedFixed = "left";
    }
    return _extends$1({
      fixed: parsedFixed
    }, restProps);
  });
}
function useColumns$1(_ref, transformColumns) {
  let {
    prefixCls,
    columns: baseColumns,
    // children,
    expandable,
    expandedKeys,
    getRowKey,
    onTriggerExpand,
    expandIcon,
    rowExpandable,
    expandIconColumnIndex,
    direction,
    expandRowByClick,
    expandColumnWidth,
    expandFixed
  } = _ref;
  const contextSlots = useInjectSlots();
  const withExpandColumns = computed(() => {
    if (expandable.value) {
      let cloneColumns = baseColumns.value.slice();
      if (!cloneColumns.includes(EXPAND_COLUMN)) {
        const expandColIndex = expandIconColumnIndex.value || 0;
        if (expandColIndex >= 0) {
          cloneColumns.splice(expandColIndex, 0, EXPAND_COLUMN);
        }
      }
      const expandColumnIndex = cloneColumns.indexOf(EXPAND_COLUMN);
      cloneColumns = cloneColumns.filter((column2, index2) => column2 !== EXPAND_COLUMN || index2 === expandColumnIndex);
      const prevColumn = baseColumns.value[expandColumnIndex];
      let fixedColumn;
      if ((expandFixed.value === "left" || expandFixed.value) && !expandIconColumnIndex.value) {
        fixedColumn = "left";
      } else if ((expandFixed.value === "right" || expandFixed.value) && expandIconColumnIndex.value === baseColumns.value.length) {
        fixedColumn = "right";
      } else {
        fixedColumn = prevColumn ? prevColumn.fixed : null;
      }
      const expandedKeysValue = expandedKeys.value;
      const rowExpandableValue = rowExpandable.value;
      const expandIconValue = expandIcon.value;
      const prefixClsValue = prefixCls.value;
      const expandRowByClickValue = expandRowByClick.value;
      const expandColumn = {
        [INTERNAL_COL_DEFINE]: {
          class: `${prefixCls.value}-expand-icon-col`,
          columnType: "EXPAND_COLUMN"
        },
        title: customRenderSlot(contextSlots.value, "expandColumnTitle", {}, () => [""]),
        fixed: fixedColumn,
        class: `${prefixCls.value}-row-expand-icon-cell`,
        width: expandColumnWidth.value,
        customRender: (_ref2) => {
          let {
            record,
            index: index2
          } = _ref2;
          const rowKey = getRowKey.value(record, index2);
          const expanded = expandedKeysValue.has(rowKey);
          const recordExpandable = rowExpandableValue ? rowExpandableValue(record) : true;
          const icon = expandIconValue({
            prefixCls: prefixClsValue,
            expanded,
            expandable: recordExpandable,
            record,
            onExpand: onTriggerExpand
          });
          if (expandRowByClickValue) {
            return createVNode("span", {
              "onClick": (e2) => e2.stopPropagation()
            }, [icon]);
          }
          return icon;
        }
      };
      return cloneColumns.map((col) => col === EXPAND_COLUMN ? expandColumn : col);
    }
    return baseColumns.value.filter((col) => col !== EXPAND_COLUMN);
  });
  const mergedColumns = computed(() => {
    let finalColumns = withExpandColumns.value;
    if (transformColumns.value) {
      finalColumns = transformColumns.value(finalColumns);
    }
    if (!finalColumns.length) {
      finalColumns = [{
        customRender: () => null
      }];
    }
    return finalColumns;
  });
  const flattenColumns = computed(() => {
    if (direction.value === "rtl") {
      return revertForRtl(flatColumns(mergedColumns.value));
    }
    return flatColumns(mergedColumns.value);
  });
  return [mergedColumns, flattenColumns];
}
function useLayoutState(defaultState) {
  const stateRef = shallowRef(defaultState);
  let rafId;
  const updateBatchRef = shallowRef([]);
  function setFrameState(updater) {
    updateBatchRef.value.push(updater);
    wrapperRaf.cancel(rafId);
    rafId = wrapperRaf(() => {
      const prevBatch = updateBatchRef.value;
      updateBatchRef.value = [];
      prevBatch.forEach((batchUpdater) => {
        stateRef.value = batchUpdater(stateRef.value);
      });
    });
  }
  onBeforeUnmount(() => {
    wrapperRaf.cancel(rafId);
  });
  return [stateRef, setFrameState];
}
function useTimeoutLock(defaultState) {
  const frameRef = ref(null);
  const timeoutRef = ref();
  function cleanUp() {
    clearTimeout(timeoutRef.value);
  }
  function setState(newState) {
    frameRef.value = newState;
    cleanUp();
    timeoutRef.value = setTimeout(() => {
      frameRef.value = null;
      timeoutRef.value = void 0;
    }, 100);
  }
  function getState() {
    return frameRef.value;
  }
  onBeforeUnmount(() => {
    cleanUp();
  });
  return [setState, getState];
}
function useStickyOffsets(colWidthsRef, columnCountRef, directionRef) {
  const stickyOffsets = computed(() => {
    const leftOffsets = [];
    const rightOffsets = [];
    let left = 0;
    let right = 0;
    const colWidths = colWidthsRef.value;
    const columnCount = columnCountRef.value;
    const direction = directionRef.value;
    for (let start = 0; start < columnCount; start += 1) {
      if (direction === "rtl") {
        rightOffsets[start] = right;
        right += colWidths[start] || 0;
        const end = columnCount - start - 1;
        leftOffsets[end] = left;
        left += colWidths[end] || 0;
      } else {
        leftOffsets[start] = left;
        left += colWidths[start] || 0;
        const end = columnCount - start - 1;
        rightOffsets[end] = right;
        right += colWidths[end] || 0;
      }
    }
    return {
      left: leftOffsets,
      right: rightOffsets
    };
  });
  return stickyOffsets;
}
var __rest$c = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
function ColGroup(_ref) {
  let {
    colWidths,
    columns,
    columCount
  } = _ref;
  const cols = [];
  const len = columCount || columns.length;
  let mustInsert = false;
  for (let i2 = len - 1; i2 >= 0; i2 -= 1) {
    const width = colWidths[i2];
    const column2 = columns && columns[i2];
    const additionalProps = column2 && column2[INTERNAL_COL_DEFINE];
    if (width || additionalProps || mustInsert) {
      const _a2 = additionalProps || {}, restAdditionalProps = __rest$c(_a2, ["columnType"]);
      cols.unshift(createVNode("col", _objectSpread2$1({
        "key": i2,
        "style": {
          width: typeof width === "number" ? `${width}px` : width
        }
      }, restAdditionalProps), null));
      mustInsert = true;
    }
  }
  return createVNode("colgroup", null, [cols]);
}
function Panel(_2, _ref) {
  let {
    slots
  } = _ref;
  var _a2;
  return createVNode("div", null, [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]);
}
Panel.displayName = "Panel";
let indexGuid = 0;
const Summary = defineComponent({
  name: "TableSummary",
  props: ["fixed"],
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const tableContext = useInjectTable();
    const uniKey = `table-summary-uni-key-${++indexGuid}`;
    const fixed = computed(() => props2.fixed === "" || props2.fixed);
    watchEffect(() => {
      tableContext.summaryCollect(uniKey, fixed.value);
    });
    onBeforeUnmount(() => {
      tableContext.summaryCollect(uniKey, false);
    });
    return () => {
      var _a2;
      return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
    };
  }
});
const SummaryRow = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ATableSummaryRow",
  setup(_props, _ref) {
    let {
      slots
    } = _ref;
    return () => {
      var _a2;
      return createVNode("tr", null, [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]);
    };
  }
});
const SummaryContextKey = Symbol("SummaryContextProps");
const useProvideSummary = (props2) => {
  provide(SummaryContextKey, props2);
};
const useInjectSummary = () => {
  return inject(SummaryContextKey, {});
};
const SummaryCell = defineComponent({
  name: "ATableSummaryCell",
  props: ["index", "colSpan", "rowSpan", "align"],
  setup(props2, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const tableContext = useInjectTable();
    const summaryContext = useInjectSummary();
    return () => {
      const {
        index: index2,
        colSpan = 1,
        rowSpan,
        align
      } = props2;
      const {
        prefixCls,
        direction
      } = tableContext;
      const {
        scrollColumnIndex,
        stickyOffsets,
        flattenColumns
      } = summaryContext;
      const lastIndex = index2 + colSpan - 1;
      const mergedColSpan = lastIndex + 1 === scrollColumnIndex ? colSpan + 1 : colSpan;
      const fixedInfo = getCellFixedInfo(index2, index2 + mergedColSpan - 1, flattenColumns, stickyOffsets, direction);
      return createVNode(Cell, _objectSpread2$1({
        "class": attrs.class,
        "index": index2,
        "component": "td",
        "prefixCls": prefixCls,
        "record": null,
        "dataIndex": null,
        "align": align,
        "colSpan": mergedColSpan,
        "rowSpan": rowSpan,
        "customRender": () => {
          var _a2;
          return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
        }
      }, fixedInfo), null);
    };
  }
});
const Footer = defineComponent({
  name: "TableFooter",
  inheritAttrs: false,
  props: ["stickyOffsets", "flattenColumns"],
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const tableContext = useInjectTable();
    useProvideSummary(reactive({
      stickyOffsets: toRef(props2, "stickyOffsets"),
      flattenColumns: toRef(props2, "flattenColumns"),
      scrollColumnIndex: computed(() => {
        const lastColumnIndex = props2.flattenColumns.length - 1;
        const scrollColumn = props2.flattenColumns[lastColumnIndex];
        return (scrollColumn === null || scrollColumn === void 0 ? void 0 : scrollColumn.scrollbar) ? lastColumnIndex : null;
      })
    }));
    return () => {
      var _a2;
      const {
        prefixCls
      } = tableContext;
      return createVNode("tfoot", {
        "class": `${prefixCls}-summary`
      }, [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]);
    };
  }
});
const FooterComponents = Summary;
function renderExpandIcon$1(_ref) {
  let {
    prefixCls,
    record,
    onExpand,
    expanded,
    expandable
  } = _ref;
  const expandClassName = `${prefixCls}-row-expand-icon`;
  if (!expandable) {
    return createVNode("span", {
      "class": [expandClassName, `${prefixCls}-row-spaced`]
    }, null);
  }
  const onClick = (event) => {
    onExpand(record, event);
    event.stopPropagation();
  };
  return createVNode("span", {
    "class": {
      [expandClassName]: true,
      [`${prefixCls}-row-expanded`]: expanded,
      [`${prefixCls}-row-collapsed`]: !expanded
    },
    "onClick": onClick
  }, null);
}
function findAllChildrenKeys(data, getRowKey, childrenColumnName) {
  const keys2 = [];
  function dig(list) {
    (list || []).forEach((item, index2) => {
      keys2.push(getRowKey(item, index2));
      dig(item[childrenColumnName]);
    });
  }
  dig(data);
  return keys2;
}
const StickyScrollBar = defineComponent({
  name: "StickyScrollBar",
  inheritAttrs: false,
  props: ["offsetScroll", "container", "scrollBodyRef", "scrollBodySizeInfo"],
  emits: ["scroll"],
  setup(props2, _ref) {
    let {
      emit,
      expose
    } = _ref;
    const tableContext = useInjectTable();
    const bodyScrollWidth = shallowRef(0);
    const bodyWidth = shallowRef(0);
    const scrollBarWidth = shallowRef(0);
    watchEffect(() => {
      bodyScrollWidth.value = props2.scrollBodySizeInfo.scrollWidth || 0;
      bodyWidth.value = props2.scrollBodySizeInfo.clientWidth || 0;
      scrollBarWidth.value = bodyScrollWidth.value && bodyWidth.value * (bodyWidth.value / bodyScrollWidth.value);
    }, {
      flush: "post"
    });
    const scrollBarRef = shallowRef();
    const [scrollState, setScrollState] = useLayoutState({
      scrollLeft: 0,
      isHiddenScrollBar: true
    });
    const refState = ref({
      delta: 0,
      x: 0
    });
    const isActive = shallowRef(false);
    const onMouseUp = () => {
      isActive.value = false;
    };
    const onMouseDown = (event) => {
      refState.value = {
        delta: event.pageX - scrollState.value.scrollLeft,
        x: 0
      };
      isActive.value = true;
      event.preventDefault();
    };
    const onMouseMove = (event) => {
      const {
        buttons
      } = event || (window === null || window === void 0 ? void 0 : window.event);
      if (!isActive.value || buttons === 0) {
        if (isActive.value) {
          isActive.value = false;
        }
        return;
      }
      let left = refState.value.x + event.pageX - refState.value.x - refState.value.delta;
      if (left <= 0) {
        left = 0;
      }
      if (left + scrollBarWidth.value >= bodyWidth.value) {
        left = bodyWidth.value - scrollBarWidth.value;
      }
      emit("scroll", {
        scrollLeft: left / bodyWidth.value * (bodyScrollWidth.value + 2)
      });
      refState.value.x = event.pageX;
    };
    const onContainerScroll = () => {
      if (!props2.scrollBodyRef.value) {
        return;
      }
      const tableOffsetTop = getOffset$1(props2.scrollBodyRef.value).top;
      const tableBottomOffset = tableOffsetTop + props2.scrollBodyRef.value.offsetHeight;
      const currentClientOffset = props2.container === window ? document.documentElement.scrollTop + window.innerHeight : getOffset$1(props2.container).top + props2.container.clientHeight;
      if (tableBottomOffset - getScrollBarSize() <= currentClientOffset || tableOffsetTop >= currentClientOffset - props2.offsetScroll) {
        setScrollState((state) => _extends$1(_extends$1({}, state), {
          isHiddenScrollBar: true
        }));
      } else {
        setScrollState((state) => _extends$1(_extends$1({}, state), {
          isHiddenScrollBar: false
        }));
      }
    };
    const setScrollLeft = (left) => {
      setScrollState((state) => {
        return _extends$1(_extends$1({}, state), {
          scrollLeft: left / bodyScrollWidth.value * bodyWidth.value || 0
        });
      });
    };
    expose({
      setScrollLeft
    });
    let onMouseUpListener = null;
    let onMouseMoveListener = null;
    let onResizeListener = null;
    let onScrollListener = null;
    onMounted(() => {
      onMouseUpListener = addEventListenerWrap(document.body, "mouseup", onMouseUp, false);
      onMouseMoveListener = addEventListenerWrap(document.body, "mousemove", onMouseMove, false);
      onResizeListener = addEventListenerWrap(window, "resize", onContainerScroll, false);
    });
    onActivated(() => {
      nextTick(() => {
        onContainerScroll();
      });
    });
    onMounted(() => {
      setTimeout(() => {
        watch([scrollBarWidth, isActive], () => {
          onContainerScroll();
        }, {
          immediate: true,
          flush: "post"
        });
      });
    });
    watch(() => props2.container, () => {
      onScrollListener === null || onScrollListener === void 0 ? void 0 : onScrollListener.remove();
      onScrollListener = addEventListenerWrap(props2.container, "scroll", onContainerScroll, false);
    }, {
      immediate: true,
      flush: "post"
    });
    onBeforeUnmount(() => {
      onMouseUpListener === null || onMouseUpListener === void 0 ? void 0 : onMouseUpListener.remove();
      onMouseMoveListener === null || onMouseMoveListener === void 0 ? void 0 : onMouseMoveListener.remove();
      onScrollListener === null || onScrollListener === void 0 ? void 0 : onScrollListener.remove();
      onResizeListener === null || onResizeListener === void 0 ? void 0 : onResizeListener.remove();
    });
    watch(() => _extends$1({}, scrollState.value), (newState, preState) => {
      if (newState.isHiddenScrollBar !== (preState === null || preState === void 0 ? void 0 : preState.isHiddenScrollBar) && !newState.isHiddenScrollBar) {
        setScrollState((state) => {
          const bodyNode = props2.scrollBodyRef.value;
          if (!bodyNode) {
            return state;
          }
          return _extends$1(_extends$1({}, state), {
            scrollLeft: bodyNode.scrollLeft / bodyNode.scrollWidth * bodyNode.clientWidth
          });
        });
      }
    }, {
      immediate: true
    });
    const scrollbarSize = getScrollBarSize();
    return () => {
      if (bodyScrollWidth.value <= bodyWidth.value || !scrollBarWidth.value || scrollState.value.isHiddenScrollBar) {
        return null;
      }
      const {
        prefixCls
      } = tableContext;
      return createVNode("div", {
        "style": {
          height: `${scrollbarSize}px`,
          width: `${bodyWidth.value}px`,
          bottom: `${props2.offsetScroll}px`
        },
        "class": `${prefixCls}-sticky-scroll`
      }, [createVNode("div", {
        "onMousedown": onMouseDown,
        "ref": scrollBarRef,
        "class": classNames(`${prefixCls}-sticky-scroll-bar`, {
          [`${prefixCls}-sticky-scroll-bar-active`]: isActive.value
        }),
        "style": {
          width: `${scrollBarWidth.value}px`,
          transform: `translate3d(${scrollState.value.scrollLeft}px, 0, 0)`
        }
      }, null)]);
    };
  }
});
const defaultContainer = canUseDom() ? window : null;
function useSticky(stickyRef, prefixClsRef) {
  return computed(() => {
    const {
      offsetHeader = 0,
      offsetSummary = 0,
      offsetScroll = 0,
      getContainer: getContainer2 = () => defaultContainer
    } = typeof stickyRef.value === "object" ? stickyRef.value : {};
    const container = getContainer2() || defaultContainer;
    const isSticky = !!stickyRef.value;
    return {
      isSticky,
      stickyClassName: isSticky ? `${prefixClsRef.value}-sticky-holder` : "",
      offsetHeader,
      offsetSummary,
      offsetScroll,
      container
    };
  });
}
function useColumnWidth(colWidthsRef, columCountRef) {
  return computed(() => {
    const cloneColumns = [];
    const colWidths = colWidthsRef.value;
    const columCount = columCountRef.value;
    for (let i2 = 0; i2 < columCount; i2 += 1) {
      const val = colWidths[i2];
      if (val !== void 0) {
        cloneColumns[i2] = val;
      } else {
        return null;
      }
    }
    return cloneColumns;
  });
}
const FixedHolder = defineComponent({
  name: "FixedHolder",
  inheritAttrs: false,
  props: ["columns", "flattenColumns", "stickyOffsets", "customHeaderRow", "noData", "maxContentScroll", "colWidths", "columCount", "direction", "fixHeader", "stickyTopOffset", "stickyBottomOffset", "stickyClassName"],
  emits: ["scroll"],
  setup(props2, _ref) {
    let {
      attrs,
      slots,
      emit
    } = _ref;
    const tableContext = useInjectTable();
    const combinationScrollBarSize = computed(() => tableContext.isSticky && !props2.fixHeader ? 0 : tableContext.scrollbarSize);
    const scrollRef = ref();
    const onWheel = (e2) => {
      const {
        currentTarget,
        deltaX
      } = e2;
      if (deltaX) {
        emit("scroll", {
          currentTarget,
          scrollLeft: currentTarget.scrollLeft + deltaX
        });
        e2.preventDefault();
      }
    };
    const wheelEvent = ref();
    onMounted(() => {
      nextTick(() => {
        wheelEvent.value = addEventListenerWrap(scrollRef.value, "wheel", onWheel);
      });
    });
    onBeforeUnmount(() => {
      var _a2;
      (_a2 = wheelEvent.value) === null || _a2 === void 0 ? void 0 : _a2.remove();
    });
    const allFlattenColumnsWithWidth = computed(() => props2.flattenColumns.every((column2) => column2.width && column2.width !== 0 && column2.width !== "0px"));
    const columnsWithScrollbar = ref([]);
    const flattenColumnsWithScrollbar = ref([]);
    watchEffect(() => {
      const lastColumn = props2.flattenColumns[props2.flattenColumns.length - 1];
      const ScrollBarColumn = {
        fixed: lastColumn ? lastColumn.fixed : null,
        scrollbar: true,
        customHeaderCell: () => ({
          class: `${tableContext.prefixCls}-cell-scrollbar`
        })
      };
      columnsWithScrollbar.value = combinationScrollBarSize.value ? [...props2.columns, ScrollBarColumn] : props2.columns;
      flattenColumnsWithScrollbar.value = combinationScrollBarSize.value ? [...props2.flattenColumns, ScrollBarColumn] : props2.flattenColumns;
    });
    const headerStickyOffsets = computed(() => {
      const {
        stickyOffsets,
        direction
      } = props2;
      const {
        right,
        left
      } = stickyOffsets;
      return _extends$1(_extends$1({}, stickyOffsets), {
        left: direction === "rtl" ? [...left.map((width) => width + combinationScrollBarSize.value), 0] : left,
        right: direction === "rtl" ? right : [...right.map((width) => width + combinationScrollBarSize.value), 0],
        isSticky: tableContext.isSticky
      });
    });
    const mergedColumnWidth = useColumnWidth(toRef(props2, "colWidths"), toRef(props2, "columCount"));
    return () => {
      var _a2;
      const {
        noData,
        columCount,
        stickyTopOffset,
        stickyBottomOffset,
        stickyClassName,
        maxContentScroll
      } = props2;
      const {
        isSticky
      } = tableContext;
      return createVNode("div", {
        "style": _extends$1({
          overflow: "hidden"
        }, isSticky ? {
          top: `${stickyTopOffset}px`,
          bottom: `${stickyBottomOffset}px`
        } : {}),
        "ref": scrollRef,
        "class": classNames(attrs.class, {
          [stickyClassName]: !!stickyClassName
        })
      }, [createVNode("table", {
        "style": {
          tableLayout: "fixed",
          visibility: noData || mergedColumnWidth.value ? null : "hidden"
        }
      }, [(!noData || !maxContentScroll || allFlattenColumnsWithWidth.value) && createVNode(ColGroup, {
        "colWidths": mergedColumnWidth.value ? [...mergedColumnWidth.value, combinationScrollBarSize.value] : [],
        "columCount": columCount + 1,
        "columns": flattenColumnsWithScrollbar.value
      }, null), (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots, _extends$1(_extends$1({}, props2), {
        stickyOffsets: headerStickyOffsets.value,
        columns: columnsWithScrollbar.value,
        flattenColumns: flattenColumnsWithScrollbar.value
      }))])]);
    };
  }
});
function reactivePick(obj) {
  for (var _len = arguments.length, keys2 = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    keys2[_key - 1] = arguments[_key];
  }
  return reactive(fromPairs(keys2.map((k2) => [k2, toRef(obj, k2)])));
}
const EMPTY_DATA = [];
const EMPTY_SCROLL_TARGET = {};
const INTERNAL_HOOKS = "rc-table-internal-hook";
const Table$2 = defineComponent({
  name: "VcTable",
  inheritAttrs: false,
  props: ["prefixCls", "data", "columns", "rowKey", "tableLayout", "scroll", "rowClassName", "title", "footer", "id", "showHeader", "components", "customRow", "customHeaderRow", "direction", "expandFixed", "expandColumnWidth", "expandedRowKeys", "defaultExpandedRowKeys", "expandedRowRender", "expandRowByClick", "expandIcon", "onExpand", "onExpandedRowsChange", "onUpdate:expandedRowKeys", "defaultExpandAllRows", "indentSize", "expandIconColumnIndex", "expandedRowClassName", "childrenColumnName", "rowExpandable", "sticky", "transformColumns", "internalHooks", "internalRefs", "canExpandable", "onUpdateInternalRefs", "transformCellText"],
  emits: ["expand", "expandedRowsChange", "updateInternalRefs", "update:expandedRowKeys"],
  setup(props2, _ref) {
    let {
      attrs,
      slots,
      emit
    } = _ref;
    const mergedData = computed(() => props2.data || EMPTY_DATA);
    const hasData = computed(() => !!mergedData.value.length);
    const mergedComponents = computed(() => mergeObject(props2.components, {}));
    const getComponent2 = (path2, defaultComponent) => getPathValue(mergedComponents.value, path2) || defaultComponent;
    const getRowKey = computed(() => {
      const rowKey = props2.rowKey;
      if (typeof rowKey === "function") {
        return rowKey;
      }
      return (record) => {
        const key2 = record && record[rowKey];
        return key2;
      };
    });
    const mergedExpandIcon = computed(() => props2.expandIcon || renderExpandIcon$1);
    const mergedChildrenColumnName = computed(() => props2.childrenColumnName || "children");
    const expandableType = computed(() => {
      if (props2.expandedRowRender) {
        return "row";
      }
      if (props2.canExpandable || mergedData.value.some((record) => record && typeof record === "object" && record[mergedChildrenColumnName.value])) {
        return "nest";
      }
      return false;
    });
    const innerExpandedKeys = shallowRef([]);
    const stop = watchEffect(() => {
      if (props2.defaultExpandedRowKeys) {
        innerExpandedKeys.value = props2.defaultExpandedRowKeys;
      }
      if (props2.defaultExpandAllRows) {
        innerExpandedKeys.value = findAllChildrenKeys(mergedData.value, getRowKey.value, mergedChildrenColumnName.value);
      }
    });
    stop();
    const mergedExpandedKeys = computed(() => new Set(props2.expandedRowKeys || innerExpandedKeys.value || []));
    const onTriggerExpand = (record) => {
      const key2 = getRowKey.value(record, mergedData.value.indexOf(record));
      let newExpandedKeys;
      const hasKey = mergedExpandedKeys.value.has(key2);
      if (hasKey) {
        mergedExpandedKeys.value.delete(key2);
        newExpandedKeys = [...mergedExpandedKeys.value];
      } else {
        newExpandedKeys = [...mergedExpandedKeys.value, key2];
      }
      innerExpandedKeys.value = newExpandedKeys;
      emit("expand", !hasKey, record);
      emit("update:expandedRowKeys", newExpandedKeys);
      emit("expandedRowsChange", newExpandedKeys);
    };
    const componentWidth = ref(0);
    const [columns, flattenColumns] = useColumns$1(_extends$1(_extends$1({}, toRefs(props2)), {
      // children,
      expandable: computed(() => !!props2.expandedRowRender),
      expandedKeys: mergedExpandedKeys,
      getRowKey,
      onTriggerExpand,
      expandIcon: mergedExpandIcon
    }), computed(() => props2.internalHooks === INTERNAL_HOOKS ? props2.transformColumns : null));
    const columnContext = computed(() => ({
      columns: columns.value,
      flattenColumns: flattenColumns.value
    }));
    const fullTableRef = ref();
    const scrollHeaderRef = ref();
    const scrollBodyRef = ref();
    const scrollBodySizeInfo = ref({
      scrollWidth: 0,
      clientWidth: 0
    });
    const scrollSummaryRef = ref();
    const [pingedLeft, setPingedLeft] = useState(false);
    const [pingedRight, setPingedRight] = useState(false);
    const [colsWidths, updateColsWidths] = useLayoutState(/* @__PURE__ */ new Map());
    const colsKeys = computed(() => getColumnsKey(flattenColumns.value));
    const colWidths = computed(() => colsKeys.value.map((columnKey) => colsWidths.value.get(columnKey)));
    const columnCount = computed(() => flattenColumns.value.length);
    const stickyOffsets = useStickyOffsets(colWidths, columnCount, toRef(props2, "direction"));
    const fixHeader = computed(() => props2.scroll && validateValue(props2.scroll.y));
    const horizonScroll = computed(() => props2.scroll && validateValue(props2.scroll.x) || Boolean(props2.expandFixed));
    const fixColumn = computed(() => horizonScroll.value && flattenColumns.value.some((_ref2) => {
      let {
        fixed
      } = _ref2;
      return fixed;
    }));
    const stickyRef = ref();
    const stickyState = useSticky(toRef(props2, "sticky"), toRef(props2, "prefixCls"));
    const summaryFixedInfos = reactive({});
    const fixFooter = computed(() => {
      const info = Object.values(summaryFixedInfos)[0];
      return (fixHeader.value || stickyState.value.isSticky) && info;
    });
    const summaryCollect = (uniKey, fixed) => {
      if (fixed) {
        summaryFixedInfos[uniKey] = fixed;
      } else {
        delete summaryFixedInfos[uniKey];
      }
    };
    const scrollXStyle = ref({});
    const scrollYStyle = ref({});
    const scrollTableStyle = ref({});
    watchEffect(() => {
      if (fixHeader.value) {
        scrollYStyle.value = {
          overflowY: "scroll",
          maxHeight: toPx(props2.scroll.y)
        };
      }
      if (horizonScroll.value) {
        scrollXStyle.value = {
          overflowX: "auto"
        };
        if (!fixHeader.value) {
          scrollYStyle.value = {
            overflowY: "hidden"
          };
        }
        scrollTableStyle.value = {
          width: props2.scroll.x === true ? "auto" : toPx(props2.scroll.x),
          minWidth: "100%"
        };
      }
    });
    const onColumnResize = (columnKey, width) => {
      if (isVisible(fullTableRef.value)) {
        updateColsWidths((widths) => {
          if (widths.get(columnKey) !== width) {
            const newWidths = new Map(widths);
            newWidths.set(columnKey, width);
            return newWidths;
          }
          return widths;
        });
      }
    };
    const [setScrollTarget, getScrollTarget] = useTimeoutLock();
    function forceScroll(scrollLeft, target) {
      if (!target) {
        return;
      }
      if (typeof target === "function") {
        target(scrollLeft);
        return;
      }
      const domTarget = target.$el || target;
      if (domTarget.scrollLeft !== scrollLeft) {
        domTarget.scrollLeft = scrollLeft;
      }
    }
    const onScroll = (_ref3) => {
      let {
        currentTarget,
        scrollLeft
      } = _ref3;
      var _a2;
      const isRTL = props2.direction === "rtl";
      const mergedScrollLeft = typeof scrollLeft === "number" ? scrollLeft : currentTarget.scrollLeft;
      const compareTarget = currentTarget || EMPTY_SCROLL_TARGET;
      if (!getScrollTarget() || getScrollTarget() === compareTarget) {
        setScrollTarget(compareTarget);
        forceScroll(mergedScrollLeft, scrollHeaderRef.value);
        forceScroll(mergedScrollLeft, scrollBodyRef.value);
        forceScroll(mergedScrollLeft, scrollSummaryRef.value);
        forceScroll(mergedScrollLeft, (_a2 = stickyRef.value) === null || _a2 === void 0 ? void 0 : _a2.setScrollLeft);
      }
      if (currentTarget) {
        const {
          scrollWidth,
          clientWidth
        } = currentTarget;
        if (isRTL) {
          setPingedLeft(-mergedScrollLeft < scrollWidth - clientWidth);
          setPingedRight(-mergedScrollLeft > 0);
        } else {
          setPingedLeft(mergedScrollLeft > 0);
          setPingedRight(mergedScrollLeft < scrollWidth - clientWidth);
        }
      }
    };
    const triggerOnScroll = () => {
      if (horizonScroll.value && scrollBodyRef.value) {
        onScroll({
          currentTarget: scrollBodyRef.value
        });
      } else {
        setPingedLeft(false);
        setPingedRight(false);
      }
    };
    let timtout;
    const updateWidth = (width) => {
      if (width !== componentWidth.value) {
        triggerOnScroll();
        componentWidth.value = fullTableRef.value ? fullTableRef.value.offsetWidth : width;
      }
    };
    const onFullTableResize = (_ref4) => {
      let {
        width
      } = _ref4;
      clearTimeout(timtout);
      if (componentWidth.value === 0) {
        updateWidth(width);
        return;
      }
      timtout = setTimeout(() => {
        updateWidth(width);
      }, 100);
    };
    watch([horizonScroll, () => props2.data, () => props2.columns], () => {
      if (horizonScroll.value) {
        triggerOnScroll();
      }
    }, {
      flush: "post"
    });
    const [scrollbarSize, setScrollbarSize] = useState(0);
    useProvideSticky();
    onMounted(() => {
      nextTick(() => {
        var _a2, _b;
        triggerOnScroll();
        setScrollbarSize(getTargetScrollBarSize(scrollBodyRef.value).width);
        scrollBodySizeInfo.value = {
          scrollWidth: ((_a2 = scrollBodyRef.value) === null || _a2 === void 0 ? void 0 : _a2.scrollWidth) || 0,
          clientWidth: ((_b = scrollBodyRef.value) === null || _b === void 0 ? void 0 : _b.clientWidth) || 0
        };
      });
    });
    onUpdated(() => {
      nextTick(() => {
        var _a2, _b;
        const scrollWidth = ((_a2 = scrollBodyRef.value) === null || _a2 === void 0 ? void 0 : _a2.scrollWidth) || 0;
        const clientWidth = ((_b = scrollBodyRef.value) === null || _b === void 0 ? void 0 : _b.clientWidth) || 0;
        if (scrollBodySizeInfo.value.scrollWidth !== scrollWidth || scrollBodySizeInfo.value.clientWidth !== clientWidth) {
          scrollBodySizeInfo.value = {
            scrollWidth,
            clientWidth
          };
        }
      });
    });
    watchEffect(() => {
      if (props2.internalHooks === INTERNAL_HOOKS && props2.internalRefs) {
        props2.onUpdateInternalRefs({
          body: scrollBodyRef.value ? scrollBodyRef.value.$el || scrollBodyRef.value : null
        });
      }
    }, {
      flush: "post"
    });
    const mergedTableLayout = computed(() => {
      if (props2.tableLayout) {
        return props2.tableLayout;
      }
      if (fixColumn.value) {
        return props2.scroll.x === "max-content" ? "auto" : "fixed";
      }
      if (fixHeader.value || stickyState.value.isSticky || flattenColumns.value.some((_ref5) => {
        let {
          ellipsis
        } = _ref5;
        return ellipsis;
      })) {
        return "fixed";
      }
      return "auto";
    });
    const emptyNode = () => {
      var _a2;
      return hasData.value ? null : ((_a2 = slots.emptyText) === null || _a2 === void 0 ? void 0 : _a2.call(slots)) || "No Data";
    };
    useProvideTable(reactive(_extends$1(_extends$1({}, toRefs(reactivePick(props2, "prefixCls", "direction", "transformCellText"))), {
      getComponent: getComponent2,
      scrollbarSize,
      fixedInfoList: computed(() => flattenColumns.value.map((_2, colIndex) => getCellFixedInfo(colIndex, colIndex, flattenColumns.value, stickyOffsets.value, props2.direction))),
      isSticky: computed(() => stickyState.value.isSticky),
      summaryCollect
    })));
    useProvideBody(reactive(_extends$1(_extends$1({}, toRefs(reactivePick(props2, "rowClassName", "expandedRowClassName", "expandRowByClick", "expandedRowRender", "expandIconColumnIndex", "indentSize"))), {
      columns,
      flattenColumns,
      tableLayout: mergedTableLayout,
      expandIcon: mergedExpandIcon,
      expandableType,
      onTriggerExpand
    })));
    useProvideResize({
      onColumnResize
    });
    useProvideExpandedRow({
      componentWidth,
      fixHeader,
      fixColumn,
      horizonScroll
    });
    const bodyTable = () => createVNode(Body, {
      "data": mergedData.value,
      "measureColumnWidth": fixHeader.value || horizonScroll.value || stickyState.value.isSticky,
      "expandedKeys": mergedExpandedKeys.value,
      "rowExpandable": props2.rowExpandable,
      "getRowKey": getRowKey.value,
      "customRow": props2.customRow,
      "childrenColumnName": mergedChildrenColumnName.value
    }, {
      emptyNode
    });
    const bodyColGroup = () => createVNode(ColGroup, {
      "colWidths": flattenColumns.value.map((_ref6) => {
        let {
          width
        } = _ref6;
        return width;
      }),
      "columns": flattenColumns.value
    }, null);
    return () => {
      var _a2;
      const {
        prefixCls,
        scroll,
        tableLayout,
        direction,
        // Additional Part
        title = slots.title,
        footer = slots.footer,
        // Customize
        id,
        showHeader,
        customHeaderRow
      } = props2;
      const {
        isSticky,
        offsetHeader,
        offsetSummary,
        offsetScroll,
        stickyClassName,
        container
      } = stickyState.value;
      const TableComponent = getComponent2(["table"], "table");
      const customizeScrollBody = getComponent2(["body"]);
      const summaryNode = (_a2 = slots.summary) === null || _a2 === void 0 ? void 0 : _a2.call(slots, {
        pageData: mergedData.value
      });
      let groupTableNode = () => null;
      const headerProps = {
        colWidths: colWidths.value,
        columCount: flattenColumns.value.length,
        stickyOffsets: stickyOffsets.value,
        customHeaderRow,
        fixHeader: fixHeader.value,
        scroll
      };
      if (fixHeader.value || isSticky) {
        let bodyContent = () => null;
        if (typeof customizeScrollBody === "function") {
          bodyContent = () => customizeScrollBody(mergedData.value, {
            scrollbarSize: scrollbarSize.value,
            ref: scrollBodyRef,
            onScroll
          });
          headerProps.colWidths = flattenColumns.value.map((_ref7, index2) => {
            let {
              width
            } = _ref7;
            const colWidth = index2 === columns.value.length - 1 ? width - scrollbarSize.value : width;
            if (typeof colWidth === "number" && !Number.isNaN(colWidth)) {
              return colWidth;
            }
            return 0;
          });
        } else {
          bodyContent = () => createVNode("div", {
            "style": _extends$1(_extends$1({}, scrollXStyle.value), scrollYStyle.value),
            "onScroll": onScroll,
            "ref": scrollBodyRef,
            "class": classNames(`${prefixCls}-body`)
          }, [createVNode(TableComponent, {
            "style": _extends$1(_extends$1({}, scrollTableStyle.value), {
              tableLayout: mergedTableLayout.value
            })
          }, {
            default: () => [bodyColGroup(), bodyTable(), !fixFooter.value && summaryNode && createVNode(Footer, {
              "stickyOffsets": stickyOffsets.value,
              "flattenColumns": flattenColumns.value
            }, {
              default: () => [summaryNode]
            })]
          })]);
        }
        const fixedHolderProps = _extends$1(_extends$1(_extends$1({
          noData: !mergedData.value.length,
          maxContentScroll: horizonScroll.value && scroll.x === "max-content"
        }, headerProps), columnContext.value), {
          direction,
          stickyClassName,
          onScroll
        });
        groupTableNode = () => createVNode(Fragment, null, [showHeader !== false && createVNode(FixedHolder, _objectSpread2$1(_objectSpread2$1({}, fixedHolderProps), {}, {
          "stickyTopOffset": offsetHeader,
          "class": `${prefixCls}-header`,
          "ref": scrollHeaderRef
        }), {
          default: (fixedHolderPassProps) => createVNode(Fragment, null, [createVNode(Header, fixedHolderPassProps, null), fixFooter.value === "top" && createVNode(Footer, fixedHolderPassProps, {
            default: () => [summaryNode]
          })])
        }), bodyContent(), fixFooter.value && fixFooter.value !== "top" && createVNode(FixedHolder, _objectSpread2$1(_objectSpread2$1({}, fixedHolderProps), {}, {
          "stickyBottomOffset": offsetSummary,
          "class": `${prefixCls}-summary`,
          "ref": scrollSummaryRef
        }), {
          default: (fixedHolderPassProps) => createVNode(Footer, fixedHolderPassProps, {
            default: () => [summaryNode]
          })
        }), isSticky && scrollBodyRef.value && createVNode(StickyScrollBar, {
          "ref": stickyRef,
          "offsetScroll": offsetScroll,
          "scrollBodyRef": scrollBodyRef,
          "onScroll": onScroll,
          "container": container,
          "scrollBodySizeInfo": scrollBodySizeInfo.value
        }, null)]);
      } else {
        groupTableNode = () => createVNode("div", {
          "style": _extends$1(_extends$1({}, scrollXStyle.value), scrollYStyle.value),
          "class": classNames(`${prefixCls}-content`),
          "onScroll": onScroll,
          "ref": scrollBodyRef
        }, [createVNode(TableComponent, {
          "style": _extends$1(_extends$1({}, scrollTableStyle.value), {
            tableLayout: mergedTableLayout.value
          })
        }, {
          default: () => [bodyColGroup(), showHeader !== false && createVNode(Header, _objectSpread2$1(_objectSpread2$1({}, headerProps), columnContext.value), null), bodyTable(), summaryNode && createVNode(Footer, {
            "stickyOffsets": stickyOffsets.value,
            "flattenColumns": flattenColumns.value
          }, {
            default: () => [summaryNode]
          })]
        })]);
      }
      const ariaProps = pickAttrs(attrs, {
        aria: true,
        data: true
      });
      const fullTable = () => createVNode("div", _objectSpread2$1(_objectSpread2$1({}, ariaProps), {}, {
        "class": classNames(prefixCls, {
          [`${prefixCls}-rtl`]: direction === "rtl",
          [`${prefixCls}-ping-left`]: pingedLeft.value,
          [`${prefixCls}-ping-right`]: pingedRight.value,
          [`${prefixCls}-layout-fixed`]: tableLayout === "fixed",
          [`${prefixCls}-fixed-header`]: fixHeader.value,
          /** No used but for compatible */
          [`${prefixCls}-fixed-column`]: fixColumn.value,
          [`${prefixCls}-scroll-horizontal`]: horizonScroll.value,
          [`${prefixCls}-has-fix-left`]: flattenColumns.value[0] && flattenColumns.value[0].fixed,
          [`${prefixCls}-has-fix-right`]: flattenColumns.value[columnCount.value - 1] && flattenColumns.value[columnCount.value - 1].fixed === "right",
          [attrs.class]: attrs.class
        }),
        "style": attrs.style,
        "id": id,
        "ref": fullTableRef
      }), [title && createVNode(Panel, {
        "class": `${prefixCls}-title`
      }, {
        default: () => [title(mergedData.value)]
      }), createVNode("div", {
        "class": `${prefixCls}-container`
      }, [groupTableNode()]), footer && createVNode(Panel, {
        "class": `${prefixCls}-footer`
      }, {
        default: () => [footer(mergedData.value)]
      })]);
      if (horizonScroll.value) {
        return createVNode(ResizeObserver$1, {
          "onResize": onFullTableResize
        }, {
          default: fullTable
        });
      }
      return fullTable();
    };
  }
});
function extendsObject() {
  const result = _extends$1({}, arguments.length <= 0 ? void 0 : arguments[0]);
  for (let i2 = 1; i2 < arguments.length; i2++) {
    const obj = i2 < 0 || arguments.length <= i2 ? void 0 : arguments[i2];
    if (obj) {
      Object.keys(obj).forEach((key2) => {
        const val = obj[key2];
        if (val !== void 0) {
          result[key2] = val;
        }
      });
    }
  }
  return result;
}
const DEFAULT_PAGE_SIZE = 10;
function getPaginationParam(mergedPagination, pagination) {
  const param = {
    current: mergedPagination.current,
    pageSize: mergedPagination.pageSize
  };
  const paginationObj = pagination && typeof pagination === "object" ? pagination : {};
  Object.keys(paginationObj).forEach((pageProp) => {
    const value = mergedPagination[pageProp];
    if (typeof value !== "function") {
      param[pageProp] = value;
    }
  });
  return param;
}
function usePagination(totalRef, paginationRef, onChange) {
  const pagination = computed(() => paginationRef.value && typeof paginationRef.value === "object" ? paginationRef.value : {});
  const paginationTotal = computed(() => pagination.value.total || 0);
  const [innerPagination, setInnerPagination] = useState(() => ({
    current: "defaultCurrent" in pagination.value ? pagination.value.defaultCurrent : 1,
    pageSize: "defaultPageSize" in pagination.value ? pagination.value.defaultPageSize : DEFAULT_PAGE_SIZE
  }));
  const mergedPagination = computed(() => {
    const mP = extendsObject(innerPagination.value, pagination.value, {
      total: paginationTotal.value > 0 ? paginationTotal.value : totalRef.value
    });
    const maxPage = Math.ceil((paginationTotal.value || totalRef.value) / mP.pageSize);
    if (mP.current > maxPage) {
      mP.current = maxPage || 1;
    }
    return mP;
  });
  const refreshPagination = (current, pageSize) => {
    if (paginationRef.value === false) return;
    setInnerPagination({
      current: current !== null && current !== void 0 ? current : 1,
      pageSize: pageSize || mergedPagination.value.pageSize
    });
  };
  const onInternalChange = (current, pageSize) => {
    var _a2, _b;
    if (paginationRef.value) {
      (_b = (_a2 = pagination.value).onChange) === null || _b === void 0 ? void 0 : _b.call(_a2, current, pageSize);
    }
    refreshPagination(current, pageSize);
    onChange(current, pageSize || mergedPagination.value.pageSize);
  };
  return [computed(() => {
    return paginationRef.value === false ? {} : _extends$1(_extends$1({}, mergedPagination.value), {
      onChange: onInternalChange
    });
  }), refreshPagination];
}
function useLazyKVMap(dataRef, childrenColumnNameRef, getRowKeyRef) {
  const mapCacheRef = shallowRef({});
  watch([dataRef, childrenColumnNameRef, getRowKeyRef], () => {
    const kvMap = /* @__PURE__ */ new Map();
    const getRowKey = getRowKeyRef.value;
    const childrenColumnName = childrenColumnNameRef.value;
    function dig(records) {
      records.forEach((record, index2) => {
        const rowKey = getRowKey(record, index2);
        kvMap.set(rowKey, record);
        if (record && typeof record === "object" && childrenColumnName in record) {
          dig(record[childrenColumnName] || []);
        }
      });
    }
    dig(dataRef.value);
    mapCacheRef.value = {
      kvMap
    };
  }, {
    deep: true,
    immediate: true
  });
  function getRecordByKey(key2) {
    return mapCacheRef.value.kvMap.get(key2);
  }
  return [getRecordByKey];
}
const SELECTION_COLUMN = {};
const SELECTION_ALL = "SELECT_ALL";
const SELECTION_INVERT = "SELECT_INVERT";
const SELECTION_NONE = "SELECT_NONE";
const EMPTY_LIST$1 = [];
function flattenData(childrenColumnName, data) {
  let list = [];
  (data || []).forEach((record) => {
    list.push(record);
    if (record && typeof record === "object" && childrenColumnName in record) {
      list = [...list, ...flattenData(childrenColumnName, record[childrenColumnName])];
    }
  });
  return list;
}
function useSelection(rowSelectionRef, configRef) {
  const mergedRowSelection = computed(() => {
    const temp = rowSelectionRef.value || {};
    const {
      checkStrictly = true
    } = temp;
    return _extends$1(_extends$1({}, temp), {
      checkStrictly
    });
  });
  const [mergedSelectedKeys, setMergedSelectedKeys] = useMergedState(mergedRowSelection.value.selectedRowKeys || mergedRowSelection.value.defaultSelectedRowKeys || EMPTY_LIST$1, {
    value: computed(() => mergedRowSelection.value.selectedRowKeys)
  });
  const preserveRecordsRef = shallowRef(/* @__PURE__ */ new Map());
  const updatePreserveRecordsCache = (keys2) => {
    if (mergedRowSelection.value.preserveSelectedRowKeys) {
      const newCache = /* @__PURE__ */ new Map();
      keys2.forEach((key2) => {
        let record = configRef.getRecordByKey(key2);
        if (!record && preserveRecordsRef.value.has(key2)) {
          record = preserveRecordsRef.value.get(key2);
        }
        newCache.set(key2, record);
      });
      preserveRecordsRef.value = newCache;
    }
  };
  watchEffect(() => {
    updatePreserveRecordsCache(mergedSelectedKeys.value);
  });
  const keyEntities = computed(() => mergedRowSelection.value.checkStrictly ? null : convertDataToEntities(configRef.data.value, {
    externalGetKey: configRef.getRowKey.value,
    childrenPropName: configRef.childrenColumnName.value
  }).keyEntities);
  const flattedData = computed(() => flattenData(configRef.childrenColumnName.value, configRef.pageData.value));
  const checkboxPropsMap = computed(() => {
    const map = /* @__PURE__ */ new Map();
    const getRowKey = configRef.getRowKey.value;
    const getCheckboxProps = mergedRowSelection.value.getCheckboxProps;
    flattedData.value.forEach((record, index2) => {
      const key2 = getRowKey(record, index2);
      const checkboxProps2 = (getCheckboxProps ? getCheckboxProps(record) : null) || {};
      map.set(key2, checkboxProps2);
    });
    return map;
  });
  const {
    maxLevel,
    levelEntities
  } = useMaxLevel(keyEntities);
  const isCheckboxDisabled = (r2) => {
    var _a2;
    return !!((_a2 = checkboxPropsMap.value.get(configRef.getRowKey.value(r2))) === null || _a2 === void 0 ? void 0 : _a2.disabled);
  };
  const selectKeysState = computed(() => {
    if (mergedRowSelection.value.checkStrictly) {
      return [mergedSelectedKeys.value || [], []];
    }
    const {
      checkedKeys,
      halfCheckedKeys
    } = conductCheck(mergedSelectedKeys.value, true, keyEntities.value, maxLevel.value, levelEntities.value, isCheckboxDisabled);
    return [checkedKeys || [], halfCheckedKeys];
  });
  const derivedSelectedKeys = computed(() => selectKeysState.value[0]);
  const derivedHalfSelectedKeys = computed(() => selectKeysState.value[1]);
  const derivedSelectedKeySet = computed(() => {
    const keys2 = mergedRowSelection.value.type === "radio" ? derivedSelectedKeys.value.slice(0, 1) : derivedSelectedKeys.value;
    return new Set(keys2);
  });
  const derivedHalfSelectedKeySet = computed(() => mergedRowSelection.value.type === "radio" ? /* @__PURE__ */ new Set() : new Set(derivedHalfSelectedKeys.value));
  const [lastSelectedKey, setLastSelectedKey] = useState(null);
  const setSelectedKeys = (keys2) => {
    let availableKeys;
    let records;
    updatePreserveRecordsCache(keys2);
    const {
      preserveSelectedRowKeys,
      onChange: onSelectionChange
    } = mergedRowSelection.value;
    const {
      getRecordByKey
    } = configRef;
    if (preserveSelectedRowKeys) {
      availableKeys = keys2;
      records = keys2.map((key2) => preserveRecordsRef.value.get(key2));
    } else {
      availableKeys = [];
      records = [];
      keys2.forEach((key2) => {
        const record = getRecordByKey(key2);
        if (record !== void 0) {
          availableKeys.push(key2);
          records.push(record);
        }
      });
    }
    setMergedSelectedKeys(availableKeys);
    onSelectionChange === null || onSelectionChange === void 0 ? void 0 : onSelectionChange(availableKeys, records);
  };
  const triggerSingleSelection = (key2, selected, keys2, event) => {
    const {
      onSelect
    } = mergedRowSelection.value;
    const {
      getRecordByKey
    } = configRef;
    if (onSelect) {
      const rows = keys2.map((k2) => getRecordByKey(k2));
      onSelect(getRecordByKey(key2), selected, rows, event);
    }
    setSelectedKeys(keys2);
  };
  const mergedSelections = computed(() => {
    const {
      onSelectInvert,
      onSelectNone,
      selections,
      hideSelectAll
    } = mergedRowSelection.value;
    const {
      data,
      pageData,
      getRowKey,
      locale: tableLocale
    } = configRef;
    if (!selections || hideSelectAll) {
      return null;
    }
    const selectionList = selections === true ? [SELECTION_ALL, SELECTION_INVERT, SELECTION_NONE] : selections;
    return selectionList.map((selection) => {
      if (selection === SELECTION_ALL) {
        return {
          key: "all",
          text: tableLocale.value.selectionAll,
          onSelect() {
            setSelectedKeys(data.value.map((record, index2) => getRowKey.value(record, index2)).filter((key2) => {
              const checkProps = checkboxPropsMap.value.get(key2);
              return !(checkProps === null || checkProps === void 0 ? void 0 : checkProps.disabled) || derivedSelectedKeySet.value.has(key2);
            }));
          }
        };
      }
      if (selection === SELECTION_INVERT) {
        return {
          key: "invert",
          text: tableLocale.value.selectInvert,
          onSelect() {
            const keySet = new Set(derivedSelectedKeySet.value);
            pageData.value.forEach((record, index2) => {
              const key2 = getRowKey.value(record, index2);
              const checkProps = checkboxPropsMap.value.get(key2);
              if (!(checkProps === null || checkProps === void 0 ? void 0 : checkProps.disabled)) {
                if (keySet.has(key2)) {
                  keySet.delete(key2);
                } else {
                  keySet.add(key2);
                }
              }
            });
            const keys2 = Array.from(keySet);
            if (onSelectInvert) {
              devWarning(false, "Table", "`onSelectInvert` will be removed in future. Please use `onChange` instead.");
              onSelectInvert(keys2);
            }
            setSelectedKeys(keys2);
          }
        };
      }
      if (selection === SELECTION_NONE) {
        return {
          key: "none",
          text: tableLocale.value.selectNone,
          onSelect() {
            onSelectNone === null || onSelectNone === void 0 ? void 0 : onSelectNone();
            setSelectedKeys(Array.from(derivedSelectedKeySet.value).filter((key2) => {
              const checkProps = checkboxPropsMap.value.get(key2);
              return checkProps === null || checkProps === void 0 ? void 0 : checkProps.disabled;
            }));
          }
        };
      }
      return selection;
    });
  });
  const flattedDataLength = computed(() => flattedData.value.length);
  const transformColumns = (columns) => {
    var _a2;
    const {
      onSelectAll,
      onSelectMultiple,
      columnWidth: selectionColWidth,
      type: selectionType,
      fixed,
      renderCell: customizeRenderCell,
      hideSelectAll,
      checkStrictly
    } = mergedRowSelection.value;
    const {
      prefixCls,
      getRecordByKey,
      getRowKey,
      expandType,
      getPopupContainer
    } = configRef;
    if (!rowSelectionRef.value) {
      return columns.filter((col) => col !== SELECTION_COLUMN);
    }
    let cloneColumns = columns.slice();
    const keySet = new Set(derivedSelectedKeySet.value);
    const recordKeys = flattedData.value.map(getRowKey.value).filter((key2) => !checkboxPropsMap.value.get(key2).disabled);
    const checkedCurrentAll = recordKeys.every((key2) => keySet.has(key2));
    const checkedCurrentSome = recordKeys.some((key2) => keySet.has(key2));
    const onSelectAllChange = () => {
      const changeKeys = [];
      if (checkedCurrentAll) {
        recordKeys.forEach((key2) => {
          keySet.delete(key2);
          changeKeys.push(key2);
        });
      } else {
        recordKeys.forEach((key2) => {
          if (!keySet.has(key2)) {
            keySet.add(key2);
            changeKeys.push(key2);
          }
        });
      }
      const keys2 = Array.from(keySet);
      onSelectAll === null || onSelectAll === void 0 ? void 0 : onSelectAll(!checkedCurrentAll, keys2.map((k2) => getRecordByKey(k2)), changeKeys.map((k2) => getRecordByKey(k2)));
      setSelectedKeys(keys2);
    };
    let title;
    if (selectionType !== "radio") {
      let customizeSelections;
      if (mergedSelections.value) {
        const menu = createVNode(Menu, {
          "getPopupContainer": getPopupContainer.value
        }, {
          default: () => [mergedSelections.value.map((selection, index2) => {
            const {
              key: key2,
              text,
              onSelect: onSelectionClick
            } = selection;
            return createVNode(Menu.Item, {
              "key": key2 || index2,
              "onClick": () => {
                onSelectionClick === null || onSelectionClick === void 0 ? void 0 : onSelectionClick(recordKeys);
              }
            }, {
              default: () => [text]
            });
          })]
        });
        customizeSelections = createVNode("div", {
          "class": `${prefixCls.value}-selection-extra`
        }, [createVNode(Dropdown, {
          "overlay": menu,
          "getPopupContainer": getPopupContainer.value
        }, {
          default: () => [createVNode("span", null, [createVNode(DownOutlined, null, null)])]
        })]);
      }
      const allDisabledData = flattedData.value.map((record, index2) => {
        const key2 = getRowKey.value(record, index2);
        const checkboxProps2 = checkboxPropsMap.value.get(key2) || {};
        return _extends$1({
          checked: keySet.has(key2)
        }, checkboxProps2);
      }).filter((_ref) => {
        let {
          disabled
        } = _ref;
        return disabled;
      });
      const allDisabled = !!allDisabledData.length && allDisabledData.length === flattedDataLength.value;
      const allDisabledAndChecked = allDisabled && allDisabledData.every((_ref2) => {
        let {
          checked
        } = _ref2;
        return checked;
      });
      const allDisabledSomeChecked = allDisabled && allDisabledData.some((_ref3) => {
        let {
          checked
        } = _ref3;
        return checked;
      });
      title = !hideSelectAll && createVNode("div", {
        "class": `${prefixCls.value}-selection`
      }, [createVNode(Checkbox, {
        "checked": !allDisabled ? !!flattedDataLength.value && checkedCurrentAll : allDisabledAndChecked,
        "indeterminate": !allDisabled ? !checkedCurrentAll && checkedCurrentSome : !allDisabledAndChecked && allDisabledSomeChecked,
        "onChange": onSelectAllChange,
        "disabled": flattedDataLength.value === 0 || allDisabled,
        "aria-label": customizeSelections ? "Custom selection" : "Select all",
        "skipGroup": true
      }, null), customizeSelections]);
    }
    let renderCell;
    if (selectionType === "radio") {
      renderCell = (_ref4) => {
        let {
          record,
          index: index2
        } = _ref4;
        const key2 = getRowKey.value(record, index2);
        const checked = keySet.has(key2);
        return {
          node: createVNode(Radio, _objectSpread2$1(_objectSpread2$1({}, checkboxPropsMap.value.get(key2)), {}, {
            "checked": checked,
            "onClick": (e2) => e2.stopPropagation(),
            "onChange": (event) => {
              if (!keySet.has(key2)) {
                triggerSingleSelection(key2, true, [key2], event.nativeEvent);
              }
            }
          }), null),
          checked
        };
      };
    } else {
      renderCell = (_ref5) => {
        let {
          record,
          index: index2
        } = _ref5;
        var _a22;
        const key2 = getRowKey.value(record, index2);
        const checked = keySet.has(key2);
        const indeterminate = derivedHalfSelectedKeySet.value.has(key2);
        const checkboxProps2 = checkboxPropsMap.value.get(key2);
        let mergedIndeterminate;
        if (expandType.value === "nest") {
          mergedIndeterminate = indeterminate;
          devWarning(typeof (checkboxProps2 === null || checkboxProps2 === void 0 ? void 0 : checkboxProps2.indeterminate) !== "boolean", "Table", "set `indeterminate` using `rowSelection.getCheckboxProps` is not allowed with tree structured dataSource.");
        } else {
          mergedIndeterminate = (_a22 = checkboxProps2 === null || checkboxProps2 === void 0 ? void 0 : checkboxProps2.indeterminate) !== null && _a22 !== void 0 ? _a22 : indeterminate;
        }
        return {
          node: createVNode(Checkbox, _objectSpread2$1(_objectSpread2$1({}, checkboxProps2), {}, {
            "indeterminate": mergedIndeterminate,
            "checked": checked,
            "skipGroup": true,
            "onClick": (e2) => e2.stopPropagation(),
            "onChange": (_ref6) => {
              let {
                nativeEvent
              } = _ref6;
              const {
                shiftKey
              } = nativeEvent;
              let startIndex = -1;
              let endIndex = -1;
              if (shiftKey && checkStrictly) {
                const pointKeys = /* @__PURE__ */ new Set([lastSelectedKey.value, key2]);
                recordKeys.some((recordKey, recordIndex) => {
                  if (pointKeys.has(recordKey)) {
                    if (startIndex === -1) {
                      startIndex = recordIndex;
                    } else {
                      endIndex = recordIndex;
                      return true;
                    }
                  }
                  return false;
                });
              }
              if (endIndex !== -1 && startIndex !== endIndex && checkStrictly) {
                const rangeKeys = recordKeys.slice(startIndex, endIndex + 1);
                const changedKeys = [];
                if (checked) {
                  rangeKeys.forEach((recordKey) => {
                    if (keySet.has(recordKey)) {
                      changedKeys.push(recordKey);
                      keySet.delete(recordKey);
                    }
                  });
                } else {
                  rangeKeys.forEach((recordKey) => {
                    if (!keySet.has(recordKey)) {
                      changedKeys.push(recordKey);
                      keySet.add(recordKey);
                    }
                  });
                }
                const keys2 = Array.from(keySet);
                onSelectMultiple === null || onSelectMultiple === void 0 ? void 0 : onSelectMultiple(!checked, keys2.map((recordKey) => getRecordByKey(recordKey)), changedKeys.map((recordKey) => getRecordByKey(recordKey)));
                setSelectedKeys(keys2);
              } else {
                const originCheckedKeys = derivedSelectedKeys.value;
                if (checkStrictly) {
                  const checkedKeys = checked ? arrDel(originCheckedKeys, key2) : arrAdd(originCheckedKeys, key2);
                  triggerSingleSelection(key2, !checked, checkedKeys, nativeEvent);
                } else {
                  const result = conductCheck([...originCheckedKeys, key2], true, keyEntities.value, maxLevel.value, levelEntities.value, isCheckboxDisabled);
                  const {
                    checkedKeys,
                    halfCheckedKeys
                  } = result;
                  let nextCheckedKeys = checkedKeys;
                  if (checked) {
                    const tempKeySet = new Set(checkedKeys);
                    tempKeySet.delete(key2);
                    nextCheckedKeys = conductCheck(Array.from(tempKeySet), {
                      checked: false,
                      halfCheckedKeys
                    }, keyEntities.value, maxLevel.value, levelEntities.value, isCheckboxDisabled).checkedKeys;
                  }
                  triggerSingleSelection(key2, !checked, nextCheckedKeys, nativeEvent);
                }
              }
              setLastSelectedKey(key2);
            }
          }), null),
          checked
        };
      };
    }
    const renderSelectionCell = (_ref7) => {
      let {
        record,
        index: index2
      } = _ref7;
      const {
        node: node2,
        checked
      } = renderCell({
        record,
        index: index2
      });
      if (customizeRenderCell) {
        return customizeRenderCell(checked, record, index2, node2);
      }
      return node2;
    };
    if (!cloneColumns.includes(SELECTION_COLUMN)) {
      if (cloneColumns.findIndex((col) => {
        var _a22;
        return ((_a22 = col[INTERNAL_COL_DEFINE]) === null || _a22 === void 0 ? void 0 : _a22.columnType) === "EXPAND_COLUMN";
      }) === 0) {
        const [expandColumn, ...restColumns] = cloneColumns;
        cloneColumns = [expandColumn, SELECTION_COLUMN, ...restColumns];
      } else {
        cloneColumns = [SELECTION_COLUMN, ...cloneColumns];
      }
    }
    const selectionColumnIndex = cloneColumns.indexOf(SELECTION_COLUMN);
    cloneColumns = cloneColumns.filter((column2, index2) => column2 !== SELECTION_COLUMN || index2 === selectionColumnIndex);
    const prevCol = cloneColumns[selectionColumnIndex - 1];
    const nextCol = cloneColumns[selectionColumnIndex + 1];
    let mergedFixed = fixed;
    if (mergedFixed === void 0) {
      if ((nextCol === null || nextCol === void 0 ? void 0 : nextCol.fixed) !== void 0) {
        mergedFixed = nextCol.fixed;
      } else if ((prevCol === null || prevCol === void 0 ? void 0 : prevCol.fixed) !== void 0) {
        mergedFixed = prevCol.fixed;
      }
    }
    if (mergedFixed && prevCol && ((_a2 = prevCol[INTERNAL_COL_DEFINE]) === null || _a2 === void 0 ? void 0 : _a2.columnType) === "EXPAND_COLUMN" && prevCol.fixed === void 0) {
      prevCol.fixed = mergedFixed;
    }
    const selectionColumn = {
      fixed: mergedFixed,
      width: selectionColWidth,
      className: `${prefixCls.value}-selection-column`,
      title: mergedRowSelection.value.columnTitle || title,
      customRender: renderSelectionCell,
      [INTERNAL_COL_DEFINE]: {
        class: `${prefixCls.value}-selection-col`
      }
    };
    return cloneColumns.map((col) => col === SELECTION_COLUMN ? selectionColumn : col);
  };
  return [transformColumns, derivedSelectedKeySet];
}
var __rest$b = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
function getColumnKey(column2, defaultKey) {
  if ("key" in column2 && column2.key !== void 0 && column2.key !== null) {
    return column2.key;
  }
  if (column2.dataIndex) {
    return Array.isArray(column2.dataIndex) ? column2.dataIndex.join(".") : column2.dataIndex;
  }
  return defaultKey;
}
function getColumnPos(index2, pos) {
  return pos ? `${pos}-${index2}` : `${index2}`;
}
function renderColumnTitle(title, props2) {
  if (typeof title === "function") {
    return title(props2);
  }
  return title;
}
function convertChildrenToColumns() {
  let elements = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  const flattenElements = flattenChildren(elements);
  const columns = [];
  flattenElements.forEach((element) => {
    var _a2, _b, _c, _d;
    if (!element) {
      return;
    }
    const key2 = element.key;
    const style = ((_a2 = element.props) === null || _a2 === void 0 ? void 0 : _a2.style) || {};
    const cls = ((_b = element.props) === null || _b === void 0 ? void 0 : _b.class) || "";
    const props2 = element.props || {};
    for (const [k2, v2] of Object.entries(props2)) {
      props2[camelize(k2)] = v2;
    }
    const _e = element.children || {}, {
      default: children
    } = _e, restSlots = __rest$b(_e, ["default"]);
    const column2 = _extends$1(_extends$1(_extends$1({}, restSlots), props2), {
      style,
      class: cls
    });
    if (key2) {
      column2.key = key2;
    }
    if ((_c = element.type) === null || _c === void 0 ? void 0 : _c.__ANT_TABLE_COLUMN_GROUP) {
      column2.children = convertChildrenToColumns(typeof children === "function" ? children() : children);
    } else {
      const customRender = (_d = element.children) === null || _d === void 0 ? void 0 : _d.default;
      column2.customRender = column2.customRender || customRender;
    }
    columns.push(column2);
  });
  return columns;
}
const ASCEND = "ascend";
const DESCEND = "descend";
function getMultiplePriority(column2) {
  if (typeof column2.sorter === "object" && typeof column2.sorter.multiple === "number") {
    return column2.sorter.multiple;
  }
  return false;
}
function getSortFunction(sorter) {
  if (typeof sorter === "function") {
    return sorter;
  }
  if (sorter && typeof sorter === "object" && sorter.compare) {
    return sorter.compare;
  }
  return false;
}
function nextSortDirection(sortDirections, current) {
  if (!current) {
    return sortDirections[0];
  }
  return sortDirections[sortDirections.indexOf(current) + 1];
}
function collectSortStates(columns, init, pos) {
  let sortStates = [];
  function pushState(column2, columnPos) {
    sortStates.push({
      column: column2,
      key: getColumnKey(column2, columnPos),
      multiplePriority: getMultiplePriority(column2),
      sortOrder: column2.sortOrder
    });
  }
  (columns || []).forEach((column2, index2) => {
    const columnPos = getColumnPos(index2, pos);
    if (column2.children) {
      if ("sortOrder" in column2) {
        pushState(column2, columnPos);
      }
      sortStates = [...sortStates, ...collectSortStates(column2.children, init, columnPos)];
    } else if (column2.sorter) {
      if ("sortOrder" in column2) {
        pushState(column2, columnPos);
      } else if (init && column2.defaultSortOrder) {
        sortStates.push({
          column: column2,
          key: getColumnKey(column2, columnPos),
          multiplePriority: getMultiplePriority(column2),
          sortOrder: column2.defaultSortOrder
        });
      }
    }
  });
  return sortStates;
}
function injectSorter(prefixCls, columns, sorterStates, triggerSorter, defaultSortDirections, tableLocale, tableShowSorterTooltip, pos) {
  return (columns || []).map((column2, index2) => {
    const columnPos = getColumnPos(index2, pos);
    let newColumn = column2;
    if (newColumn.sorter) {
      const sortDirections = newColumn.sortDirections || defaultSortDirections;
      const showSorterTooltip = newColumn.showSorterTooltip === void 0 ? tableShowSorterTooltip : newColumn.showSorterTooltip;
      const columnKey = getColumnKey(newColumn, columnPos);
      const sorterState = sorterStates.find((_ref) => {
        let {
          key: key2
        } = _ref;
        return key2 === columnKey;
      });
      const sorterOrder = sorterState ? sorterState.sortOrder : null;
      const nextSortOrder = nextSortDirection(sortDirections, sorterOrder);
      const upNode = sortDirections.includes(ASCEND) && createVNode(CaretUpOutlined, {
        "class": classNames(`${prefixCls}-column-sorter-up`, {
          active: sorterOrder === ASCEND
        }),
        "role": "presentation"
      }, null);
      const downNode = sortDirections.includes(DESCEND) && createVNode(CaretDownOutlined, {
        "role": "presentation",
        "class": classNames(`${prefixCls}-column-sorter-down`, {
          active: sorterOrder === DESCEND
        })
      }, null);
      const {
        cancelSort,
        triggerAsc,
        triggerDesc
      } = tableLocale || {};
      let sortTip = cancelSort;
      if (nextSortOrder === DESCEND) {
        sortTip = triggerDesc;
      } else if (nextSortOrder === ASCEND) {
        sortTip = triggerAsc;
      }
      const tooltipProps2 = typeof showSorterTooltip === "object" ? showSorterTooltip : {
        title: sortTip
      };
      newColumn = _extends$1(_extends$1({}, newColumn), {
        className: classNames(newColumn.className, {
          [`${prefixCls}-column-sort`]: sorterOrder
        }),
        title: (renderProps) => {
          const renderSortTitle = createVNode("div", {
            "class": `${prefixCls}-column-sorters`
          }, [createVNode("span", {
            "class": `${prefixCls}-column-title`
          }, [renderColumnTitle(column2.title, renderProps)]), createVNode("span", {
            "class": classNames(`${prefixCls}-column-sorter`, {
              [`${prefixCls}-column-sorter-full`]: !!(upNode && downNode)
            })
          }, [createVNode("span", {
            "class": `${prefixCls}-column-sorter-inner`
          }, [upNode, downNode])])]);
          return showSorterTooltip ? createVNode(Tooltip, tooltipProps2, {
            default: () => [renderSortTitle]
          }) : renderSortTitle;
        },
        customHeaderCell: (col) => {
          const cell = column2.customHeaderCell && column2.customHeaderCell(col) || {};
          const originOnClick = cell.onClick;
          const originOKeyDown = cell.onKeydown;
          cell.onClick = (event) => {
            triggerSorter({
              column: column2,
              key: columnKey,
              sortOrder: nextSortOrder,
              multiplePriority: getMultiplePriority(column2)
            });
            if (originOnClick) {
              originOnClick(event);
            }
          };
          cell.onKeydown = (event) => {
            if (event.keyCode === KeyCode.ENTER) {
              triggerSorter({
                column: column2,
                key: columnKey,
                sortOrder: nextSortOrder,
                multiplePriority: getMultiplePriority(column2)
              });
              originOKeyDown === null || originOKeyDown === void 0 ? void 0 : originOKeyDown(event);
            }
          };
          if (sorterOrder) {
            cell["aria-sort"] = sorterOrder === "ascend" ? "ascending" : "descending";
          }
          cell.class = classNames(cell.class, `${prefixCls}-column-has-sorters`);
          cell.tabindex = 0;
          return cell;
        }
      });
    }
    if ("children" in newColumn) {
      newColumn = _extends$1(_extends$1({}, newColumn), {
        children: injectSorter(prefixCls, newColumn.children, sorterStates, triggerSorter, defaultSortDirections, tableLocale, tableShowSorterTooltip, columnPos)
      });
    }
    return newColumn;
  });
}
function stateToInfo(sorterStates) {
  const {
    column: column2,
    sortOrder
  } = sorterStates;
  return {
    column: column2,
    order: sortOrder,
    field: column2.dataIndex,
    columnKey: column2.key
  };
}
function generateSorterInfo(sorterStates) {
  const list = sorterStates.filter((_ref2) => {
    let {
      sortOrder
    } = _ref2;
    return sortOrder;
  }).map(stateToInfo);
  if (list.length === 0 && sorterStates.length) {
    return _extends$1(_extends$1({}, stateToInfo(sorterStates[sorterStates.length - 1])), {
      column: void 0
    });
  }
  if (list.length <= 1) {
    return list[0] || {};
  }
  return list;
}
function getSortData(data, sortStates, childrenColumnName) {
  const innerSorterStates = sortStates.slice().sort((a2, b2) => b2.multiplePriority - a2.multiplePriority);
  const cloneData = data.slice();
  const runningSorters = innerSorterStates.filter((_ref3) => {
    let {
      column: {
        sorter
      },
      sortOrder
    } = _ref3;
    return getSortFunction(sorter) && sortOrder;
  });
  if (!runningSorters.length) {
    return cloneData;
  }
  return cloneData.sort((record1, record2) => {
    for (let i2 = 0; i2 < runningSorters.length; i2 += 1) {
      const sorterState = runningSorters[i2];
      const {
        column: {
          sorter
        },
        sortOrder
      } = sorterState;
      const compareFn = getSortFunction(sorter);
      if (compareFn && sortOrder) {
        const compareResult = compareFn(record1, record2, sortOrder);
        if (compareResult !== 0) {
          return sortOrder === ASCEND ? compareResult : -compareResult;
        }
      }
    }
    return 0;
  }).map((record) => {
    const subRecords = record[childrenColumnName];
    if (subRecords) {
      return _extends$1(_extends$1({}, record), {
        [childrenColumnName]: getSortData(subRecords, sortStates, childrenColumnName)
      });
    }
    return record;
  });
}
function useFilterSorter(_ref4) {
  let {
    prefixCls,
    mergedColumns,
    onSorterChange,
    sortDirections,
    tableLocale,
    showSorterTooltip
  } = _ref4;
  const [sortStates, setSortStates] = useState(collectSortStates(mergedColumns.value, true));
  const mergedSorterStates = computed(() => {
    let validate = true;
    const collectedStates = collectSortStates(mergedColumns.value, false);
    if (!collectedStates.length) {
      return sortStates.value;
    }
    const validateStates = [];
    function patchStates(state) {
      if (validate) {
        validateStates.push(state);
      } else {
        validateStates.push(_extends$1(_extends$1({}, state), {
          sortOrder: null
        }));
      }
    }
    let multipleMode = null;
    collectedStates.forEach((state) => {
      if (multipleMode === null) {
        patchStates(state);
        if (state.sortOrder) {
          if (state.multiplePriority === false) {
            validate = false;
          } else {
            multipleMode = true;
          }
        }
      } else if (multipleMode && state.multiplePriority !== false) {
        patchStates(state);
      } else {
        validate = false;
        patchStates(state);
      }
    });
    return validateStates;
  });
  const columnTitleSorterProps = computed(() => {
    const sortColumns = mergedSorterStates.value.map((_ref5) => {
      let {
        column: column2,
        sortOrder
      } = _ref5;
      return {
        column: column2,
        order: sortOrder
      };
    });
    return {
      sortColumns,
      // Legacy
      sortColumn: sortColumns[0] && sortColumns[0].column,
      sortOrder: sortColumns[0] && sortColumns[0].order
    };
  });
  function triggerSorter(sortState) {
    let newSorterStates;
    if (sortState.multiplePriority === false || !mergedSorterStates.value.length || mergedSorterStates.value[0].multiplePriority === false) {
      newSorterStates = [sortState];
    } else {
      newSorterStates = [...mergedSorterStates.value.filter((_ref6) => {
        let {
          key: key2
        } = _ref6;
        return key2 !== sortState.key;
      }), sortState];
    }
    setSortStates(newSorterStates);
    onSorterChange(generateSorterInfo(newSorterStates), newSorterStates);
  }
  const transformColumns = (innerColumns) => injectSorter(prefixCls.value, innerColumns, mergedSorterStates.value, triggerSorter, sortDirections.value, tableLocale.value, showSorterTooltip.value);
  const sorters = computed(() => generateSorterInfo(mergedSorterStates.value));
  return [transformColumns, mergedSorterStates, columnTitleSorterProps, sorters];
}
const onKeyDown = (event) => {
  const {
    keyCode
  } = event;
  if (keyCode === KeyCode.ENTER) {
    event.stopPropagation();
  }
};
const FilterDropdownMenuWrapper = (_props, _ref) => {
  let {
    slots
  } = _ref;
  var _a2;
  return createVNode("div", {
    "onClick": (e2) => e2.stopPropagation(),
    "onKeydown": onKeyDown
  }, [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]);
};
const FilterSearch = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "FilterSearch",
  inheritAttrs: false,
  props: {
    value: stringType(),
    onChange: functionType(),
    filterSearch: someType([Boolean, Function]),
    tablePrefixCls: stringType(),
    locale: objectType()
  },
  setup(props2) {
    return () => {
      const {
        value,
        onChange,
        filterSearch,
        tablePrefixCls,
        locale: locale2
      } = props2;
      if (!filterSearch) {
        return null;
      }
      return createVNode("div", {
        "class": `${tablePrefixCls}-filter-dropdown-search`
      }, [createVNode(Input, {
        "placeholder": locale2.filterSearchPlaceholder,
        "onChange": onChange,
        "value": value,
        "htmlSize": 1,
        "class": `${tablePrefixCls}-filter-dropdown-search-input`
      }, {
        prefix: () => createVNode(SearchOutlined, null, null)
      })]);
    };
  }
});
var __rest$a = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const MotionTreeNode = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "MotionTreeNode",
  inheritAttrs: false,
  props: _extends$1(_extends$1({}, treeNodeProps), {
    active: Boolean,
    motion: Object,
    motionNodes: {
      type: Array
    },
    onMotionStart: Function,
    onMotionEnd: Function,
    motionType: String
  }),
  setup(props2, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const visible = shallowRef(true);
    const context2 = useInjectTreeContext();
    const motionedRef = shallowRef(false);
    const transitionProps = computed(() => {
      if (props2.motion) {
        return props2.motion;
      } else {
        return collapseMotion();
      }
    });
    const onMotionEnd = (node2, type4) => {
      var _a2, _b, _c, _d;
      if (type4 === "appear") {
        (_b = (_a2 = transitionProps.value) === null || _a2 === void 0 ? void 0 : _a2.onAfterEnter) === null || _b === void 0 ? void 0 : _b.call(_a2, node2);
      } else if (type4 === "leave") {
        (_d = (_c = transitionProps.value) === null || _c === void 0 ? void 0 : _c.onAfterLeave) === null || _d === void 0 ? void 0 : _d.call(_c, node2);
      }
      if (!motionedRef.value) {
        props2.onMotionEnd();
      }
      motionedRef.value = true;
    };
    watch(() => props2.motionNodes, () => {
      if (props2.motionNodes && props2.motionType === "hide" && visible.value) {
        nextTick(() => {
          visible.value = false;
        });
      }
    }, {
      immediate: true,
      flush: "post"
    });
    onMounted(() => {
      props2.motionNodes && props2.onMotionStart();
    });
    onBeforeUnmount(() => {
      props2.motionNodes && onMotionEnd();
    });
    return () => {
      const {
        motion,
        motionNodes,
        motionType,
        active,
        eventKey
      } = props2, otherProps = __rest$a(props2, ["motion", "motionNodes", "motionType", "active", "eventKey"]);
      if (motionNodes) {
        return createVNode(Transition, _objectSpread2$1(_objectSpread2$1({}, transitionProps.value), {}, {
          "appear": motionType === "show",
          "onAfterAppear": (node2) => onMotionEnd(node2, "appear"),
          "onAfterLeave": (node2) => onMotionEnd(node2, "leave")
        }), {
          default: () => [withDirectives(createVNode("div", {
            "class": `${context2.value.prefixCls}-treenode-motion`
          }, [motionNodes.map((treeNode) => {
            const restProps = __rest$a(treeNode.data, []), {
              title,
              key: key2,
              isStart,
              isEnd
            } = treeNode;
            delete restProps.children;
            return createVNode(VcTreeNode, _objectSpread2$1(_objectSpread2$1({}, restProps), {}, {
              "title": title,
              "active": active,
              "data": treeNode.data,
              "key": key2,
              "eventKey": key2,
              "isStart": isStart,
              "isEnd": isEnd
            }), slots);
          })]), [[vShow, visible.value]])]
        });
      }
      return createVNode(VcTreeNode, _objectSpread2$1(_objectSpread2$1({
        "class": attrs.class,
        "style": attrs.style
      }, otherProps), {}, {
        "active": active,
        "eventKey": eventKey
      }), slots);
    };
  }
});
function findExpandedKeys() {
  let prev2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  let next2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  const prevLen = prev2.length;
  const nextLen = next2.length;
  if (Math.abs(prevLen - nextLen) !== 1) {
    return {
      add: false,
      key: null
    };
  }
  function find2(shorter, longer) {
    const cache = /* @__PURE__ */ new Map();
    shorter.forEach((key2) => {
      cache.set(key2, true);
    });
    const keys2 = longer.filter((key2) => !cache.has(key2));
    return keys2.length === 1 ? keys2[0] : null;
  }
  if (prevLen < nextLen) {
    return {
      add: true,
      key: find2(prev2, next2)
    };
  }
  return {
    add: false,
    key: find2(next2, prev2)
  };
}
function getExpandRange(shorter, longer, key2) {
  const shorterStartIndex = shorter.findIndex((item) => item.key === key2);
  const shorterEndNode = shorter[shorterStartIndex + 1];
  const longerStartIndex = longer.findIndex((item) => item.key === key2);
  if (shorterEndNode) {
    const longerEndIndex = longer.findIndex((item) => item.key === shorterEndNode.key);
    return longer.slice(longerStartIndex + 1, longerEndIndex);
  }
  return longer.slice(longerStartIndex + 1);
}
var __rest$9 = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const HIDDEN_STYLE = {
  width: 0,
  height: 0,
  display: "flex",
  overflow: "hidden",
  opacity: 0,
  border: 0,
  padding: 0,
  margin: 0
};
const noop = () => {
};
const MOTION_KEY = `RC_TREE_MOTION_${Math.random()}`;
const MotionNode = {
  key: MOTION_KEY
};
const MotionEntity = {
  key: MOTION_KEY,
  level: 0,
  index: 0,
  pos: "0",
  node: MotionNode,
  nodes: [MotionNode]
};
const MotionFlattenData = {
  parent: null,
  children: [],
  pos: MotionEntity.pos,
  data: MotionNode,
  title: null,
  key: MOTION_KEY,
  /** Hold empty list here since we do not use it */
  isStart: [],
  isEnd: []
};
function getMinimumRangeTransitionRange(list, virtual, height, itemHeight) {
  if (virtual === false || !height) {
    return list;
  }
  return list.slice(0, Math.ceil(height / itemHeight) + 1);
}
function itemKey(item) {
  const {
    key: key2,
    pos
  } = item;
  return getKey(key2, pos);
}
function getAccessibilityPath(item) {
  let path2 = String(item.key);
  let current = item;
  while (current.parent) {
    current = current.parent;
    path2 = `${current.key} > ${path2}`;
  }
  return path2;
}
const NodeList = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "NodeList",
  inheritAttrs: false,
  props: nodeListProps,
  setup(props2, _ref) {
    let {
      expose,
      attrs
    } = _ref;
    const listRef = ref();
    const indentMeasurerRef = ref();
    const {
      expandedKeys,
      flattenNodes
    } = useInjectKeysState();
    expose({
      scrollTo: (scroll) => {
        listRef.value.scrollTo(scroll);
      },
      getIndentWidth: () => indentMeasurerRef.value.offsetWidth
    });
    const transitionData = shallowRef(flattenNodes.value);
    const transitionRange = shallowRef([]);
    const motionType = ref(null);
    function onMotionEnd() {
      transitionData.value = flattenNodes.value;
      transitionRange.value = [];
      motionType.value = null;
      props2.onListChangeEnd();
    }
    const context2 = useInjectTreeContext();
    watch([() => expandedKeys.value.slice(), flattenNodes], (_ref2, _ref3) => {
      let [expandedKeys2, data] = _ref2;
      let [prevExpandedKeys, prevData] = _ref3;
      const diffExpanded = findExpandedKeys(prevExpandedKeys, expandedKeys2);
      if (diffExpanded.key !== null) {
        const {
          virtual,
          height,
          itemHeight
        } = props2;
        if (diffExpanded.add) {
          const keyIndex2 = prevData.findIndex((_ref4) => {
            let {
              key: key2
            } = _ref4;
            return key2 === diffExpanded.key;
          });
          const rangeNodes = getMinimumRangeTransitionRange(getExpandRange(prevData, data, diffExpanded.key), virtual, height, itemHeight);
          const newTransitionData = prevData.slice();
          newTransitionData.splice(keyIndex2 + 1, 0, MotionFlattenData);
          transitionData.value = newTransitionData;
          transitionRange.value = rangeNodes;
          motionType.value = "show";
        } else {
          const keyIndex2 = data.findIndex((_ref5) => {
            let {
              key: key2
            } = _ref5;
            return key2 === diffExpanded.key;
          });
          const rangeNodes = getMinimumRangeTransitionRange(getExpandRange(data, prevData, diffExpanded.key), virtual, height, itemHeight);
          const newTransitionData = data.slice();
          newTransitionData.splice(keyIndex2 + 1, 0, MotionFlattenData);
          transitionData.value = newTransitionData;
          transitionRange.value = rangeNodes;
          motionType.value = "hide";
        }
      } else if (prevData !== data) {
        transitionData.value = data;
      }
    });
    watch(() => context2.value.dragging, (dragging) => {
      if (!dragging) {
        onMotionEnd();
      }
    });
    const mergedData = computed(() => props2.motion === void 0 ? transitionData.value : flattenNodes.value);
    const onActiveChange = () => {
      props2.onActiveChange(null);
    };
    return () => {
      const _a2 = _extends$1(_extends$1({}, props2), attrs), {
        prefixCls,
        selectable,
        checkable,
        disabled,
        motion,
        height,
        itemHeight,
        virtual,
        focusable,
        activeItem,
        focused,
        tabindex,
        onKeydown,
        onFocus,
        onBlur,
        onListChangeStart,
        onListChangeEnd
      } = _a2, domProps = __rest$9(_a2, ["prefixCls", "selectable", "checkable", "disabled", "motion", "height", "itemHeight", "virtual", "focusable", "activeItem", "focused", "tabindex", "onKeydown", "onFocus", "onBlur", "onListChangeStart", "onListChangeEnd"]);
      return createVNode(Fragment, null, [focused && activeItem && createVNode("span", {
        "style": HIDDEN_STYLE,
        "aria-live": "assertive"
      }, [getAccessibilityPath(activeItem)]), createVNode("div", null, [createVNode("input", {
        "style": HIDDEN_STYLE,
        "disabled": focusable === false || disabled,
        "tabindex": focusable !== false ? tabindex : null,
        "onKeydown": onKeydown,
        "onFocus": onFocus,
        "onBlur": onBlur,
        "value": "",
        "onChange": noop,
        "aria-label": "for screen reader"
      }, null)]), createVNode("div", {
        "class": `${prefixCls}-treenode`,
        "aria-hidden": true,
        "style": {
          position: "absolute",
          pointerEvents: "none",
          visibility: "hidden",
          height: 0,
          overflow: "hidden"
        }
      }, [createVNode("div", {
        "class": `${prefixCls}-indent`
      }, [createVNode("div", {
        "ref": indentMeasurerRef,
        "class": `${prefixCls}-indent-unit`
      }, null)])]), createVNode(List$1, _objectSpread2$1(_objectSpread2$1({}, omit$1(domProps, ["onActiveChange"])), {}, {
        "data": mergedData.value,
        "itemKey": itemKey,
        "height": height,
        "fullHeight": false,
        "virtual": virtual,
        "itemHeight": itemHeight,
        "prefixCls": `${prefixCls}-list`,
        "ref": listRef,
        "onVisibleChange": (originList, fullList) => {
          const originSet = new Set(originList);
          const restList = fullList.filter((item) => !originSet.has(item));
          if (restList.some((item) => itemKey(item) === MOTION_KEY)) {
            onMotionEnd();
          }
        }
      }), {
        default: (treeNode) => {
          const {
            pos
          } = treeNode, restProps = __rest$9(treeNode.data, []), {
            title,
            key: key2,
            isStart,
            isEnd
          } = treeNode;
          const mergedKey = getKey(key2, pos);
          delete restProps.key;
          delete restProps.children;
          return createVNode(MotionTreeNode, _objectSpread2$1(_objectSpread2$1({}, restProps), {}, {
            "eventKey": mergedKey,
            "title": title,
            "active": !!activeItem && key2 === activeItem.key,
            "data": treeNode.data,
            "isStart": isStart,
            "isEnd": isEnd,
            "motion": motion,
            "motionNodes": key2 === MOTION_KEY ? transitionRange.value : null,
            "motionType": motionType.value,
            "onMotionStart": onListChangeStart,
            "onMotionEnd": onMotionEnd,
            "onMousemove": onActiveChange
          }), null);
        }
      })]);
    };
  }
});
function DropIndicator(_ref) {
  let {
    dropPosition,
    dropLevelOffset,
    indent
  } = _ref;
  const style = {
    pointerEvents: "none",
    position: "absolute",
    right: 0,
    backgroundColor: "red",
    height: `${2}px`
  };
  switch (dropPosition) {
    case -1:
      style.top = 0;
      style.left = `${-dropLevelOffset * indent}px`;
      break;
    case 1:
      style.bottom = 0;
      style.left = `${-dropLevelOffset * indent}px`;
      break;
    case 0:
      style.bottom = 0;
      style.left = `${indent}`;
      break;
  }
  return createVNode("div", {
    "style": style
  }, null);
}
const MAX_RETRY_TIMES = 10;
const Tree$2 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Tree",
  inheritAttrs: false,
  props: initDefaultProps(treeProps$1(), {
    prefixCls: "vc-tree",
    showLine: false,
    showIcon: true,
    selectable: true,
    multiple: false,
    checkable: false,
    disabled: false,
    checkStrictly: false,
    draggable: false,
    expandAction: false,
    defaultExpandParent: true,
    autoExpandParent: false,
    defaultExpandAll: false,
    defaultExpandedKeys: [],
    defaultCheckedKeys: [],
    defaultSelectedKeys: [],
    dropIndicatorRender: DropIndicator,
    allowDrop: () => true
  }),
  setup(props2, _ref) {
    let {
      attrs,
      slots,
      expose
    } = _ref;
    const destroyed = shallowRef(false);
    let delayedDragEnterLogic = {};
    const indent = shallowRef();
    const selectedKeys = shallowRef([]);
    const checkedKeys = shallowRef([]);
    const halfCheckedKeys = shallowRef([]);
    const loadedKeys = shallowRef([]);
    const loadingKeys = shallowRef([]);
    const expandedKeys = shallowRef([]);
    const loadingRetryTimes = {};
    const dragState = reactive({
      draggingNodeKey: null,
      dragChildrenKeys: [],
      // dropTargetKey is the key of abstract-drop-node
      // the abstract-drop-node is the real drop node when drag and drop
      // not the DOM drag over node
      dropTargetKey: null,
      dropPosition: null,
      dropContainerKey: null,
      dropLevelOffset: null,
      dropTargetPos: null,
      dropAllowed: true,
      // the abstract-drag-over-node
      // if mouse is on the bottom of top dom node or no the top of the bottom dom node
      // abstract-drag-over-node is the top node
      dragOverNodeKey: null
    });
    const treeData = shallowRef([]);
    watch([() => props2.treeData, () => props2.children], () => {
      treeData.value = props2.treeData !== void 0 ? props2.treeData.slice() : convertTreeToData(toRaw(props2.children));
    }, {
      immediate: true,
      deep: true
    });
    const keyEntities = shallowRef({});
    const focused = shallowRef(false);
    const activeKey = shallowRef(null);
    const listChanging = shallowRef(false);
    const fieldNames = computed(() => fillFieldNames(props2.fieldNames));
    const listRef = shallowRef();
    let dragStartMousePosition = null;
    let dragNode = null;
    let currentMouseOverDroppableNodeKey = null;
    const treeNodeRequiredProps = computed(() => {
      return {
        expandedKeysSet: expandedKeysSet.value,
        selectedKeysSet: selectedKeysSet.value,
        loadedKeysSet: loadedKeysSet.value,
        loadingKeysSet: loadingKeysSet.value,
        checkedKeysSet: checkedKeysSet.value,
        halfCheckedKeysSet: halfCheckedKeysSet.value,
        dragOverNodeKey: dragState.dragOverNodeKey,
        dropPosition: dragState.dropPosition,
        keyEntities: keyEntities.value
      };
    });
    const expandedKeysSet = computed(() => {
      return new Set(expandedKeys.value);
    });
    const selectedKeysSet = computed(() => {
      return new Set(selectedKeys.value);
    });
    const loadedKeysSet = computed(() => {
      return new Set(loadedKeys.value);
    });
    const loadingKeysSet = computed(() => {
      return new Set(loadingKeys.value);
    });
    const checkedKeysSet = computed(() => {
      return new Set(checkedKeys.value);
    });
    const halfCheckedKeysSet = computed(() => {
      return new Set(halfCheckedKeys.value);
    });
    watchEffect(() => {
      if (treeData.value) {
        const entitiesMap = convertDataToEntities(treeData.value, {
          fieldNames: fieldNames.value
        });
        keyEntities.value = _extends$1({
          [MOTION_KEY]: MotionEntity
        }, entitiesMap.keyEntities);
      }
    });
    let init = false;
    watch(
      [() => props2.expandedKeys, () => props2.autoExpandParent, keyEntities],
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      (_ref2, _ref3) => {
        let [_newKeys, newAutoExpandParent] = _ref2;
        let [_oldKeys, oldAutoExpandParent] = _ref3;
        let keys2 = expandedKeys.value;
        if (props2.expandedKeys !== void 0 || init && newAutoExpandParent !== oldAutoExpandParent) {
          keys2 = props2.autoExpandParent || !init && props2.defaultExpandParent ? conductExpandParent(props2.expandedKeys, keyEntities.value) : props2.expandedKeys;
        } else if (!init && props2.defaultExpandAll) {
          const cloneKeyEntities = _extends$1({}, keyEntities.value);
          delete cloneKeyEntities[MOTION_KEY];
          keys2 = Object.keys(cloneKeyEntities).map((key2) => cloneKeyEntities[key2].key);
        } else if (!init && props2.defaultExpandedKeys) {
          keys2 = props2.autoExpandParent || props2.defaultExpandParent ? conductExpandParent(props2.defaultExpandedKeys, keyEntities.value) : props2.defaultExpandedKeys;
        }
        if (keys2) {
          expandedKeys.value = keys2;
        }
        init = true;
      },
      {
        immediate: true
      }
    );
    const flattenNodes = shallowRef([]);
    watchEffect(() => {
      flattenNodes.value = flattenTreeData(treeData.value, expandedKeys.value, fieldNames.value);
    });
    watchEffect(() => {
      if (props2.selectable) {
        if (props2.selectedKeys !== void 0) {
          selectedKeys.value = calcSelectedKeys(props2.selectedKeys, props2);
        } else if (!init && props2.defaultSelectedKeys) {
          selectedKeys.value = calcSelectedKeys(props2.defaultSelectedKeys, props2);
        }
      }
    });
    const {
      maxLevel,
      levelEntities
    } = useMaxLevel(keyEntities);
    watchEffect(() => {
      if (props2.checkable) {
        let checkedKeyEntity;
        if (props2.checkedKeys !== void 0) {
          checkedKeyEntity = parseCheckedKeys(props2.checkedKeys) || {};
        } else if (!init && props2.defaultCheckedKeys) {
          checkedKeyEntity = parseCheckedKeys(props2.defaultCheckedKeys) || {};
        } else if (treeData.value) {
          checkedKeyEntity = parseCheckedKeys(props2.checkedKeys) || {
            checkedKeys: checkedKeys.value,
            halfCheckedKeys: halfCheckedKeys.value
          };
        }
        if (checkedKeyEntity) {
          let {
            checkedKeys: newCheckedKeys = [],
            halfCheckedKeys: newHalfCheckedKeys = []
          } = checkedKeyEntity;
          if (!props2.checkStrictly) {
            const conductKeys = conductCheck(newCheckedKeys, true, keyEntities.value, maxLevel.value, levelEntities.value);
            ({
              checkedKeys: newCheckedKeys,
              halfCheckedKeys: newHalfCheckedKeys
            } = conductKeys);
          }
          checkedKeys.value = newCheckedKeys;
          halfCheckedKeys.value = newHalfCheckedKeys;
        }
      }
    });
    watchEffect(() => {
      if (props2.loadedKeys) {
        loadedKeys.value = props2.loadedKeys;
      }
    });
    const resetDragState = () => {
      _extends$1(dragState, {
        dragOverNodeKey: null,
        dropPosition: null,
        dropLevelOffset: null,
        dropTargetKey: null,
        dropContainerKey: null,
        dropTargetPos: null,
        dropAllowed: false
      });
    };
    const scrollTo2 = (scroll) => {
      listRef.value.scrollTo(scroll);
    };
    watch(() => props2.activeKey, () => {
      if (props2.activeKey !== void 0) {
        activeKey.value = props2.activeKey;
      }
    }, {
      immediate: true
    });
    watch(activeKey, (val) => {
      nextTick(() => {
        if (val !== null) {
          scrollTo2({
            key: val
          });
        }
      });
    }, {
      immediate: true,
      flush: "post"
    });
    const setExpandedKeys = (keys2) => {
      if (props2.expandedKeys === void 0) {
        expandedKeys.value = keys2;
      }
    };
    const cleanDragState = () => {
      if (dragState.draggingNodeKey !== null) {
        _extends$1(dragState, {
          draggingNodeKey: null,
          dropPosition: null,
          dropContainerKey: null,
          dropTargetKey: null,
          dropLevelOffset: null,
          dropAllowed: true,
          dragOverNodeKey: null
        });
      }
      dragStartMousePosition = null;
      currentMouseOverDroppableNodeKey = null;
    };
    const onNodeDragEnd = (event, node2) => {
      const {
        onDragend
      } = props2;
      dragState.dragOverNodeKey = null;
      cleanDragState();
      onDragend === null || onDragend === void 0 ? void 0 : onDragend({
        event,
        node: node2.eventData
      });
      dragNode = null;
    };
    const onWindowDragEnd = (event) => {
      onNodeDragEnd(event, null);
      window.removeEventListener("dragend", onWindowDragEnd);
    };
    const onNodeDragStart = (event, node2) => {
      const {
        onDragstart
      } = props2;
      const {
        eventKey,
        eventData
      } = node2;
      dragNode = node2;
      dragStartMousePosition = {
        x: event.clientX,
        y: event.clientY
      };
      const newExpandedKeys = arrDel(expandedKeys.value, eventKey);
      dragState.draggingNodeKey = eventKey;
      dragState.dragChildrenKeys = getDragChildrenKeys(eventKey, keyEntities.value);
      indent.value = listRef.value.getIndentWidth();
      setExpandedKeys(newExpandedKeys);
      window.addEventListener("dragend", onWindowDragEnd);
      if (onDragstart) {
        onDragstart({
          event,
          node: eventData
        });
      }
    };
    const onNodeDragEnter = (event, node2) => {
      const {
        onDragenter,
        onExpand,
        allowDrop,
        direction
      } = props2;
      const {
        pos,
        eventKey
      } = node2;
      if (currentMouseOverDroppableNodeKey !== eventKey) {
        currentMouseOverDroppableNodeKey = eventKey;
      }
      if (!dragNode) {
        resetDragState();
        return;
      }
      const {
        dropPosition,
        dropLevelOffset,
        dropTargetKey,
        dropContainerKey,
        dropTargetPos,
        dropAllowed,
        dragOverNodeKey
      } = calcDropPosition(event, dragNode, node2, indent.value, dragStartMousePosition, allowDrop, flattenNodes.value, keyEntities.value, expandedKeysSet.value, direction);
      if (
        // don't allow drop inside its children
        dragState.dragChildrenKeys.indexOf(dropTargetKey) !== -1 || // don't allow drop when drop is not allowed caculated by calcDropPosition
        !dropAllowed
      ) {
        resetDragState();
        return;
      }
      if (!delayedDragEnterLogic) {
        delayedDragEnterLogic = {};
      }
      Object.keys(delayedDragEnterLogic).forEach((key2) => {
        clearTimeout(delayedDragEnterLogic[key2]);
      });
      if (dragNode.eventKey !== node2.eventKey) {
        delayedDragEnterLogic[pos] = window.setTimeout(() => {
          if (dragState.draggingNodeKey === null) return;
          let newExpandedKeys = expandedKeys.value.slice();
          const entity = keyEntities.value[node2.eventKey];
          if (entity && (entity.children || []).length) {
            newExpandedKeys = arrAdd(expandedKeys.value, node2.eventKey);
          }
          setExpandedKeys(newExpandedKeys);
          if (onExpand) {
            onExpand(newExpandedKeys, {
              node: node2.eventData,
              expanded: true,
              nativeEvent: event
            });
          }
        }, 800);
      }
      if (dragNode.eventKey === dropTargetKey && dropLevelOffset === 0) {
        resetDragState();
        return;
      }
      _extends$1(dragState, {
        dragOverNodeKey,
        dropPosition,
        dropLevelOffset,
        dropTargetKey,
        dropContainerKey,
        dropTargetPos,
        dropAllowed
      });
      if (onDragenter) {
        onDragenter({
          event,
          node: node2.eventData,
          expandedKeys: expandedKeys.value
        });
      }
    };
    const onNodeDragOver = (event, node2) => {
      const {
        onDragover,
        allowDrop,
        direction
      } = props2;
      if (!dragNode) {
        return;
      }
      const {
        dropPosition,
        dropLevelOffset,
        dropTargetKey,
        dropContainerKey,
        dropAllowed,
        dropTargetPos,
        dragOverNodeKey
      } = calcDropPosition(event, dragNode, node2, indent.value, dragStartMousePosition, allowDrop, flattenNodes.value, keyEntities.value, expandedKeysSet.value, direction);
      if (dragState.dragChildrenKeys.indexOf(dropTargetKey) !== -1 || !dropAllowed) {
        return;
      }
      if (dragNode.eventKey === dropTargetKey && dropLevelOffset === 0) {
        if (!(dragState.dropPosition === null && dragState.dropLevelOffset === null && dragState.dropTargetKey === null && dragState.dropContainerKey === null && dragState.dropTargetPos === null && dragState.dropAllowed === false && dragState.dragOverNodeKey === null)) {
          resetDragState();
        }
      } else if (!(dropPosition === dragState.dropPosition && dropLevelOffset === dragState.dropLevelOffset && dropTargetKey === dragState.dropTargetKey && dropContainerKey === dragState.dropContainerKey && dropTargetPos === dragState.dropTargetPos && dropAllowed === dragState.dropAllowed && dragOverNodeKey === dragState.dragOverNodeKey)) {
        _extends$1(dragState, {
          dropPosition,
          dropLevelOffset,
          dropTargetKey,
          dropContainerKey,
          dropTargetPos,
          dropAllowed,
          dragOverNodeKey
        });
      }
      if (onDragover) {
        onDragover({
          event,
          node: node2.eventData
        });
      }
    };
    const onNodeDragLeave = (event, node2) => {
      if (currentMouseOverDroppableNodeKey === node2.eventKey && !event.currentTarget.contains(event.relatedTarget)) {
        resetDragState();
        currentMouseOverDroppableNodeKey = null;
      }
      const {
        onDragleave
      } = props2;
      if (onDragleave) {
        onDragleave({
          event,
          node: node2.eventData
        });
      }
    };
    const onNodeDrop = function(event, _node) {
      let outsideTree = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var _a2;
      const {
        dragChildrenKeys,
        dropPosition,
        dropTargetKey,
        dropTargetPos,
        dropAllowed
      } = dragState;
      if (!dropAllowed) return;
      const {
        onDrop
      } = props2;
      dragState.dragOverNodeKey = null;
      cleanDragState();
      if (dropTargetKey === null) return;
      const abstractDropNodeProps = _extends$1(_extends$1({}, getTreeNodeProps(dropTargetKey, toRaw(treeNodeRequiredProps.value))), {
        active: ((_a2 = activeItem.value) === null || _a2 === void 0 ? void 0 : _a2.key) === dropTargetKey,
        data: keyEntities.value[dropTargetKey].node
      });
      dragChildrenKeys.indexOf(dropTargetKey) !== -1;
      const posArr = posToArr(dropTargetPos);
      const dropResult = {
        event,
        node: convertNodePropsToEventData(abstractDropNodeProps),
        dragNode: dragNode ? dragNode.eventData : null,
        dragNodesKeys: [dragNode.eventKey].concat(dragChildrenKeys),
        dropToGap: dropPosition !== 0,
        dropPosition: dropPosition + Number(posArr[posArr.length - 1])
      };
      if (!outsideTree) {
        onDrop === null || onDrop === void 0 ? void 0 : onDrop(dropResult);
      }
      dragNode = null;
    };
    const triggerExpandActionExpand = (e2, treeNode) => {
      const {
        expanded,
        key: key2
      } = treeNode;
      const node2 = flattenNodes.value.filter((nodeItem) => nodeItem.key === key2)[0];
      const eventNode = convertNodePropsToEventData(_extends$1(_extends$1({}, getTreeNodeProps(key2, treeNodeRequiredProps.value)), {
        data: node2.data
      }));
      setExpandedKeys(expanded ? arrDel(expandedKeys.value, key2) : arrAdd(expandedKeys.value, key2));
      onNodeExpand(e2, eventNode);
    };
    const onNodeClick = (e2, treeNode) => {
      const {
        onClick,
        expandAction
      } = props2;
      if (expandAction === "click") {
        triggerExpandActionExpand(e2, treeNode);
      }
      if (onClick) {
        onClick(e2, treeNode);
      }
    };
    const onNodeDoubleClick = (e2, treeNode) => {
      const {
        onDblclick,
        expandAction
      } = props2;
      if (expandAction === "doubleclick" || expandAction === "dblclick") {
        triggerExpandActionExpand(e2, treeNode);
      }
      if (onDblclick) {
        onDblclick(e2, treeNode);
      }
    };
    const onNodeSelect = (e2, treeNode) => {
      let newSelectedKeys = selectedKeys.value;
      const {
        onSelect,
        multiple
      } = props2;
      const {
        selected
      } = treeNode;
      const key2 = treeNode[fieldNames.value.key];
      const targetSelected = !selected;
      if (!targetSelected) {
        newSelectedKeys = arrDel(newSelectedKeys, key2);
      } else if (!multiple) {
        newSelectedKeys = [key2];
      } else {
        newSelectedKeys = arrAdd(newSelectedKeys, key2);
      }
      const keyEntitiesValue = keyEntities.value;
      const selectedNodes = newSelectedKeys.map((selectedKey) => {
        const entity = keyEntitiesValue[selectedKey];
        if (!entity) return null;
        return entity.node;
      }).filter((node2) => node2);
      if (props2.selectedKeys === void 0) {
        selectedKeys.value = newSelectedKeys;
      }
      if (onSelect) {
        onSelect(newSelectedKeys, {
          event: "select",
          selected: targetSelected,
          node: treeNode,
          selectedNodes,
          nativeEvent: e2
        });
      }
    };
    const onNodeCheck = (e2, treeNode, checked) => {
      const {
        checkStrictly,
        onCheck
      } = props2;
      const key2 = treeNode[fieldNames.value.key];
      let checkedObj;
      const eventObj = {
        event: "check",
        node: treeNode,
        checked,
        nativeEvent: e2
      };
      const keyEntitiesValue = keyEntities.value;
      if (checkStrictly) {
        const newCheckedKeys = checked ? arrAdd(checkedKeys.value, key2) : arrDel(checkedKeys.value, key2);
        const newHalfCheckedKeys = arrDel(halfCheckedKeys.value, key2);
        checkedObj = {
          checked: newCheckedKeys,
          halfChecked: newHalfCheckedKeys
        };
        eventObj.checkedNodes = newCheckedKeys.map((checkedKey) => keyEntitiesValue[checkedKey]).filter((entity) => entity).map((entity) => entity.node);
        if (props2.checkedKeys === void 0) {
          checkedKeys.value = newCheckedKeys;
        }
      } else {
        let {
          checkedKeys: newCheckedKeys,
          halfCheckedKeys: newHalfCheckedKeys
        } = conductCheck([...checkedKeys.value, key2], true, keyEntitiesValue, maxLevel.value, levelEntities.value);
        if (!checked) {
          const keySet = new Set(newCheckedKeys);
          keySet.delete(key2);
          ({
            checkedKeys: newCheckedKeys,
            halfCheckedKeys: newHalfCheckedKeys
          } = conductCheck(Array.from(keySet), {
            checked: false,
            halfCheckedKeys: newHalfCheckedKeys
          }, keyEntitiesValue, maxLevel.value, levelEntities.value));
        }
        checkedObj = newCheckedKeys;
        eventObj.checkedNodes = [];
        eventObj.checkedNodesPositions = [];
        eventObj.halfCheckedKeys = newHalfCheckedKeys;
        newCheckedKeys.forEach((checkedKey) => {
          const entity = keyEntitiesValue[checkedKey];
          if (!entity) return;
          const {
            node: node2,
            pos
          } = entity;
          eventObj.checkedNodes.push(node2);
          eventObj.checkedNodesPositions.push({
            node: node2,
            pos
          });
        });
        if (props2.checkedKeys === void 0) {
          checkedKeys.value = newCheckedKeys;
          halfCheckedKeys.value = newHalfCheckedKeys;
        }
      }
      if (onCheck) {
        onCheck(checkedObj, eventObj);
      }
    };
    const onNodeLoad = (treeNode) => {
      const key2 = treeNode[fieldNames.value.key];
      const loadPromise = new Promise((resolve, reject) => {
        const {
          loadData,
          onLoad
        } = props2;
        if (!loadData || loadedKeysSet.value.has(key2) || loadingKeysSet.value.has(key2)) {
          return null;
        }
        const promise = loadData(treeNode);
        promise.then(() => {
          const newLoadedKeys = arrAdd(loadedKeys.value, key2);
          const newLoadingKeys = arrDel(loadingKeys.value, key2);
          if (onLoad) {
            onLoad(newLoadedKeys, {
              event: "load",
              node: treeNode
            });
          }
          if (props2.loadedKeys === void 0) {
            loadedKeys.value = newLoadedKeys;
          }
          loadingKeys.value = newLoadingKeys;
          resolve();
        }).catch((e2) => {
          const newLoadingKeys = arrDel(loadingKeys.value, key2);
          loadingKeys.value = newLoadingKeys;
          loadingRetryTimes[key2] = (loadingRetryTimes[key2] || 0) + 1;
          if (loadingRetryTimes[key2] >= MAX_RETRY_TIMES) {
            const newLoadedKeys = arrAdd(loadedKeys.value, key2);
            if (props2.loadedKeys === void 0) {
              loadedKeys.value = newLoadedKeys;
            }
            resolve();
          }
          reject(e2);
        });
        loadingKeys.value = arrAdd(loadingKeys.value, key2);
      });
      loadPromise.catch(() => {
      });
      return loadPromise;
    };
    const onNodeMouseEnter = (event, node2) => {
      const {
        onMouseenter
      } = props2;
      if (onMouseenter) {
        onMouseenter({
          event,
          node: node2
        });
      }
    };
    const onNodeMouseLeave = (event, node2) => {
      const {
        onMouseleave
      } = props2;
      if (onMouseleave) {
        onMouseleave({
          event,
          node: node2
        });
      }
    };
    const onNodeContextMenu = (event, node2) => {
      const {
        onRightClick
      } = props2;
      if (onRightClick) {
        event.preventDefault();
        onRightClick({
          event,
          node: node2
        });
      }
    };
    const onFocus = (e2) => {
      const {
        onFocus: onFocus2
      } = props2;
      focused.value = true;
      if (onFocus2) {
        onFocus2(e2);
      }
    };
    const onBlur = (e2) => {
      const {
        onBlur: onBlur2
      } = props2;
      focused.value = false;
      onActiveChange(null);
      if (onBlur2) {
        onBlur2(e2);
      }
    };
    const onNodeExpand = (e2, treeNode) => {
      let newExpandedKeys = expandedKeys.value;
      const {
        onExpand,
        loadData
      } = props2;
      const {
        expanded
      } = treeNode;
      const key2 = treeNode[fieldNames.value.key];
      if (listChanging.value) {
        return;
      }
      newExpandedKeys.indexOf(key2);
      const targetExpanded = !expanded;
      if (targetExpanded) {
        newExpandedKeys = arrAdd(newExpandedKeys, key2);
      } else {
        newExpandedKeys = arrDel(newExpandedKeys, key2);
      }
      setExpandedKeys(newExpandedKeys);
      if (onExpand) {
        onExpand(newExpandedKeys, {
          node: treeNode,
          expanded: targetExpanded,
          nativeEvent: e2
        });
      }
      if (targetExpanded && loadData) {
        const loadPromise = onNodeLoad(treeNode);
        if (loadPromise) {
          loadPromise.then(() => {
          }).catch((e3) => {
            const expandedKeysToRestore = arrDel(expandedKeys.value, key2);
            setExpandedKeys(expandedKeysToRestore);
            Promise.reject(e3);
          });
        }
      }
    };
    const onListChangeStart = () => {
      listChanging.value = true;
    };
    const onListChangeEnd = () => {
      setTimeout(() => {
        listChanging.value = false;
      });
    };
    const onActiveChange = (newActiveKey) => {
      const {
        onActiveChange: onActiveChange2
      } = props2;
      if (activeKey.value === newActiveKey) {
        return;
      }
      if (props2.activeKey !== void 0) {
        activeKey.value = newActiveKey;
      }
      if (newActiveKey !== null) {
        scrollTo2({
          key: newActiveKey
        });
      }
      if (onActiveChange2) {
        onActiveChange2(newActiveKey);
      }
    };
    const activeItem = computed(() => {
      if (activeKey.value === null) {
        return null;
      }
      return flattenNodes.value.find((_ref4) => {
        let {
          key: key2
        } = _ref4;
        return key2 === activeKey.value;
      }) || null;
    });
    const offsetActiveKey = (offset3) => {
      let index2 = flattenNodes.value.findIndex((_ref5) => {
        let {
          key: key2
        } = _ref5;
        return key2 === activeKey.value;
      });
      if (index2 === -1 && offset3 < 0) {
        index2 = flattenNodes.value.length;
      }
      index2 = (index2 + offset3 + flattenNodes.value.length) % flattenNodes.value.length;
      const item = flattenNodes.value[index2];
      if (item) {
        const {
          key: key2
        } = item;
        onActiveChange(key2);
      } else {
        onActiveChange(null);
      }
    };
    const activeItemEventNode = computed(() => {
      return convertNodePropsToEventData(_extends$1(_extends$1({}, getTreeNodeProps(activeKey.value, treeNodeRequiredProps.value)), {
        data: activeItem.value.data,
        active: true
      }));
    });
    const onKeydown = (event) => {
      const {
        onKeydown: onKeydown2,
        checkable,
        selectable
      } = props2;
      switch (event.which) {
        case KeyCode.UP: {
          offsetActiveKey(-1);
          event.preventDefault();
          break;
        }
        case KeyCode.DOWN: {
          offsetActiveKey(1);
          event.preventDefault();
          break;
        }
      }
      const item = activeItem.value;
      if (item && item.data) {
        const expandable = item.data.isLeaf === false || !!(item.data.children || []).length;
        const eventNode = activeItemEventNode.value;
        switch (event.which) {
          // >>> Expand
          case KeyCode.LEFT: {
            if (expandable && expandedKeysSet.value.has(activeKey.value)) {
              onNodeExpand({}, eventNode);
            } else if (item.parent) {
              onActiveChange(item.parent.key);
            }
            event.preventDefault();
            break;
          }
          case KeyCode.RIGHT: {
            if (expandable && !expandedKeysSet.value.has(activeKey.value)) {
              onNodeExpand({}, eventNode);
            } else if (item.children && item.children.length) {
              onActiveChange(item.children[0].key);
            }
            event.preventDefault();
            break;
          }
          // Selection
          case KeyCode.ENTER:
          case KeyCode.SPACE: {
            if (checkable && !eventNode.disabled && eventNode.checkable !== false && !eventNode.disableCheckbox) {
              onNodeCheck({}, eventNode, !checkedKeysSet.value.has(activeKey.value));
            } else if (!checkable && selectable && !eventNode.disabled && eventNode.selectable !== false) {
              onNodeSelect({}, eventNode);
            }
            break;
          }
        }
      }
      if (onKeydown2) {
        onKeydown2(event);
      }
    };
    expose({
      onNodeExpand,
      scrollTo: scrollTo2,
      onKeydown,
      selectedKeys: computed(() => selectedKeys.value),
      checkedKeys: computed(() => checkedKeys.value),
      halfCheckedKeys: computed(() => halfCheckedKeys.value),
      loadedKeys: computed(() => loadedKeys.value),
      loadingKeys: computed(() => loadingKeys.value),
      expandedKeys: computed(() => expandedKeys.value)
    });
    onUnmounted(() => {
      window.removeEventListener("dragend", onWindowDragEnd);
      destroyed.value = true;
    });
    useProvideKeysState({
      expandedKeys,
      selectedKeys,
      loadedKeys,
      loadingKeys,
      checkedKeys,
      halfCheckedKeys,
      expandedKeysSet,
      selectedKeysSet,
      loadedKeysSet,
      loadingKeysSet,
      checkedKeysSet,
      halfCheckedKeysSet,
      flattenNodes
    });
    return () => {
      const {
        // focused,
        // flattenNodes,
        // keyEntities,
        draggingNodeKey,
        // activeKey,
        dropLevelOffset,
        dropContainerKey,
        dropTargetKey,
        dropPosition,
        dragOverNodeKey
        // indent,
      } = dragState;
      const {
        prefixCls,
        showLine,
        focusable,
        tabindex = 0,
        selectable,
        showIcon,
        icon = slots.icon,
        switcherIcon,
        draggable,
        checkable,
        checkStrictly,
        disabled,
        motion,
        loadData,
        filterTreeNode,
        height,
        itemHeight,
        virtual,
        dropIndicatorRender: dropIndicatorRender2,
        onContextmenu,
        onScroll,
        direction,
        rootClassName,
        rootStyle
      } = props2;
      const {
        class: className,
        style
      } = attrs;
      const domProps = pickAttrs(_extends$1(_extends$1({}, props2), attrs), {
        aria: true,
        data: true
      });
      let draggableConfig;
      if (draggable) {
        if (typeof draggable === "object") {
          draggableConfig = draggable;
        } else if (typeof draggable === "function") {
          draggableConfig = {
            nodeDraggable: draggable
          };
        } else {
          draggableConfig = {};
        }
      } else {
        draggableConfig = false;
      }
      return createVNode(TreeContext, {
        "value": {
          prefixCls,
          selectable,
          showIcon,
          icon,
          switcherIcon,
          draggable: draggableConfig,
          draggingNodeKey,
          checkable,
          customCheckable: slots.checkable,
          checkStrictly,
          disabled,
          keyEntities: keyEntities.value,
          dropLevelOffset,
          dropContainerKey,
          dropTargetKey,
          dropPosition,
          dragOverNodeKey,
          dragging: draggingNodeKey !== null,
          indent: indent.value,
          direction,
          dropIndicatorRender: dropIndicatorRender2,
          loadData,
          filterTreeNode,
          onNodeClick,
          onNodeDoubleClick,
          onNodeExpand,
          onNodeSelect,
          onNodeCheck,
          onNodeLoad,
          onNodeMouseEnter,
          onNodeMouseLeave,
          onNodeContextMenu,
          onNodeDragStart,
          onNodeDragEnter,
          onNodeDragOver,
          onNodeDragLeave,
          onNodeDragEnd,
          onNodeDrop,
          slots
        }
      }, {
        default: () => [createVNode("div", {
          "role": "tree",
          "class": classNames(prefixCls, className, rootClassName, {
            [`${prefixCls}-show-line`]: showLine,
            [`${prefixCls}-focused`]: focused.value,
            [`${prefixCls}-active-focused`]: activeKey.value !== null
          }),
          "style": rootStyle
        }, [createVNode(NodeList, _objectSpread2$1({
          "ref": listRef,
          "prefixCls": prefixCls,
          "style": style,
          "disabled": disabled,
          "selectable": selectable,
          "checkable": !!checkable,
          "motion": motion,
          "height": height,
          "itemHeight": itemHeight,
          "virtual": virtual,
          "focusable": focusable,
          "focused": focused.value,
          "tabindex": tabindex,
          "activeItem": activeItem.value,
          "onFocus": onFocus,
          "onBlur": onBlur,
          "onKeydown": onKeydown,
          "onActiveChange": onActiveChange,
          "onListChangeStart": onListChangeStart,
          "onListChangeEnd": onListChangeEnd,
          "onContextmenu": onContextmenu,
          "onScroll": onScroll
        }, domProps), null)])]
      });
    };
  }
});
function renderSwitcherIcon(prefixCls, switcherIcon, props2, leafIcon, showLine) {
  const {
    isLeaf: isLeaf2,
    expanded,
    loading
  } = props2;
  let icon = switcherIcon;
  if (loading) {
    return createVNode(LoadingOutlined, {
      "class": `${prefixCls}-switcher-loading-icon`
    }, null);
  }
  let showLeafIcon;
  if (showLine && typeof showLine === "object") {
    showLeafIcon = showLine.showLeafIcon;
  }
  let defaultIcon = null;
  const switcherCls = `${prefixCls}-switcher-icon`;
  if (isLeaf2) {
    if (!showLine) {
      return null;
    }
    if (showLeafIcon && leafIcon) {
      return leafIcon(props2);
    }
    if (typeof showLine === "object" && !showLeafIcon) {
      defaultIcon = createVNode("span", {
        "class": `${prefixCls}-switcher-leaf-line`
      }, null);
    } else {
      defaultIcon = createVNode(FileOutlined, {
        "class": `${prefixCls}-switcher-line-icon`
      }, null);
    }
    return defaultIcon;
  } else {
    defaultIcon = createVNode(CaretDownFilled, {
      "class": switcherCls
    }, null);
    if (showLine) {
      defaultIcon = expanded ? createVNode(MinusSquareOutlined, {
        "class": `${prefixCls}-switcher-line-icon`
      }, null) : createVNode(PlusSquareOutlined, {
        "class": `${prefixCls}-switcher-line-icon`
      }, null);
    }
  }
  if (typeof switcherIcon === "function") {
    icon = switcherIcon(_extends$1(_extends$1({}, props2), {
      defaultIcon,
      switcherCls
    }));
  } else if (isValidElement(icon)) {
    icon = cloneVNode(icon, {
      class: switcherCls
    });
  }
  return icon || defaultIcon;
}
const offset2 = 4;
function dropIndicatorRender(props2) {
  const {
    dropPosition,
    dropLevelOffset,
    prefixCls,
    indent,
    direction = "ltr"
  } = props2;
  const startPosition = direction === "ltr" ? "left" : "right";
  const endPosition = direction === "ltr" ? "right" : "left";
  const style = {
    [startPosition]: `${-dropLevelOffset * indent + offset2}px`,
    [endPosition]: 0
  };
  switch (dropPosition) {
    case -1:
      style.top = `${-3}px`;
      break;
    case 1:
      style.bottom = `${-3}px`;
      break;
    default:
      style.bottom = `${-3}px`;
      style[startPosition] = `${indent + offset2}px`;
      break;
  }
  return createVNode("div", {
    "style": style,
    "class": `${prefixCls}-drop-indicator`
  }, null);
}
const treeNodeFX = new Keyframe("ant-tree-node-fx-do-not-use", {
  "0%": {
    opacity: 0
  },
  "100%": {
    opacity: 1
  }
});
const getSwitchStyle = (prefixCls, token2) => ({
  [`.${prefixCls}-switcher-icon`]: {
    display: "inline-block",
    fontSize: 10,
    verticalAlign: "baseline",
    svg: {
      transition: `transform ${token2.motionDurationSlow}`
    }
  }
});
const getDropIndicatorStyle = (prefixCls, token2) => ({
  [`.${prefixCls}-drop-indicator`]: {
    position: "absolute",
    // it should displayed over the following node
    zIndex: 1,
    height: 2,
    backgroundColor: token2.colorPrimary,
    borderRadius: 1,
    pointerEvents: "none",
    "&:after": {
      position: "absolute",
      top: -3,
      insetInlineStart: -6,
      width: 8,
      height: 8,
      backgroundColor: "transparent",
      border: `${token2.lineWidthBold}px solid ${token2.colorPrimary}`,
      borderRadius: "50%",
      content: '""'
    }
  }
});
const genBaseStyle$2 = (prefixCls, token2) => {
  const {
    treeCls,
    treeNodeCls,
    treeNodePadding,
    treeTitleHeight
  } = token2;
  const treeCheckBoxMarginVertical = (treeTitleHeight - token2.fontSizeLG) / 2;
  const treeCheckBoxMarginHorizontal = token2.paddingXS;
  return {
    [treeCls]: _extends$1(_extends$1({}, resetComponent(token2)), {
      background: token2.colorBgContainer,
      borderRadius: token2.borderRadius,
      transition: `background-color ${token2.motionDurationSlow}`,
      [`&${treeCls}-rtl`]: {
        // >>> Switcher
        [`${treeCls}-switcher`]: {
          "&_close": {
            [`${treeCls}-switcher-icon`]: {
              svg: {
                transform: "rotate(90deg)"
              }
            }
          }
        }
      },
      [`&-focused:not(:hover):not(${treeCls}-active-focused)`]: _extends$1({}, genFocusOutline(token2)),
      // =================== Virtual List ===================
      [`${treeCls}-list-holder-inner`]: {
        alignItems: "flex-start"
      },
      [`&${treeCls}-block-node`]: {
        [`${treeCls}-list-holder-inner`]: {
          alignItems: "stretch",
          // >>> Title
          [`${treeCls}-node-content-wrapper`]: {
            flex: "auto"
          },
          // >>> Drag
          [`${treeNodeCls}.dragging`]: {
            position: "relative",
            "&:after": {
              position: "absolute",
              top: 0,
              insetInlineEnd: 0,
              bottom: treeNodePadding,
              insetInlineStart: 0,
              border: `1px solid ${token2.colorPrimary}`,
              opacity: 0,
              animationName: treeNodeFX,
              animationDuration: token2.motionDurationSlow,
              animationPlayState: "running",
              animationFillMode: "forwards",
              content: '""',
              pointerEvents: "none"
            }
          }
        }
      },
      // ===================== TreeNode =====================
      [`${treeNodeCls}`]: {
        display: "flex",
        alignItems: "flex-start",
        padding: `0 0 ${treeNodePadding}px 0`,
        outline: "none",
        "&-rtl": {
          direction: "rtl"
        },
        // Disabled
        "&-disabled": {
          // >>> Title
          [`${treeCls}-node-content-wrapper`]: {
            color: token2.colorTextDisabled,
            cursor: "not-allowed",
            "&:hover": {
              background: "transparent"
            }
          }
        },
        [`&-active ${treeCls}-node-content-wrapper`]: _extends$1({}, genFocusOutline(token2)),
        [`&:not(${treeNodeCls}-disabled).filter-node ${treeCls}-title`]: {
          color: "inherit",
          fontWeight: 500
        },
        "&-draggable": {
          [`${treeCls}-draggable-icon`]: {
            width: treeTitleHeight,
            lineHeight: `${treeTitleHeight}px`,
            textAlign: "center",
            visibility: "visible",
            opacity: 0.2,
            transition: `opacity ${token2.motionDurationSlow}`,
            [`${treeNodeCls}:hover &`]: {
              opacity: 0.45
            }
          },
          [`&${treeNodeCls}-disabled`]: {
            [`${treeCls}-draggable-icon`]: {
              visibility: "hidden"
            }
          }
        }
      },
      // >>> Indent
      [`${treeCls}-indent`]: {
        alignSelf: "stretch",
        whiteSpace: "nowrap",
        userSelect: "none",
        "&-unit": {
          display: "inline-block",
          width: treeTitleHeight
        }
      },
      // >>> Drag Handler
      [`${treeCls}-draggable-icon`]: {
        visibility: "hidden"
      },
      // >>> Switcher
      [`${treeCls}-switcher`]: _extends$1(_extends$1({}, getSwitchStyle(prefixCls, token2)), {
        position: "relative",
        flex: "none",
        alignSelf: "stretch",
        width: treeTitleHeight,
        margin: 0,
        lineHeight: `${treeTitleHeight}px`,
        textAlign: "center",
        cursor: "pointer",
        userSelect: "none",
        "&-noop": {
          cursor: "default"
        },
        "&_close": {
          [`${treeCls}-switcher-icon`]: {
            svg: {
              transform: "rotate(-90deg)"
            }
          }
        },
        "&-loading-icon": {
          color: token2.colorPrimary
        },
        "&-leaf-line": {
          position: "relative",
          zIndex: 1,
          display: "inline-block",
          width: "100%",
          height: "100%",
          // https://github.com/ant-design/ant-design/issues/31884
          "&:before": {
            position: "absolute",
            top: 0,
            insetInlineEnd: treeTitleHeight / 2,
            bottom: -treeNodePadding,
            marginInlineStart: -1,
            borderInlineEnd: `1px solid ${token2.colorBorder}`,
            content: '""'
          },
          "&:after": {
            position: "absolute",
            width: treeTitleHeight / 2 * 0.8,
            height: treeTitleHeight / 2,
            borderBottom: `1px solid ${token2.colorBorder}`,
            content: '""'
          }
        }
      }),
      // >>> Checkbox
      [`${treeCls}-checkbox`]: {
        top: "initial",
        marginInlineEnd: treeCheckBoxMarginHorizontal,
        marginBlockStart: treeCheckBoxMarginVertical
      },
      // >>> Title
      // add `${treeCls}-checkbox + span` to cover checkbox `${checkboxCls} + span`
      [`${treeCls}-node-content-wrapper, ${treeCls}-checkbox + span`]: {
        position: "relative",
        zIndex: "auto",
        minHeight: treeTitleHeight,
        margin: 0,
        padding: `0 ${token2.paddingXS / 2}px`,
        color: "inherit",
        lineHeight: `${treeTitleHeight}px`,
        background: "transparent",
        borderRadius: token2.borderRadius,
        cursor: "pointer",
        transition: `all ${token2.motionDurationMid}, border 0s, line-height 0s, box-shadow 0s`,
        "&:hover": {
          backgroundColor: token2.controlItemBgHover
        },
        [`&${treeCls}-node-selected`]: {
          backgroundColor: token2.controlItemBgActive
        },
        // Icon
        [`${treeCls}-iconEle`]: {
          display: "inline-block",
          width: treeTitleHeight,
          height: treeTitleHeight,
          lineHeight: `${treeTitleHeight}px`,
          textAlign: "center",
          verticalAlign: "top",
          "&:empty": {
            display: "none"
          }
        }
      },
      // https://github.com/ant-design/ant-design/issues/28217
      [`${treeCls}-unselectable ${treeCls}-node-content-wrapper:hover`]: {
        backgroundColor: "transparent"
      },
      // ==================== Draggable =====================
      [`${treeCls}-node-content-wrapper`]: _extends$1({
        lineHeight: `${treeTitleHeight}px`,
        userSelect: "none"
      }, getDropIndicatorStyle(prefixCls, token2)),
      [`${treeNodeCls}.drop-container`]: {
        "> [draggable]": {
          boxShadow: `0 0 0 2px ${token2.colorPrimary}`
        }
      },
      // ==================== Show Line =====================
      "&-show-line": {
        // ================ Indent lines ================
        [`${treeCls}-indent`]: {
          "&-unit": {
            position: "relative",
            height: "100%",
            "&:before": {
              position: "absolute",
              top: 0,
              insetInlineEnd: treeTitleHeight / 2,
              bottom: -treeNodePadding,
              borderInlineEnd: `1px solid ${token2.colorBorder}`,
              content: '""'
            },
            "&-end": {
              "&:before": {
                display: "none"
              }
            }
          }
        },
        // ============== Cover Background ==============
        [`${treeCls}-switcher`]: {
          background: "transparent",
          "&-line-icon": {
            // https://github.com/ant-design/ant-design/issues/32813
            verticalAlign: "-0.15em"
          }
        }
      },
      [`${treeNodeCls}-leaf-last`]: {
        [`${treeCls}-switcher`]: {
          "&-leaf-line": {
            "&:before": {
              top: "auto !important",
              bottom: "auto !important",
              height: `${treeTitleHeight / 2}px !important`
            }
          }
        }
      }
    })
  };
};
const genDirectoryStyle = (token2) => {
  const {
    treeCls,
    treeNodeCls,
    treeNodePadding
  } = token2;
  return {
    [`${treeCls}${treeCls}-directory`]: {
      // ================== TreeNode ==================
      [treeNodeCls]: {
        position: "relative",
        // Hover color
        "&:before": {
          position: "absolute",
          top: 0,
          insetInlineEnd: 0,
          bottom: treeNodePadding,
          insetInlineStart: 0,
          transition: `background-color ${token2.motionDurationMid}`,
          content: '""',
          pointerEvents: "none"
        },
        "&:hover": {
          "&:before": {
            background: token2.controlItemBgHover
          }
        },
        // Elements
        "> *": {
          zIndex: 1
        },
        // >>> Switcher
        [`${treeCls}-switcher`]: {
          transition: `color ${token2.motionDurationMid}`
        },
        // >>> Title
        [`${treeCls}-node-content-wrapper`]: {
          borderRadius: 0,
          userSelect: "none",
          "&:hover": {
            background: "transparent"
          },
          [`&${treeCls}-node-selected`]: {
            color: token2.colorTextLightSolid,
            background: "transparent"
          }
        },
        // ============= Selected =============
        "&-selected": {
          [`
            &:hover::before,
            &::before
          `]: {
            background: token2.colorPrimary
          },
          // >>> Switcher
          [`${treeCls}-switcher`]: {
            color: token2.colorTextLightSolid
          },
          // >>> Title
          [`${treeCls}-node-content-wrapper`]: {
            color: token2.colorTextLightSolid,
            background: "transparent"
          }
        }
      }
    }
  };
};
const genTreeStyle = (prefixCls, token2) => {
  const treeCls = `.${prefixCls}`;
  const treeNodeCls = `${treeCls}-treenode`;
  const treeNodePadding = token2.paddingXS / 2;
  const treeTitleHeight = token2.controlHeightSM;
  const treeToken = merge(token2, {
    treeCls,
    treeNodeCls,
    treeNodePadding,
    treeTitleHeight
  });
  return [
    // Basic
    genBaseStyle$2(prefixCls, treeToken),
    // Directory
    genDirectoryStyle(treeToken)
  ];
};
const useStyle$6 = genComponentStyleHook("Tree", (token2, _ref) => {
  let {
    prefixCls
  } = _ref;
  return [{
    [token2.componentCls]: getStyle$2(`${prefixCls}-checkbox`, token2)
  }, genTreeStyle(prefixCls, token2), genCollapseMotion(token2)];
});
const treeProps = () => {
  const baseTreeProps = treeProps$1();
  return _extends$1(_extends$1({}, baseTreeProps), {
    showLine: someType([Boolean, Object]),
    /** 是否支持多选 */
    multiple: booleanType(),
    /** 是否自动展开父节点 */
    autoExpandParent: booleanType(),
    /** checkable状态下节点选择完全受控（父子节点选中状态不再关联）*/
    checkStrictly: booleanType(),
    /** 是否支持选中 */
    checkable: booleanType(),
    /** 是否禁用树 */
    disabled: booleanType(),
    /** 默认展开所有树节点 */
    defaultExpandAll: booleanType(),
    /** 默认展开对应树节点 */
    defaultExpandParent: booleanType(),
    /** 默认展开指定的树节点 */
    defaultExpandedKeys: arrayType(),
    /** （受控）展开指定的树节点 */
    expandedKeys: arrayType(),
    /** （受控）选中复选框的树节点 */
    checkedKeys: someType([Array, Object]),
    /** 默认选中复选框的树节点 */
    defaultCheckedKeys: arrayType(),
    /** （受控）设置选中的树节点 */
    selectedKeys: arrayType(),
    /** 默认选中的树节点 */
    defaultSelectedKeys: arrayType(),
    selectable: booleanType(),
    loadedKeys: arrayType(),
    draggable: booleanType(),
    showIcon: booleanType(),
    icon: functionType(),
    switcherIcon: PropTypes.any,
    prefixCls: String,
    /**
     * @default{title,key,children}
     * deprecated, please use `fieldNames` instead
     * 替换treeNode中 title,key,children字段为treeData中对应的字段
     */
    replaceFields: objectType(),
    blockNode: booleanType(),
    openAnimation: PropTypes.any,
    onDoubleclick: baseTreeProps.onDblclick,
    "onUpdate:selectedKeys": functionType(),
    "onUpdate:checkedKeys": functionType(),
    "onUpdate:expandedKeys": functionType()
  });
};
const Tree$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ATree",
  inheritAttrs: false,
  props: initDefaultProps(treeProps(), {
    checkable: false,
    selectable: true,
    showIcon: false,
    blockNode: false
  }),
  slots: Object,
  setup(props2, _ref) {
    let {
      attrs,
      expose,
      emit,
      slots
    } = _ref;
    warning$2(!(props2.treeData === void 0 && slots.default));
    const {
      prefixCls,
      direction,
      virtual
    } = useConfigInject("tree", props2);
    const [wrapSSR, hashId] = useStyle$6(prefixCls);
    const treeRef = ref();
    const scrollTo2 = (scroll) => {
      var _a2;
      (_a2 = treeRef.value) === null || _a2 === void 0 ? void 0 : _a2.scrollTo(scroll);
    };
    expose({
      treeRef,
      onNodeExpand: function() {
        var _a2;
        (_a2 = treeRef.value) === null || _a2 === void 0 ? void 0 : _a2.onNodeExpand(...arguments);
      },
      scrollTo: scrollTo2,
      selectedKeys: computed(() => {
        var _a2;
        return (_a2 = treeRef.value) === null || _a2 === void 0 ? void 0 : _a2.selectedKeys;
      }),
      checkedKeys: computed(() => {
        var _a2;
        return (_a2 = treeRef.value) === null || _a2 === void 0 ? void 0 : _a2.checkedKeys;
      }),
      halfCheckedKeys: computed(() => {
        var _a2;
        return (_a2 = treeRef.value) === null || _a2 === void 0 ? void 0 : _a2.halfCheckedKeys;
      }),
      loadedKeys: computed(() => {
        var _a2;
        return (_a2 = treeRef.value) === null || _a2 === void 0 ? void 0 : _a2.loadedKeys;
      }),
      loadingKeys: computed(() => {
        var _a2;
        return (_a2 = treeRef.value) === null || _a2 === void 0 ? void 0 : _a2.loadingKeys;
      }),
      expandedKeys: computed(() => {
        var _a2;
        return (_a2 = treeRef.value) === null || _a2 === void 0 ? void 0 : _a2.expandedKeys;
      })
    });
    watchEffect(() => {
      devWarning(props2.replaceFields === void 0, "Tree", "`replaceFields` is deprecated, please use fieldNames instead");
    });
    const handleCheck = (checkedObjOrKeys, eventObj) => {
      emit("update:checkedKeys", checkedObjOrKeys);
      emit("check", checkedObjOrKeys, eventObj);
    };
    const handleExpand = (expandedKeys, eventObj) => {
      emit("update:expandedKeys", expandedKeys);
      emit("expand", expandedKeys, eventObj);
    };
    const handleSelect = (selectedKeys, eventObj) => {
      emit("update:selectedKeys", selectedKeys);
      emit("select", selectedKeys, eventObj);
    };
    return () => {
      const {
        showIcon,
        showLine,
        switcherIcon = slots.switcherIcon,
        icon = slots.icon,
        blockNode,
        checkable,
        selectable,
        fieldNames = props2.replaceFields,
        motion = props2.openAnimation,
        itemHeight = 28,
        onDoubleclick,
        onDblclick
      } = props2;
      const newProps = _extends$1(_extends$1(_extends$1({}, attrs), omit$1(props2, ["onUpdate:checkedKeys", "onUpdate:expandedKeys", "onUpdate:selectedKeys", "onDoubleclick"])), {
        showLine: Boolean(showLine),
        dropIndicatorRender,
        fieldNames,
        icon,
        itemHeight
      });
      const children = slots.default ? filterEmpty(slots.default()) : void 0;
      return wrapSSR(createVNode(Tree$2, _objectSpread2$1(_objectSpread2$1({}, newProps), {}, {
        "virtual": virtual.value,
        "motion": motion,
        "ref": treeRef,
        "prefixCls": prefixCls.value,
        "class": classNames({
          [`${prefixCls.value}-icon-hide`]: !showIcon,
          [`${prefixCls.value}-block-node`]: blockNode,
          [`${prefixCls.value}-unselectable`]: !selectable,
          [`${prefixCls.value}-rtl`]: direction.value === "rtl"
        }, attrs.class, hashId.value),
        "direction": direction.value,
        "checkable": checkable,
        "selectable": selectable,
        "switcherIcon": (nodeProps) => renderSwitcherIcon(prefixCls.value, switcherIcon, nodeProps, slots.leafIcon, showLine),
        "onCheck": handleCheck,
        "onExpand": handleExpand,
        "onSelect": handleSelect,
        "onDblclick": onDblclick || onDoubleclick,
        "children": children
      }), _extends$1(_extends$1({}, slots), {
        checkable: () => createVNode("span", {
          "class": `${prefixCls.value}-checkbox-inner`
        }, null)
      })));
    };
  }
});
var Record;
(function(Record2) {
  Record2[Record2["None"] = 0] = "None";
  Record2[Record2["Start"] = 1] = "Start";
  Record2[Record2["End"] = 2] = "End";
})(Record || (Record = {}));
function traverseNodesKey(treeData, fieldNames, callback) {
  function processNode(dataNode) {
    const key2 = dataNode[fieldNames.key];
    const children = dataNode[fieldNames.children];
    if (callback(key2, dataNode) !== false) {
      traverseNodesKey(children || [], fieldNames, callback);
    }
  }
  treeData.forEach(processNode);
}
function calcRangeKeys(_ref) {
  let {
    treeData,
    expandedKeys,
    startKey,
    endKey,
    fieldNames = {
      title: "title",
      key: "key",
      children: "children"
    }
  } = _ref;
  const keys2 = [];
  let record = Record.None;
  if (startKey && startKey === endKey) {
    return [startKey];
  }
  if (!startKey || !endKey) {
    return [];
  }
  function matchKey(key2) {
    return key2 === startKey || key2 === endKey;
  }
  traverseNodesKey(treeData, fieldNames, (key2) => {
    if (record === Record.End) {
      return false;
    }
    if (matchKey(key2)) {
      keys2.push(key2);
      if (record === Record.None) {
        record = Record.Start;
      } else if (record === Record.Start) {
        record = Record.End;
        return false;
      }
    } else if (record === Record.Start) {
      keys2.push(key2);
    }
    return expandedKeys.includes(key2);
  });
  return keys2;
}
function convertDirectoryKeysToNodes(treeData, keys2, fieldNames) {
  const restKeys = [...keys2];
  const nodes = [];
  traverseNodesKey(treeData, fieldNames, (key2, node2) => {
    const index2 = restKeys.indexOf(key2);
    if (index2 !== -1) {
      nodes.push(node2);
      restKeys.splice(index2, 1);
    }
    return !!restKeys.length;
  });
  return nodes;
}
var __rest$8 = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const directoryTreeProps = () => _extends$1(_extends$1({}, treeProps()), {
  expandAction: someType([Boolean, String])
});
function getIcon(props2) {
  const {
    isLeaf: isLeaf2,
    expanded
  } = props2;
  if (isLeaf2) {
    return createVNode(FileOutlined, null, null);
  }
  return expanded ? createVNode(FolderOpenOutlined, null, null) : createVNode(FolderOutlined, null, null);
}
const DirectoryTree = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ADirectoryTree",
  inheritAttrs: false,
  props: initDefaultProps(directoryTreeProps(), {
    showIcon: true,
    expandAction: "click"
  }),
  slots: Object,
  // emits: [
  //   'update:selectedKeys',
  //   'update:checkedKeys',
  //   'update:expandedKeys',
  //   'expand',
  //   'select',
  //   'check',
  //   'doubleclick',
  //   'dblclick',
  //   'click',
  // ],
  setup(props2, _ref) {
    let {
      attrs,
      slots,
      emit,
      expose
    } = _ref;
    var _a2;
    const treeData = ref(props2.treeData || convertTreeToData(filterEmpty((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots))));
    watch(() => props2.treeData, () => {
      treeData.value = props2.treeData;
    });
    onUpdated(() => {
      nextTick(() => {
        var _a3;
        if (props2.treeData === void 0 && slots.default) {
          treeData.value = convertTreeToData(filterEmpty((_a3 = slots.default) === null || _a3 === void 0 ? void 0 : _a3.call(slots)));
        }
      });
    });
    const lastSelectedKey = ref();
    const cachedSelectedKeys = ref();
    const fieldNames = computed(() => fillFieldNames(props2.fieldNames));
    const treeRef = ref();
    const scrollTo2 = (scroll) => {
      var _a3;
      (_a3 = treeRef.value) === null || _a3 === void 0 ? void 0 : _a3.scrollTo(scroll);
    };
    expose({
      scrollTo: scrollTo2,
      selectedKeys: computed(() => {
        var _a3;
        return (_a3 = treeRef.value) === null || _a3 === void 0 ? void 0 : _a3.selectedKeys;
      }),
      checkedKeys: computed(() => {
        var _a3;
        return (_a3 = treeRef.value) === null || _a3 === void 0 ? void 0 : _a3.checkedKeys;
      }),
      halfCheckedKeys: computed(() => {
        var _a3;
        return (_a3 = treeRef.value) === null || _a3 === void 0 ? void 0 : _a3.halfCheckedKeys;
      }),
      loadedKeys: computed(() => {
        var _a3;
        return (_a3 = treeRef.value) === null || _a3 === void 0 ? void 0 : _a3.loadedKeys;
      }),
      loadingKeys: computed(() => {
        var _a3;
        return (_a3 = treeRef.value) === null || _a3 === void 0 ? void 0 : _a3.loadingKeys;
      }),
      expandedKeys: computed(() => {
        var _a3;
        return (_a3 = treeRef.value) === null || _a3 === void 0 ? void 0 : _a3.expandedKeys;
      })
    });
    const getInitExpandedKeys = () => {
      const {
        keyEntities
      } = convertDataToEntities(treeData.value, {
        fieldNames: fieldNames.value
      });
      let initExpandedKeys;
      if (props2.defaultExpandAll) {
        initExpandedKeys = Object.keys(keyEntities);
      } else if (props2.defaultExpandParent) {
        initExpandedKeys = conductExpandParent(props2.expandedKeys || props2.defaultExpandedKeys || [], keyEntities);
      } else {
        initExpandedKeys = props2.expandedKeys || props2.defaultExpandedKeys;
      }
      return initExpandedKeys;
    };
    const selectedKeys = ref(props2.selectedKeys || props2.defaultSelectedKeys || []);
    const expandedKeys = ref(getInitExpandedKeys());
    watch(() => props2.selectedKeys, () => {
      if (props2.selectedKeys !== void 0) {
        selectedKeys.value = props2.selectedKeys;
      }
    }, {
      immediate: true
    });
    watch(() => props2.expandedKeys, () => {
      if (props2.expandedKeys !== void 0) {
        expandedKeys.value = props2.expandedKeys;
      }
    }, {
      immediate: true
    });
    const expandFolderNode = (event, node2) => {
      const {
        isLeaf: isLeaf2
      } = node2;
      if (isLeaf2 || event.shiftKey || event.metaKey || event.ctrlKey) {
        return;
      }
      treeRef.value.onNodeExpand(event, node2);
    };
    const onDebounceExpand = debounce$1(expandFolderNode, 200, {
      leading: true
    });
    const onExpand = (keys2, info) => {
      if (props2.expandedKeys === void 0) {
        expandedKeys.value = keys2;
      }
      emit("update:expandedKeys", keys2);
      emit("expand", keys2, info);
    };
    const onClick = (event, node2) => {
      const {
        expandAction
      } = props2;
      if (expandAction === "click") {
        onDebounceExpand(event, node2);
      }
      emit("click", event, node2);
    };
    const onDoubleClick = (event, node2) => {
      const {
        expandAction
      } = props2;
      if (expandAction === "dblclick" || expandAction === "doubleclick") {
        onDebounceExpand(event, node2);
      }
      emit("doubleclick", event, node2);
      emit("dblclick", event, node2);
    };
    const onSelect = (keys2, event) => {
      const {
        multiple
      } = props2;
      const {
        node: node2,
        nativeEvent
      } = event;
      const key2 = node2[fieldNames.value.key];
      const newEvent = _extends$1(_extends$1({}, event), {
        selected: true
      });
      const ctrlPick = (nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.ctrlKey) || (nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.metaKey);
      const shiftPick = nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.shiftKey;
      let newSelectedKeys;
      if (multiple && ctrlPick) {
        newSelectedKeys = keys2;
        lastSelectedKey.value = key2;
        cachedSelectedKeys.value = newSelectedKeys;
        newEvent.selectedNodes = convertDirectoryKeysToNodes(treeData.value, newSelectedKeys, fieldNames.value);
      } else if (multiple && shiftPick) {
        newSelectedKeys = Array.from(/* @__PURE__ */ new Set([...cachedSelectedKeys.value || [], ...calcRangeKeys({
          treeData: treeData.value,
          expandedKeys: expandedKeys.value,
          startKey: key2,
          endKey: lastSelectedKey.value,
          fieldNames: fieldNames.value
        })]));
        newEvent.selectedNodes = convertDirectoryKeysToNodes(treeData.value, newSelectedKeys, fieldNames.value);
      } else {
        newSelectedKeys = [key2];
        lastSelectedKey.value = key2;
        cachedSelectedKeys.value = newSelectedKeys;
        newEvent.selectedNodes = convertDirectoryKeysToNodes(treeData.value, newSelectedKeys, fieldNames.value);
      }
      emit("update:selectedKeys", newSelectedKeys);
      emit("select", newSelectedKeys, newEvent);
      if (props2.selectedKeys === void 0) {
        selectedKeys.value = newSelectedKeys;
      }
    };
    const onCheck = (checkedObjOrKeys, eventObj) => {
      emit("update:checkedKeys", checkedObjOrKeys);
      emit("check", checkedObjOrKeys, eventObj);
    };
    const {
      prefixCls,
      direction
    } = useConfigInject("tree", props2);
    return () => {
      const connectClassName = classNames(`${prefixCls.value}-directory`, {
        [`${prefixCls.value}-directory-rtl`]: direction.value === "rtl"
      }, attrs.class);
      const {
        icon = slots.icon,
        blockNode = true
      } = props2, otherProps = __rest$8(props2, ["icon", "blockNode"]);
      return createVNode(Tree$1, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "icon": icon || getIcon,
        "ref": treeRef,
        "blockNode": blockNode
      }, otherProps), {}, {
        "prefixCls": prefixCls.value,
        "class": connectClassName,
        "expandedKeys": expandedKeys.value,
        "selectedKeys": selectedKeys.value,
        "onSelect": onSelect,
        "onClick": onClick,
        "onDblclick": onDoubleClick,
        "onExpand": onExpand,
        "onCheck": onCheck
      }), slots);
    };
  }
});
const TreeNode = VcTreeNode;
const Tree = _extends$1(Tree$1, {
  DirectoryTree,
  TreeNode,
  install: (app) => {
    app.component(Tree$1.name, Tree$1);
    app.component(TreeNode.name, TreeNode);
    app.component(DirectoryTree.name, DirectoryTree);
    return app;
  }
});
function isEqual(obj1, obj2) {
  let shallow = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  const refSet = /* @__PURE__ */ new Set();
  function deepEqual(a2, b2) {
    let level = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    const circular = refSet.has(a2);
    warningOnce(!circular, "Warning: There may be circular references");
    if (circular) {
      return false;
    }
    if (a2 === b2) {
      return true;
    }
    if (shallow && level > 1) {
      return false;
    }
    refSet.add(a2);
    const newLevel = level + 1;
    if (Array.isArray(a2)) {
      if (!Array.isArray(b2) || a2.length !== b2.length) {
        return false;
      }
      for (let i2 = 0; i2 < a2.length; i2++) {
        if (!deepEqual(a2[i2], b2[i2], newLevel)) {
          return false;
        }
      }
      return true;
    }
    if (a2 && b2 && typeof a2 === "object" && typeof b2 === "object") {
      const keys2 = Object.keys(a2);
      if (keys2.length !== Object.keys(b2).length) {
        return false;
      }
      return keys2.every((key2) => deepEqual(a2[key2], b2[key2], newLevel));
    }
    return false;
  }
  return deepEqual(obj1, obj2);
}
const {
  SubMenu,
  Item: MenuItem
} = Menu;
function hasSubMenu(filters) {
  return filters.some((_ref) => {
    let {
      children
    } = _ref;
    return children && children.length > 0;
  });
}
function searchValueMatched(searchValue, text) {
  if (typeof text === "string" || typeof text === "number") {
    return text === null || text === void 0 ? void 0 : text.toString().toLowerCase().includes(searchValue.trim().toLowerCase());
  }
  return false;
}
function renderFilterItems(_ref2) {
  let {
    filters,
    prefixCls,
    filteredKeys,
    filterMultiple,
    searchValue,
    filterSearch
  } = _ref2;
  return filters.map((filter, index2) => {
    const key2 = String(filter.value);
    if (filter.children) {
      return createVNode(SubMenu, {
        "key": key2 || index2,
        "title": filter.text,
        "popupClassName": `${prefixCls}-dropdown-submenu`
      }, {
        default: () => [renderFilterItems({
          filters: filter.children,
          prefixCls,
          filteredKeys,
          filterMultiple,
          searchValue,
          filterSearch
        })]
      });
    }
    const Component = filterMultiple ? Checkbox : Radio;
    const item = createVNode(MenuItem, {
      "key": filter.value !== void 0 ? key2 : index2
    }, {
      default: () => [createVNode(Component, {
        "checked": filteredKeys.includes(key2)
      }, null), createVNode("span", null, [filter.text])]
    });
    if (searchValue.trim()) {
      if (typeof filterSearch === "function") {
        return filterSearch(searchValue, filter) ? item : void 0;
      }
      return searchValueMatched(searchValue, filter.text) ? item : void 0;
    }
    return item;
  });
}
const FilterDropdown = defineComponent({
  name: "FilterDropdown",
  props: ["tablePrefixCls", "prefixCls", "dropdownPrefixCls", "column", "filterState", "filterMultiple", "filterMode", "filterSearch", "columnKey", "triggerFilter", "locale", "getPopupContainer"],
  setup(props2, _ref3) {
    let {
      slots
    } = _ref3;
    const contextSlots = useInjectSlots();
    const filterMode = computed(() => {
      var _a2;
      return (_a2 = props2.filterMode) !== null && _a2 !== void 0 ? _a2 : "menu";
    });
    const filterSearch = computed(() => {
      var _a2;
      return (_a2 = props2.filterSearch) !== null && _a2 !== void 0 ? _a2 : false;
    });
    const filterDropdownOpen = computed(() => props2.column.filterDropdownOpen || props2.column.filterDropdownVisible);
    const onFilterDropdownOpenChange = computed(() => props2.column.onFilterDropdownOpenChange || props2.column.onFilterDropdownVisibleChange);
    const visible = shallowRef(false);
    const filtered = computed(() => {
      var _a2;
      return !!(props2.filterState && (((_a2 = props2.filterState.filteredKeys) === null || _a2 === void 0 ? void 0 : _a2.length) || props2.filterState.forceFiltered));
    });
    const filterFlattenKeys = computed(() => {
      var _a2;
      return flattenKeys((_a2 = props2.column) === null || _a2 === void 0 ? void 0 : _a2.filters);
    });
    const filterDropdownRef = computed(() => {
      const {
        filterDropdown,
        slots: slots2 = {},
        customFilterDropdown
      } = props2.column;
      return filterDropdown || slots2.filterDropdown && contextSlots.value[slots2.filterDropdown] || customFilterDropdown && contextSlots.value.customFilterDropdown;
    });
    const filterIconRef = computed(() => {
      const {
        filterIcon,
        slots: slots2 = {}
      } = props2.column;
      return filterIcon || slots2.filterIcon && contextSlots.value[slots2.filterIcon] || contextSlots.value.customFilterIcon;
    });
    const triggerVisible = (newVisible) => {
      var _a2;
      visible.value = newVisible;
      (_a2 = onFilterDropdownOpenChange.value) === null || _a2 === void 0 ? void 0 : _a2.call(onFilterDropdownOpenChange, newVisible);
    };
    const mergedVisible = computed(() => typeof filterDropdownOpen.value === "boolean" ? filterDropdownOpen.value : visible.value);
    const propFilteredKeys = computed(() => {
      var _a2;
      return (_a2 = props2.filterState) === null || _a2 === void 0 ? void 0 : _a2.filteredKeys;
    });
    const filteredKeys = shallowRef([]);
    const onSelectKeys = (_ref5) => {
      let {
        selectedKeys
      } = _ref5;
      filteredKeys.value = selectedKeys;
    };
    const onCheck = (keys2, _ref6) => {
      let {
        node: node2,
        checked
      } = _ref6;
      if (!props2.filterMultiple) {
        onSelectKeys({
          selectedKeys: checked && node2.key ? [node2.key] : []
        });
      } else {
        onSelectKeys({
          selectedKeys: keys2
        });
      }
    };
    watch(propFilteredKeys, () => {
      if (!visible.value) {
        return;
      }
      onSelectKeys({
        selectedKeys: propFilteredKeys.value || []
      });
    }, {
      immediate: true
    });
    const openKeys = shallowRef([]);
    const openRef = shallowRef();
    const onOpenChange = (keys2) => {
      openRef.value = setTimeout(() => {
        openKeys.value = keys2;
      });
    };
    const onMenuClick = () => {
      clearTimeout(openRef.value);
    };
    onBeforeUnmount(() => {
      clearTimeout(openRef.value);
    });
    const searchValue = shallowRef("");
    const onSearch = (e2) => {
      const {
        value
      } = e2.target;
      searchValue.value = value;
    };
    watch(visible, () => {
      if (!visible.value) {
        searchValue.value = "";
      }
    });
    const internalTriggerFilter = (keys2) => {
      const {
        column: column2,
        columnKey,
        filterState
      } = props2;
      const mergedKeys = keys2 && keys2.length ? keys2 : null;
      if (mergedKeys === null && (!filterState || !filterState.filteredKeys)) {
        return null;
      }
      if (isEqual(mergedKeys, filterState === null || filterState === void 0 ? void 0 : filterState.filteredKeys, true)) {
        return null;
      }
      props2.triggerFilter({
        column: column2,
        key: columnKey,
        filteredKeys: mergedKeys
      });
    };
    const onConfirm = () => {
      triggerVisible(false);
      internalTriggerFilter(filteredKeys.value);
    };
    const onReset = function() {
      let {
        confirm: confirm2,
        closeDropdown
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
        confirm: false,
        closeDropdown: false
      };
      if (confirm2) {
        internalTriggerFilter([]);
      }
      if (closeDropdown) {
        triggerVisible(false);
      }
      searchValue.value = "";
      if (props2.column.filterResetToDefaultFilteredValue) {
        filteredKeys.value = (props2.column.defaultFilteredValue || []).map((key2) => String(key2));
      } else {
        filteredKeys.value = [];
      }
    };
    const doFilter = function() {
      let {
        closeDropdown
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
        closeDropdown: true
      };
      if (closeDropdown) {
        triggerVisible(false);
      }
      internalTriggerFilter(filteredKeys.value);
    };
    const onVisibleChange = (newVisible) => {
      if (newVisible && propFilteredKeys.value !== void 0) {
        filteredKeys.value = propFilteredKeys.value || [];
      }
      triggerVisible(newVisible);
      if (!newVisible && !filterDropdownRef.value) {
        onConfirm();
      }
    };
    const {
      direction
    } = useConfigInject("", props2);
    const onCheckAll = (e2) => {
      if (e2.target.checked) {
        const allFilterKeys = filterFlattenKeys.value;
        filteredKeys.value = allFilterKeys;
      } else {
        filteredKeys.value = [];
      }
    };
    const getTreeData = (_ref7) => {
      let {
        filters
      } = _ref7;
      return (filters || []).map((filter, index2) => {
        const key2 = String(filter.value);
        const item = {
          title: filter.text,
          key: filter.value !== void 0 ? key2 : index2
        };
        if (filter.children) {
          item.children = getTreeData({
            filters: filter.children
          });
        }
        return item;
      });
    };
    const getFilterData2 = (node2) => {
      var _a2;
      return _extends$1(_extends$1({}, node2), {
        text: node2.title,
        value: node2.key,
        children: ((_a2 = node2.children) === null || _a2 === void 0 ? void 0 : _a2.map((item) => getFilterData2(item))) || []
      });
    };
    const treeData = computed(() => getTreeData({
      filters: props2.column.filters
    }));
    const dropdownMenuClass = computed(() => classNames({
      [`${props2.dropdownPrefixCls}-menu-without-submenu`]: !hasSubMenu(props2.column.filters || [])
    }));
    const getFilterComponent = () => {
      const selectedKeys = filteredKeys.value;
      const {
        column: column2,
        locale: locale2,
        tablePrefixCls,
        filterMultiple,
        dropdownPrefixCls,
        getPopupContainer,
        prefixCls
      } = props2;
      if ((column2.filters || []).length === 0) {
        return createVNode(Empty$1, {
          "image": Empty$1.PRESENTED_IMAGE_SIMPLE,
          "description": locale2.filterEmptyText,
          "imageStyle": {
            height: 24
          },
          "style": {
            margin: 0,
            padding: "16px 0"
          }
        }, null);
      }
      if (filterMode.value === "tree") {
        return createVNode(Fragment, null, [createVNode(FilterSearch, {
          "filterSearch": filterSearch.value,
          "value": searchValue.value,
          "onChange": onSearch,
          "tablePrefixCls": tablePrefixCls,
          "locale": locale2
        }, null), createVNode("div", {
          "class": `${tablePrefixCls}-filter-dropdown-tree`
        }, [filterMultiple ? createVNode(Checkbox, {
          "class": `${tablePrefixCls}-filter-dropdown-checkall`,
          "onChange": onCheckAll,
          "checked": selectedKeys.length === filterFlattenKeys.value.length,
          "indeterminate": selectedKeys.length > 0 && selectedKeys.length < filterFlattenKeys.value.length
        }, {
          default: () => [locale2.filterCheckall]
        }) : null, createVNode(Tree, {
          "checkable": true,
          "selectable": false,
          "blockNode": true,
          "multiple": filterMultiple,
          "checkStrictly": !filterMultiple,
          "class": `${dropdownPrefixCls}-menu`,
          "onCheck": onCheck,
          "checkedKeys": selectedKeys,
          "selectedKeys": selectedKeys,
          "showIcon": false,
          "treeData": treeData.value,
          "autoExpandParent": true,
          "defaultExpandAll": true,
          "filterTreeNode": searchValue.value.trim() ? (node2) => {
            if (typeof filterSearch.value === "function") {
              return filterSearch.value(searchValue.value, getFilterData2(node2));
            }
            return searchValueMatched(searchValue.value, node2.title);
          } : void 0
        }, null)])]);
      }
      return createVNode(Fragment, null, [createVNode(FilterSearch, {
        "filterSearch": filterSearch.value,
        "value": searchValue.value,
        "onChange": onSearch,
        "tablePrefixCls": tablePrefixCls,
        "locale": locale2
      }, null), createVNode(Menu, {
        "multiple": filterMultiple,
        "prefixCls": `${dropdownPrefixCls}-menu`,
        "class": dropdownMenuClass.value,
        "onClick": onMenuClick,
        "onSelect": onSelectKeys,
        "onDeselect": onSelectKeys,
        "selectedKeys": selectedKeys,
        "getPopupContainer": getPopupContainer,
        "openKeys": openKeys.value,
        "onOpenChange": onOpenChange
      }, {
        default: () => renderFilterItems({
          filters: column2.filters || [],
          filterSearch: filterSearch.value,
          prefixCls,
          filteredKeys: filteredKeys.value,
          filterMultiple,
          searchValue: searchValue.value
        })
      })]);
    };
    const resetDisabled = computed(() => {
      const selectedKeys = filteredKeys.value;
      if (props2.column.filterResetToDefaultFilteredValue) {
        return isEqual((props2.column.defaultFilteredValue || []).map((key2) => String(key2)), selectedKeys, true);
      }
      return selectedKeys.length === 0;
    });
    return () => {
      var _a2;
      const {
        tablePrefixCls,
        prefixCls,
        column: column2,
        dropdownPrefixCls,
        locale: locale2,
        getPopupContainer
      } = props2;
      let dropdownContent;
      if (typeof filterDropdownRef.value === "function") {
        dropdownContent = filterDropdownRef.value({
          prefixCls: `${dropdownPrefixCls}-custom`,
          setSelectedKeys: (selectedKeys) => onSelectKeys({
            selectedKeys
          }),
          selectedKeys: filteredKeys.value,
          confirm: doFilter,
          clearFilters: onReset,
          filters: column2.filters,
          visible: mergedVisible.value,
          column: column2.__originColumn__,
          close: () => {
            triggerVisible(false);
          }
        });
      } else if (filterDropdownRef.value) {
        dropdownContent = filterDropdownRef.value;
      } else {
        dropdownContent = createVNode(Fragment, null, [getFilterComponent(), createVNode("div", {
          "class": `${prefixCls}-dropdown-btns`
        }, [createVNode(Button$1, {
          "type": "link",
          "size": "small",
          "disabled": resetDisabled.value,
          "onClick": () => onReset()
        }, {
          default: () => [locale2.filterReset]
        }), createVNode(Button$1, {
          "type": "primary",
          "size": "small",
          "onClick": onConfirm
        }, {
          default: () => [locale2.filterConfirm]
        })])]);
      }
      const menu = createVNode(FilterDropdownMenuWrapper, {
        "class": `${prefixCls}-dropdown`
      }, {
        default: () => [dropdownContent]
      });
      let filterIcon;
      if (typeof filterIconRef.value === "function") {
        filterIcon = filterIconRef.value({
          filtered: filtered.value,
          column: column2.__originColumn__
        });
      } else if (filterIconRef.value) {
        filterIcon = filterIconRef.value;
      } else {
        filterIcon = createVNode(FilterFilled, null, null);
      }
      return createVNode("div", {
        "class": `${prefixCls}-column`
      }, [createVNode("span", {
        "class": `${tablePrefixCls}-column-title`
      }, [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]), createVNode(Dropdown, {
        "overlay": menu,
        "trigger": ["click"],
        "open": mergedVisible.value,
        "onOpenChange": onVisibleChange,
        "getPopupContainer": getPopupContainer,
        "placement": direction.value === "rtl" ? "bottomLeft" : "bottomRight"
      }, {
        default: () => [createVNode("span", {
          "role": "button",
          "tabindex": -1,
          "class": classNames(`${prefixCls}-trigger`, {
            active: filtered.value
          }),
          "onClick": (e2) => {
            e2.stopPropagation();
          }
        }, [filterIcon])]
      })]);
    };
  }
});
function collectFilterStates(columns, init, pos) {
  let filterStates = [];
  (columns || []).forEach((column2, index2) => {
    var _a2, _b;
    const columnPos = getColumnPos(index2, pos);
    const hasFilterDropdown = column2.filterDropdown || ((_a2 = column2 === null || column2 === void 0 ? void 0 : column2.slots) === null || _a2 === void 0 ? void 0 : _a2.filterDropdown) || column2.customFilterDropdown;
    if (column2.filters || hasFilterDropdown || "onFilter" in column2) {
      if ("filteredValue" in column2) {
        let filteredValues = column2.filteredValue;
        if (!hasFilterDropdown) {
          filteredValues = (_b = filteredValues === null || filteredValues === void 0 ? void 0 : filteredValues.map(String)) !== null && _b !== void 0 ? _b : filteredValues;
        }
        filterStates.push({
          column: column2,
          key: getColumnKey(column2, columnPos),
          filteredKeys: filteredValues,
          forceFiltered: column2.filtered
        });
      } else {
        filterStates.push({
          column: column2,
          key: getColumnKey(column2, columnPos),
          filteredKeys: init && column2.defaultFilteredValue ? column2.defaultFilteredValue : void 0,
          forceFiltered: column2.filtered
        });
      }
    }
    if ("children" in column2) {
      filterStates = [...filterStates, ...collectFilterStates(column2.children, init, columnPos)];
    }
  });
  return filterStates;
}
function injectFilter(prefixCls, dropdownPrefixCls, columns, filterStates, locale2, triggerFilter, getPopupContainer, pos) {
  return columns.map((column2, index2) => {
    var _a2;
    const columnPos = getColumnPos(index2, pos);
    const {
      filterMultiple = true,
      filterMode,
      filterSearch
    } = column2;
    let newColumn = column2;
    const hasFilterDropdown = column2.filterDropdown || ((_a2 = column2 === null || column2 === void 0 ? void 0 : column2.slots) === null || _a2 === void 0 ? void 0 : _a2.filterDropdown) || column2.customFilterDropdown;
    if (newColumn.filters || hasFilterDropdown) {
      const columnKey = getColumnKey(newColumn, columnPos);
      const filterState = filterStates.find((_ref) => {
        let {
          key: key2
        } = _ref;
        return columnKey === key2;
      });
      newColumn = _extends$1(_extends$1({}, newColumn), {
        title: (renderProps) => createVNode(FilterDropdown, {
          "tablePrefixCls": prefixCls,
          "prefixCls": `${prefixCls}-filter`,
          "dropdownPrefixCls": dropdownPrefixCls,
          "column": newColumn,
          "columnKey": columnKey,
          "filterState": filterState,
          "filterMultiple": filterMultiple,
          "filterMode": filterMode,
          "filterSearch": filterSearch,
          "triggerFilter": triggerFilter,
          "locale": locale2,
          "getPopupContainer": getPopupContainer
        }, {
          default: () => [renderColumnTitle(column2.title, renderProps)]
        })
      });
    }
    if ("children" in newColumn) {
      newColumn = _extends$1(_extends$1({}, newColumn), {
        children: injectFilter(prefixCls, dropdownPrefixCls, newColumn.children, filterStates, locale2, triggerFilter, getPopupContainer, columnPos)
      });
    }
    return newColumn;
  });
}
function flattenKeys(filters) {
  let keys2 = [];
  (filters || []).forEach((_ref2) => {
    let {
      value,
      children
    } = _ref2;
    keys2.push(value);
    if (children) {
      keys2 = [...keys2, ...flattenKeys(children)];
    }
  });
  return keys2;
}
function generateFilterInfo(filterStates) {
  const currentFilters = {};
  filterStates.forEach((_ref3) => {
    let {
      key: key2,
      filteredKeys,
      column: column2
    } = _ref3;
    var _a2;
    const hasFilterDropdown = column2.filterDropdown || ((_a2 = column2 === null || column2 === void 0 ? void 0 : column2.slots) === null || _a2 === void 0 ? void 0 : _a2.filterDropdown) || column2.customFilterDropdown;
    const {
      filters
    } = column2;
    if (hasFilterDropdown) {
      currentFilters[key2] = filteredKeys || null;
    } else if (Array.isArray(filteredKeys)) {
      const keys2 = flattenKeys(filters);
      currentFilters[key2] = keys2.filter((originKey) => filteredKeys.includes(String(originKey)));
    } else {
      currentFilters[key2] = null;
    }
  });
  return currentFilters;
}
function getFilterData(data, filterStates) {
  return filterStates.reduce((currentData, filterState) => {
    const {
      column: {
        onFilter,
        filters
      },
      filteredKeys
    } = filterState;
    if (onFilter && filteredKeys && filteredKeys.length) {
      return currentData.filter((record) => filteredKeys.some((key2) => {
        const keys2 = flattenKeys(filters);
        const keyIndex2 = keys2.findIndex((k2) => String(k2) === String(key2));
        const realKey = keyIndex2 !== -1 ? keys2[keyIndex2] : key2;
        return onFilter(realKey, record);
      }));
    }
    return currentData;
  }, data);
}
function getMergedColumns(rawMergedColumns) {
  return rawMergedColumns.flatMap((column2) => {
    if ("children" in column2) {
      return [column2, ...getMergedColumns(column2.children || [])];
    }
    return [column2];
  });
}
function useFilter(_ref4) {
  let {
    prefixCls,
    dropdownPrefixCls,
    mergedColumns: rawMergedColumns,
    locale: locale2,
    onFilterChange,
    getPopupContainer
  } = _ref4;
  const mergedColumns = computed(() => getMergedColumns(rawMergedColumns.value));
  const [filterStates, setFilterStates] = useState(collectFilterStates(mergedColumns.value, true));
  const mergedFilterStates = computed(() => {
    const collectedStates = collectFilterStates(mergedColumns.value, false);
    if (collectedStates.length === 0) {
      return collectedStates;
    }
    let filteredKeysIsAllNotControlled = true;
    let filteredKeysIsAllControlled = true;
    collectedStates.forEach((_ref5) => {
      let {
        filteredKeys
      } = _ref5;
      if (filteredKeys !== void 0) {
        filteredKeysIsAllNotControlled = false;
      } else {
        filteredKeysIsAllControlled = false;
      }
    });
    if (filteredKeysIsAllNotControlled) {
      const keyList = (mergedColumns.value || []).map((column2, index2) => getColumnKey(column2, getColumnPos(index2)));
      return filterStates.value.filter((_ref6) => {
        let {
          key: key2
        } = _ref6;
        return keyList.includes(key2);
      }).map((item) => {
        const col = mergedColumns.value[keyList.findIndex((key2) => key2 === item.key)];
        return _extends$1(_extends$1({}, item), {
          column: _extends$1(_extends$1({}, item.column), col),
          forceFiltered: col.filtered
        });
      });
    }
    devWarning(filteredKeysIsAllControlled, "Table", "Columns should all contain `filteredValue` or not contain `filteredValue`.");
    return collectedStates;
  });
  const filters = computed(() => generateFilterInfo(mergedFilterStates.value));
  const triggerFilter = (filterState) => {
    const newFilterStates = mergedFilterStates.value.filter((_ref7) => {
      let {
        key: key2
      } = _ref7;
      return key2 !== filterState.key;
    });
    newFilterStates.push(filterState);
    setFilterStates(newFilterStates);
    onFilterChange(generateFilterInfo(newFilterStates), newFilterStates);
  };
  const transformColumns = (innerColumns) => {
    return injectFilter(prefixCls.value, dropdownPrefixCls.value, innerColumns, mergedFilterStates.value, locale2.value, triggerFilter, getPopupContainer.value);
  };
  return [transformColumns, mergedFilterStates, filters];
}
function fillTitle(columns, columnTitleProps) {
  return columns.map((column2) => {
    const cloneColumn = _extends$1({}, column2);
    cloneColumn.title = renderColumnTitle(cloneColumn.title, columnTitleProps);
    if ("children" in cloneColumn) {
      cloneColumn.children = fillTitle(cloneColumn.children, columnTitleProps);
    }
    return cloneColumn;
  });
}
function useTitleColumns(columnTitleProps) {
  const filledColumns = (columns) => fillTitle(columns, columnTitleProps.value);
  return [filledColumns];
}
function renderExpandIcon(locale2) {
  return function expandIcon(_ref) {
    let {
      prefixCls,
      onExpand,
      record,
      expanded,
      expandable
    } = _ref;
    const iconPrefix = `${prefixCls}-row-expand-icon`;
    return createVNode("button", {
      "type": "button",
      "onClick": (e2) => {
        onExpand(record, e2);
        e2.stopPropagation();
      },
      "class": classNames(iconPrefix, {
        [`${iconPrefix}-spaced`]: !expandable,
        [`${iconPrefix}-expanded`]: expandable && expanded,
        [`${iconPrefix}-collapsed`]: expandable && !expanded
      }),
      "aria-label": expanded ? locale2.collapse : locale2.expand,
      "aria-expanded": expanded
    }, null);
  };
}
function fillSlots(columns, contextSlots) {
  const $slots = contextSlots.value;
  return columns.map((column2) => {
    var _a2;
    if (column2 === SELECTION_COLUMN || column2 === EXPAND_COLUMN) return column2;
    const cloneColumn = _extends$1({}, column2);
    const {
      slots = {}
    } = cloneColumn;
    cloneColumn.__originColumn__ = column2;
    devWarning(!("slots" in cloneColumn), "Table", "`column.slots` is deprecated. Please use `v-slot:headerCell` `v-slot:bodyCell` instead.");
    Object.keys(slots).forEach((key2) => {
      const name = slots[key2];
      if (cloneColumn[key2] === void 0 && $slots[name]) {
        cloneColumn[key2] = $slots[name];
      }
    });
    if (contextSlots.value.headerCell && !((_a2 = column2.slots) === null || _a2 === void 0 ? void 0 : _a2.title)) {
      cloneColumn.title = customRenderSlot(contextSlots.value, "headerCell", {
        title: column2.title,
        column: column2
      }, () => [column2.title]);
    }
    if ("children" in cloneColumn && Array.isArray(cloneColumn.children)) {
      cloneColumn.children = fillSlots(cloneColumn.children, contextSlots);
    }
    return cloneColumn;
  });
}
function useColumns(contextSlots) {
  const filledColumns = (columns) => fillSlots(columns, contextSlots);
  return [filledColumns];
}
const genBorderedStyle = (token2) => {
  const {
    componentCls
  } = token2;
  const tableBorder = `${token2.lineWidth}px ${token2.lineType} ${token2.tableBorderColor}`;
  const getSizeBorderStyle = (size, paddingVertical, paddingHorizontal) => ({
    [`&${componentCls}-${size}`]: {
      [`> ${componentCls}-container`]: {
        [`> ${componentCls}-content, > ${componentCls}-body`]: {
          "> table > tbody > tr > td": {
            [`> ${componentCls}-expanded-row-fixed`]: {
              margin: `-${paddingVertical}px -${paddingHorizontal + token2.lineWidth}px`
            }
          }
        }
      }
    }
  });
  return {
    [`${componentCls}-wrapper`]: {
      [`${componentCls}${componentCls}-bordered`]: _extends$1(_extends$1(_extends$1({
        // ============================ Title =============================
        [`> ${componentCls}-title`]: {
          border: tableBorder,
          borderBottom: 0
        },
        // ============================ Content ============================
        [`> ${componentCls}-container`]: {
          borderInlineStart: tableBorder,
          [`
            > ${componentCls}-content,
            > ${componentCls}-header,
            > ${componentCls}-body,
            > ${componentCls}-summary
          `]: {
            "> table": {
              // ============================= Cell =============================
              [`
                > thead > tr > th,
                > tbody > tr > td,
                > tfoot > tr > th,
                > tfoot > tr > td
              `]: {
                borderInlineEnd: tableBorder
              },
              // ============================ Header ============================
              "> thead": {
                "> tr:not(:last-child) > th": {
                  borderBottom: tableBorder
                },
                "> tr > th::before": {
                  backgroundColor: "transparent !important"
                }
              },
              // Fixed right should provides additional border
              [`
                > thead > tr,
                > tbody > tr,
                > tfoot > tr
              `]: {
                [`> ${componentCls}-cell-fix-right-first::after`]: {
                  borderInlineEnd: tableBorder
                }
              },
              // ========================== Expandable ==========================
              "> tbody > tr > td": {
                [`> ${componentCls}-expanded-row-fixed`]: {
                  margin: `-${token2.tablePaddingVertical}px -${token2.tablePaddingHorizontal + token2.lineWidth}px`,
                  "&::after": {
                    position: "absolute",
                    top: 0,
                    insetInlineEnd: token2.lineWidth,
                    bottom: 0,
                    borderInlineEnd: tableBorder,
                    content: '""'
                  }
                }
              }
            }
          },
          [`
            > ${componentCls}-content,
            > ${componentCls}-header
          `]: {
            "> table": {
              borderTop: tableBorder
            }
          }
        },
        // ============================ Scroll ============================
        [`&${componentCls}-scroll-horizontal`]: {
          [`> ${componentCls}-container > ${componentCls}-body`]: {
            "> table > tbody": {
              [`
                > tr${componentCls}-expanded-row,
                > tr${componentCls}-placeholder
              `]: {
                "> td": {
                  borderInlineEnd: 0
                }
              }
            }
          }
        }
      }, getSizeBorderStyle("middle", token2.tablePaddingVerticalMiddle, token2.tablePaddingHorizontalMiddle)), getSizeBorderStyle("small", token2.tablePaddingVerticalSmall, token2.tablePaddingHorizontalSmall)), {
        // ============================ Footer ============================
        [`> ${componentCls}-footer`]: {
          border: tableBorder,
          borderTop: 0
        }
      }),
      // ============================ Nested ============================
      [`${componentCls}-cell`]: {
        [`${componentCls}-container:first-child`]: {
          // :first-child to avoid the case when bordered and title is set
          borderTop: 0
        },
        // https://github.com/ant-design/ant-design/issues/35577
        "&-scrollbar:not([rowspan])": {
          boxShadow: `0 ${token2.lineWidth}px 0 ${token2.lineWidth}px ${token2.tableHeaderBg}`
        }
      }
    }
  };
};
const genEllipsisStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-wrapper`]: {
      [`${componentCls}-cell-ellipsis`]: _extends$1(_extends$1({}, textEllipsis), {
        wordBreak: "keep-all",
        // Fixed first or last should special process
        [`
          &${componentCls}-cell-fix-left-last,
          &${componentCls}-cell-fix-right-first
        `]: {
          overflow: "visible",
          [`${componentCls}-cell-content`]: {
            display: "block",
            overflow: "hidden",
            textOverflow: "ellipsis"
          }
        },
        [`${componentCls}-column-title`]: {
          overflow: "hidden",
          textOverflow: "ellipsis",
          wordBreak: "keep-all"
        }
      })
    }
  };
};
const genEmptyStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-wrapper`]: {
      [`${componentCls}-tbody > tr${componentCls}-placeholder`]: {
        textAlign: "center",
        color: token2.colorTextDisabled,
        "&:hover > td": {
          background: token2.colorBgContainer
        }
      }
    }
  };
};
const genExpandStyle = (token2) => {
  const {
    componentCls,
    antCls,
    controlInteractiveSize: checkboxSize,
    motionDurationSlow,
    lineWidth,
    paddingXS,
    lineType,
    tableBorderColor,
    tableExpandIconBg,
    tableExpandColumnWidth,
    borderRadius,
    fontSize,
    fontSizeSM,
    lineHeight,
    tablePaddingVertical,
    tablePaddingHorizontal,
    tableExpandedRowBg,
    paddingXXS
  } = token2;
  const halfInnerSize = checkboxSize / 2 - lineWidth;
  const expandIconSize = halfInnerSize * 2 + lineWidth * 3;
  const tableBorder = `${lineWidth}px ${lineType} ${tableBorderColor}`;
  const expandIconLineOffset = paddingXXS - lineWidth;
  return {
    [`${componentCls}-wrapper`]: {
      [`${componentCls}-expand-icon-col`]: {
        width: tableExpandColumnWidth
      },
      [`${componentCls}-row-expand-icon-cell`]: {
        textAlign: "center",
        [`${componentCls}-row-expand-icon`]: {
          display: "inline-flex",
          float: "none",
          verticalAlign: "sub"
        }
      },
      [`${componentCls}-row-indent`]: {
        height: 1,
        float: "left"
      },
      [`${componentCls}-row-expand-icon`]: _extends$1(_extends$1({}, operationUnit(token2)), {
        position: "relative",
        float: "left",
        boxSizing: "border-box",
        width: expandIconSize,
        height: expandIconSize,
        padding: 0,
        color: "inherit",
        lineHeight: `${expandIconSize}px`,
        background: tableExpandIconBg,
        border: tableBorder,
        borderRadius,
        transform: `scale(${checkboxSize / expandIconSize})`,
        transition: `all ${motionDurationSlow}`,
        userSelect: "none",
        [`&:focus, &:hover, &:active`]: {
          borderColor: "currentcolor"
        },
        [`&::before, &::after`]: {
          position: "absolute",
          background: "currentcolor",
          transition: `transform ${motionDurationSlow} ease-out`,
          content: '""'
        },
        "&::before": {
          top: halfInnerSize,
          insetInlineEnd: expandIconLineOffset,
          insetInlineStart: expandIconLineOffset,
          height: lineWidth
        },
        "&::after": {
          top: expandIconLineOffset,
          bottom: expandIconLineOffset,
          insetInlineStart: halfInnerSize,
          width: lineWidth,
          transform: "rotate(90deg)"
        },
        // Motion effect
        "&-collapsed::before": {
          transform: "rotate(-180deg)"
        },
        "&-collapsed::after": {
          transform: "rotate(0deg)"
        },
        "&-spaced": {
          "&::before, &::after": {
            display: "none",
            content: "none"
          },
          background: "transparent",
          border: 0,
          visibility: "hidden"
        }
      }),
      [`${componentCls}-row-indent + ${componentCls}-row-expand-icon`]: {
        marginTop: (fontSize * lineHeight - lineWidth * 3) / 2 - Math.ceil((fontSizeSM * 1.4 - lineWidth * 3) / 2),
        marginInlineEnd: paddingXS
      },
      [`tr${componentCls}-expanded-row`]: {
        "&, &:hover": {
          "> td": {
            background: tableExpandedRowBg
          }
        },
        // https://github.com/ant-design/ant-design/issues/25573
        [`${antCls}-descriptions-view`]: {
          display: "flex",
          table: {
            flex: "auto",
            width: "auto"
          }
        }
      },
      // With fixed
      [`${componentCls}-expanded-row-fixed`]: {
        position: "relative",
        margin: `-${tablePaddingVertical}px -${tablePaddingHorizontal}px`,
        padding: `${tablePaddingVertical}px ${tablePaddingHorizontal}px`
      }
    }
  };
};
const genFilterStyle = (token2) => {
  const {
    componentCls,
    antCls,
    iconCls,
    tableFilterDropdownWidth,
    tableFilterDropdownSearchWidth,
    paddingXXS,
    paddingXS,
    colorText,
    lineWidth,
    lineType,
    tableBorderColor,
    tableHeaderIconColor,
    fontSizeSM,
    tablePaddingHorizontal,
    borderRadius,
    motionDurationSlow,
    colorTextDescription,
    colorPrimary,
    tableHeaderFilterActiveBg,
    colorTextDisabled,
    tableFilterDropdownBg,
    tableFilterDropdownHeight,
    controlItemBgHover,
    controlItemBgActive,
    boxShadowSecondary
  } = token2;
  const dropdownPrefixCls = `${antCls}-dropdown`;
  const tableFilterDropdownPrefixCls = `${componentCls}-filter-dropdown`;
  const treePrefixCls = `${antCls}-tree`;
  const tableBorder = `${lineWidth}px ${lineType} ${tableBorderColor}`;
  return [
    {
      [`${componentCls}-wrapper`]: {
        [`${componentCls}-filter-column`]: {
          display: "flex",
          justifyContent: "space-between"
        },
        [`${componentCls}-filter-trigger`]: {
          position: "relative",
          display: "flex",
          alignItems: "center",
          marginBlock: -paddingXXS,
          marginInline: `${paddingXXS}px ${-tablePaddingHorizontal / 2}px`,
          padding: `0 ${paddingXXS}px`,
          color: tableHeaderIconColor,
          fontSize: fontSizeSM,
          borderRadius,
          cursor: "pointer",
          transition: `all ${motionDurationSlow}`,
          "&:hover": {
            color: colorTextDescription,
            background: tableHeaderFilterActiveBg
          },
          "&.active": {
            color: colorPrimary
          }
        }
      }
    },
    {
      // Dropdown
      [`${antCls}-dropdown`]: {
        [tableFilterDropdownPrefixCls]: _extends$1(_extends$1({}, resetComponent(token2)), {
          minWidth: tableFilterDropdownWidth,
          backgroundColor: tableFilterDropdownBg,
          borderRadius,
          boxShadow: boxShadowSecondary,
          // Reset menu
          [`${dropdownPrefixCls}-menu`]: {
            // https://github.com/ant-design/ant-design/issues/4916
            // https://github.com/ant-design/ant-design/issues/19542
            maxHeight: tableFilterDropdownHeight,
            overflowX: "hidden",
            border: 0,
            boxShadow: "none",
            "&:empty::after": {
              display: "block",
              padding: `${paddingXS}px 0`,
              color: colorTextDisabled,
              fontSize: fontSizeSM,
              textAlign: "center",
              content: '"Not Found"'
            }
          },
          [`${tableFilterDropdownPrefixCls}-tree`]: {
            paddingBlock: `${paddingXS}px 0`,
            paddingInline: paddingXS,
            [treePrefixCls]: {
              padding: 0
            },
            [`${treePrefixCls}-treenode ${treePrefixCls}-node-content-wrapper:hover`]: {
              backgroundColor: controlItemBgHover
            },
            [`${treePrefixCls}-treenode-checkbox-checked ${treePrefixCls}-node-content-wrapper`]: {
              "&, &:hover": {
                backgroundColor: controlItemBgActive
              }
            }
          },
          [`${tableFilterDropdownPrefixCls}-search`]: {
            padding: paddingXS,
            borderBottom: tableBorder,
            "&-input": {
              input: {
                minWidth: tableFilterDropdownSearchWidth
              },
              [iconCls]: {
                color: colorTextDisabled
              }
            }
          },
          [`${tableFilterDropdownPrefixCls}-checkall`]: {
            width: "100%",
            marginBottom: paddingXXS,
            marginInlineStart: paddingXXS
          },
          // Operation
          [`${tableFilterDropdownPrefixCls}-btns`]: {
            display: "flex",
            justifyContent: "space-between",
            padding: `${paddingXS - lineWidth}px ${paddingXS}px`,
            overflow: "hidden",
            backgroundColor: "inherit",
            borderTop: tableBorder
          }
        })
      }
    },
    // Dropdown Menu & SubMenu
    {
      // submenu of table filter dropdown
      [`${antCls}-dropdown ${tableFilterDropdownPrefixCls}, ${tableFilterDropdownPrefixCls}-submenu`]: {
        // Checkbox
        [`${antCls}-checkbox-wrapper + span`]: {
          paddingInlineStart: paddingXS,
          color: colorText
        },
        [`> ul`]: {
          maxHeight: "calc(100vh - 130px)",
          overflowX: "hidden",
          overflowY: "auto"
        }
      }
    }
  ];
};
const genFixedStyle = (token2) => {
  const {
    componentCls,
    lineWidth,
    colorSplit,
    motionDurationSlow,
    zIndexTableFixed,
    tableBg,
    zIndexTableSticky
  } = token2;
  const shadowColor = colorSplit;
  return {
    [`${componentCls}-wrapper`]: {
      [`
        ${componentCls}-cell-fix-left,
        ${componentCls}-cell-fix-right
      `]: {
        position: "sticky !important",
        zIndex: zIndexTableFixed,
        background: tableBg
      },
      [`
        ${componentCls}-cell-fix-left-first::after,
        ${componentCls}-cell-fix-left-last::after
      `]: {
        position: "absolute",
        top: 0,
        right: {
          _skip_check_: true,
          value: 0
        },
        bottom: -lineWidth,
        width: 30,
        transform: "translateX(100%)",
        transition: `box-shadow ${motionDurationSlow}`,
        content: '""',
        pointerEvents: "none"
      },
      [`${componentCls}-cell-fix-left-all::after`]: {
        display: "none"
      },
      [`
        ${componentCls}-cell-fix-right-first::after,
        ${componentCls}-cell-fix-right-last::after
      `]: {
        position: "absolute",
        top: 0,
        bottom: -lineWidth,
        left: {
          _skip_check_: true,
          value: 0
        },
        width: 30,
        transform: "translateX(-100%)",
        transition: `box-shadow ${motionDurationSlow}`,
        content: '""',
        pointerEvents: "none"
      },
      [`${componentCls}-container`]: {
        "&::before, &::after": {
          position: "absolute",
          top: 0,
          bottom: 0,
          zIndex: zIndexTableSticky + 1,
          width: 30,
          transition: `box-shadow ${motionDurationSlow}`,
          content: '""',
          pointerEvents: "none"
        },
        "&::before": {
          insetInlineStart: 0
        },
        "&::after": {
          insetInlineEnd: 0
        }
      },
      [`${componentCls}-ping-left`]: {
        [`&:not(${componentCls}-has-fix-left) ${componentCls}-container`]: {
          position: "relative",
          "&::before": {
            boxShadow: `inset 10px 0 8px -8px ${shadowColor}`
          }
        },
        [`
          ${componentCls}-cell-fix-left-first::after,
          ${componentCls}-cell-fix-left-last::after
        `]: {
          boxShadow: `inset 10px 0 8px -8px ${shadowColor}`
        },
        [`${componentCls}-cell-fix-left-last::before`]: {
          backgroundColor: "transparent !important"
        }
      },
      [`${componentCls}-ping-right`]: {
        [`&:not(${componentCls}-has-fix-right) ${componentCls}-container`]: {
          position: "relative",
          "&::after": {
            boxShadow: `inset -10px 0 8px -8px ${shadowColor}`
          }
        },
        [`
          ${componentCls}-cell-fix-right-first::after,
          ${componentCls}-cell-fix-right-last::after
        `]: {
          boxShadow: `inset -10px 0 8px -8px ${shadowColor}`
        }
      }
    }
  };
};
const genPaginationStyle = (token2) => {
  const {
    componentCls,
    antCls
  } = token2;
  return {
    [`${componentCls}-wrapper`]: {
      // ========================== Pagination ==========================
      [`${componentCls}-pagination${antCls}-pagination`]: {
        margin: `${token2.margin}px 0`
      },
      [`${componentCls}-pagination`]: {
        display: "flex",
        flexWrap: "wrap",
        rowGap: token2.paddingXS,
        "> *": {
          flex: "none"
        },
        "&-left": {
          justifyContent: "flex-start"
        },
        "&-center": {
          justifyContent: "center"
        },
        "&-right": {
          justifyContent: "flex-end"
        }
      }
    }
  };
};
const genRadiusStyle = (token2) => {
  const {
    componentCls,
    tableRadius
  } = token2;
  return {
    [`${componentCls}-wrapper`]: {
      [componentCls]: {
        // https://github.com/ant-design/ant-design/issues/39115#issuecomment-1362314574
        [`${componentCls}-title, ${componentCls}-header`]: {
          borderRadius: `${tableRadius}px ${tableRadius}px 0 0`
        },
        [`${componentCls}-title + ${componentCls}-container`]: {
          borderStartStartRadius: 0,
          borderStartEndRadius: 0,
          table: {
            borderRadius: 0,
            "> thead > tr:first-child": {
              "th:first-child": {
                borderRadius: 0
              },
              "th:last-child": {
                borderRadius: 0
              }
            }
          }
        },
        "&-container": {
          borderStartStartRadius: tableRadius,
          borderStartEndRadius: tableRadius,
          "table > thead > tr:first-child": {
            "> *:first-child": {
              borderStartStartRadius: tableRadius
            },
            "> *:last-child": {
              borderStartEndRadius: tableRadius
            }
          }
        },
        "&-footer": {
          borderRadius: `0 0 ${tableRadius}px ${tableRadius}px`
        }
      }
    }
  };
};
const genStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-wrapper-rtl`]: {
      direction: "rtl",
      table: {
        direction: "rtl"
      },
      [`${componentCls}-pagination-left`]: {
        justifyContent: "flex-end"
      },
      [`${componentCls}-pagination-right`]: {
        justifyContent: "flex-start"
      },
      [`${componentCls}-row-expand-icon`]: {
        "&::after": {
          transform: "rotate(-90deg)"
        },
        "&-collapsed::before": {
          transform: "rotate(180deg)"
        },
        "&-collapsed::after": {
          transform: "rotate(0deg)"
        }
      }
    }
  };
};
const genSelectionStyle = (token2) => {
  const {
    componentCls,
    antCls,
    iconCls,
    fontSizeIcon,
    paddingXS,
    tableHeaderIconColor,
    tableHeaderIconColorHover
  } = token2;
  return {
    [`${componentCls}-wrapper`]: {
      // ========================== Selections ==========================
      [`${componentCls}-selection-col`]: {
        width: token2.tableSelectionColumnWidth
      },
      [`${componentCls}-bordered ${componentCls}-selection-col`]: {
        width: token2.tableSelectionColumnWidth + paddingXS * 2
      },
      [`
        table tr th${componentCls}-selection-column,
        table tr td${componentCls}-selection-column
      `]: {
        paddingInlineEnd: token2.paddingXS,
        paddingInlineStart: token2.paddingXS,
        textAlign: "center",
        [`${antCls}-radio-wrapper`]: {
          marginInlineEnd: 0
        }
      },
      [`table tr th${componentCls}-selection-column${componentCls}-cell-fix-left`]: {
        zIndex: token2.zIndexTableFixed + 1
      },
      [`table tr th${componentCls}-selection-column::after`]: {
        backgroundColor: "transparent !important"
      },
      [`${componentCls}-selection`]: {
        position: "relative",
        display: "inline-flex",
        flexDirection: "column"
      },
      [`${componentCls}-selection-extra`]: {
        position: "absolute",
        top: 0,
        zIndex: 1,
        cursor: "pointer",
        transition: `all ${token2.motionDurationSlow}`,
        marginInlineStart: "100%",
        paddingInlineStart: `${token2.tablePaddingHorizontal / 4}px`,
        [iconCls]: {
          color: tableHeaderIconColor,
          fontSize: fontSizeIcon,
          verticalAlign: "baseline",
          "&:hover": {
            color: tableHeaderIconColorHover
          }
        }
      }
    }
  };
};
const genSizeStyle = (token2) => {
  const {
    componentCls
  } = token2;
  const getSizeStyle = (size, paddingVertical, paddingHorizontal, fontSize) => ({
    [`${componentCls}${componentCls}-${size}`]: {
      fontSize,
      [`
        ${componentCls}-title,
        ${componentCls}-footer,
        ${componentCls}-thead > tr > th,
        ${componentCls}-tbody > tr > td,
        tfoot > tr > th,
        tfoot > tr > td
      `]: {
        padding: `${paddingVertical}px ${paddingHorizontal}px`
      },
      [`${componentCls}-filter-trigger`]: {
        marginInlineEnd: `-${paddingHorizontal / 2}px`
      },
      [`${componentCls}-expanded-row-fixed`]: {
        margin: `-${paddingVertical}px -${paddingHorizontal}px`
      },
      [`${componentCls}-tbody`]: {
        // ========================= Nest Table ===========================
        [`${componentCls}-wrapper:only-child ${componentCls}`]: {
          marginBlock: `-${paddingVertical}px`,
          marginInline: `${token2.tableExpandColumnWidth - paddingHorizontal}px -${paddingHorizontal}px`
        }
      },
      // https://github.com/ant-design/ant-design/issues/35167
      [`${componentCls}-selection-column`]: {
        paddingInlineStart: `${paddingHorizontal / 4}px`
      }
    }
  });
  return {
    [`${componentCls}-wrapper`]: _extends$1(_extends$1({}, getSizeStyle("middle", token2.tablePaddingVerticalMiddle, token2.tablePaddingHorizontalMiddle, token2.tableFontSizeMiddle)), getSizeStyle("small", token2.tablePaddingVerticalSmall, token2.tablePaddingHorizontalSmall, token2.tableFontSizeSmall))
  };
};
const genResizeStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-wrapper ${componentCls}-resize-handle`]: {
      position: "absolute",
      top: 0,
      height: "100% !important",
      bottom: 0,
      left: " auto !important",
      right: " -8px",
      cursor: "col-resize",
      touchAction: "none",
      userSelect: "auto",
      width: "16px",
      zIndex: 1,
      [`&-line`]: {
        display: "block",
        width: "1px",
        marginLeft: "7px",
        height: "100% !important",
        backgroundColor: token2.colorPrimary,
        opacity: 0
      },
      [`&:hover &-line`]: {
        opacity: 1
      }
    },
    [`${componentCls}-wrapper  ${componentCls}-resize-handle.dragging`]: {
      overflow: "hidden",
      [`${componentCls}-resize-handle-line`]: {
        opacity: 1
      },
      [`&:before`]: {
        position: "absolute",
        top: 0,
        bottom: 0,
        content: '" "',
        width: "200vw",
        transform: "translateX(-50%)",
        opacity: 0
      }
    }
  };
};
const genSorterStyle = (token2) => {
  const {
    componentCls,
    marginXXS,
    fontSizeIcon,
    tableHeaderIconColor,
    tableHeaderIconColorHover
  } = token2;
  return {
    [`${componentCls}-wrapper`]: {
      [`${componentCls}-thead th${componentCls}-column-has-sorters`]: {
        outline: "none",
        cursor: "pointer",
        transition: `all ${token2.motionDurationSlow}`,
        "&:hover": {
          background: token2.tableHeaderSortHoverBg,
          "&::before": {
            backgroundColor: "transparent !important"
          }
        },
        "&:focus-visible": {
          color: token2.colorPrimary
        },
        // https://github.com/ant-design/ant-design/issues/30969
        [`
          &${componentCls}-cell-fix-left:hover,
          &${componentCls}-cell-fix-right:hover
        `]: {
          background: token2.tableFixedHeaderSortActiveBg
        }
      },
      [`${componentCls}-thead th${componentCls}-column-sort`]: {
        background: token2.tableHeaderSortBg,
        "&::before": {
          backgroundColor: "transparent !important"
        }
      },
      [`td${componentCls}-column-sort`]: {
        background: token2.tableBodySortBg
      },
      [`${componentCls}-column-title`]: {
        position: "relative",
        zIndex: 1,
        flex: 1
      },
      [`${componentCls}-column-sorters`]: {
        display: "flex",
        flex: "auto",
        alignItems: "center",
        justifyContent: "space-between",
        "&::after": {
          position: "absolute",
          inset: 0,
          width: "100%",
          height: "100%",
          content: '""'
        }
      },
      [`${componentCls}-column-sorter`]: {
        marginInlineStart: marginXXS,
        color: tableHeaderIconColor,
        fontSize: 0,
        transition: `color ${token2.motionDurationSlow}`,
        "&-inner": {
          display: "inline-flex",
          flexDirection: "column",
          alignItems: "center"
        },
        "&-up, &-down": {
          fontSize: fontSizeIcon,
          "&.active": {
            color: token2.colorPrimary
          }
        },
        [`${componentCls}-column-sorter-up + ${componentCls}-column-sorter-down`]: {
          marginTop: "-0.3em"
        }
      },
      [`${componentCls}-column-sorters:hover ${componentCls}-column-sorter`]: {
        color: tableHeaderIconColorHover
      }
    }
  };
};
const genStickyStyle = (token2) => {
  const {
    componentCls,
    opacityLoading,
    tableScrollThumbBg,
    tableScrollThumbBgHover,
    tableScrollThumbSize,
    tableScrollBg,
    zIndexTableSticky
  } = token2;
  const tableBorder = `${token2.lineWidth}px ${token2.lineType} ${token2.tableBorderColor}`;
  return {
    [`${componentCls}-wrapper`]: {
      [`${componentCls}-sticky`]: {
        "&-holder": {
          position: "sticky",
          zIndex: zIndexTableSticky,
          background: token2.colorBgContainer
        },
        "&-scroll": {
          position: "sticky",
          bottom: 0,
          height: `${tableScrollThumbSize}px !important`,
          zIndex: zIndexTableSticky,
          display: "flex",
          alignItems: "center",
          background: tableScrollBg,
          borderTop: tableBorder,
          opacity: opacityLoading,
          "&:hover": {
            transformOrigin: "center bottom"
          },
          // fake scrollbar style of sticky
          "&-bar": {
            height: tableScrollThumbSize,
            backgroundColor: tableScrollThumbBg,
            borderRadius: 100,
            transition: `all ${token2.motionDurationSlow}, transform none`,
            position: "absolute",
            bottom: 0,
            "&:hover, &-active": {
              backgroundColor: tableScrollThumbBgHover
            }
          }
        }
      }
    }
  };
};
const genSummaryStyle = (token2) => {
  const {
    componentCls,
    lineWidth,
    tableBorderColor
  } = token2;
  const tableBorder = `${lineWidth}px ${token2.lineType} ${tableBorderColor}`;
  return {
    [`${componentCls}-wrapper`]: {
      [`${componentCls}-summary`]: {
        position: "relative",
        zIndex: token2.zIndexTableFixed,
        background: token2.tableBg,
        "> tr": {
          "> th, > td": {
            borderBottom: tableBorder
          }
        }
      },
      [`div${componentCls}-summary`]: {
        boxShadow: `0 -${lineWidth}px 0 ${tableBorderColor}`
      }
    }
  };
};
const genTableStyle = (token2) => {
  const {
    componentCls,
    fontWeightStrong,
    tablePaddingVertical,
    tablePaddingHorizontal,
    lineWidth,
    lineType,
    tableBorderColor,
    tableFontSize,
    tableBg,
    tableRadius,
    tableHeaderTextColor,
    motionDurationMid,
    tableHeaderBg,
    tableHeaderCellSplitColor,
    tableRowHoverBg,
    tableSelectedRowBg,
    tableSelectedRowHoverBg,
    tableFooterTextColor,
    tableFooterBg,
    paddingContentVerticalLG
  } = token2;
  const tableBorder = `${lineWidth}px ${lineType} ${tableBorderColor}`;
  return {
    [`${componentCls}-wrapper`]: _extends$1(_extends$1({
      clear: "both",
      maxWidth: "100%"
    }, clearFix()), {
      [componentCls]: _extends$1(_extends$1({}, resetComponent(token2)), {
        fontSize: tableFontSize,
        background: tableBg,
        borderRadius: `${tableRadius}px ${tableRadius}px 0 0`
      }),
      // https://github.com/ant-design/ant-design/issues/17611
      table: {
        width: "100%",
        textAlign: "start",
        borderRadius: `${tableRadius}px ${tableRadius}px 0 0`,
        borderCollapse: "separate",
        borderSpacing: 0
      },
      // ============================= Cell =============================
      [`
          ${componentCls}-thead > tr > th,
          ${componentCls}-tbody > tr > td,
          tfoot > tr > th,
          tfoot > tr > td
        `]: {
        position: "relative",
        padding: `${paddingContentVerticalLG}px ${tablePaddingHorizontal}px`,
        overflowWrap: "break-word"
      },
      // ============================ Title =============================
      [`${componentCls}-title`]: {
        padding: `${tablePaddingVertical}px ${tablePaddingHorizontal}px`
      },
      // ============================ Header ============================
      [`${componentCls}-thead`]: {
        [`
          > tr > th,
          > tr > td
        `]: {
          position: "relative",
          color: tableHeaderTextColor,
          fontWeight: fontWeightStrong,
          textAlign: "start",
          background: tableHeaderBg,
          borderBottom: tableBorder,
          transition: `background ${motionDurationMid} ease`,
          "&[colspan]:not([colspan='1'])": {
            textAlign: "center"
          },
          [`&:not(:last-child):not(${componentCls}-selection-column):not(${componentCls}-row-expand-icon-cell):not([colspan])::before`]: {
            position: "absolute",
            top: "50%",
            insetInlineEnd: 0,
            width: 1,
            height: "1.6em",
            backgroundColor: tableHeaderCellSplitColor,
            transform: "translateY(-50%)",
            transition: `background-color ${motionDurationMid}`,
            content: '""'
          }
        },
        "> tr:not(:last-child) > th[colspan]": {
          borderBottom: 0
        }
      },
      // ============================ Body ============================
      // Borderless Table has unique hover style, which would be implemented with `borderTop`.
      [`${componentCls}:not(${componentCls}-bordered)`]: {
        [`${componentCls}-tbody`]: {
          "> tr": {
            "> td": {
              borderTop: tableBorder,
              borderBottom: "transparent"
            },
            "&:last-child > td": {
              borderBottom: tableBorder
            },
            [`&:first-child > td,
              &${componentCls}-measure-row + tr > td`]: {
              borderTop: "none",
              borderTopColor: "transparent"
            }
          }
        }
      },
      // Bordered Table remains simple `borderBottom`.
      // Ref issue: https://github.com/ant-design/ant-design/issues/38724
      [`${componentCls}${componentCls}-bordered`]: {
        [`${componentCls}-tbody`]: {
          "> tr": {
            "> td": {
              borderBottom: tableBorder
            }
          }
        }
      },
      [`${componentCls}-tbody`]: {
        "> tr": {
          "> td": {
            transition: `background ${motionDurationMid}, border-color ${motionDurationMid}`,
            // ========================= Nest Table ===========================
            [`
              > ${componentCls}-wrapper:only-child,
              > ${componentCls}-expanded-row-fixed > ${componentCls}-wrapper:only-child
            `]: {
              [componentCls]: {
                marginBlock: `-${tablePaddingVertical}px`,
                marginInline: `${token2.tableExpandColumnWidth - tablePaddingHorizontal}px -${tablePaddingHorizontal}px`,
                [`${componentCls}-tbody > tr:last-child > td`]: {
                  borderBottom: 0,
                  "&:first-child, &:last-child": {
                    borderRadius: 0
                  }
                }
              }
            }
          },
          [`
            &${componentCls}-row:hover > td,
            > td${componentCls}-cell-row-hover
          `]: {
            background: tableRowHoverBg
          },
          [`&${componentCls}-row-selected`]: {
            "> td": {
              background: tableSelectedRowBg
            },
            "&:hover > td": {
              background: tableSelectedRowHoverBg
            }
          }
        }
      },
      // ============================ Footer ============================
      [`${componentCls}-footer`]: {
        padding: `${tablePaddingVertical}px ${tablePaddingHorizontal}px`,
        color: tableFooterTextColor,
        background: tableFooterBg
      }
    })
  };
};
const useStyle$5 = genComponentStyleHook("Table", (token2) => {
  const {
    controlItemBgActive,
    controlItemBgActiveHover,
    colorTextPlaceholder,
    colorTextHeading,
    colorSplit,
    colorBorderSecondary,
    fontSize,
    padding,
    paddingXS,
    paddingSM,
    controlHeight,
    colorFillAlter,
    colorIcon,
    colorIconHover,
    opacityLoading,
    colorBgContainer,
    borderRadiusLG,
    colorFillContent,
    colorFillSecondary,
    controlInteractiveSize: checkboxSize
  } = token2;
  const baseColorAction = new TinyColor(colorIcon);
  const baseColorActionHover = new TinyColor(colorIconHover);
  const tableSelectedRowBg = controlItemBgActive;
  const zIndexTableFixed = 2;
  const colorFillSecondarySolid = new TinyColor(colorFillSecondary).onBackground(colorBgContainer).toHexString();
  const colorFillContentSolid = new TinyColor(colorFillContent).onBackground(colorBgContainer).toHexString();
  const colorFillAlterSolid = new TinyColor(colorFillAlter).onBackground(colorBgContainer).toHexString();
  const tableToken = merge(token2, {
    tableFontSize: fontSize,
    tableBg: colorBgContainer,
    tableRadius: borderRadiusLG,
    tablePaddingVertical: padding,
    tablePaddingHorizontal: padding,
    tablePaddingVerticalMiddle: paddingSM,
    tablePaddingHorizontalMiddle: paddingXS,
    tablePaddingVerticalSmall: paddingXS,
    tablePaddingHorizontalSmall: paddingXS,
    tableBorderColor: colorBorderSecondary,
    tableHeaderTextColor: colorTextHeading,
    tableHeaderBg: colorFillAlterSolid,
    tableFooterTextColor: colorTextHeading,
    tableFooterBg: colorFillAlterSolid,
    tableHeaderCellSplitColor: colorBorderSecondary,
    tableHeaderSortBg: colorFillSecondarySolid,
    tableHeaderSortHoverBg: colorFillContentSolid,
    tableHeaderIconColor: baseColorAction.clone().setAlpha(baseColorAction.getAlpha() * opacityLoading).toRgbString(),
    tableHeaderIconColorHover: baseColorActionHover.clone().setAlpha(baseColorActionHover.getAlpha() * opacityLoading).toRgbString(),
    tableBodySortBg: colorFillAlterSolid,
    tableFixedHeaderSortActiveBg: colorFillSecondarySolid,
    tableHeaderFilterActiveBg: colorFillContent,
    tableFilterDropdownBg: colorBgContainer,
    tableRowHoverBg: colorFillAlterSolid,
    tableSelectedRowBg,
    tableSelectedRowHoverBg: controlItemBgActiveHover,
    zIndexTableFixed,
    zIndexTableSticky: zIndexTableFixed + 1,
    tableFontSizeMiddle: fontSize,
    tableFontSizeSmall: fontSize,
    tableSelectionColumnWidth: controlHeight,
    tableExpandIconBg: colorBgContainer,
    tableExpandColumnWidth: checkboxSize + 2 * token2.padding,
    tableExpandedRowBg: colorFillAlter,
    // Dropdown
    tableFilterDropdownWidth: 120,
    tableFilterDropdownHeight: 264,
    tableFilterDropdownSearchWidth: 140,
    // Virtual Scroll Bar
    tableScrollThumbSize: 8,
    tableScrollThumbBg: colorTextPlaceholder,
    tableScrollThumbBgHover: colorTextHeading,
    tableScrollBg: colorSplit
  });
  return [genTableStyle(tableToken), genPaginationStyle(tableToken), genSummaryStyle(tableToken), genSorterStyle(tableToken), genFilterStyle(tableToken), genBorderedStyle(tableToken), genRadiusStyle(tableToken), genExpandStyle(tableToken), genSummaryStyle(tableToken), genEmptyStyle(tableToken), genSelectionStyle(tableToken), genFixedStyle(tableToken), genStickyStyle(tableToken), genEllipsisStyle(tableToken), genSizeStyle(tableToken), genResizeStyle(tableToken), genStyle(tableToken)];
});
const EMPTY_LIST = [];
const tableProps = () => {
  return {
    prefixCls: stringType(),
    columns: arrayType(),
    rowKey: someType([String, Function]),
    tableLayout: stringType(),
    rowClassName: someType([String, Function]),
    title: functionType(),
    footer: functionType(),
    id: stringType(),
    showHeader: booleanType(),
    components: objectType(),
    customRow: functionType(),
    customHeaderRow: functionType(),
    direction: stringType(),
    expandFixed: someType([Boolean, String]),
    expandColumnWidth: Number,
    expandedRowKeys: arrayType(),
    defaultExpandedRowKeys: arrayType(),
    expandedRowRender: functionType(),
    expandRowByClick: booleanType(),
    expandIcon: functionType(),
    onExpand: functionType(),
    onExpandedRowsChange: functionType(),
    "onUpdate:expandedRowKeys": functionType(),
    defaultExpandAllRows: booleanType(),
    indentSize: Number,
    /** @deprecated Please use `EXPAND_COLUMN` in `columns` directly */
    expandIconColumnIndex: Number,
    showExpandColumn: booleanType(),
    expandedRowClassName: functionType(),
    childrenColumnName: stringType(),
    rowExpandable: functionType(),
    sticky: someType([Boolean, Object]),
    dropdownPrefixCls: String,
    dataSource: arrayType(),
    pagination: someType([Boolean, Object]),
    loading: someType([Boolean, Object]),
    size: stringType(),
    bordered: booleanType(),
    locale: objectType(),
    onChange: functionType(),
    onResizeColumn: functionType(),
    rowSelection: objectType(),
    getPopupContainer: functionType(),
    scroll: objectType(),
    sortDirections: arrayType(),
    showSorterTooltip: someType([Boolean, Object], true),
    transformCellText: functionType()
  };
};
const InternalTable = defineComponent({
  name: "InternalTable",
  inheritAttrs: false,
  props: initDefaultProps(_extends$1(_extends$1({}, tableProps()), {
    contextSlots: objectType()
  }), {
    rowKey: "key"
  }),
  setup(props2, _ref) {
    let {
      attrs,
      slots,
      expose,
      emit
    } = _ref;
    devWarning(!(typeof props2.rowKey === "function" && props2.rowKey.length > 1), "Table", "`index` parameter of `rowKey` function is deprecated. There is no guarantee that it will work as expected.");
    useProvideSlots(computed(() => props2.contextSlots));
    useProvideTableContext({
      onResizeColumn: (w2, col) => {
        emit("resizeColumn", w2, col);
      }
    });
    const screens = useBreakpoint();
    const mergedColumns = computed(() => {
      const matched = new Set(Object.keys(screens.value).filter((m2) => screens.value[m2]));
      return props2.columns.filter((c2) => !c2.responsive || c2.responsive.some((r2) => matched.has(r2)));
    });
    const {
      size: mergedSize,
      renderEmpty: renderEmpty2,
      direction,
      prefixCls,
      configProvider
    } = useConfigInject("table", props2);
    const [wrapSSR, hashId] = useStyle$5(prefixCls);
    const transformCellText = computed(() => {
      var _a2;
      return props2.transformCellText || ((_a2 = configProvider.transformCellText) === null || _a2 === void 0 ? void 0 : _a2.value);
    });
    const [tableLocale] = useLocaleReceiver("Table", localeValues.Table, toRef(props2, "locale"));
    const rawData = computed(() => props2.dataSource || EMPTY_LIST);
    const dropdownPrefixCls = computed(() => configProvider.getPrefixCls("dropdown", props2.dropdownPrefixCls));
    const childrenColumnName = computed(() => props2.childrenColumnName || "children");
    const expandType = computed(() => {
      if (rawData.value.some((item) => item === null || item === void 0 ? void 0 : item[childrenColumnName.value])) {
        return "nest";
      }
      if (props2.expandedRowRender) {
        return "row";
      }
      return null;
    });
    const internalRefs = reactive({
      body: null
    });
    const updateInternalRefs = (refs) => {
      _extends$1(internalRefs, refs);
    };
    const getRowKey = computed(() => {
      if (typeof props2.rowKey === "function") {
        return props2.rowKey;
      }
      return (record) => record === null || record === void 0 ? void 0 : record[props2.rowKey];
    });
    const [getRecordByKey] = useLazyKVMap(rawData, childrenColumnName, getRowKey);
    const changeEventInfo = {};
    const triggerOnChange = function(info, action) {
      let reset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      const {
        pagination,
        scroll,
        onChange
      } = props2;
      const changeInfo = _extends$1(_extends$1({}, changeEventInfo), info);
      if (reset) {
        changeEventInfo.resetPagination();
        if (changeInfo.pagination.current) {
          changeInfo.pagination.current = 1;
        }
        if (pagination && pagination.onChange) {
          pagination.onChange(1, changeInfo.pagination.pageSize);
        }
      }
      if (scroll && scroll.scrollToFirstRowOnChange !== false && internalRefs.body) {
        scrollTo$1(0, {
          getContainer: () => internalRefs.body
        });
      }
      onChange === null || onChange === void 0 ? void 0 : onChange(changeInfo.pagination, changeInfo.filters, changeInfo.sorter, {
        currentDataSource: getFilterData(getSortData(rawData.value, changeInfo.sorterStates, childrenColumnName.value), changeInfo.filterStates),
        action
      });
    };
    const onSorterChange = (sorter, sorterStates) => {
      triggerOnChange({
        sorter,
        sorterStates
      }, "sort", false);
    };
    const [transformSorterColumns, sortStates, sorterTitleProps, sorters] = useFilterSorter({
      prefixCls,
      mergedColumns,
      onSorterChange,
      sortDirections: computed(() => props2.sortDirections || ["ascend", "descend"]),
      tableLocale,
      showSorterTooltip: toRef(props2, "showSorterTooltip")
    });
    const sortedData = computed(() => getSortData(rawData.value, sortStates.value, childrenColumnName.value));
    const onFilterChange = (filters2, filterStates2) => {
      triggerOnChange({
        filters: filters2,
        filterStates: filterStates2
      }, "filter", true);
    };
    const [transformFilterColumns, filterStates, filters] = useFilter({
      prefixCls,
      locale: tableLocale,
      dropdownPrefixCls,
      mergedColumns,
      onFilterChange,
      getPopupContainer: toRef(props2, "getPopupContainer")
    });
    const mergedData = computed(() => getFilterData(sortedData.value, filterStates.value));
    const [transformBasicColumns] = useColumns(toRef(props2, "contextSlots"));
    const columnTitleProps = computed(() => {
      const mergedFilters = {};
      const filtersValue = filters.value;
      Object.keys(filtersValue).forEach((filterKey) => {
        if (filtersValue[filterKey] !== null) {
          mergedFilters[filterKey] = filtersValue[filterKey];
        }
      });
      return _extends$1(_extends$1({}, sorterTitleProps.value), {
        filters: mergedFilters
      });
    });
    const [transformTitleColumns] = useTitleColumns(columnTitleProps);
    const onPaginationChange = (current, pageSize) => {
      triggerOnChange({
        pagination: _extends$1(_extends$1({}, changeEventInfo.pagination), {
          current,
          pageSize
        })
      }, "paginate");
    };
    const [mergedPagination, resetPagination] = usePagination(computed(() => mergedData.value.length), toRef(props2, "pagination"), onPaginationChange);
    watchEffect(() => {
      changeEventInfo.sorter = sorters.value;
      changeEventInfo.sorterStates = sortStates.value;
      changeEventInfo.filters = filters.value;
      changeEventInfo.filterStates = filterStates.value;
      changeEventInfo.pagination = props2.pagination === false ? {} : getPaginationParam(mergedPagination.value, props2.pagination);
      changeEventInfo.resetPagination = resetPagination;
    });
    const pageData = computed(() => {
      if (props2.pagination === false || !mergedPagination.value.pageSize) {
        return mergedData.value;
      }
      const {
        current = 1,
        total,
        pageSize = DEFAULT_PAGE_SIZE
      } = mergedPagination.value;
      devWarning(current > 0, "Table", "`current` should be positive number.");
      if (mergedData.value.length < total) {
        if (mergedData.value.length > pageSize) {
          return mergedData.value.slice((current - 1) * pageSize, current * pageSize);
        }
        return mergedData.value;
      }
      return mergedData.value.slice((current - 1) * pageSize, current * pageSize);
    });
    watchEffect(() => {
      nextTick(() => {
        const {
          total,
          pageSize = DEFAULT_PAGE_SIZE
        } = mergedPagination.value;
        if (mergedData.value.length < total) {
          if (mergedData.value.length > pageSize) {
            devWarning(false, "Table", "`dataSource` length is less than `pagination.total` but large than `pagination.pageSize`. Please make sure your config correct data with async mode.");
          }
        }
      });
    }, {
      flush: "post"
    });
    const expandIconColumnIndex = computed(() => {
      if (props2.showExpandColumn === false) return -1;
      if (expandType.value === "nest" && props2.expandIconColumnIndex === void 0) {
        return props2.rowSelection ? 1 : 0;
      } else if (props2.expandIconColumnIndex > 0 && props2.rowSelection) {
        return props2.expandIconColumnIndex - 1;
      }
      return props2.expandIconColumnIndex;
    });
    const rowSelection = ref();
    watch(() => props2.rowSelection, () => {
      rowSelection.value = props2.rowSelection ? _extends$1({}, props2.rowSelection) : props2.rowSelection;
    }, {
      deep: true,
      immediate: true
    });
    const [transformSelectionColumns, selectedKeySet] = useSelection(rowSelection, {
      prefixCls,
      data: mergedData,
      pageData,
      getRowKey,
      getRecordByKey,
      expandType,
      childrenColumnName,
      locale: tableLocale,
      getPopupContainer: computed(() => props2.getPopupContainer)
    });
    const internalRowClassName = (record, index2, indent) => {
      let mergedRowClassName;
      const {
        rowClassName
      } = props2;
      if (typeof rowClassName === "function") {
        mergedRowClassName = classNames(rowClassName(record, index2, indent));
      } else {
        mergedRowClassName = classNames(rowClassName);
      }
      return classNames({
        [`${prefixCls.value}-row-selected`]: selectedKeySet.value.has(getRowKey.value(record, index2))
      }, mergedRowClassName);
    };
    expose({
      selectedKeySet
    });
    const indentSize = computed(() => {
      return typeof props2.indentSize === "number" ? props2.indentSize : 15;
    });
    const transformColumns = (innerColumns) => {
      const res = transformTitleColumns(transformSelectionColumns(transformFilterColumns(transformSorterColumns(transformBasicColumns(innerColumns)))));
      return res;
    };
    return () => {
      var _a2;
      const {
        expandIcon = slots.expandIcon || renderExpandIcon(tableLocale.value),
        pagination,
        loading,
        bordered
      } = props2;
      let topPaginationNode;
      let bottomPaginationNode;
      if (pagination !== false && ((_a2 = mergedPagination.value) === null || _a2 === void 0 ? void 0 : _a2.total)) {
        let paginationSize;
        if (mergedPagination.value.size) {
          paginationSize = mergedPagination.value.size;
        } else {
          paginationSize = mergedSize.value === "small" || mergedSize.value === "middle" ? "small" : void 0;
        }
        const renderPagination = (position3) => createVNode(Pagination, _objectSpread2$1(_objectSpread2$1({}, mergedPagination.value), {}, {
          "class": [`${prefixCls.value}-pagination ${prefixCls.value}-pagination-${position3}`, mergedPagination.value.class],
          "size": paginationSize
        }), null);
        const defaultPosition = direction.value === "rtl" ? "left" : "right";
        const {
          position: position2
        } = mergedPagination.value;
        if (position2 !== null && Array.isArray(position2)) {
          const topPos = position2.find((p) => p.includes("top"));
          const bottomPos = position2.find((p) => p.includes("bottom"));
          const isDisable = position2.every((p) => `${p}` === "none");
          if (!topPos && !bottomPos && !isDisable) {
            bottomPaginationNode = renderPagination(defaultPosition);
          }
          if (topPos) {
            topPaginationNode = renderPagination(topPos.toLowerCase().replace("top", ""));
          }
          if (bottomPos) {
            bottomPaginationNode = renderPagination(bottomPos.toLowerCase().replace("bottom", ""));
          }
        } else {
          bottomPaginationNode = renderPagination(defaultPosition);
        }
      }
      let spinProps2;
      if (typeof loading === "boolean") {
        spinProps2 = {
          spinning: loading
        };
      } else if (typeof loading === "object") {
        spinProps2 = _extends$1({
          spinning: true
        }, loading);
      }
      const wrapperClassNames = classNames(`${prefixCls.value}-wrapper`, {
        [`${prefixCls.value}-wrapper-rtl`]: direction.value === "rtl"
      }, attrs.class, hashId.value);
      const tableProps2 = omit$1(props2, ["columns"]);
      return wrapSSR(createVNode("div", {
        "class": wrapperClassNames,
        "style": attrs.style
      }, [createVNode(Spin, _objectSpread2$1({
        "spinning": false
      }, spinProps2), {
        default: () => [topPaginationNode, createVNode(Table$2, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, attrs), tableProps2), {}, {
          "expandedRowKeys": props2.expandedRowKeys,
          "defaultExpandedRowKeys": props2.defaultExpandedRowKeys,
          "expandIconColumnIndex": expandIconColumnIndex.value,
          "indentSize": indentSize.value,
          "expandIcon": expandIcon,
          "columns": mergedColumns.value,
          "direction": direction.value,
          "prefixCls": prefixCls.value,
          "class": classNames({
            [`${prefixCls.value}-middle`]: mergedSize.value === "middle",
            [`${prefixCls.value}-small`]: mergedSize.value === "small",
            [`${prefixCls.value}-bordered`]: bordered,
            [`${prefixCls.value}-empty`]: rawData.value.length === 0
          }),
          "data": pageData.value,
          "rowKey": getRowKey.value,
          "rowClassName": internalRowClassName,
          "internalHooks": INTERNAL_HOOKS,
          "internalRefs": internalRefs,
          "onUpdateInternalRefs": updateInternalRefs,
          "transformColumns": transformColumns,
          "transformCellText": transformCellText.value
        }), _extends$1(_extends$1({}, slots), {
          emptyText: () => {
            var _a3, _b;
            return ((_a3 = slots.emptyText) === null || _a3 === void 0 ? void 0 : _a3.call(slots)) || ((_b = props2.locale) === null || _b === void 0 ? void 0 : _b.emptyText) || renderEmpty2("Table");
          }
        })), bottomPaginationNode]
      })]));
    };
  }
});
const Table$1 = defineComponent({
  name: "ATable",
  inheritAttrs: false,
  props: initDefaultProps(tableProps(), {
    rowKey: "key"
  }),
  slots: Object,
  setup(props2, _ref2) {
    let {
      attrs,
      slots,
      expose
    } = _ref2;
    const table = ref();
    expose({
      table
    });
    return () => {
      var _a2;
      const columns = props2.columns || convertChildrenToColumns((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots));
      return createVNode(InternalTable, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
        "ref": table
      }, attrs), props2), {}, {
        "columns": columns,
        "expandedRowRender": slots.expandedRowRender || props2.expandedRowRender,
        "contextSlots": _extends$1({}, slots)
      }), slots);
    };
  }
});
const Column = defineComponent({
  name: "ATableColumn",
  slots: Object,
  render() {
    return null;
  }
});
const ColumnGroup = defineComponent({
  name: "ATableColumnGroup",
  slots: Object,
  __ANT_TABLE_COLUMN_GROUP: true,
  render() {
    return null;
  }
});
const TableSummaryRow = SummaryRow;
const TableSummaryCell = SummaryCell;
const TableSummary = _extends$1(FooterComponents, {
  Cell: TableSummaryCell,
  Row: TableSummaryRow,
  name: "ATableSummary"
});
const Table = _extends$1(Table$1, {
  SELECTION_ALL,
  SELECTION_INVERT,
  SELECTION_NONE,
  SELECTION_COLUMN,
  EXPAND_COLUMN,
  Column,
  ColumnGroup,
  Summary: TableSummary,
  install: (app) => {
    app.component(TableSummary.name, TableSummary);
    app.component(TableSummaryCell.name, TableSummaryCell);
    app.component(TableSummaryRow.name, TableSummaryRow);
    app.component(Table$1.name, Table$1);
    app.component(Column.name, Column);
    app.component(ColumnGroup.name, ColumnGroup);
    return app;
  }
});
const timePickerProps = () => ({
  format: String,
  showNow: booleanType(),
  showHour: booleanType(),
  showMinute: booleanType(),
  showSecond: booleanType(),
  use12Hours: booleanType(),
  hourStep: Number,
  minuteStep: Number,
  secondStep: Number,
  hideDisabledOptions: booleanType(),
  popupClassName: String,
  status: stringType()
});
function createTimePicker(generateConfig2) {
  const DatePicker2 = generatePicker(generateConfig2, _extends$1(_extends$1({}, timePickerProps()), {
    order: {
      type: Boolean,
      default: true
    }
  }));
  const {
    TimePicker: InternalTimePicker,
    RangePicker: InternalRangePicker
  } = DatePicker2;
  const TimePicker2 = defineComponent({
    name: "ATimePicker",
    inheritAttrs: false,
    props: _extends$1(_extends$1(_extends$1(_extends$1({}, commonProps()), datePickerProps()), timePickerProps()), {
      addon: {
        type: Function
      }
    }),
    slots: Object,
    setup(p, _ref) {
      let {
        slots,
        expose,
        emit,
        attrs
      } = _ref;
      const props2 = p;
      const formItemContext = useInjectFormItemContext();
      devWarning(!(slots.addon || props2.addon), "TimePicker", "`addon` is deprecated. Please use `v-slot:renderExtraFooter` instead.");
      const pickerRef = ref();
      expose({
        focus: () => {
          var _a2;
          (_a2 = pickerRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
        },
        blur: () => {
          var _a2;
          (_a2 = pickerRef.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
        }
      });
      const onChange = (value, dateString) => {
        emit("update:value", value);
        emit("change", value, dateString);
        formItemContext.onFieldChange();
      };
      const onOpenChange = (open2) => {
        emit("update:open", open2);
        emit("openChange", open2);
      };
      const onFocus = (e2) => {
        emit("focus", e2);
      };
      const onBlur = (e2) => {
        emit("blur", e2);
        formItemContext.onFieldBlur();
      };
      const onOk = (value) => {
        emit("ok", value);
      };
      return () => {
        const {
          id = formItemContext.id.value
        } = props2;
        return createVNode(InternalTimePicker, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, attrs), omit$1(props2, ["onUpdate:value", "onUpdate:open"])), {}, {
          "id": id,
          "dropdownClassName": props2.popupClassName,
          "mode": void 0,
          "ref": pickerRef,
          "renderExtraFooter": props2.addon || slots.addon || props2.renderExtraFooter || slots.renderExtraFooter,
          "onChange": onChange,
          "onOpenChange": onOpenChange,
          "onFocus": onFocus,
          "onBlur": onBlur,
          "onOk": onOk
        }), slots);
      };
    }
  });
  const TimeRangePicker2 = defineComponent({
    name: "ATimeRangePicker",
    inheritAttrs: false,
    props: _extends$1(_extends$1(_extends$1(_extends$1({}, commonProps()), rangePickerProps()), timePickerProps()), {
      order: {
        type: Boolean,
        default: true
      }
    }),
    slots: Object,
    setup(p, _ref2) {
      let {
        slots,
        expose,
        emit,
        attrs
      } = _ref2;
      const props2 = p;
      const pickerRef = ref();
      const formItemContext = useInjectFormItemContext();
      expose({
        focus: () => {
          var _a2;
          (_a2 = pickerRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
        },
        blur: () => {
          var _a2;
          (_a2 = pickerRef.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
        }
      });
      const onChange = (values, dateStrings) => {
        emit("update:value", values);
        emit("change", values, dateStrings);
        formItemContext.onFieldChange();
      };
      const onOpenChange = (open2) => {
        emit("update:open", open2);
        emit("openChange", open2);
      };
      const onFocus = (e2) => {
        emit("focus", e2);
      };
      const onBlur = (e2) => {
        emit("blur", e2);
        formItemContext.onFieldBlur();
      };
      const onPanelChange = (values, modes) => {
        emit("panelChange", values, modes);
      };
      const onOk = (values) => {
        emit("ok", values);
      };
      const onCalendarChange = (values, dateStrings, info) => {
        emit("calendarChange", values, dateStrings, info);
      };
      return () => {
        const {
          id = formItemContext.id.value
        } = props2;
        return createVNode(InternalRangePicker, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, attrs), omit$1(props2, ["onUpdate:open", "onUpdate:value"])), {}, {
          "id": id,
          "dropdownClassName": props2.popupClassName,
          "picker": "time",
          "mode": void 0,
          "ref": pickerRef,
          "onChange": onChange,
          "onOpenChange": onOpenChange,
          "onFocus": onFocus,
          "onBlur": onBlur,
          "onPanelChange": onPanelChange,
          "onOk": onOk,
          "onCalendarChange": onCalendarChange
        }), slots);
      };
    }
  });
  return {
    TimePicker: TimePicker2,
    TimeRangePicker: TimeRangePicker2
  };
}
const {
  TimePicker,
  TimeRangePicker
} = createTimePicker(generateConfig);
const TimePicker$1 = _extends$1(TimePicker, {
  TimePicker,
  TimeRangePicker,
  install: (app) => {
    app.component(TimePicker.name, TimePicker);
    app.component(TimeRangePicker.name, TimeRangePicker);
    return app;
  }
});
const getTitleStyle = (fontSize, lineHeight, color, token2) => {
  const {
    sizeMarginHeadingVerticalEnd,
    fontWeightStrong
  } = token2;
  return {
    marginBottom: sizeMarginHeadingVerticalEnd,
    color,
    fontWeight: fontWeightStrong,
    fontSize,
    lineHeight
  };
};
const getTitleStyles = (token2) => {
  const headings = [1, 2, 3, 4, 5];
  const styles = {};
  headings.forEach((headingLevel) => {
    styles[`
      h${headingLevel}&,
      div&-h${headingLevel},
      div&-h${headingLevel} > textarea,
      h${headingLevel}
    `] = getTitleStyle(token2[`fontSizeHeading${headingLevel}`], token2[`lineHeightHeading${headingLevel}`], token2.colorTextHeading, token2);
  });
  return styles;
};
const getLinkStyles = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    "a&, a": _extends$1(_extends$1({}, operationUnit(token2)), {
      textDecoration: token2.linkDecoration,
      "&:active, &:hover": {
        textDecoration: token2.linkHoverDecoration
      },
      [`&[disabled], &${componentCls}-disabled`]: {
        color: token2.colorTextDisabled,
        cursor: "not-allowed",
        "&:active, &:hover": {
          color: token2.colorTextDisabled
        },
        "&:active": {
          pointerEvents: "none"
        }
      }
    })
  };
};
const getResetStyles = () => ({
  code: {
    margin: "0 0.2em",
    paddingInline: "0.4em",
    paddingBlock: "0.2em 0.1em",
    fontSize: "85%",
    background: "rgba(150, 150, 150, 0.1)",
    border: "1px solid rgba(100, 100, 100, 0.2)",
    borderRadius: 3
  },
  kbd: {
    margin: "0 0.2em",
    paddingInline: "0.4em",
    paddingBlock: "0.15em 0.1em",
    fontSize: "90%",
    background: "rgba(150, 150, 150, 0.06)",
    border: "1px solid rgba(100, 100, 100, 0.2)",
    borderBottomWidth: 2,
    borderRadius: 3
  },
  mark: {
    padding: 0,
    // FIXME hardcode in v4
    backgroundColor: gold[2]
  },
  "u, ins": {
    textDecoration: "underline",
    textDecorationSkipInk: "auto"
  },
  "s, del": {
    textDecoration: "line-through"
  },
  strong: {
    fontWeight: 600
  },
  // list
  "ul, ol": {
    marginInline: 0,
    marginBlock: "0 1em",
    padding: 0,
    li: {
      marginInline: "20px 0",
      marginBlock: 0,
      paddingInline: "4px 0",
      paddingBlock: 0
    }
  },
  ul: {
    listStyleType: "circle",
    ul: {
      listStyleType: "disc"
    }
  },
  ol: {
    listStyleType: "decimal"
  },
  // pre & block
  "pre, blockquote": {
    margin: "1em 0"
  },
  pre: {
    padding: "0.4em 0.6em",
    whiteSpace: "pre-wrap",
    wordWrap: "break-word",
    background: "rgba(150, 150, 150, 0.1)",
    border: "1px solid rgba(100, 100, 100, 0.2)",
    borderRadius: 3,
    // Compatible for marked
    code: {
      display: "inline",
      margin: 0,
      padding: 0,
      fontSize: "inherit",
      fontFamily: "inherit",
      background: "transparent",
      border: 0
    }
  },
  blockquote: {
    paddingInline: "0.6em 0",
    paddingBlock: 0,
    borderInlineStart: "4px solid rgba(100, 100, 100, 0.2)",
    opacity: 0.85
  }
});
const getEditableStyles = (token2) => {
  const {
    componentCls
  } = token2;
  const inputToken = initInputToken(token2);
  const inputShift = inputToken.inputPaddingVertical + 1;
  return {
    "&-edit-content": {
      position: "relative",
      "div&": {
        insetInlineStart: -token2.paddingSM,
        marginTop: -inputShift,
        marginBottom: `calc(1em - ${inputShift}px)`
      },
      [`${componentCls}-edit-content-confirm`]: {
        position: "absolute",
        insetInlineEnd: token2.marginXS + 2,
        insetBlockEnd: token2.marginXS,
        color: token2.colorTextDescription,
        // default style
        fontWeight: "normal",
        fontSize: token2.fontSize,
        fontStyle: "normal",
        pointerEvents: "none"
      },
      textarea: {
        margin: "0!important",
        // Fix Editable Textarea flash in Firefox
        MozTransition: "none",
        height: "1em"
      }
    }
  };
};
const getCopiableStyles = (token2) => ({
  "&-copy-success": {
    [`
    &,
    &:hover,
    &:focus`]: {
      color: token2.colorSuccess
    }
  }
});
const getEllipsisStyles = () => ({
  [`
  a&-ellipsis,
  span&-ellipsis
  `]: {
    display: "inline-block",
    maxWidth: "100%"
  },
  "&-single-line": {
    whiteSpace: "nowrap"
  },
  "&-ellipsis-single-line": {
    overflow: "hidden",
    textOverflow: "ellipsis",
    // https://blog.csdn.net/iefreer/article/details/50421025
    "a&, span&": {
      verticalAlign: "bottom"
    }
  },
  "&-ellipsis-multiple-line": {
    display: "-webkit-box",
    overflow: "hidden",
    WebkitLineClamp: 3,
    WebkitBoxOrient: "vertical"
  }
});
const genTypographyStyle = (token2) => {
  const {
    componentCls,
    sizeMarginHeadingVerticalStart
  } = token2;
  return {
    [componentCls]: _extends$1(_extends$1(_extends$1(_extends$1(_extends$1(_extends$1(_extends$1(_extends$1(_extends$1({
      color: token2.colorText,
      wordBreak: "break-word",
      lineHeight: token2.lineHeight,
      [`&${componentCls}-secondary`]: {
        color: token2.colorTextDescription
      },
      [`&${componentCls}-success`]: {
        color: token2.colorSuccess
      },
      [`&${componentCls}-warning`]: {
        color: token2.colorWarning
      },
      [`&${componentCls}-danger`]: {
        color: token2.colorError,
        "a&:active, a&:focus": {
          color: token2.colorErrorActive
        },
        "a&:hover": {
          color: token2.colorErrorHover
        }
      },
      [`&${componentCls}-disabled`]: {
        color: token2.colorTextDisabled,
        cursor: "not-allowed",
        userSelect: "none"
      },
      [`
        div&,
        p
      `]: {
        marginBottom: "1em"
      }
    }, getTitleStyles(token2)), {
      [`
      & + h1${componentCls},
      & + h2${componentCls},
      & + h3${componentCls},
      & + h4${componentCls},
      & + h5${componentCls}
      `]: {
        marginTop: sizeMarginHeadingVerticalStart
      },
      [`
      div,
      ul,
      li,
      p,
      h1,
      h2,
      h3,
      h4,
      h5`]: {
        [`
        + h1,
        + h2,
        + h3,
        + h4,
        + h5
        `]: {
          marginTop: sizeMarginHeadingVerticalStart
        }
      }
    }), getResetStyles()), getLinkStyles(token2)), {
      // Operation
      [`
        ${componentCls}-expand,
        ${componentCls}-edit,
        ${componentCls}-copy
      `]: _extends$1(_extends$1({}, operationUnit(token2)), {
        marginInlineStart: token2.marginXXS
      })
    }), getEditableStyles(token2)), getCopiableStyles(token2)), getEllipsisStyles()), {
      "&-rtl": {
        direction: "rtl"
      }
    })
  };
};
const useStyle$4 = genComponentStyleHook("Typography", (token2) => [genTypographyStyle(token2)], {
  sizeMarginHeadingVerticalStart: "1.2em",
  sizeMarginHeadingVerticalEnd: "0.5em"
});
const editableProps = () => ({
  prefixCls: String,
  value: String,
  maxlength: Number,
  autoSize: {
    type: [Boolean, Object]
  },
  onSave: Function,
  onCancel: Function,
  onEnd: Function,
  onChange: Function,
  originContent: String,
  direction: String,
  component: String
});
const Editable = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Editable",
  inheritAttrs: false,
  props: editableProps(),
  // emits: ['save', 'cancel', 'end', 'change'],
  setup(props2, _ref) {
    let {
      emit,
      slots,
      attrs
    } = _ref;
    const {
      prefixCls
    } = toRefs(props2);
    const state = reactive({
      current: props2.value || "",
      lastKeyCode: void 0,
      inComposition: false,
      cancelFlag: false
    });
    watch(() => props2.value, (current) => {
      state.current = current;
    });
    const textArea = ref();
    onMounted(() => {
      var _a2;
      if (textArea.value) {
        const resizableTextArea = (_a2 = textArea.value) === null || _a2 === void 0 ? void 0 : _a2.resizableTextArea;
        const innerTextArea = resizableTextArea === null || resizableTextArea === void 0 ? void 0 : resizableTextArea.textArea;
        innerTextArea.focus();
        const {
          length: length2
        } = innerTextArea.value;
        innerTextArea.setSelectionRange(length2, length2);
      }
    });
    function saveTextAreaRef(node2) {
      textArea.value = node2;
    }
    function onChange(_ref2) {
      let {
        target: {
          value
        }
      } = _ref2;
      state.current = value.replace(/[\r\n]/g, "");
      emit("change", state.current);
    }
    function onCompositionStart() {
      state.inComposition = true;
    }
    function onCompositionEnd() {
      state.inComposition = false;
    }
    function onKeyDown2(e2) {
      const {
        keyCode
      } = e2;
      if (keyCode === KeyCode.ENTER) {
        e2.preventDefault();
      }
      if (state.inComposition) return;
      state.lastKeyCode = keyCode;
    }
    function onKeyUp(e2) {
      const {
        keyCode,
        ctrlKey,
        altKey,
        metaKey,
        shiftKey
      } = e2;
      if (state.lastKeyCode === keyCode && !state.inComposition && !ctrlKey && !altKey && !metaKey && !shiftKey) {
        if (keyCode === KeyCode.ENTER) {
          confirmChange();
          emit("end");
        } else if (keyCode === KeyCode.ESC) {
          state.current = props2.originContent;
          emit("cancel");
        }
      }
    }
    function onBlur() {
      confirmChange();
    }
    function confirmChange() {
      emit("save", state.current.trim());
    }
    const [wrapSSR, hashId] = useStyle$4(prefixCls);
    return () => {
      const textAreaClassName = classNames({
        [`${prefixCls.value}`]: true,
        [`${prefixCls.value}-edit-content`]: true,
        [`${prefixCls.value}-rtl`]: props2.direction === "rtl",
        [props2.component ? `${prefixCls.value}-${props2.component}` : ""]: true
      }, attrs.class, hashId.value);
      return wrapSSR(createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "class": textAreaClassName
      }), [createVNode(Textarea, {
        "ref": saveTextAreaRef,
        "maxlength": props2.maxlength,
        "value": state.current,
        "onChange": onChange,
        "onKeydown": onKeyDown2,
        "onKeyup": onKeyUp,
        "onCompositionstart": onCompositionStart,
        "onCompositionend": onCompositionEnd,
        "onBlur": onBlur,
        "rows": 1,
        "autoSize": props2.autoSize === void 0 || props2.autoSize
      }, null), slots.enterIcon ? slots.enterIcon({
        className: `${props2.prefixCls}-edit-content-confirm`
      }) : createVNode(EnterOutlined, {
        "class": `${props2.prefixCls}-edit-content-confirm`
      }, null)]));
    };
  }
});
const TEXT_NODE = 3;
const COMMENT_NODE = 8;
let ellipsisContainer;
const wrapperStyle = {
  padding: 0,
  margin: 0,
  display: "inline",
  lineHeight: "inherit"
};
function resetDomStyles(target, origin) {
  target.setAttribute("aria-hidden", "true");
  const originStyle = window.getComputedStyle(origin);
  const originCSS = styleToString(originStyle);
  target.setAttribute("style", originCSS);
  target.style.position = "fixed";
  target.style.left = "0";
  target.style.height = "auto";
  target.style.minHeight = "auto";
  target.style.maxHeight = "auto";
  target.style.paddingTop = "0";
  target.style.paddingBottom = "0";
  target.style.borderTopWidth = "0";
  target.style.borderBottomWidth = "0";
  target.style.top = "-999999px";
  target.style.zIndex = "-1000";
  target.style.textOverflow = "clip";
  target.style.whiteSpace = "normal";
  target.style.webkitLineClamp = "none";
}
function getRealLineHeight(originElement) {
  const heightContainer = document.createElement("div");
  resetDomStyles(heightContainer, originElement);
  heightContainer.appendChild(document.createTextNode("text"));
  document.body.appendChild(heightContainer);
  const realHeight = heightContainer.getBoundingClientRect().height;
  document.body.removeChild(heightContainer);
  return realHeight;
}
const measure = (originElement, option, content, fixedContent, ellipsisStr) => {
  if (!ellipsisContainer) {
    ellipsisContainer = document.createElement("div");
    ellipsisContainer.setAttribute("aria-hidden", "true");
    document.body.appendChild(ellipsisContainer);
  }
  const {
    rows,
    suffix = ""
  } = option;
  const lineHeight = getRealLineHeight(originElement);
  const maxHeight = Math.round(lineHeight * rows * 100) / 100;
  resetDomStyles(ellipsisContainer, originElement);
  const vm = createApp({
    render() {
      return createVNode("div", {
        "style": wrapperStyle
      }, [createVNode("span", {
        "style": wrapperStyle
      }, [content, suffix]), createVNode("span", {
        "style": wrapperStyle
      }, [fixedContent])]);
    }
  });
  vm.mount(ellipsisContainer);
  function inRange() {
    const currentHeight = Math.round(ellipsisContainer.getBoundingClientRect().height * 100) / 100;
    return currentHeight - 0.1 <= maxHeight;
  }
  if (inRange()) {
    vm.unmount();
    return {
      content,
      text: ellipsisContainer.innerHTML,
      ellipsis: false
    };
  }
  const childNodes = Array.prototype.slice.apply(ellipsisContainer.childNodes[0].childNodes[0].cloneNode(true).childNodes).filter((_ref) => {
    let {
      nodeType,
      data
    } = _ref;
    return nodeType !== COMMENT_NODE && data !== "";
  });
  const fixedNodes = Array.prototype.slice.apply(ellipsisContainer.childNodes[0].childNodes[1].cloneNode(true).childNodes);
  vm.unmount();
  const ellipsisChildren = [];
  ellipsisContainer.innerHTML = "";
  const ellipsisContentHolder = document.createElement("span");
  ellipsisContainer.appendChild(ellipsisContentHolder);
  const ellipsisTextNode = document.createTextNode(ellipsisStr + suffix);
  ellipsisContentHolder.appendChild(ellipsisTextNode);
  fixedNodes.forEach((childNode) => {
    ellipsisContainer.appendChild(childNode);
  });
  function appendChildNode(node2) {
    ellipsisContentHolder.insertBefore(node2, ellipsisTextNode);
  }
  function measureText(textNode, fullText) {
    let startLoc = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    let endLoc = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : fullText.length;
    let lastSuccessLoc = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
    const midLoc = Math.floor((startLoc + endLoc) / 2);
    const currentText = fullText.slice(0, midLoc);
    textNode.textContent = currentText;
    if (startLoc >= endLoc - 1) {
      for (let step = endLoc; step >= startLoc; step -= 1) {
        const currentStepText = fullText.slice(0, step);
        textNode.textContent = currentStepText;
        if (inRange() || !currentStepText) {
          return step === fullText.length ? {
            finished: false,
            vNode: fullText
          } : {
            finished: true,
            vNode: currentStepText
          };
        }
      }
    }
    if (inRange()) {
      return measureText(textNode, fullText, midLoc, endLoc, midLoc);
    }
    return measureText(textNode, fullText, startLoc, midLoc, lastSuccessLoc);
  }
  function measureNode(childNode) {
    const type4 = childNode.nodeType;
    if (type4 === TEXT_NODE) {
      const fullText = childNode.textContent || "";
      const textNode = document.createTextNode(fullText);
      appendChildNode(textNode);
      return measureText(textNode, fullText);
    }
    return {
      finished: false,
      vNode: null
    };
  }
  childNodes.some((childNode) => {
    const {
      finished,
      vNode
    } = measureNode(childNode);
    if (vNode) {
      ellipsisChildren.push(vNode);
    }
    return finished;
  });
  return {
    content: ellipsisChildren,
    text: ellipsisContainer.innerHTML,
    ellipsis: true
  };
};
var __rest$7 = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const typographyProps = () => ({
  prefixCls: String,
  direction: String,
  // Form Internal use
  component: String
});
const Typography = defineComponent({
  name: "ATypography",
  inheritAttrs: false,
  props: typographyProps(),
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const {
      prefixCls,
      direction
    } = useConfigInject("typography", props2);
    const [wrapSSR, hashId] = useStyle$4(prefixCls);
    return () => {
      var _a2;
      const _b = _extends$1(_extends$1({}, props2), attrs), {
        prefixCls: _prefixCls,
        direction: _direction,
        component: Component = "article"
      } = _b, restProps = __rest$7(_b, ["prefixCls", "direction", "component"]);
      return wrapSSR(createVNode(Component, _objectSpread2$1(_objectSpread2$1({}, restProps), {}, {
        "class": classNames(prefixCls.value, {
          [`${prefixCls.value}-rtl`]: direction.value === "rtl"
        }, attrs.class, hashId.value)
      }), {
        default: () => [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]
      }));
    };
  }
});
const deselectCurrent = () => {
  const selection = document.getSelection();
  if (!selection.rangeCount) {
    return function() {
    };
  }
  let active = document.activeElement;
  const ranges = [];
  for (let i2 = 0; i2 < selection.rangeCount; i2++) {
    ranges.push(selection.getRangeAt(i2));
  }
  switch (active.tagName.toUpperCase()) {
    case "INPUT":
    case "TEXTAREA":
      active.blur();
      break;
    default:
      active = null;
      break;
  }
  selection.removeAllRanges();
  return function() {
    selection.type === "Caret" && selection.removeAllRanges();
    if (!selection.rangeCount) {
      ranges.forEach(function(range3) {
        selection.addRange(range3);
      });
    }
    active && active.focus();
  };
};
const clipboardToIE11Formatting = {
  "text/plain": "Text",
  "text/html": "Url",
  default: "Text"
};
const defaultMessage = "Copy to clipboard: #{key}, Enter";
function format(message) {
  const copyKey = (/mac os x/i.test(navigator.userAgent) ? "⌘" : "Ctrl") + "+C";
  return message.replace(/#{\s*key\s*}/g, copyKey);
}
function copy(text, options) {
  let message, reselectPrevious, range3, selection, mark, success = false;
  if (!options) {
    options = {};
  }
  const debug = options.debug || false;
  try {
    reselectPrevious = deselectCurrent();
    range3 = document.createRange();
    selection = document.getSelection();
    mark = document.createElement("span");
    mark.textContent = text;
    mark.style.all = "unset";
    mark.style.position = "fixed";
    mark.style.top = 0;
    mark.style.clip = "rect(0, 0, 0, 0)";
    mark.style.whiteSpace = "pre";
    mark.style.webkitUserSelect = "text";
    mark.style.MozUserSelect = "text";
    mark.style.msUserSelect = "text";
    mark.style.userSelect = "text";
    mark.addEventListener("copy", function(e2) {
      e2.stopPropagation();
      if (options.format) {
        e2.preventDefault();
        if (typeof e2.clipboardData === "undefined") {
          debug && console.warn("unable to use e.clipboardData");
          debug && console.warn("trying IE specific stuff");
          window.clipboardData.clearData();
          const format2 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
          window.clipboardData.setData(format2, text);
        } else {
          e2.clipboardData.clearData();
          e2.clipboardData.setData(options.format, text);
        }
      }
      if (options.onCopy) {
        e2.preventDefault();
        options.onCopy(e2.clipboardData);
      }
    });
    document.body.appendChild(mark);
    range3.selectNodeContents(mark);
    selection.addRange(range3);
    const successful = document.execCommand("copy");
    if (!successful) {
      throw new Error("copy command was unsuccessful");
    }
    success = true;
  } catch (err) {
    debug && console.error("unable to copy using execCommand: ", err);
    debug && console.warn("trying IE specific stuff");
    try {
      window.clipboardData.setData(options.format || "text", text);
      options.onCopy && options.onCopy(window.clipboardData);
      success = true;
    } catch (err2) {
      debug && console.error("unable to copy using clipboardData: ", err2);
      debug && console.error("falling back to prompt");
      message = format("message" in options ? options.message : defaultMessage);
      window.prompt(message, text);
    }
  } finally {
    if (selection) {
      if (typeof selection.removeRange == "function") {
        selection.removeRange(range3);
      } else {
        selection.removeAllRanges();
      }
    }
    if (mark) {
      document.body.removeChild(mark);
    }
    reselectPrevious();
  }
  return success;
}
var __rest$6 = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const isLineClampSupport = isStyleSupport("webkitLineClamp");
const isTextOverflowSupport = isStyleSupport("textOverflow");
const ELLIPSIS_STR = "...";
const baseProps = () => ({
  editable: {
    type: [Boolean, Object],
    default: void 0
  },
  copyable: {
    type: [Boolean, Object],
    default: void 0
  },
  prefixCls: String,
  component: String,
  type: String,
  disabled: {
    type: Boolean,
    default: void 0
  },
  ellipsis: {
    type: [Boolean, Object],
    default: void 0
  },
  code: {
    type: Boolean,
    default: void 0
  },
  mark: {
    type: Boolean,
    default: void 0
  },
  underline: {
    type: Boolean,
    default: void 0
  },
  delete: {
    type: Boolean,
    default: void 0
  },
  strong: {
    type: Boolean,
    default: void 0
  },
  keyboard: {
    type: Boolean,
    default: void 0
  },
  content: String,
  "onUpdate:content": Function
});
const Base = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "TypographyBase",
  inheritAttrs: false,
  props: baseProps(),
  // emits: ['update:content'],
  setup(props2, _ref) {
    let {
      slots,
      attrs,
      emit
    } = _ref;
    const {
      prefixCls,
      direction
    } = useConfigInject("typography", props2);
    const state = reactive({
      copied: false,
      ellipsisText: "",
      ellipsisContent: null,
      isEllipsis: false,
      expanded: false,
      clientRendered: false,
      //locale
      expandStr: "",
      copyStr: "",
      copiedStr: "",
      editStr: "",
      copyId: void 0,
      rafId: void 0,
      prevProps: void 0,
      originContent: ""
    });
    const contentRef = ref();
    const editIcon = ref();
    const ellipsis = computed(() => {
      const ellipsis2 = props2.ellipsis;
      if (!ellipsis2) return {};
      return _extends$1({
        rows: 1,
        expandable: false
      }, typeof ellipsis2 === "object" ? ellipsis2 : null);
    });
    onMounted(() => {
      state.clientRendered = true;
      syncEllipsis();
    });
    onBeforeUnmount(() => {
      clearTimeout(state.copyId);
      wrapperRaf.cancel(state.rafId);
    });
    watch([() => ellipsis.value.rows, () => props2.content], () => {
      nextTick(() => {
        resizeOnNextFrame();
      });
    }, {
      flush: "post",
      deep: true
    });
    watchEffect(() => {
      if (props2.content === void 0) {
        warning$1(!props2.editable);
        warning$1(!props2.ellipsis);
      }
    });
    function getChildrenText() {
      var _a2;
      return props2.ellipsis || props2.editable ? props2.content : (_a2 = findDOMNode(contentRef.value)) === null || _a2 === void 0 ? void 0 : _a2.innerText;
    }
    function onExpandClick(e2) {
      const {
        onExpand
      } = ellipsis.value;
      state.expanded = true;
      onExpand === null || onExpand === void 0 ? void 0 : onExpand(e2);
    }
    function onEditClick(e2) {
      e2.preventDefault();
      state.originContent = props2.content;
      triggerEdit(true);
    }
    function onEditChange(value) {
      onContentChange(value);
      triggerEdit(false);
    }
    function onContentChange(value) {
      const {
        onChange
      } = editable.value;
      if (value !== props2.content) {
        emit("update:content", value);
        onChange === null || onChange === void 0 ? void 0 : onChange(value);
      }
    }
    function onEditCancel() {
      var _a2, _b;
      (_b = (_a2 = editable.value).onCancel) === null || _b === void 0 ? void 0 : _b.call(_a2);
      triggerEdit(false);
    }
    function onCopyClick(e2) {
      e2.preventDefault();
      e2.stopPropagation();
      const {
        copyable
      } = props2;
      const copyConfig = _extends$1({}, typeof copyable === "object" ? copyable : null);
      if (copyConfig.text === void 0) {
        copyConfig.text = getChildrenText();
      }
      copy(copyConfig.text || "");
      state.copied = true;
      nextTick(() => {
        if (copyConfig.onCopy) {
          copyConfig.onCopy(e2);
        }
        state.copyId = setTimeout(() => {
          state.copied = false;
        }, 3e3);
      });
    }
    const editable = computed(() => {
      const editable2 = props2.editable;
      if (!editable2) return {
        editing: false
      };
      return _extends$1({}, typeof editable2 === "object" ? editable2 : null);
    });
    const [editing, setEditing] = useMergedState(false, {
      value: computed(() => {
        return editable.value.editing;
      })
    });
    function triggerEdit(edit) {
      const {
        onStart
      } = editable.value;
      if (edit && onStart) {
        onStart();
      }
      setEditing(edit);
    }
    watch(editing, (val) => {
      var _a2;
      if (!val) {
        (_a2 = editIcon.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
      }
    }, {
      flush: "post"
    });
    function resizeOnNextFrame(sizeInfo) {
      if (sizeInfo) {
        const {
          width,
          height
        } = sizeInfo;
        if (!width || !height) return;
      }
      wrapperRaf.cancel(state.rafId);
      state.rafId = wrapperRaf(() => {
        syncEllipsis();
      });
    }
    const canUseCSSEllipsis = computed(() => {
      const {
        rows,
        expandable,
        suffix,
        onEllipsis,
        tooltip
      } = ellipsis.value;
      if (suffix || tooltip) return false;
      if (props2.editable || props2.copyable || expandable || onEllipsis) {
        return false;
      }
      if (rows === 1) {
        return isTextOverflowSupport;
      }
      return isLineClampSupport;
    });
    const syncEllipsis = () => {
      const {
        ellipsisText,
        isEllipsis
      } = state;
      const {
        rows,
        suffix,
        onEllipsis
      } = ellipsis.value;
      if (!rows || rows < 0 || !findDOMNode(contentRef.value) || state.expanded || props2.content === void 0) return;
      if (canUseCSSEllipsis.value) return;
      const {
        content,
        text,
        ellipsis: ell
      } = measure(findDOMNode(contentRef.value), {
        rows,
        suffix
      }, props2.content, renderOperations(true), ELLIPSIS_STR);
      if (ellipsisText !== text || state.isEllipsis !== ell) {
        state.ellipsisText = text;
        state.ellipsisContent = content;
        state.isEllipsis = ell;
        if (isEllipsis !== ell && onEllipsis) {
          onEllipsis(ell);
        }
      }
    };
    function wrapperDecorations(_ref2, content) {
      let {
        mark,
        code,
        underline,
        delete: del,
        strong,
        keyboard
      } = _ref2;
      let currentContent = content;
      function wrap(needed, Tag2) {
        if (!needed) return;
        const _currentContent = /* @__PURE__ */ function() {
          return currentContent;
        }();
        currentContent = createVNode(Tag2, null, {
          default: () => [_currentContent]
        });
      }
      wrap(strong, "strong");
      wrap(underline, "u");
      wrap(del, "del");
      wrap(code, "code");
      wrap(mark, "mark");
      wrap(keyboard, "kbd");
      return currentContent;
    }
    function renderExpand(forceRender) {
      const {
        expandable,
        symbol
      } = ellipsis.value;
      if (!expandable) return null;
      if (!forceRender && (state.expanded || !state.isEllipsis)) return null;
      const expandContent = (slots.ellipsisSymbol ? slots.ellipsisSymbol() : symbol) || state.expandStr;
      return createVNode("a", {
        "key": "expand",
        "class": `${prefixCls.value}-expand`,
        "onClick": onExpandClick,
        "aria-label": state.expandStr
      }, [expandContent]);
    }
    function renderEdit() {
      if (!props2.editable) return;
      const {
        tooltip,
        triggerType = ["icon"]
      } = props2.editable;
      const icon = slots.editableIcon ? slots.editableIcon() : createVNode(EditOutlined, {
        "role": "button"
      }, null);
      const title = slots.editableTooltip ? slots.editableTooltip() : state.editStr;
      const ariaLabel = typeof title === "string" ? title : "";
      return triggerType.indexOf("icon") !== -1 ? createVNode(Tooltip, {
        "key": "edit",
        "title": tooltip === false ? "" : title
      }, {
        default: () => [createVNode(TransButton, {
          "ref": editIcon,
          "class": `${prefixCls.value}-edit`,
          "onClick": onEditClick,
          "aria-label": ariaLabel
        }, {
          default: () => [icon]
        })]
      }) : null;
    }
    function renderCopy() {
      if (!props2.copyable) return;
      const {
        tooltip
      } = props2.copyable;
      const defaultTitle2 = state.copied ? state.copiedStr : state.copyStr;
      const title = slots.copyableTooltip ? slots.copyableTooltip({
        copied: state.copied
      }) : defaultTitle2;
      const ariaLabel = typeof title === "string" ? title : "";
      const defaultIcon = state.copied ? createVNode(CheckOutlined, null, null) : createVNode(CopyOutlined, null, null);
      const icon = slots.copyableIcon ? slots.copyableIcon({
        copied: !!state.copied
      }) : defaultIcon;
      return createVNode(Tooltip, {
        "key": "copy",
        "title": tooltip === false ? "" : title
      }, {
        default: () => [createVNode(TransButton, {
          "class": [`${prefixCls.value}-copy`, {
            [`${prefixCls.value}-copy-success`]: state.copied
          }],
          "onClick": onCopyClick,
          "aria-label": ariaLabel
        }, {
          default: () => [icon]
        })]
      });
    }
    function renderEditInput() {
      const {
        class: className,
        style
      } = attrs;
      const {
        maxlength,
        autoSize,
        onEnd
      } = editable.value;
      return createVNode(Editable, {
        "class": className,
        "style": style,
        "prefixCls": prefixCls.value,
        "value": props2.content,
        "originContent": state.originContent,
        "maxlength": maxlength,
        "autoSize": autoSize,
        "onSave": onEditChange,
        "onChange": onContentChange,
        "onCancel": onEditCancel,
        "onEnd": onEnd,
        "direction": direction.value,
        "component": props2.component
      }, {
        enterIcon: slots.editableEnterIcon
      });
    }
    function renderOperations(forceRenderExpanded) {
      return [renderExpand(forceRenderExpanded), renderEdit(), renderCopy()].filter((node2) => node2);
    }
    return () => {
      var _a2;
      const {
        triggerType = ["icon"]
      } = editable.value;
      const children = props2.ellipsis || props2.editable ? props2.content !== void 0 ? props2.content : (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots) : slots.default ? slots.default() : props2.content;
      if (editing.value) {
        return renderEditInput();
      }
      return createVNode(LocaleReceiver, {
        "componentName": "Text",
        "children": (locale2) => {
          const _a3 = _extends$1(_extends$1({}, props2), attrs), {
            type: type4,
            disabled,
            content,
            class: className,
            style
          } = _a3, restProps = __rest$6(_a3, ["type", "disabled", "content", "class", "style"]);
          const {
            rows,
            suffix,
            tooltip
          } = ellipsis.value;
          const {
            edit,
            copy: copyStr,
            copied,
            expand
          } = locale2;
          state.editStr = edit;
          state.copyStr = copyStr;
          state.copiedStr = copied;
          state.expandStr = expand;
          const textProps2 = omit$1(restProps, ["prefixCls", "editable", "copyable", "ellipsis", "mark", "code", "delete", "underline", "strong", "keyboard", "onUpdate:content"]);
          const cssEllipsis = canUseCSSEllipsis.value;
          const cssTextOverflow = rows === 1 && cssEllipsis;
          const cssLineClamp = rows && rows > 1 && cssEllipsis;
          let textNode = children;
          let ariaLabel;
          if (rows && state.isEllipsis && !state.expanded && !cssEllipsis) {
            const {
              title: title2
            } = restProps;
            let restContent = title2 || "";
            if (!title2 && (typeof children === "string" || typeof children === "number")) {
              restContent = String(children);
            }
            restContent = restContent === null || restContent === void 0 ? void 0 : restContent.slice(String(state.ellipsisContent || "").length);
            textNode = createVNode(Fragment, null, [toRaw(state.ellipsisContent), createVNode("span", {
              "title": restContent,
              "aria-hidden": "true"
            }, [ELLIPSIS_STR]), suffix]);
          } else {
            textNode = createVNode(Fragment, null, [children, suffix]);
          }
          textNode = wrapperDecorations(props2, textNode);
          const showTooltip = tooltip && rows && state.isEllipsis && !state.expanded && !cssEllipsis;
          const title = slots.ellipsisTooltip ? slots.ellipsisTooltip() : tooltip;
          return createVNode(ResizeObserver$1, {
            "onResize": resizeOnNextFrame,
            "disabled": !rows
          }, {
            default: () => [createVNode(Typography, _objectSpread2$1({
              "ref": contentRef,
              "class": [{
                [`${prefixCls.value}-${type4}`]: type4,
                [`${prefixCls.value}-disabled`]: disabled,
                [`${prefixCls.value}-ellipsis`]: rows,
                [`${prefixCls.value}-single-line`]: rows === 1 && !state.isEllipsis,
                [`${prefixCls.value}-ellipsis-single-line`]: cssTextOverflow,
                [`${prefixCls.value}-ellipsis-multiple-line`]: cssLineClamp
              }, className],
              "style": _extends$1(_extends$1({}, style), {
                WebkitLineClamp: cssLineClamp ? rows : void 0
              }),
              "aria-label": ariaLabel,
              "direction": direction.value,
              "onClick": triggerType.indexOf("text") !== -1 ? onEditClick : () => {
              }
            }, textProps2), {
              default: () => [showTooltip ? createVNode(Tooltip, {
                "title": tooltip === true ? children : title
              }, {
                default: () => [createVNode("span", null, [textNode])]
              }) : textNode, renderOperations()]
            })]
          });
        }
      }, null);
    };
  }
});
var __rest$5 = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const linkProps = () => omit$1(_extends$1(_extends$1({}, baseProps()), {
  ellipsis: {
    type: Boolean,
    default: void 0
  }
}), ["component"]);
const Link = (props2, _ref) => {
  let {
    slots,
    attrs
  } = _ref;
  const _a2 = _extends$1(_extends$1({}, props2), attrs), {
    ellipsis,
    rel
  } = _a2, restProps = __rest$5(_a2, ["ellipsis", "rel"]);
  const mergedProps = _extends$1(_extends$1({}, restProps), {
    rel: rel === void 0 && restProps.target === "_blank" ? "noopener noreferrer" : rel,
    ellipsis: !!ellipsis,
    component: "a"
  });
  delete mergedProps.navigate;
  return createVNode(Base, mergedProps, slots);
};
Link.displayName = "ATypographyLink";
Link.inheritAttrs = false;
Link.props = linkProps();
const paragraphProps = () => omit$1(baseProps(), ["component"]);
const Paragraph = (props2, _ref) => {
  let {
    slots,
    attrs
  } = _ref;
  const paragraphProps2 = _extends$1(_extends$1(_extends$1({}, props2), {
    component: "div"
  }), attrs);
  return createVNode(Base, paragraphProps2, slots);
};
Paragraph.displayName = "ATypographyParagraph";
Paragraph.inheritAttrs = false;
Paragraph.props = paragraphProps();
const textProps = () => _extends$1(_extends$1({}, omit$1(baseProps(), ["component"])), {
  ellipsis: {
    type: [Boolean, Object],
    default: void 0
  }
});
const Text = (props2, _ref) => {
  let {
    slots,
    attrs
  } = _ref;
  const {
    ellipsis
  } = props2;
  const textProps2 = _extends$1(_extends$1(_extends$1({}, props2), {
    ellipsis: ellipsis && typeof ellipsis === "object" ? omit$1(ellipsis, ["expandable", "rows"]) : ellipsis,
    component: "span"
  }), attrs);
  return createVNode(Base, textProps2, slots);
};
Text.displayName = "ATypographyText";
Text.inheritAttrs = false;
Text.props = textProps();
var __rest$4 = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const TITLE_ELE_LIST = tupleNum(1, 2, 3, 4, 5);
const titleProps = () => _extends$1(_extends$1({}, omit$1(baseProps(), ["component", "strong"])), {
  level: Number
});
const Title = (props2, _ref) => {
  let {
    slots,
    attrs
  } = _ref;
  const {
    level = 1
  } = props2, restProps = __rest$4(props2, ["level"]);
  let component;
  if (TITLE_ELE_LIST.includes(level)) {
    component = `h${level}`;
  } else {
    component = "h1";
  }
  const titleProps2 = _extends$1(_extends$1(_extends$1({}, restProps), {
    component
  }), attrs);
  return createVNode(Base, titleProps2, slots);
};
Title.displayName = "ATypographyTitle";
Title.inheritAttrs = false;
Title.props = titleProps();
Typography.Text = Text;
Typography.Title = Title;
Typography.Paragraph = Paragraph;
Typography.Link = Link;
Typography.Base = Base;
Typography.install = function(app) {
  app.component(Typography.name, Typography);
  app.component(Typography.Text.displayName, Text);
  app.component(Typography.Title.displayName, Title);
  app.component(Typography.Paragraph.displayName, Paragraph);
  app.component(Typography.Link.displayName, Link);
  return app;
};
function getError(option, xhr) {
  const msg = `cannot ${option.method} ${option.action} ${xhr.status}'`;
  const err = new Error(msg);
  err.status = xhr.status;
  err.method = option.method;
  err.url = option.action;
  return err;
}
function getBody(xhr) {
  const text = xhr.responseText || xhr.response;
  if (!text) {
    return text;
  }
  try {
    return JSON.parse(text);
  } catch (e2) {
    return text;
  }
}
function upload(option) {
  const xhr = new XMLHttpRequest();
  if (option.onProgress && xhr.upload) {
    xhr.upload.onprogress = function progress(e2) {
      if (e2.total > 0) {
        e2.percent = e2.loaded / e2.total * 100;
      }
      option.onProgress(e2);
    };
  }
  const formData = new FormData();
  if (option.data) {
    Object.keys(option.data).forEach((key2) => {
      const value = option.data[key2];
      if (Array.isArray(value)) {
        value.forEach((item) => {
          formData.append(`${key2}[]`, item);
        });
        return;
      }
      formData.append(key2, value);
    });
  }
  if (option.file instanceof Blob) {
    formData.append(option.filename, option.file, option.file.name);
  } else {
    formData.append(option.filename, option.file);
  }
  xhr.onerror = function error(e2) {
    option.onError(e2);
  };
  xhr.onload = function onload() {
    if (xhr.status < 200 || xhr.status >= 300) {
      return option.onError(getError(option, xhr), getBody(xhr));
    }
    return option.onSuccess(getBody(xhr), xhr);
  };
  xhr.open(option.method, option.action, true);
  if (option.withCredentials && "withCredentials" in xhr) {
    xhr.withCredentials = true;
  }
  const headers = option.headers || {};
  if (headers["X-Requested-With"] !== null) {
    xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
  }
  Object.keys(headers).forEach((h2) => {
    if (headers[h2] !== null) {
      xhr.setRequestHeader(h2, headers[h2]);
    }
  });
  xhr.send(formData);
  return {
    abort() {
      xhr.abort();
    }
  };
}
const now = +/* @__PURE__ */ new Date();
let index = 0;
function uid() {
  return `vc-upload-${now}-${++index}`;
}
const attrAccept = (file, acceptedFiles) => {
  if (file && acceptedFiles) {
    const acceptedFilesArray = Array.isArray(acceptedFiles) ? acceptedFiles : acceptedFiles.split(",");
    const fileName = file.name || "";
    const mimeType = file.type || "";
    const baseMimeType = mimeType.replace(/\/.*$/, "");
    return acceptedFilesArray.some((type4) => {
      const validType = type4.trim();
      if (/^\*(\/\*)?$/.test(type4)) {
        return true;
      }
      if (validType.charAt(0) === ".") {
        const lowerFileName = fileName.toLowerCase();
        const lowerType = validType.toLowerCase();
        let affixList = [lowerType];
        if (lowerType === ".jpg" || lowerType === ".jpeg") {
          affixList = [".jpg", ".jpeg"];
        }
        return affixList.some((affix) => lowerFileName.endsWith(affix));
      }
      if (/\/\*$/.test(validType)) {
        return baseMimeType === validType.replace(/\/.*$/, "");
      }
      if (mimeType === validType) {
        return true;
      }
      if (/^\w+$/.test(validType)) {
        return true;
      }
      return false;
    });
  }
  return true;
};
function loopFiles(item, callback) {
  const dirReader = item.createReader();
  let fileList = [];
  function sequence() {
    dirReader.readEntries((entries) => {
      const entryList = Array.prototype.slice.apply(entries);
      fileList = fileList.concat(entryList);
      const isFinished = !entryList.length;
      if (isFinished) {
        callback(fileList);
      } else {
        sequence();
      }
    });
  }
  sequence();
}
const traverseFileTree = (files, callback, isAccepted) => {
  const _traverseFileTree = (item, path2) => {
    item.path = path2 || "";
    if (item.isFile) {
      item.file((file) => {
        if (isAccepted(file)) {
          if (item.fullPath && !file.webkitRelativePath) {
            Object.defineProperties(file, {
              webkitRelativePath: {
                writable: true
              }
            });
            file.webkitRelativePath = item.fullPath.replace(/^\//, "");
            Object.defineProperties(file, {
              webkitRelativePath: {
                writable: false
              }
            });
          }
          callback([file]);
        }
      });
    } else if (item.isDirectory) {
      loopFiles(item, (entries) => {
        entries.forEach((entryItem) => {
          _traverseFileTree(entryItem, `${path2}${item.name}/`);
        });
      });
    }
  };
  files.forEach((file) => {
    _traverseFileTree(file.webkitGetAsEntry());
  });
};
const uploadProps$1 = () => {
  return {
    capture: [Boolean, String],
    multipart: {
      type: Boolean,
      default: void 0
    },
    name: String,
    disabled: {
      type: Boolean,
      default: void 0
    },
    componentTag: String,
    action: [String, Function],
    method: String,
    directory: {
      type: Boolean,
      default: void 0
    },
    data: [Object, Function],
    headers: Object,
    accept: String,
    multiple: {
      type: Boolean,
      default: void 0
    },
    onBatchStart: Function,
    onReject: Function,
    onStart: Function,
    onError: Function,
    onSuccess: Function,
    onProgress: Function,
    beforeUpload: Function,
    customRequest: Function,
    withCredentials: {
      type: Boolean,
      default: void 0
    },
    openFileDialogOnClick: {
      type: Boolean,
      default: void 0
    },
    prefixCls: String,
    id: String,
    onMouseenter: Function,
    onMouseleave: Function,
    onClick: Function
  };
};
var __awaiter$1 = function(thisArg, _arguments, P2, generator2) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator2.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator2["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator2 = generator2.apply(thisArg, _arguments || [])).next());
  });
};
var __rest$3 = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const AjaxUpload = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AjaxUploader",
  inheritAttrs: false,
  props: uploadProps$1(),
  setup(props2, _ref) {
    let {
      slots,
      attrs,
      expose
    } = _ref;
    const uid$1 = ref(uid());
    const reqs = {};
    const fileInput = ref();
    let isMounted = false;
    const processFile = (file, fileList) => __awaiter$1(this, void 0, void 0, function* () {
      const {
        beforeUpload
      } = props2;
      let transformedFile = file;
      if (beforeUpload) {
        try {
          transformedFile = yield beforeUpload(file, fileList);
        } catch (e2) {
          transformedFile = false;
        }
        if (transformedFile === false) {
          return {
            origin: file,
            parsedFile: null,
            action: null,
            data: null
          };
        }
      }
      const {
        action
      } = props2;
      let mergedAction;
      if (typeof action === "function") {
        mergedAction = yield action(file);
      } else {
        mergedAction = action;
      }
      const {
        data
      } = props2;
      let mergedData;
      if (typeof data === "function") {
        mergedData = yield data(file);
      } else {
        mergedData = data;
      }
      const parsedData = (
        // string type is from legacy `transformFile`.
        // Not sure if this will work since no related test case works with it
        (typeof transformedFile === "object" || typeof transformedFile === "string") && transformedFile ? transformedFile : file
      );
      let parsedFile;
      if (parsedData instanceof File) {
        parsedFile = parsedData;
      } else {
        parsedFile = new File([parsedData], file.name, {
          type: file.type
        });
      }
      const mergedParsedFile = parsedFile;
      mergedParsedFile.uid = file.uid;
      return {
        origin: file,
        data: mergedData,
        parsedFile: mergedParsedFile,
        action: mergedAction
      };
    });
    const post = (_ref2) => {
      let {
        data,
        origin,
        action,
        parsedFile
      } = _ref2;
      if (!isMounted) {
        return;
      }
      const {
        onStart,
        customRequest,
        name,
        headers,
        withCredentials,
        method: method4
      } = props2;
      const {
        uid: uid2
      } = origin;
      const request = customRequest || upload;
      const requestOption = {
        action,
        filename: name,
        data,
        file: parsedFile,
        headers,
        withCredentials,
        method: method4 || "post",
        onProgress: (e2) => {
          const {
            onProgress
          } = props2;
          onProgress === null || onProgress === void 0 ? void 0 : onProgress(e2, parsedFile);
        },
        onSuccess: (ret, xhr) => {
          const {
            onSuccess
          } = props2;
          onSuccess === null || onSuccess === void 0 ? void 0 : onSuccess(ret, parsedFile, xhr);
          delete reqs[uid2];
        },
        onError: (err, ret) => {
          const {
            onError
          } = props2;
          onError === null || onError === void 0 ? void 0 : onError(err, ret, parsedFile);
          delete reqs[uid2];
        }
      };
      onStart(origin);
      reqs[uid2] = request(requestOption);
    };
    const reset = () => {
      uid$1.value = uid();
    };
    const abort = (file) => {
      if (file) {
        const uid2 = file.uid ? file.uid : file;
        if (reqs[uid2] && reqs[uid2].abort) {
          reqs[uid2].abort();
        }
        delete reqs[uid2];
      } else {
        Object.keys(reqs).forEach((uid2) => {
          if (reqs[uid2] && reqs[uid2].abort) {
            reqs[uid2].abort();
          }
          delete reqs[uid2];
        });
      }
    };
    onMounted(() => {
      isMounted = true;
    });
    onBeforeUnmount(() => {
      isMounted = false;
      abort();
    });
    const uploadFiles = (files) => {
      const originFiles = [...files];
      const postFiles = originFiles.map((file) => {
        file.uid = uid();
        return processFile(file, originFiles);
      });
      Promise.all(postFiles).then((fileList) => {
        const {
          onBatchStart
        } = props2;
        onBatchStart === null || onBatchStart === void 0 ? void 0 : onBatchStart(fileList.map((_ref3) => {
          let {
            origin,
            parsedFile
          } = _ref3;
          return {
            file: origin,
            parsedFile
          };
        }));
        fileList.filter((file) => file.parsedFile !== null).forEach((file) => {
          post(file);
        });
      });
    };
    const onChange = (e2) => {
      const {
        accept,
        directory
      } = props2;
      const {
        files
      } = e2.target;
      const acceptedFiles = [...files].filter((file) => !directory || attrAccept(file, accept));
      uploadFiles(acceptedFiles);
      reset();
    };
    const onClick = (e2) => {
      const el = fileInput.value;
      if (!el) {
        return;
      }
      const {
        onClick: onClick2
      } = props2;
      el.click();
      if (onClick2) {
        onClick2(e2);
      }
    };
    const onKeyDown2 = (e2) => {
      if (e2.key === "Enter") {
        onClick(e2);
      }
    };
    const onFileDrop = (e2) => {
      const {
        multiple
      } = props2;
      e2.preventDefault();
      if (e2.type === "dragover") {
        return;
      }
      if (props2.directory) {
        traverseFileTree(Array.prototype.slice.call(e2.dataTransfer.items), uploadFiles, (_file) => attrAccept(_file, props2.accept));
      } else {
        const files = partition(Array.prototype.slice.call(e2.dataTransfer.files), (file) => attrAccept(file, props2.accept));
        let successFiles = files[0];
        const errorFiles = files[1];
        if (multiple === false) {
          successFiles = successFiles.slice(0, 1);
        }
        uploadFiles(successFiles);
        if (errorFiles.length && props2.onReject) props2.onReject(errorFiles);
      }
    };
    expose({
      abort
    });
    return () => {
      var _a2;
      const {
        componentTag: Tag2,
        prefixCls,
        disabled,
        id,
        multiple,
        accept,
        capture,
        directory,
        openFileDialogOnClick,
        onMouseenter,
        onMouseleave
      } = props2, otherProps = __rest$3(props2, ["componentTag", "prefixCls", "disabled", "id", "multiple", "accept", "capture", "directory", "openFileDialogOnClick", "onMouseenter", "onMouseleave"]);
      const cls = {
        [prefixCls]: true,
        [`${prefixCls}-disabled`]: disabled,
        [attrs.class]: !!attrs.class
      };
      const dirProps = directory ? {
        directory: "directory",
        webkitdirectory: "webkitdirectory"
      } : {};
      const events2 = disabled ? {} : {
        onClick: openFileDialogOnClick ? onClick : () => {
        },
        onKeydown: openFileDialogOnClick ? onKeyDown2 : () => {
        },
        onMouseenter,
        onMouseleave,
        onDrop: onFileDrop,
        onDragover: onFileDrop,
        tabindex: "0"
      };
      return createVNode(Tag2, _objectSpread2$1(_objectSpread2$1({}, events2), {}, {
        "class": cls,
        "role": "button",
        "style": attrs.style
      }), {
        default: () => [createVNode("input", _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, pickAttrs(otherProps, {
          aria: true,
          data: true
        })), {}, {
          "id": id,
          "type": "file",
          "ref": fileInput,
          "onClick": (e2) => e2.stopPropagation(),
          "onCancel": (e2) => e2.stopPropagation(),
          "key": uid$1.value,
          "style": {
            display: "none"
          },
          "accept": accept
        }, dirProps), {}, {
          "multiple": multiple,
          "onChange": onChange
        }, capture != null ? {
          capture
        } : {}), null), (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]
      });
    };
  }
});
function empty() {
}
const Upload$2 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Upload",
  inheritAttrs: false,
  props: initDefaultProps(uploadProps$1(), {
    componentTag: "span",
    prefixCls: "rc-upload",
    data: {},
    headers: {},
    name: "file",
    multipart: false,
    onStart: empty,
    onError: empty,
    onSuccess: empty,
    multiple: false,
    beforeUpload: null,
    customRequest: null,
    withCredentials: false,
    openFileDialogOnClick: true
  }),
  setup(props2, _ref) {
    let {
      slots,
      attrs,
      expose
    } = _ref;
    const uploader = ref();
    const abort = (file) => {
      var _a2;
      (_a2 = uploader.value) === null || _a2 === void 0 ? void 0 : _a2.abort(file);
    };
    expose({
      abort
    });
    return () => {
      return createVNode(AjaxUpload, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, props2), attrs), {}, {
        "ref": uploader
      }), slots);
    };
  }
});
function uploadProps() {
  return {
    capture: someType([Boolean, String]),
    type: stringType(),
    name: String,
    defaultFileList: arrayType(),
    fileList: arrayType(),
    action: someType([String, Function]),
    directory: booleanType(),
    data: someType([Object, Function]),
    method: stringType(),
    headers: objectType(),
    showUploadList: someType([Boolean, Object]),
    multiple: booleanType(),
    accept: String,
    beforeUpload: functionType(),
    onChange: functionType(),
    "onUpdate:fileList": functionType(),
    onDrop: functionType(),
    listType: stringType(),
    onPreview: functionType(),
    onDownload: functionType(),
    onReject: functionType(),
    onRemove: functionType(),
    /** @deprecated Please use `onRemove` directly */
    remove: functionType(),
    supportServerRender: booleanType(),
    disabled: booleanType(),
    prefixCls: String,
    customRequest: functionType(),
    withCredentials: booleanType(),
    openFileDialogOnClick: booleanType(),
    locale: objectType(),
    id: String,
    previewFile: functionType(),
    /** @deprecated Please use `beforeUpload` directly */
    transformFile: functionType(),
    iconRender: functionType(),
    isImageUrl: functionType(),
    progress: objectType(),
    itemRender: functionType(),
    /** Config max count of `fileList`. Will replace current one when `maxCount` is 1 */
    maxCount: Number,
    height: someType([Number, String]),
    removeIcon: functionType(),
    downloadIcon: functionType(),
    previewIcon: functionType()
  };
}
function uploadListProps() {
  return {
    listType: stringType(),
    onPreview: functionType(),
    onDownload: functionType(),
    onRemove: functionType(),
    items: arrayType(),
    progress: objectType(),
    prefixCls: stringType(),
    showRemoveIcon: booleanType(),
    showDownloadIcon: booleanType(),
    showPreviewIcon: booleanType(),
    removeIcon: functionType(),
    downloadIcon: functionType(),
    previewIcon: functionType(),
    locale: objectType(void 0),
    previewFile: functionType(),
    iconRender: functionType(),
    isImageUrl: functionType(),
    appendAction: functionType(),
    appendActionVisible: booleanType(),
    itemRender: functionType()
  };
}
function file2Obj(file) {
  return _extends$1(_extends$1({}, file), {
    lastModified: file.lastModified,
    lastModifiedDate: file.lastModifiedDate,
    name: file.name,
    size: file.size,
    type: file.type,
    uid: file.uid,
    percent: 0,
    originFileObj: file
  });
}
function updateFileList(file, fileList) {
  const nextFileList = [...fileList];
  const fileIndex = nextFileList.findIndex((_ref) => {
    let {
      uid: uid2
    } = _ref;
    return uid2 === file.uid;
  });
  if (fileIndex === -1) {
    nextFileList.push(file);
  } else {
    nextFileList[fileIndex] = file;
  }
  return nextFileList;
}
function getFileItem(file, fileList) {
  const matchKey = file.uid !== void 0 ? "uid" : "name";
  return fileList.filter((item) => item[matchKey] === file[matchKey])[0];
}
function removeFileItem(file, fileList) {
  const matchKey = file.uid !== void 0 ? "uid" : "name";
  const removed = fileList.filter((item) => item[matchKey] !== file[matchKey]);
  if (removed.length === fileList.length) {
    return null;
  }
  return removed;
}
const extname = function() {
  let url2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  const temp = url2.split("/");
  const filename = temp[temp.length - 1];
  const filenameWithoutSuffix = filename.split(/#|\?/)[0];
  return (/\.[^./\\]*$/.exec(filenameWithoutSuffix) || [""])[0];
};
const isImageFileType = (type4) => type4.indexOf("image/") === 0;
const isImageUrl = (file) => {
  if (file.type && !file.thumbUrl) {
    return isImageFileType(file.type);
  }
  const url2 = file.thumbUrl || file.url || "";
  const extension = extname(url2);
  if (/^data:image\//.test(url2) || /(webp|svg|png|gif|jpg|jpeg|jfif|bmp|dpg|ico)$/i.test(extension)) {
    return true;
  }
  if (/^data:/.test(url2)) {
    return false;
  }
  if (extension) {
    return false;
  }
  return true;
};
const MEASURE_SIZE = 200;
function previewImage(file) {
  return new Promise((resolve) => {
    if (!file.type || !isImageFileType(file.type)) {
      resolve("");
      return;
    }
    const canvas = document.createElement("canvas");
    canvas.width = MEASURE_SIZE;
    canvas.height = MEASURE_SIZE;
    canvas.style.cssText = `position: fixed; left: 0; top: 0; width: ${MEASURE_SIZE}px; height: ${MEASURE_SIZE}px; z-index: 9999; display: none;`;
    document.body.appendChild(canvas);
    const ctx = canvas.getContext("2d");
    const img = new Image();
    img.onload = () => {
      const {
        width,
        height
      } = img;
      let drawWidth = MEASURE_SIZE;
      let drawHeight = MEASURE_SIZE;
      let offsetX = 0;
      let offsetY = 0;
      if (width > height) {
        drawHeight = height * (MEASURE_SIZE / width);
        offsetY = -(drawHeight - drawWidth) / 2;
      } else {
        drawWidth = width * (MEASURE_SIZE / height);
        offsetX = -(drawWidth - drawHeight) / 2;
      }
      ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
      const dataURL = canvas.toDataURL();
      document.body.removeChild(canvas);
      resolve(dataURL);
    };
    img.crossOrigin = "anonymous";
    if (file.type.startsWith("image/svg+xml")) {
      const reader = new FileReader();
      reader.addEventListener("load", () => {
        if (reader.result) img.src = reader.result;
      });
      reader.readAsDataURL(file);
    } else {
      img.src = window.URL.createObjectURL(file);
    }
  });
}
const listItemProps = () => {
  return {
    prefixCls: String,
    locale: objectType(void 0),
    file: objectType(),
    items: arrayType(),
    listType: stringType(),
    isImgUrl: functionType(),
    showRemoveIcon: booleanType(),
    showDownloadIcon: booleanType(),
    showPreviewIcon: booleanType(),
    removeIcon: functionType(),
    downloadIcon: functionType(),
    previewIcon: functionType(),
    iconRender: functionType(),
    actionIconRender: functionType(),
    itemRender: functionType(),
    onPreview: functionType(),
    onClose: functionType(),
    onDownload: functionType(),
    progress: objectType()
  };
};
const ListItem = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ListItem",
  inheritAttrs: false,
  props: listItemProps(),
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    var _a2;
    const showProgress = shallowRef(false);
    const progressRafRef = shallowRef();
    onMounted(() => {
      progressRafRef.value = setTimeout(() => {
        showProgress.value = true;
      }, 300);
    });
    onBeforeUnmount(() => {
      clearTimeout(progressRafRef.value);
    });
    const mergedStatus = shallowRef((_a2 = props2.file) === null || _a2 === void 0 ? void 0 : _a2.status);
    watch(() => {
      var _a3;
      return (_a3 = props2.file) === null || _a3 === void 0 ? void 0 : _a3.status;
    }, (status) => {
      if (status !== "removed") {
        mergedStatus.value = status;
      }
    });
    const {
      rootPrefixCls
    } = useConfigInject("upload", props2);
    const transitionProps = computed(() => getTransitionProps(`${rootPrefixCls.value}-fade`));
    return () => {
      var _a3, _b;
      const {
        prefixCls,
        locale: locale2,
        listType,
        file,
        items,
        progress: progressProps2,
        iconRender = slots.iconRender,
        actionIconRender = slots.actionIconRender,
        itemRender = slots.itemRender,
        isImgUrl,
        showPreviewIcon,
        showRemoveIcon,
        showDownloadIcon,
        previewIcon: customPreviewIcon = slots.previewIcon,
        removeIcon: customRemoveIcon = slots.removeIcon,
        downloadIcon: customDownloadIcon = slots.downloadIcon,
        onPreview,
        onDownload,
        onClose
      } = props2;
      const {
        class: className,
        style
      } = attrs;
      const iconNode = iconRender({
        file
      });
      let icon = createVNode("div", {
        "class": `${prefixCls}-text-icon`
      }, [iconNode]);
      if (listType === "picture" || listType === "picture-card") {
        if (mergedStatus.value === "uploading" || !file.thumbUrl && !file.url) {
          const uploadingClassName = {
            [`${prefixCls}-list-item-thumbnail`]: true,
            [`${prefixCls}-list-item-file`]: mergedStatus.value !== "uploading"
          };
          icon = createVNode("div", {
            "class": uploadingClassName
          }, [iconNode]);
        } else {
          const thumbnail = (isImgUrl === null || isImgUrl === void 0 ? void 0 : isImgUrl(file)) ? createVNode("img", {
            "src": file.thumbUrl || file.url,
            "alt": file.name,
            "class": `${prefixCls}-list-item-image`,
            "crossorigin": file.crossOrigin
          }, null) : iconNode;
          const aClassName = {
            [`${prefixCls}-list-item-thumbnail`]: true,
            [`${prefixCls}-list-item-file`]: isImgUrl && !isImgUrl(file)
          };
          icon = createVNode("a", {
            "class": aClassName,
            "onClick": (e2) => onPreview(file, e2),
            "href": file.url || file.thumbUrl,
            "target": "_blank",
            "rel": "noopener noreferrer"
          }, [thumbnail]);
        }
      }
      const infoUploadingClass = {
        [`${prefixCls}-list-item`]: true,
        [`${prefixCls}-list-item-${mergedStatus.value}`]: true
      };
      const linkProps2 = typeof file.linkProps === "string" ? JSON.parse(file.linkProps) : file.linkProps;
      const removeIcon = showRemoveIcon ? actionIconRender({
        customIcon: customRemoveIcon ? customRemoveIcon({
          file
        }) : createVNode(DeleteOutlined, null, null),
        callback: () => onClose(file),
        prefixCls,
        title: locale2.removeFile
      }) : null;
      const downloadIcon = showDownloadIcon && mergedStatus.value === "done" ? actionIconRender({
        customIcon: customDownloadIcon ? customDownloadIcon({
          file
        }) : createVNode(DownloadOutlined, null, null),
        callback: () => onDownload(file),
        prefixCls,
        title: locale2.downloadFile
      }) : null;
      const downloadOrDelete = listType !== "picture-card" && createVNode("span", {
        "key": "download-delete",
        "class": [`${prefixCls}-list-item-actions`, {
          picture: listType === "picture"
        }]
      }, [downloadIcon, removeIcon]);
      const listItemNameClass = `${prefixCls}-list-item-name`;
      const fileName = file.url ? [createVNode("a", _objectSpread2$1(_objectSpread2$1({
        "key": "view",
        "target": "_blank",
        "rel": "noopener noreferrer",
        "class": listItemNameClass,
        "title": file.name
      }, linkProps2), {}, {
        "href": file.url,
        "onClick": (e2) => onPreview(file, e2)
      }), [file.name]), downloadOrDelete] : [createVNode("span", {
        "key": "view",
        "class": listItemNameClass,
        "onClick": (e2) => onPreview(file, e2),
        "title": file.name
      }, [file.name]), downloadOrDelete];
      const previewStyle = {
        pointerEvents: "none",
        opacity: 0.5
      };
      const previewIcon = showPreviewIcon ? createVNode("a", {
        "href": file.url || file.thumbUrl,
        "target": "_blank",
        "rel": "noopener noreferrer",
        "style": file.url || file.thumbUrl ? void 0 : previewStyle,
        "onClick": (e2) => onPreview(file, e2),
        "title": locale2.previewFile
      }, [customPreviewIcon ? customPreviewIcon({
        file
      }) : createVNode(EyeOutlined, null, null)]) : null;
      const pictureCardActions = listType === "picture-card" && mergedStatus.value !== "uploading" && createVNode("span", {
        "class": `${prefixCls}-list-item-actions`
      }, [previewIcon, mergedStatus.value === "done" && downloadIcon, removeIcon]);
      const dom = createVNode("div", {
        "class": infoUploadingClass
      }, [icon, fileName, pictureCardActions, showProgress.value && createVNode(Transition, transitionProps.value, {
        default: () => [withDirectives(createVNode("div", {
          "class": `${prefixCls}-list-item-progress`
        }, ["percent" in file ? createVNode(Progress, _objectSpread2$1(_objectSpread2$1({}, progressProps2), {}, {
          "type": "line",
          "percent": file.percent
        }), null) : null]), [[vShow, mergedStatus.value === "uploading"]])]
      })]);
      const listContainerNameClass = {
        [`${prefixCls}-list-item-container`]: true,
        [`${className}`]: !!className
      };
      const message = file.response && typeof file.response === "string" ? file.response : ((_a3 = file.error) === null || _a3 === void 0 ? void 0 : _a3.statusText) || ((_b = file.error) === null || _b === void 0 ? void 0 : _b.message) || locale2.uploadError;
      const item = mergedStatus.value === "error" ? createVNode(Tooltip, {
        "title": message,
        "getPopupContainer": (node2) => node2.parentNode
      }, {
        default: () => [dom]
      }) : dom;
      return createVNode("div", {
        "class": listContainerNameClass,
        "style": style
      }, [itemRender ? itemRender({
        originNode: item,
        file,
        fileList: items,
        actions: {
          download: onDownload.bind(null, file),
          preview: onPreview.bind(null, file),
          remove: onClose.bind(null, file)
        }
      }) : item]);
    };
  }
});
const HackSlot = (_2, _ref) => {
  let {
    slots
  } = _ref;
  var _a2;
  return filterEmpty((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots))[0];
};
const UploadList = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AUploadList",
  props: initDefaultProps(uploadListProps(), {
    listType: "text",
    progress: {
      strokeWidth: 2,
      showInfo: false
    },
    showRemoveIcon: true,
    showDownloadIcon: false,
    showPreviewIcon: true,
    previewFile: previewImage,
    isImageUrl,
    items: [],
    appendActionVisible: true
  }),
  setup(props2, _ref2) {
    let {
      slots,
      expose
    } = _ref2;
    const motionAppear = shallowRef(false);
    onMounted(() => {
      motionAppear.value == true;
    });
    const mergedItems = shallowRef([]);
    watch(() => props2.items, function() {
      let val = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      mergedItems.value = val.slice();
    }, {
      immediate: true,
      deep: true
    });
    watchEffect(() => {
      if (props2.listType !== "picture" && props2.listType !== "picture-card") {
        return;
      }
      let hasUpdate = false;
      (props2.items || []).forEach((file, index2) => {
        if (typeof document === "undefined" || typeof window === "undefined" || !window.FileReader || !window.File || !(file.originFileObj instanceof File || file.originFileObj instanceof Blob) || file.thumbUrl !== void 0) {
          return;
        }
        file.thumbUrl = "";
        if (props2.previewFile) {
          props2.previewFile(file.originFileObj).then((previewDataUrl) => {
            const thumbUrl = previewDataUrl || "";
            if (thumbUrl !== file.thumbUrl) {
              mergedItems.value[index2].thumbUrl = thumbUrl;
              hasUpdate = true;
            }
          });
        }
      });
      if (hasUpdate) {
        triggerRef(mergedItems);
      }
    });
    const onInternalPreview = (file, e2) => {
      if (!props2.onPreview) {
        return;
      }
      e2 === null || e2 === void 0 ? void 0 : e2.preventDefault();
      return props2.onPreview(file);
    };
    const onInternalDownload = (file) => {
      if (typeof props2.onDownload === "function") {
        props2.onDownload(file);
      } else if (file.url) {
        window.open(file.url);
      }
    };
    const onInternalClose = (file) => {
      var _a2;
      (_a2 = props2.onRemove) === null || _a2 === void 0 ? void 0 : _a2.call(props2, file);
    };
    const internalIconRender = (_ref3) => {
      let {
        file
      } = _ref3;
      const iconRender = props2.iconRender || slots.iconRender;
      if (iconRender) {
        return iconRender({
          file,
          listType: props2.listType
        });
      }
      const isLoading = file.status === "uploading";
      const fileIcon = props2.isImageUrl && props2.isImageUrl(file) ? createVNode(PictureTwoTone, null, null) : createVNode(FileTwoTone, null, null);
      let icon = isLoading ? createVNode(LoadingOutlined, null, null) : createVNode(PaperClipOutlined, null, null);
      if (props2.listType === "picture") {
        icon = isLoading ? createVNode(LoadingOutlined, null, null) : fileIcon;
      } else if (props2.listType === "picture-card") {
        icon = isLoading ? props2.locale.uploading : fileIcon;
      }
      return icon;
    };
    const actionIconRender = (opt) => {
      const {
        customIcon,
        callback,
        prefixCls: prefixCls2,
        title
      } = opt;
      const btnProps = {
        type: "text",
        size: "small",
        title,
        onClick: () => {
          callback();
        },
        class: `${prefixCls2}-list-item-action`
      };
      if (isValidElement(customIcon)) {
        return createVNode(Button$1, btnProps, {
          icon: () => customIcon
        });
      }
      return createVNode(Button$1, btnProps, {
        default: () => [createVNode("span", null, [customIcon])]
      });
    };
    expose({
      handlePreview: onInternalPreview,
      handleDownload: onInternalDownload
    });
    const {
      prefixCls,
      rootPrefixCls
    } = useConfigInject("upload", props2);
    const listClassNames = computed(() => ({
      [`${prefixCls.value}-list`]: true,
      [`${prefixCls.value}-list-${props2.listType}`]: true
    }));
    const transitionGroupProps = computed(() => {
      const motion = _extends$1({}, collapseMotion(`${rootPrefixCls.value}-motion-collapse`));
      delete motion.onAfterAppear;
      delete motion.onAfterEnter;
      delete motion.onAfterLeave;
      const motionConfig = _extends$1(_extends$1({}, getTransitionGroupProps(`${prefixCls.value}-${props2.listType === "picture-card" ? "animate-inline" : "animate"}`)), {
        class: listClassNames.value,
        appear: motionAppear.value
      });
      return props2.listType !== "picture-card" ? _extends$1(_extends$1({}, motion), motionConfig) : motionConfig;
    });
    return () => {
      const {
        listType,
        locale: locale2,
        isImageUrl: isImgUrl,
        showPreviewIcon,
        showRemoveIcon,
        showDownloadIcon,
        removeIcon,
        previewIcon,
        downloadIcon,
        progress,
        appendAction,
        itemRender,
        appendActionVisible
      } = props2;
      const appendActionDom = appendAction === null || appendAction === void 0 ? void 0 : appendAction();
      const items = mergedItems.value;
      return createVNode(TransitionGroup, _objectSpread2$1(_objectSpread2$1({}, transitionGroupProps.value), {}, {
        "tag": "div"
      }), {
        default: () => [items.map((file) => {
          const {
            uid: key2
          } = file;
          return createVNode(ListItem, {
            "key": key2,
            "locale": locale2,
            "prefixCls": prefixCls.value,
            "file": file,
            "items": items,
            "progress": progress,
            "listType": listType,
            "isImgUrl": isImgUrl,
            "showPreviewIcon": showPreviewIcon,
            "showRemoveIcon": showRemoveIcon,
            "showDownloadIcon": showDownloadIcon,
            "onPreview": onInternalPreview,
            "onDownload": onInternalDownload,
            "onClose": onInternalClose,
            "removeIcon": removeIcon,
            "previewIcon": previewIcon,
            "downloadIcon": downloadIcon,
            "itemRender": itemRender
          }, _extends$1(_extends$1({}, slots), {
            iconRender: internalIconRender,
            actionIconRender
          }));
        }), appendAction ? withDirectives(createVNode(HackSlot, {
          "key": "__ant_upload_appendAction"
        }, {
          default: () => appendActionDom
        }), [[vShow, !!appendActionVisible]]) : null]
      });
    };
  }
});
const genDraggerStyle = (token2) => {
  const {
    componentCls,
    iconCls
  } = token2;
  return {
    [`${componentCls}-wrapper`]: {
      [`${componentCls}-drag`]: {
        position: "relative",
        width: "100%",
        height: "100%",
        textAlign: "center",
        background: token2.colorFillAlter,
        border: `${token2.lineWidth}px dashed ${token2.colorBorder}`,
        borderRadius: token2.borderRadiusLG,
        cursor: "pointer",
        transition: `border-color ${token2.motionDurationSlow}`,
        [componentCls]: {
          padding: `${token2.padding}px 0`
        },
        [`${componentCls}-btn`]: {
          display: "table",
          width: "100%",
          height: "100%",
          outline: "none"
        },
        [`${componentCls}-drag-container`]: {
          display: "table-cell",
          verticalAlign: "middle"
        },
        [`&:not(${componentCls}-disabled):hover`]: {
          borderColor: token2.colorPrimaryHover
        },
        [`p${componentCls}-drag-icon`]: {
          marginBottom: token2.margin,
          [iconCls]: {
            color: token2.colorPrimary,
            fontSize: token2.uploadThumbnailSize
          }
        },
        [`p${componentCls}-text`]: {
          margin: `0 0 ${token2.marginXXS}px`,
          color: token2.colorTextHeading,
          fontSize: token2.fontSizeLG
        },
        [`p${componentCls}-hint`]: {
          color: token2.colorTextDescription,
          fontSize: token2.fontSize
        },
        // ===================== Disabled =====================
        [`&${componentCls}-disabled`]: {
          cursor: "not-allowed",
          [`p${componentCls}-drag-icon ${iconCls},
            p${componentCls}-text,
            p${componentCls}-hint
          `]: {
            color: token2.colorTextDisabled
          }
        }
      }
    }
  };
};
const genListStyle = (token2) => {
  const {
    componentCls,
    antCls,
    iconCls,
    fontSize,
    lineHeight
  } = token2;
  const itemCls = `${componentCls}-list-item`;
  const actionsCls = `${itemCls}-actions`;
  const actionCls = `${itemCls}-action`;
  const listItemHeightSM = Math.round(fontSize * lineHeight);
  return {
    [`${componentCls}-wrapper`]: {
      [`${componentCls}-list`]: _extends$1(_extends$1({}, clearFix()), {
        lineHeight: token2.lineHeight,
        [itemCls]: {
          position: "relative",
          height: token2.lineHeight * fontSize,
          marginTop: token2.marginXS,
          fontSize,
          display: "flex",
          alignItems: "center",
          transition: `background-color ${token2.motionDurationSlow}`,
          "&:hover": {
            backgroundColor: token2.controlItemBgHover
          },
          [`${itemCls}-name`]: _extends$1(_extends$1({}, textEllipsis), {
            padding: `0 ${token2.paddingXS}px`,
            lineHeight,
            flex: "auto",
            transition: `all ${token2.motionDurationSlow}`
          }),
          [actionsCls]: {
            [actionCls]: {
              opacity: 0
            },
            [`${actionCls}${antCls}-btn-sm`]: {
              height: listItemHeightSM,
              border: 0,
              lineHeight: 1,
              // FIXME: should not override small button
              "> span": {
                transform: "scale(1)"
              }
            },
            [`
              ${actionCls}:focus,
              &.picture ${actionCls}
            `]: {
              opacity: 1
            },
            [iconCls]: {
              color: token2.colorTextDescription,
              transition: `all ${token2.motionDurationSlow}`
            },
            [`&:hover ${iconCls}`]: {
              color: token2.colorText
            }
          },
          [`${componentCls}-icon ${iconCls}`]: {
            color: token2.colorTextDescription,
            fontSize
          },
          [`${itemCls}-progress`]: {
            position: "absolute",
            bottom: -token2.uploadProgressOffset,
            width: "100%",
            paddingInlineStart: fontSize + token2.paddingXS,
            fontSize,
            lineHeight: 0,
            pointerEvents: "none",
            "> div": {
              margin: 0
            }
          }
        },
        [`${itemCls}:hover ${actionCls}`]: {
          opacity: 1,
          color: token2.colorText
        },
        [`${itemCls}-error`]: {
          color: token2.colorError,
          [`${itemCls}-name, ${componentCls}-icon ${iconCls}`]: {
            color: token2.colorError
          },
          [actionsCls]: {
            [`${iconCls}, ${iconCls}:hover`]: {
              color: token2.colorError
            },
            [actionCls]: {
              opacity: 1
            }
          }
        },
        [`${componentCls}-list-item-container`]: {
          transition: `opacity ${token2.motionDurationSlow}, height ${token2.motionDurationSlow}`,
          // For smooth removing animation
          "&::before": {
            display: "table",
            width: 0,
            height: 0,
            content: '""'
          }
        }
      })
    }
  };
};
const uploadAnimateInlineIn = new Keyframe("uploadAnimateInlineIn", {
  from: {
    width: 0,
    height: 0,
    margin: 0,
    padding: 0,
    opacity: 0
  }
});
const uploadAnimateInlineOut = new Keyframe("uploadAnimateInlineOut", {
  to: {
    width: 0,
    height: 0,
    margin: 0,
    padding: 0,
    opacity: 0
  }
});
const genMotionStyle = (token2) => {
  const {
    componentCls
  } = token2;
  const inlineCls = `${componentCls}-animate-inline`;
  return [{
    [`${componentCls}-wrapper`]: {
      [`${inlineCls}-appear, ${inlineCls}-enter, ${inlineCls}-leave`]: {
        animationDuration: token2.motionDurationSlow,
        animationTimingFunction: token2.motionEaseInOutCirc,
        animationFillMode: "forwards"
      },
      [`${inlineCls}-appear, ${inlineCls}-enter`]: {
        animationName: uploadAnimateInlineIn
      },
      [`${inlineCls}-leave`]: {
        animationName: uploadAnimateInlineOut
      }
    }
  }, uploadAnimateInlineIn, uploadAnimateInlineOut];
};
const genPictureStyle = (token2) => {
  const {
    componentCls,
    iconCls,
    uploadThumbnailSize,
    uploadProgressOffset
  } = token2;
  const listCls = `${componentCls}-list`;
  const itemCls = `${listCls}-item`;
  return {
    [`${componentCls}-wrapper`]: {
      // ${listCls} 增加优先级
      [`${listCls}${listCls}-picture, ${listCls}${listCls}-picture-card`]: {
        [itemCls]: {
          position: "relative",
          height: uploadThumbnailSize + token2.lineWidth * 2 + token2.paddingXS * 2,
          padding: token2.paddingXS,
          border: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`,
          borderRadius: token2.borderRadiusLG,
          "&:hover": {
            background: "transparent"
          },
          [`${itemCls}-thumbnail`]: _extends$1(_extends$1({}, textEllipsis), {
            width: uploadThumbnailSize,
            height: uploadThumbnailSize,
            lineHeight: `${uploadThumbnailSize + token2.paddingSM}px`,
            textAlign: "center",
            flex: "none",
            [iconCls]: {
              fontSize: token2.fontSizeHeading2,
              color: token2.colorPrimary
            },
            img: {
              display: "block",
              width: "100%",
              height: "100%",
              overflow: "hidden"
            }
          }),
          [`${itemCls}-progress`]: {
            bottom: uploadProgressOffset,
            width: `calc(100% - ${token2.paddingSM * 2}px)`,
            marginTop: 0,
            paddingInlineStart: uploadThumbnailSize + token2.paddingXS
          }
        },
        [`${itemCls}-error`]: {
          borderColor: token2.colorError,
          // Adjust the color of the error icon : https://github.com/ant-design/ant-design/pull/24160
          [`${itemCls}-thumbnail ${iconCls}`]: {
            [`svg path[fill='#e6f7ff']`]: {
              fill: token2.colorErrorBg
            },
            [`svg path[fill='#1890ff']`]: {
              fill: token2.colorError
            }
          }
        },
        [`${itemCls}-uploading`]: {
          borderStyle: "dashed",
          [`${itemCls}-name`]: {
            marginBottom: uploadProgressOffset
          }
        }
      }
    }
  };
};
const genPictureCardStyle = (token2) => {
  const {
    componentCls,
    iconCls,
    fontSizeLG,
    colorTextLightSolid
  } = token2;
  const listCls = `${componentCls}-list`;
  const itemCls = `${listCls}-item`;
  const uploadPictureCardSize = token2.uploadPicCardSize;
  return {
    [`${componentCls}-wrapper${componentCls}-picture-card-wrapper`]: _extends$1(_extends$1({}, clearFix()), {
      display: "inline-block",
      width: "100%",
      [`${componentCls}${componentCls}-select`]: {
        width: uploadPictureCardSize,
        height: uploadPictureCardSize,
        marginInlineEnd: token2.marginXS,
        marginBottom: token2.marginXS,
        textAlign: "center",
        verticalAlign: "top",
        backgroundColor: token2.colorFillAlter,
        border: `${token2.lineWidth}px dashed ${token2.colorBorder}`,
        borderRadius: token2.borderRadiusLG,
        cursor: "pointer",
        transition: `border-color ${token2.motionDurationSlow}`,
        [`> ${componentCls}`]: {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          height: "100%",
          textAlign: "center"
        },
        [`&:not(${componentCls}-disabled):hover`]: {
          borderColor: token2.colorPrimary
        }
      },
      // list
      [`${listCls}${listCls}-picture-card`]: {
        [`${listCls}-item-container`]: {
          display: "inline-block",
          width: uploadPictureCardSize,
          height: uploadPictureCardSize,
          marginBlock: `0 ${token2.marginXS}px`,
          marginInline: `0 ${token2.marginXS}px`,
          verticalAlign: "top"
        },
        "&::after": {
          display: "none"
        },
        [itemCls]: {
          height: "100%",
          margin: 0,
          "&::before": {
            position: "absolute",
            zIndex: 1,
            width: `calc(100% - ${token2.paddingXS * 2}px)`,
            height: `calc(100% - ${token2.paddingXS * 2}px)`,
            backgroundColor: token2.colorBgMask,
            opacity: 0,
            transition: `all ${token2.motionDurationSlow}`,
            content: '" "'
          }
        },
        [`${itemCls}:hover`]: {
          [`&::before, ${itemCls}-actions`]: {
            opacity: 1
          }
        },
        [`${itemCls}-actions`]: {
          position: "absolute",
          insetInlineStart: 0,
          zIndex: 10,
          width: "100%",
          whiteSpace: "nowrap",
          textAlign: "center",
          opacity: 0,
          transition: `all ${token2.motionDurationSlow}`,
          [`${iconCls}-eye, ${iconCls}-download, ${iconCls}-delete`]: {
            zIndex: 10,
            width: fontSizeLG,
            margin: `0 ${token2.marginXXS}px`,
            fontSize: fontSizeLG,
            cursor: "pointer",
            transition: `all ${token2.motionDurationSlow}`
          }
        },
        [`${itemCls}-actions, ${itemCls}-actions:hover`]: {
          [`${iconCls}-eye, ${iconCls}-download, ${iconCls}-delete`]: {
            color: new TinyColor(colorTextLightSolid).setAlpha(0.65).toRgbString(),
            "&:hover": {
              color: colorTextLightSolid
            }
          }
        },
        [`${itemCls}-thumbnail, ${itemCls}-thumbnail img`]: {
          position: "static",
          display: "block",
          width: "100%",
          height: "100%",
          objectFit: "contain"
        },
        [`${itemCls}-name`]: {
          display: "none",
          textAlign: "center"
        },
        [`${itemCls}-file + ${itemCls}-name`]: {
          position: "absolute",
          bottom: token2.margin,
          display: "block",
          width: `calc(100% - ${token2.paddingXS * 2}px)`
        },
        [`${itemCls}-uploading`]: {
          [`&${itemCls}`]: {
            backgroundColor: token2.colorFillAlter
          },
          [`&::before, ${iconCls}-eye, ${iconCls}-download, ${iconCls}-delete`]: {
            display: "none"
          }
        },
        [`${itemCls}-progress`]: {
          bottom: token2.marginXL,
          width: `calc(100% - ${token2.paddingXS * 2}px)`,
          paddingInlineStart: 0
        }
      }
    })
  };
};
const genRtlStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-rtl`]: {
      direction: "rtl"
    }
  };
};
const genBaseStyle$1 = (token2) => {
  const {
    componentCls,
    colorTextDisabled
  } = token2;
  return {
    [`${componentCls}-wrapper`]: _extends$1(_extends$1({}, resetComponent(token2)), {
      [componentCls]: {
        outline: 0,
        "input[type='file']": {
          cursor: "pointer"
        }
      },
      [`${componentCls}-select`]: {
        display: "inline-block"
      },
      [`${componentCls}-disabled`]: {
        color: colorTextDisabled,
        cursor: "not-allowed"
      }
    })
  };
};
const useStyle$3 = genComponentStyleHook("Upload", (token2) => {
  const {
    fontSizeHeading3,
    fontSize,
    lineHeight,
    lineWidth,
    controlHeightLG
  } = token2;
  const listItemHeightSM = Math.round(fontSize * lineHeight);
  const uploadToken = merge(token2, {
    uploadThumbnailSize: fontSizeHeading3 * 2,
    uploadProgressOffset: listItemHeightSM / 2 + lineWidth,
    uploadPicCardSize: controlHeightLG * 2.55
  });
  return [genBaseStyle$1(uploadToken), genDraggerStyle(uploadToken), genPictureStyle(uploadToken), genPictureCardStyle(uploadToken), genListStyle(uploadToken), genMotionStyle(uploadToken), genRtlStyle(uploadToken), genCollapseMotion(uploadToken)];
});
var __awaiter = function(thisArg, _arguments, P2, generator2) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator2.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator2["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator2 = generator2.apply(thisArg, _arguments || [])).next());
  });
};
var __rest$2 = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const LIST_IGNORE = `__LIST_IGNORE_${Date.now()}__`;
const Upload$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AUpload",
  inheritAttrs: false,
  props: initDefaultProps(uploadProps(), {
    type: "select",
    multiple: false,
    action: "",
    data: {},
    accept: "",
    showUploadList: true,
    listType: "text",
    supportServerRender: true
  }),
  setup(props2, _ref) {
    let {
      slots,
      attrs,
      expose
    } = _ref;
    const formItemContext = useInjectFormItemContext();
    const {
      prefixCls,
      direction,
      disabled
    } = useConfigInject("upload", props2);
    const [wrapSSR, hashId] = useStyle$3(prefixCls);
    const disabledContext = useInjectDisabled();
    const mergedDisabled = computed(() => {
      var _a2;
      return (_a2 = disabled.value) !== null && _a2 !== void 0 ? _a2 : disabledContext.value;
    });
    const [mergedFileList, setMergedFileList] = useMergedState(props2.defaultFileList || [], {
      value: toRef(props2, "fileList"),
      postState: (list) => {
        const timestamp = Date.now();
        return (list !== null && list !== void 0 ? list : []).map((file, index2) => {
          if (!file.uid && !Object.isFrozen(file)) {
            file.uid = `__AUTO__${timestamp}_${index2}__`;
          }
          return file;
        });
      }
    });
    const dragState = ref("drop");
    const upload2 = ref(null);
    onMounted(() => {
      devWarning(props2.fileList !== void 0 || attrs.value === void 0, "Upload", "`value` is not a valid prop, do you mean `fileList`?");
      devWarning(props2.transformFile === void 0, "Upload", "`transformFile` is deprecated. Please use `beforeUpload` directly.");
      devWarning(props2.remove === void 0, "Upload", "`remove` props is deprecated. Please use `remove` event.");
    });
    const onInternalChange = (file, changedFileList, event) => {
      var _a2, _b;
      let cloneList = [...changedFileList];
      if (props2.maxCount === 1) {
        cloneList = cloneList.slice(-1);
      } else if (props2.maxCount) {
        cloneList = cloneList.slice(0, props2.maxCount);
      }
      setMergedFileList(cloneList);
      const changeInfo = {
        file,
        fileList: cloneList
      };
      if (event) {
        changeInfo.event = event;
      }
      (_a2 = props2["onUpdate:fileList"]) === null || _a2 === void 0 ? void 0 : _a2.call(props2, changeInfo.fileList);
      (_b = props2.onChange) === null || _b === void 0 ? void 0 : _b.call(props2, changeInfo);
      formItemContext.onFieldChange();
    };
    const mergedBeforeUpload = (file, fileListArgs) => __awaiter(this, void 0, void 0, function* () {
      const {
        beforeUpload,
        transformFile
      } = props2;
      let parsedFile = file;
      if (beforeUpload) {
        const result = yield beforeUpload(file, fileListArgs);
        if (result === false) {
          return false;
        }
        delete file[LIST_IGNORE];
        if (result === LIST_IGNORE) {
          Object.defineProperty(file, LIST_IGNORE, {
            value: true,
            configurable: true
          });
          return false;
        }
        if (typeof result === "object" && result) {
          parsedFile = result;
        }
      }
      if (transformFile) {
        parsedFile = yield transformFile(parsedFile);
      }
      return parsedFile;
    });
    const onBatchStart = (batchFileInfoList) => {
      const filteredFileInfoList = batchFileInfoList.filter((info) => !info.file[LIST_IGNORE]);
      if (!filteredFileInfoList.length) {
        return;
      }
      const objectFileList = filteredFileInfoList.map((info) => file2Obj(info.file));
      let newFileList = [...mergedFileList.value];
      objectFileList.forEach((fileObj) => {
        newFileList = updateFileList(fileObj, newFileList);
      });
      objectFileList.forEach((fileObj, index2) => {
        let triggerFileObj = fileObj;
        if (!filteredFileInfoList[index2].parsedFile) {
          const {
            originFileObj
          } = fileObj;
          let clone2;
          try {
            clone2 = new File([originFileObj], originFileObj.name, {
              type: originFileObj.type
            });
          } catch (e2) {
            clone2 = new Blob([originFileObj], {
              type: originFileObj.type
            });
            clone2.name = originFileObj.name;
            clone2.lastModifiedDate = /* @__PURE__ */ new Date();
            clone2.lastModified = (/* @__PURE__ */ new Date()).getTime();
          }
          clone2.uid = fileObj.uid;
          triggerFileObj = clone2;
        } else {
          fileObj.status = "uploading";
        }
        onInternalChange(triggerFileObj, newFileList);
      });
    };
    const onSuccess = (response, file, xhr) => {
      try {
        if (typeof response === "string") {
          response = JSON.parse(response);
        }
      } catch (e2) {
      }
      if (!getFileItem(file, mergedFileList.value)) {
        return;
      }
      const targetItem = file2Obj(file);
      targetItem.status = "done";
      targetItem.percent = 100;
      targetItem.response = response;
      targetItem.xhr = xhr;
      const nextFileList = updateFileList(targetItem, mergedFileList.value);
      onInternalChange(targetItem, nextFileList);
    };
    const onProgress = (e2, file) => {
      if (!getFileItem(file, mergedFileList.value)) {
        return;
      }
      const targetItem = file2Obj(file);
      targetItem.status = "uploading";
      targetItem.percent = e2.percent;
      const nextFileList = updateFileList(targetItem, mergedFileList.value);
      onInternalChange(targetItem, nextFileList, e2);
    };
    const onError = (error, response, file) => {
      if (!getFileItem(file, mergedFileList.value)) {
        return;
      }
      const targetItem = file2Obj(file);
      targetItem.error = error;
      targetItem.response = response;
      targetItem.status = "error";
      const nextFileList = updateFileList(targetItem, mergedFileList.value);
      onInternalChange(targetItem, nextFileList);
    };
    const handleRemove = (file) => {
      let currentFile;
      const mergedRemove = props2.onRemove || props2.remove;
      Promise.resolve(typeof mergedRemove === "function" ? mergedRemove(file) : mergedRemove).then((ret) => {
        var _a2, _b;
        if (ret === false) {
          return;
        }
        const removedFileList = removeFileItem(file, mergedFileList.value);
        if (removedFileList) {
          currentFile = _extends$1(_extends$1({}, file), {
            status: "removed"
          });
          (_a2 = mergedFileList.value) === null || _a2 === void 0 ? void 0 : _a2.forEach((item) => {
            const matchKey = currentFile.uid !== void 0 ? "uid" : "name";
            if (item[matchKey] === currentFile[matchKey] && !Object.isFrozen(item)) {
              item.status = "removed";
            }
          });
          (_b = upload2.value) === null || _b === void 0 ? void 0 : _b.abort(currentFile);
          onInternalChange(currentFile, removedFileList);
        }
      });
    };
    const onFileDrop = (e2) => {
      var _a2;
      dragState.value = e2.type;
      if (e2.type === "drop") {
        (_a2 = props2.onDrop) === null || _a2 === void 0 ? void 0 : _a2.call(props2, e2);
      }
    };
    expose({
      onBatchStart,
      onSuccess,
      onProgress,
      onError,
      fileList: mergedFileList,
      upload: upload2
    });
    const [locale2] = useLocaleReceiver("Upload", localeValues.Upload, computed(() => props2.locale));
    const renderUploadList = (button, buttonVisible) => {
      const {
        removeIcon,
        previewIcon,
        downloadIcon,
        previewFile,
        onPreview,
        onDownload,
        isImageUrl: isImageUrl2,
        progress,
        itemRender,
        iconRender,
        showUploadList
      } = props2;
      const {
        showDownloadIcon,
        showPreviewIcon,
        showRemoveIcon
      } = typeof showUploadList === "boolean" ? {} : showUploadList;
      return showUploadList ? createVNode(UploadList, {
        "prefixCls": prefixCls.value,
        "listType": props2.listType,
        "items": mergedFileList.value,
        "previewFile": previewFile,
        "onPreview": onPreview,
        "onDownload": onDownload,
        "onRemove": handleRemove,
        "showRemoveIcon": !mergedDisabled.value && showRemoveIcon,
        "showPreviewIcon": showPreviewIcon,
        "showDownloadIcon": showDownloadIcon,
        "removeIcon": removeIcon,
        "previewIcon": previewIcon,
        "downloadIcon": downloadIcon,
        "iconRender": iconRender,
        "locale": locale2.value,
        "isImageUrl": isImageUrl2,
        "progress": progress,
        "itemRender": itemRender,
        "appendActionVisible": buttonVisible,
        "appendAction": button
      }, _extends$1({}, slots)) : button === null || button === void 0 ? void 0 : button();
    };
    return () => {
      var _a2, _b, _c;
      const {
        listType,
        type: type4
      } = props2;
      const {
        class: className,
        style: styleName
      } = attrs, transAttrs = __rest$2(attrs, ["class", "style"]);
      const rcUploadProps = _extends$1(_extends$1(_extends$1({
        onBatchStart,
        onError,
        onProgress,
        onSuccess
      }, transAttrs), props2), {
        id: (_a2 = props2.id) !== null && _a2 !== void 0 ? _a2 : formItemContext.id.value,
        prefixCls: prefixCls.value,
        beforeUpload: mergedBeforeUpload,
        onChange: void 0,
        disabled: mergedDisabled.value
      });
      delete rcUploadProps.remove;
      if (!slots.default || mergedDisabled.value) {
        delete rcUploadProps.id;
      }
      const rtlCls = {
        [`${prefixCls.value}-rtl`]: direction.value === "rtl"
      };
      if (type4 === "drag") {
        const dragCls = classNames(prefixCls.value, {
          [`${prefixCls.value}-drag`]: true,
          [`${prefixCls.value}-drag-uploading`]: mergedFileList.value.some((file) => file.status === "uploading"),
          [`${prefixCls.value}-drag-hover`]: dragState.value === "dragover",
          [`${prefixCls.value}-disabled`]: mergedDisabled.value,
          [`${prefixCls.value}-rtl`]: direction.value === "rtl"
        }, attrs.class, hashId.value);
        return wrapSSR(createVNode("span", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
          "class": classNames(`${prefixCls.value}-wrapper`, rtlCls, className, hashId.value)
        }), [createVNode("div", {
          "class": dragCls,
          "onDrop": onFileDrop,
          "onDragover": onFileDrop,
          "onDragleave": onFileDrop,
          "style": attrs.style
        }, [createVNode(Upload$2, _objectSpread2$1(_objectSpread2$1({}, rcUploadProps), {}, {
          "ref": upload2,
          "class": `${prefixCls.value}-btn`
        }), _objectSpread2$1({
          default: () => [createVNode("div", {
            "class": `${prefixCls.value}-drag-container`
          }, [(_b = slots.default) === null || _b === void 0 ? void 0 : _b.call(slots)])]
        }, slots))]), renderUploadList()]));
      }
      const uploadButtonCls = classNames(prefixCls.value, {
        [`${prefixCls.value}-select`]: true,
        [`${prefixCls.value}-select-${listType}`]: true,
        [`${prefixCls.value}-disabled`]: mergedDisabled.value,
        [`${prefixCls.value}-rtl`]: direction.value === "rtl"
      });
      const children = flattenChildren((_c = slots.default) === null || _c === void 0 ? void 0 : _c.call(slots));
      const renderUploadButton = (uploadButtonStyle) => createVNode("div", {
        "class": uploadButtonCls,
        "style": uploadButtonStyle
      }, [createVNode(Upload$2, _objectSpread2$1(_objectSpread2$1({}, rcUploadProps), {}, {
        "ref": upload2
      }), slots)]);
      if (listType === "picture-card") {
        return wrapSSR(createVNode("span", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
          "class": classNames(`${prefixCls.value}-wrapper`, `${prefixCls.value}-picture-card-wrapper`, rtlCls, attrs.class, hashId.value)
        }), [renderUploadList(renderUploadButton, !!children.length)]));
      }
      return wrapSSR(createVNode("span", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "class": classNames(`${prefixCls.value}-wrapper`, rtlCls, attrs.class, hashId.value)
      }), [renderUploadButton(children.length ? void 0 : {
        display: "none"
      }), renderUploadList()]));
    };
  }
});
var __rest$1 = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const Dragger = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AUploadDragger",
  inheritAttrs: false,
  props: uploadProps(),
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    return () => {
      const {
        height
      } = props2, restProps = __rest$1(props2, ["height"]);
      const {
        style
      } = attrs, restAttrs = __rest$1(attrs, ["style"]);
      const draggerProps = _extends$1(_extends$1(_extends$1({}, restProps), restAttrs), {
        type: "drag",
        style: _extends$1(_extends$1({}, style), {
          height: typeof height === "number" ? `${height}px` : height
        })
      });
      return createVNode(Upload$1, draggerProps, slots);
    };
  }
});
const UploadDragger = Dragger;
const Upload = _extends$1(Upload$1, {
  Dragger,
  LIST_IGNORE,
  install(app) {
    app.component(Upload$1.name, Upload$1);
    app.component(Dragger.name, Dragger);
    return app;
  }
});
const genQRCodeStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [componentCls]: _extends$1(_extends$1({}, resetComponent(token2)), {
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      padding: token2.paddingSM,
      backgroundColor: token2.colorWhite,
      borderRadius: token2.borderRadiusLG,
      border: `${token2.lineWidth}px ${token2.lineType} ${token2.colorSplit}`,
      position: "relative",
      width: "100%",
      height: "100%",
      overflow: "hidden",
      [`& > ${componentCls}-mask`]: {
        position: "absolute",
        insetBlockStart: 0,
        insetInlineStart: 0,
        zIndex: 10,
        display: "flex",
        flexDirection: "column",
        justifyContent: "center",
        alignItems: "center",
        width: "100%",
        height: "100%",
        color: token2.colorText,
        lineHeight: token2.lineHeight,
        background: token2.QRCodeMaskBackgroundColor,
        textAlign: "center",
        [`& > ${componentCls}-expired , & > ${componentCls}-scanned`]: {
          color: token2.QRCodeTextColor
        }
      },
      "&-icon": {
        marginBlockEnd: token2.marginXS,
        fontSize: token2.controlHeight
      }
    }),
    [`${componentCls}-borderless`]: {
      borderColor: "transparent"
    }
  };
};
const useStyle$2 = genComponentStyleHook("QRCode", (token2) => genQRCodeStyle(merge(token2, {
  QRCodeTextColor: "rgba(0, 0, 0, 0.88)",
  QRCodeMaskBackgroundColor: "rgba(255, 255, 255, 0.96)"
})));
const qrProps = () => {
  return {
    size: {
      type: Number,
      default: 160
    },
    value: {
      type: String,
      required: true
    },
    type: stringType("canvas"),
    color: String,
    bgColor: String,
    includeMargin: Boolean,
    imageSettings: objectType()
  };
};
const qrcodeProps = () => {
  return _extends$1(_extends$1({}, qrProps()), {
    errorLevel: stringType("M"),
    icon: String,
    iconSize: {
      type: Number,
      default: 40
    },
    status: stringType("active"),
    bordered: {
      type: Boolean,
      default: true
    }
  });
};
/**
 * @license QR Code generator library (TypeScript)
 * Copyright (c) Project Nayuki.
 * SPDX-License-Identifier: MIT
 */
var qrcodegen;
(function(qrcodegen2) {
  class QrCode {
    /*-- Static factory functions (high level) --*/
    // Returns a QR Code representing the given Unicode text string at the given error correction level.
    // As a conservative upper bound, this function is guaranteed to succeed for strings that have 738 or fewer
    // Unicode code points (not UTF-16 code units) if the low error correction level is used. The smallest possible
    // QR Code version is automatically chosen for the output. The ECC level of the result may be higher than the
    // ecl argument if it can be done without increasing the version.
    static encodeText(text, ecl) {
      const segs = qrcodegen2.QrSegment.makeSegments(text);
      return QrCode.encodeSegments(segs, ecl);
    }
    // Returns a QR Code representing the given binary data at the given error correction level.
    // This function always encodes using the binary segment mode, not any text mode. The maximum number of
    // bytes allowed is 2953. The smallest possible QR Code version is automatically chosen for the output.
    // The ECC level of the result may be higher than the ecl argument if it can be done without increasing the version.
    static encodeBinary(data, ecl) {
      const seg = qrcodegen2.QrSegment.makeBytes(data);
      return QrCode.encodeSegments([seg], ecl);
    }
    /*-- Static factory functions (mid level) --*/
    // Returns a QR Code representing the given segments with the given encoding parameters.
    // The smallest possible QR Code version within the given range is automatically
    // chosen for the output. Iff boostEcl is true, then the ECC level of the result
    // may be higher than the ecl argument if it can be done without increasing the
    // version. The mask number is either between 0 to 7 (inclusive) to force that
    // mask, or -1 to automatically choose an appropriate mask (which may be slow).
    // This function allows the user to create a custom sequence of segments that switches
    // between modes (such as alphanumeric and byte) to encode text in less space.
    // This is a mid-level API; the high-level API is encodeText() and encodeBinary().
    static encodeSegments(segs, ecl) {
      let minVersion = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      let maxVersion = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 40;
      let mask = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : -1;
      let boostEcl = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : true;
      if (!(QrCode.MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= QrCode.MAX_VERSION) || mask < -1 || mask > 7) throw new RangeError("Invalid value");
      let version2;
      let dataUsedBits;
      for (version2 = minVersion; ; version2++) {
        const dataCapacityBits2 = QrCode.getNumDataCodewords(version2, ecl) * 8;
        const usedBits = QrSegment.getTotalBits(segs, version2);
        if (usedBits <= dataCapacityBits2) {
          dataUsedBits = usedBits;
          break;
        }
        if (version2 >= maxVersion)
          throw new RangeError("Data too long");
      }
      for (const newEcl of [QrCode.Ecc.MEDIUM, QrCode.Ecc.QUARTILE, QrCode.Ecc.HIGH]) {
        if (boostEcl && dataUsedBits <= QrCode.getNumDataCodewords(version2, newEcl) * 8) ecl = newEcl;
      }
      const bb = [];
      for (const seg of segs) {
        appendBits(seg.mode.modeBits, 4, bb);
        appendBits(seg.numChars, seg.mode.numCharCountBits(version2), bb);
        for (const b2 of seg.getData()) bb.push(b2);
      }
      assert(bb.length == dataUsedBits);
      const dataCapacityBits = QrCode.getNumDataCodewords(version2, ecl) * 8;
      assert(bb.length <= dataCapacityBits);
      appendBits(0, Math.min(4, dataCapacityBits - bb.length), bb);
      appendBits(0, (8 - bb.length % 8) % 8, bb);
      assert(bb.length % 8 == 0);
      for (let padByte = 236; bb.length < dataCapacityBits; padByte ^= 236 ^ 17) appendBits(padByte, 8, bb);
      const dataCodewords = [];
      while (dataCodewords.length * 8 < bb.length) dataCodewords.push(0);
      bb.forEach((b2, i2) => dataCodewords[i2 >>> 3] |= b2 << 7 - (i2 & 7));
      return new QrCode(version2, ecl, dataCodewords, mask);
    }
    /*-- Constructor (low level) and fields --*/
    // Creates a new QR Code with the given version number,
    // error correction level, data codeword bytes, and mask number.
    // This is a low-level API that most users should not use directly.
    // A mid-level API is the encodeSegments() function.
    constructor(version2, errorCorrectionLevel, dataCodewords, msk) {
      this.version = version2;
      this.errorCorrectionLevel = errorCorrectionLevel;
      this.modules = [];
      this.isFunction = [];
      if (version2 < QrCode.MIN_VERSION || version2 > QrCode.MAX_VERSION) throw new RangeError("Version value out of range");
      if (msk < -1 || msk > 7) throw new RangeError("Mask value out of range");
      this.size = version2 * 4 + 17;
      const row = [];
      for (let i2 = 0; i2 < this.size; i2++) row.push(false);
      for (let i2 = 0; i2 < this.size; i2++) {
        this.modules.push(row.slice());
        this.isFunction.push(row.slice());
      }
      this.drawFunctionPatterns();
      const allCodewords = this.addEccAndInterleave(dataCodewords);
      this.drawCodewords(allCodewords);
      if (msk == -1) {
        let minPenalty = 1e9;
        for (let i2 = 0; i2 < 8; i2++) {
          this.applyMask(i2);
          this.drawFormatBits(i2);
          const penalty = this.getPenaltyScore();
          if (penalty < minPenalty) {
            msk = i2;
            minPenalty = penalty;
          }
          this.applyMask(i2);
        }
      }
      assert(0 <= msk && msk <= 7);
      this.mask = msk;
      this.applyMask(msk);
      this.drawFormatBits(msk);
      this.isFunction = [];
    }
    /*-- Accessor methods --*/
    // Returns the color of the module (pixel) at the given coordinates, which is false
    // for light or true for dark. The top left corner has the coordinates (x=0, y=0).
    // If the given coordinates are out of bounds, then false (light) is returned.
    getModule(x2, y2) {
      return 0 <= x2 && x2 < this.size && 0 <= y2 && y2 < this.size && this.modules[y2][x2];
    }
    // Modified to expose modules for easy access
    getModules() {
      return this.modules;
    }
    /*-- Private helper methods for constructor: Drawing function modules --*/
    // Reads this object's version field, and draws and marks all function modules.
    drawFunctionPatterns() {
      for (let i2 = 0; i2 < this.size; i2++) {
        this.setFunctionModule(6, i2, i2 % 2 == 0);
        this.setFunctionModule(i2, 6, i2 % 2 == 0);
      }
      this.drawFinderPattern(3, 3);
      this.drawFinderPattern(this.size - 4, 3);
      this.drawFinderPattern(3, this.size - 4);
      const alignPatPos = this.getAlignmentPatternPositions();
      const numAlign = alignPatPos.length;
      for (let i2 = 0; i2 < numAlign; i2++) {
        for (let j2 = 0; j2 < numAlign; j2++) {
          if (!(i2 == 0 && j2 == 0 || i2 == 0 && j2 == numAlign - 1 || i2 == numAlign - 1 && j2 == 0)) this.drawAlignmentPattern(alignPatPos[i2], alignPatPos[j2]);
        }
      }
      this.drawFormatBits(0);
      this.drawVersion();
    }
    // Draws two copies of the format bits (with its own error correction code)
    // based on the given mask and this object's error correction level field.
    drawFormatBits(mask) {
      const data = this.errorCorrectionLevel.formatBits << 3 | mask;
      let rem = data;
      for (let i2 = 0; i2 < 10; i2++) rem = rem << 1 ^ (rem >>> 9) * 1335;
      const bits = (data << 10 | rem) ^ 21522;
      assert(bits >>> 15 == 0);
      for (let i2 = 0; i2 <= 5; i2++) this.setFunctionModule(8, i2, getBit(bits, i2));
      this.setFunctionModule(8, 7, getBit(bits, 6));
      this.setFunctionModule(8, 8, getBit(bits, 7));
      this.setFunctionModule(7, 8, getBit(bits, 8));
      for (let i2 = 9; i2 < 15; i2++) this.setFunctionModule(14 - i2, 8, getBit(bits, i2));
      for (let i2 = 0; i2 < 8; i2++) this.setFunctionModule(this.size - 1 - i2, 8, getBit(bits, i2));
      for (let i2 = 8; i2 < 15; i2++) this.setFunctionModule(8, this.size - 15 + i2, getBit(bits, i2));
      this.setFunctionModule(8, this.size - 8, true);
    }
    // Draws two copies of the version bits (with its own error correction code),
    // based on this object's version field, iff 7 <= version <= 40.
    drawVersion() {
      if (this.version < 7) return;
      let rem = this.version;
      for (let i2 = 0; i2 < 12; i2++) rem = rem << 1 ^ (rem >>> 11) * 7973;
      const bits = this.version << 12 | rem;
      assert(bits >>> 18 == 0);
      for (let i2 = 0; i2 < 18; i2++) {
        const color = getBit(bits, i2);
        const a2 = this.size - 11 + i2 % 3;
        const b2 = Math.floor(i2 / 3);
        this.setFunctionModule(a2, b2, color);
        this.setFunctionModule(b2, a2, color);
      }
    }
    // Draws a 9*9 finder pattern including the border separator,
    // with the center module at (x, y). Modules can be out of bounds.
    drawFinderPattern(x2, y2) {
      for (let dy = -4; dy <= 4; dy++) {
        for (let dx = -4; dx <= 4; dx++) {
          const dist = Math.max(Math.abs(dx), Math.abs(dy));
          const xx = x2 + dx;
          const yy = y2 + dy;
          if (0 <= xx && xx < this.size && 0 <= yy && yy < this.size) this.setFunctionModule(xx, yy, dist != 2 && dist != 4);
        }
      }
    }
    // Draws a 5*5 alignment pattern, with the center module
    // at (x, y). All modules must be in bounds.
    drawAlignmentPattern(x2, y2) {
      for (let dy = -2; dy <= 2; dy++) {
        for (let dx = -2; dx <= 2; dx++) this.setFunctionModule(x2 + dx, y2 + dy, Math.max(Math.abs(dx), Math.abs(dy)) != 1);
      }
    }
    // Sets the color of a module and marks it as a function module.
    // Only used by the constructor. Coordinates must be in bounds.
    setFunctionModule(x2, y2, isDark) {
      this.modules[y2][x2] = isDark;
      this.isFunction[y2][x2] = true;
    }
    /*-- Private helper methods for constructor: Codewords and masking --*/
    // Returns a new byte string representing the given data with the appropriate error correction
    // codewords appended to it, based on this object's version and error correction level.
    addEccAndInterleave(data) {
      const ver = this.version;
      const ecl = this.errorCorrectionLevel;
      if (data.length != QrCode.getNumDataCodewords(ver, ecl)) throw new RangeError("Invalid argument");
      const numBlocks = QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
      const blockEccLen = QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver];
      const rawCodewords = Math.floor(QrCode.getNumRawDataModules(ver) / 8);
      const numShortBlocks = numBlocks - rawCodewords % numBlocks;
      const shortBlockLen = Math.floor(rawCodewords / numBlocks);
      const blocks = [];
      const rsDiv = QrCode.reedSolomonComputeDivisor(blockEccLen);
      for (let i2 = 0, k2 = 0; i2 < numBlocks; i2++) {
        const dat = data.slice(k2, k2 + shortBlockLen - blockEccLen + (i2 < numShortBlocks ? 0 : 1));
        k2 += dat.length;
        const ecc = QrCode.reedSolomonComputeRemainder(dat, rsDiv);
        if (i2 < numShortBlocks) dat.push(0);
        blocks.push(dat.concat(ecc));
      }
      const result = [];
      for (let i2 = 0; i2 < blocks[0].length; i2++) {
        blocks.forEach((block, j2) => {
          if (i2 != shortBlockLen - blockEccLen || j2 >= numShortBlocks) result.push(block[i2]);
        });
      }
      assert(result.length == rawCodewords);
      return result;
    }
    // Draws the given sequence of 8-bit codewords (data and error correction) onto the entire
    // data area of this QR Code. Function modules need to be marked off before this is called.
    drawCodewords(data) {
      if (data.length != Math.floor(QrCode.getNumRawDataModules(this.version) / 8)) throw new RangeError("Invalid argument");
      let i2 = 0;
      for (let right = this.size - 1; right >= 1; right -= 2) {
        if (right == 6) right = 5;
        for (let vert = 0; vert < this.size; vert++) {
          for (let j2 = 0; j2 < 2; j2++) {
            const x2 = right - j2;
            const upward = (right + 1 & 2) == 0;
            const y2 = upward ? this.size - 1 - vert : vert;
            if (!this.isFunction[y2][x2] && i2 < data.length * 8) {
              this.modules[y2][x2] = getBit(data[i2 >>> 3], 7 - (i2 & 7));
              i2++;
            }
          }
        }
      }
      assert(i2 == data.length * 8);
    }
    // XORs the codeword modules in this QR Code with the given mask pattern.
    // The function modules must be marked and the codeword bits must be drawn
    // before masking. Due to the arithmetic of XOR, calling applyMask() with
    // the same mask value a second time will undo the mask. A final well-formed
    // QR Code needs exactly one (not zero, two, etc.) mask applied.
    applyMask(mask) {
      if (mask < 0 || mask > 7) throw new RangeError("Mask value out of range");
      for (let y2 = 0; y2 < this.size; y2++) {
        for (let x2 = 0; x2 < this.size; x2++) {
          let invert;
          switch (mask) {
            case 0:
              invert = (x2 + y2) % 2 == 0;
              break;
            case 1:
              invert = y2 % 2 == 0;
              break;
            case 2:
              invert = x2 % 3 == 0;
              break;
            case 3:
              invert = (x2 + y2) % 3 == 0;
              break;
            case 4:
              invert = (Math.floor(x2 / 3) + Math.floor(y2 / 2)) % 2 == 0;
              break;
            case 5:
              invert = x2 * y2 % 2 + x2 * y2 % 3 == 0;
              break;
            case 6:
              invert = (x2 * y2 % 2 + x2 * y2 % 3) % 2 == 0;
              break;
            case 7:
              invert = ((x2 + y2) % 2 + x2 * y2 % 3) % 2 == 0;
              break;
            default:
              throw new Error("Unreachable");
          }
          if (!this.isFunction[y2][x2] && invert) this.modules[y2][x2] = !this.modules[y2][x2];
        }
      }
    }
    // Calculates and returns the penalty score based on state of this QR Code's current modules.
    // This is used by the automatic mask choice algorithm to find the mask pattern that yields the lowest score.
    getPenaltyScore() {
      let result = 0;
      for (let y2 = 0; y2 < this.size; y2++) {
        let runColor = false;
        let runX = 0;
        const runHistory = [0, 0, 0, 0, 0, 0, 0];
        for (let x2 = 0; x2 < this.size; x2++) {
          if (this.modules[y2][x2] == runColor) {
            runX++;
            if (runX == 5) result += QrCode.PENALTY_N1;
            else if (runX > 5) result++;
          } else {
            this.finderPenaltyAddHistory(runX, runHistory);
            if (!runColor) result += this.finderPenaltyCountPatterns(runHistory) * QrCode.PENALTY_N3;
            runColor = this.modules[y2][x2];
            runX = 1;
          }
        }
        result += this.finderPenaltyTerminateAndCount(runColor, runX, runHistory) * QrCode.PENALTY_N3;
      }
      for (let x2 = 0; x2 < this.size; x2++) {
        let runColor = false;
        let runY = 0;
        const runHistory = [0, 0, 0, 0, 0, 0, 0];
        for (let y2 = 0; y2 < this.size; y2++) {
          if (this.modules[y2][x2] == runColor) {
            runY++;
            if (runY == 5) result += QrCode.PENALTY_N1;
            else if (runY > 5) result++;
          } else {
            this.finderPenaltyAddHistory(runY, runHistory);
            if (!runColor) result += this.finderPenaltyCountPatterns(runHistory) * QrCode.PENALTY_N3;
            runColor = this.modules[y2][x2];
            runY = 1;
          }
        }
        result += this.finderPenaltyTerminateAndCount(runColor, runY, runHistory) * QrCode.PENALTY_N3;
      }
      for (let y2 = 0; y2 < this.size - 1; y2++) {
        for (let x2 = 0; x2 < this.size - 1; x2++) {
          const color = this.modules[y2][x2];
          if (color == this.modules[y2][x2 + 1] && color == this.modules[y2 + 1][x2] && color == this.modules[y2 + 1][x2 + 1]) result += QrCode.PENALTY_N2;
        }
      }
      let dark = 0;
      for (const row of this.modules) dark = row.reduce((sum, color) => sum + (color ? 1 : 0), dark);
      const total = this.size * this.size;
      const k2 = Math.ceil(Math.abs(dark * 20 - total * 10) / total) - 1;
      assert(0 <= k2 && k2 <= 9);
      result += k2 * QrCode.PENALTY_N4;
      assert(0 <= result && result <= 2568888);
      return result;
    }
    /*-- Private helper functions --*/
    // Returns an ascending list of positions of alignment patterns for this version number.
    // Each position is in the range [0,177), and are used on both the x and y axes.
    // This could be implemented as lookup table of 40 variable-length lists of integers.
    getAlignmentPatternPositions() {
      if (this.version == 1) return [];
      else {
        const numAlign = Math.floor(this.version / 7) + 2;
        const step = this.version == 32 ? 26 : Math.ceil((this.version * 4 + 4) / (numAlign * 2 - 2)) * 2;
        const result = [6];
        for (let pos = this.size - 7; result.length < numAlign; pos -= step) result.splice(1, 0, pos);
        return result;
      }
    }
    // Returns the number of data bits that can be stored in a QR Code of the given version number, after
    // all function modules are excluded. This includes remainder bits, so it might not be a multiple of 8.
    // The result is in the range [208, 29648]. This could be implemented as a 40-entry lookup table.
    static getNumRawDataModules(ver) {
      if (ver < QrCode.MIN_VERSION || ver > QrCode.MAX_VERSION) throw new RangeError("Version number out of range");
      let result = (16 * ver + 128) * ver + 64;
      if (ver >= 2) {
        const numAlign = Math.floor(ver / 7) + 2;
        result -= (25 * numAlign - 10) * numAlign - 55;
        if (ver >= 7) result -= 36;
      }
      assert(208 <= result && result <= 29648);
      return result;
    }
    // Returns the number of 8-bit data (i.e. not error correction) codewords contained in any
    // QR Code of the given version number and error correction level, with remainder bits discarded.
    // This stateless pure function could be implemented as a (40*4)-cell lookup table.
    static getNumDataCodewords(ver, ecl) {
      return Math.floor(QrCode.getNumRawDataModules(ver) / 8) - QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver] * QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
    }
    // Returns a Reed-Solomon ECC generator polynomial for the given degree. This could be
    // implemented as a lookup table over all possible parameter values, instead of as an algorithm.
    static reedSolomonComputeDivisor(degree) {
      if (degree < 1 || degree > 255) throw new RangeError("Degree out of range");
      const result = [];
      for (let i2 = 0; i2 < degree - 1; i2++) result.push(0);
      result.push(1);
      let root2 = 1;
      for (let i2 = 0; i2 < degree; i2++) {
        for (let j2 = 0; j2 < result.length; j2++) {
          result[j2] = QrCode.reedSolomonMultiply(result[j2], root2);
          if (j2 + 1 < result.length) result[j2] ^= result[j2 + 1];
        }
        root2 = QrCode.reedSolomonMultiply(root2, 2);
      }
      return result;
    }
    // Returns the Reed-Solomon error correction codeword for the given data and divisor polynomials.
    static reedSolomonComputeRemainder(data, divisor) {
      const result = divisor.map((_2) => 0);
      for (const b2 of data) {
        const factor = b2 ^ result.shift();
        result.push(0);
        divisor.forEach((coef, i2) => result[i2] ^= QrCode.reedSolomonMultiply(coef, factor));
      }
      return result;
    }
    // Returns the product of the two given field elements modulo GF(2^8/0x11D). The arguments and result
    // are unsigned 8-bit integers. This could be implemented as a lookup table of 256*256 entries of uint8.
    static reedSolomonMultiply(x2, y2) {
      if (x2 >>> 8 != 0 || y2 >>> 8 != 0) throw new RangeError("Byte out of range");
      let z2 = 0;
      for (let i2 = 7; i2 >= 0; i2--) {
        z2 = z2 << 1 ^ (z2 >>> 7) * 285;
        z2 ^= (y2 >>> i2 & 1) * x2;
      }
      assert(z2 >>> 8 == 0);
      return z2;
    }
    // Can only be called immediately after a light run is added, and
    // returns either 0, 1, or 2. A helper function for getPenaltyScore().
    finderPenaltyCountPatterns(runHistory) {
      const n2 = runHistory[1];
      assert(n2 <= this.size * 3);
      const core = n2 > 0 && runHistory[2] == n2 && runHistory[3] == n2 * 3 && runHistory[4] == n2 && runHistory[5] == n2;
      return (core && runHistory[0] >= n2 * 4 && runHistory[6] >= n2 ? 1 : 0) + (core && runHistory[6] >= n2 * 4 && runHistory[0] >= n2 ? 1 : 0);
    }
    // Must be called at the end of a line (row or column) of modules. A helper function for getPenaltyScore().
    finderPenaltyTerminateAndCount(currentRunColor, currentRunLength, runHistory) {
      if (currentRunColor) {
        this.finderPenaltyAddHistory(currentRunLength, runHistory);
        currentRunLength = 0;
      }
      currentRunLength += this.size;
      this.finderPenaltyAddHistory(currentRunLength, runHistory);
      return this.finderPenaltyCountPatterns(runHistory);
    }
    // Pushes the given value to the front and drops the last value. A helper function for getPenaltyScore().
    finderPenaltyAddHistory(currentRunLength, runHistory) {
      if (runHistory[0] == 0) currentRunLength += this.size;
      runHistory.pop();
      runHistory.unshift(currentRunLength);
    }
  }
  QrCode.MIN_VERSION = 1;
  QrCode.MAX_VERSION = 40;
  QrCode.PENALTY_N1 = 3;
  QrCode.PENALTY_N2 = 3;
  QrCode.PENALTY_N3 = 40;
  QrCode.PENALTY_N4 = 10;
  QrCode.ECC_CODEWORDS_PER_BLOCK = [
    // Version: (note that index 0 is for padding, and is set to an illegal value)
    //0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
    [-1, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
    [-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28],
    [-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
    [-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30]
    // High
  ];
  QrCode.NUM_ERROR_CORRECTION_BLOCKS = [
    // Version: (note that index 0 is for padding, and is set to an illegal value)
    //0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
    [-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25],
    [-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49],
    [-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68],
    [-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81]
    // High
  ];
  qrcodegen2.QrCode = QrCode;
  function appendBits(val, len, bb) {
    if (len < 0 || len > 31 || val >>> len != 0) throw new RangeError("Value out of range");
    for (let i2 = len - 1; i2 >= 0; i2--) bb.push(val >>> i2 & 1);
  }
  function getBit(x2, i2) {
    return (x2 >>> i2 & 1) != 0;
  }
  function assert(cond) {
    if (!cond) throw new Error("Assertion error");
  }
  class QrSegment {
    /*-- Static factory functions (mid level) --*/
    // Returns a segment representing the given binary data encoded in
    // byte mode. All input byte arrays are acceptable. Any text string
    // can be converted to UTF-8 bytes and encoded as a byte mode segment.
    static makeBytes(data) {
      const bb = [];
      for (const b2 of data) appendBits(b2, 8, bb);
      return new QrSegment(QrSegment.Mode.BYTE, data.length, bb);
    }
    // Returns a segment representing the given string of decimal digits encoded in numeric mode.
    static makeNumeric(digits) {
      if (!QrSegment.isNumeric(digits)) throw new RangeError("String contains non-numeric characters");
      const bb = [];
      for (let i2 = 0; i2 < digits.length; ) {
        const n2 = Math.min(digits.length - i2, 3);
        appendBits(parseInt(digits.substring(i2, i2 + n2), 10), n2 * 3 + 1, bb);
        i2 += n2;
      }
      return new QrSegment(QrSegment.Mode.NUMERIC, digits.length, bb);
    }
    // Returns a segment representing the given text string encoded in alphanumeric mode.
    // The characters allowed are: 0 to 9, A to Z (uppercase only), space,
    // dollar, percent, asterisk, plus, hyphen, period, slash, colon.
    static makeAlphanumeric(text) {
      if (!QrSegment.isAlphanumeric(text)) throw new RangeError("String contains unencodable characters in alphanumeric mode");
      const bb = [];
      let i2;
      for (i2 = 0; i2 + 2 <= text.length; i2 += 2) {
        let temp = QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i2)) * 45;
        temp += QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i2 + 1));
        appendBits(temp, 11, bb);
      }
      if (i2 < text.length)
        appendBits(QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i2)), 6, bb);
      return new QrSegment(QrSegment.Mode.ALPHANUMERIC, text.length, bb);
    }
    // Returns a new mutable list of zero or more segments to represent the given Unicode text string.
    // The result may use various segment modes and switch modes to optimize the length of the bit stream.
    static makeSegments(text) {
      if (text == "") return [];
      else if (QrSegment.isNumeric(text)) return [QrSegment.makeNumeric(text)];
      else if (QrSegment.isAlphanumeric(text)) return [QrSegment.makeAlphanumeric(text)];
      else return [QrSegment.makeBytes(QrSegment.toUtf8ByteArray(text))];
    }
    // Returns a segment representing an Extended Channel Interpretation
    // (ECI) designator with the given assignment value.
    static makeEci(assignVal) {
      const bb = [];
      if (assignVal < 0) throw new RangeError("ECI assignment value out of range");
      else if (assignVal < 1 << 7) appendBits(assignVal, 8, bb);
      else if (assignVal < 1 << 14) {
        appendBits(2, 2, bb);
        appendBits(assignVal, 14, bb);
      } else if (assignVal < 1e6) {
        appendBits(6, 3, bb);
        appendBits(assignVal, 21, bb);
      } else throw new RangeError("ECI assignment value out of range");
      return new QrSegment(QrSegment.Mode.ECI, 0, bb);
    }
    // Tests whether the given string can be encoded as a segment in numeric mode.
    // A string is encodable iff each character is in the range 0 to 9.
    static isNumeric(text) {
      return QrSegment.NUMERIC_REGEX.test(text);
    }
    // Tests whether the given string can be encoded as a segment in alphanumeric mode.
    // A string is encodable iff each character is in the following set: 0 to 9, A to Z
    // (uppercase only), space, dollar, percent, asterisk, plus, hyphen, period, slash, colon.
    static isAlphanumeric(text) {
      return QrSegment.ALPHANUMERIC_REGEX.test(text);
    }
    /*-- Constructor (low level) and fields --*/
    // Creates a new QR Code segment with the given attributes and data.
    // The character count (numChars) must agree with the mode and the bit buffer length,
    // but the constraint isn't checked. The given bit buffer is cloned and stored.
    constructor(mode, numChars, bitData) {
      this.mode = mode;
      this.numChars = numChars;
      this.bitData = bitData;
      if (numChars < 0) throw new RangeError("Invalid argument");
      this.bitData = bitData.slice();
    }
    /*-- Methods --*/
    // Returns a new copy of the data bits of this segment.
    getData() {
      return this.bitData.slice();
    }
    // (Package-private) Calculates and returns the number of bits needed to encode the given segments at
    // the given version. The result is infinity if a segment has too many characters to fit its length field.
    static getTotalBits(segs, version2) {
      let result = 0;
      for (const seg of segs) {
        const ccbits = seg.mode.numCharCountBits(version2);
        if (seg.numChars >= 1 << ccbits) return Infinity;
        result += 4 + ccbits + seg.bitData.length;
      }
      return result;
    }
    // Returns a new array of bytes representing the given string encoded in UTF-8.
    static toUtf8ByteArray(str) {
      str = encodeURI(str);
      const result = [];
      for (let i2 = 0; i2 < str.length; i2++) {
        if (str.charAt(i2) != "%") result.push(str.charCodeAt(i2));
        else {
          result.push(parseInt(str.substring(i2 + 1, i2 + 3), 16));
          i2 += 2;
        }
      }
      return result;
    }
  }
  QrSegment.NUMERIC_REGEX = /^[0-9]*$/;
  QrSegment.ALPHANUMERIC_REGEX = /^[A-Z0-9 $%*+.\/:-]*$/;
  QrSegment.ALPHANUMERIC_CHARSET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";
  qrcodegen2.QrSegment = QrSegment;
})(qrcodegen || (qrcodegen = {}));
(function(qrcodegen2) {
  (function(QrCode) {
    class Ecc {
      /*-- Constructor and fields --*/
      constructor(ordinal, formatBits) {
        this.ordinal = ordinal;
        this.formatBits = formatBits;
      }
    }
    Ecc.LOW = new Ecc(0, 1);
    Ecc.MEDIUM = new Ecc(1, 0);
    Ecc.QUARTILE = new Ecc(2, 3);
    Ecc.HIGH = new Ecc(3, 2);
    QrCode.Ecc = Ecc;
  })(qrcodegen2.QrCode || (qrcodegen2.QrCode = {}));
})(qrcodegen || (qrcodegen = {}));
(function(qrcodegen2) {
  (function(QrSegment) {
    class Mode {
      /*-- Constructor and fields --*/
      constructor(modeBits, numBitsCharCount) {
        this.modeBits = modeBits;
        this.numBitsCharCount = numBitsCharCount;
      }
      /*-- Method --*/
      // (Package-private) Returns the bit width of the character count field for a segment in
      // this mode in a QR Code at the given version number. The result is in the range [0, 16].
      numCharCountBits(ver) {
        return this.numBitsCharCount[Math.floor((ver + 7) / 17)];
      }
    }
    Mode.NUMERIC = new Mode(1, [10, 12, 14]);
    Mode.ALPHANUMERIC = new Mode(2, [9, 11, 13]);
    Mode.BYTE = new Mode(4, [8, 16, 16]);
    Mode.KANJI = new Mode(8, [8, 10, 12]);
    Mode.ECI = new Mode(7, [0, 0, 0]);
    QrSegment.Mode = Mode;
  })(qrcodegen2.QrSegment || (qrcodegen2.QrSegment = {}));
})(qrcodegen || (qrcodegen = {}));
const ERROR_LEVEL_MAP = {
  L: qrcodegen.QrCode.Ecc.LOW,
  M: qrcodegen.QrCode.Ecc.MEDIUM,
  Q: qrcodegen.QrCode.Ecc.QUARTILE,
  H: qrcodegen.QrCode.Ecc.HIGH
};
const DEFAULT_SIZE = 128;
const DEFAULT_LEVEL = "L";
const DEFAULT_BGCOLOR = "#FFFFFF";
const DEFAULT_FGCOLOR = "#000000";
const DEFAULT_INCLUDEMARGIN = false;
const SPEC_MARGIN_SIZE = 4;
const DEFAULT_MARGIN_SIZE = 0;
const DEFAULT_IMG_SCALE = 0.1;
function generatePath(modules) {
  let margin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  const ops = [];
  modules.forEach(function(row, y2) {
    let start = null;
    row.forEach(function(cell, x2) {
      if (!cell && start !== null) {
        ops.push(`M${start + margin} ${y2 + margin}h${x2 - start}v1H${start + margin}z`);
        start = null;
        return;
      }
      if (x2 === row.length - 1) {
        if (!cell) {
          return;
        }
        if (start === null) {
          ops.push(`M${x2 + margin},${y2 + margin} h1v1H${x2 + margin}z`);
        } else {
          ops.push(`M${start + margin},${y2 + margin} h${x2 + 1 - start}v1H${start + margin}z`);
        }
        return;
      }
      if (cell && start === null) {
        start = x2;
      }
    });
  });
  return ops.join("");
}
function excavateModules(modules, excavation) {
  return modules.slice().map((row, y2) => {
    if (y2 < excavation.y || y2 >= excavation.y + excavation.h) {
      return row;
    }
    return row.map((cell, x2) => {
      if (x2 < excavation.x || x2 >= excavation.x + excavation.w) {
        return cell;
      }
      return false;
    });
  });
}
function getImageSettings(cells, size, margin, imageSettings) {
  if (imageSettings == null) {
    return null;
  }
  const numCells = cells.length + margin * 2;
  const defaultSize = Math.floor(size * DEFAULT_IMG_SCALE);
  const scale = numCells / size;
  const w2 = (imageSettings.width || defaultSize) * scale;
  const h2 = (imageSettings.height || defaultSize) * scale;
  const x2 = imageSettings.x == null ? cells.length / 2 - w2 / 2 : imageSettings.x * scale;
  const y2 = imageSettings.y == null ? cells.length / 2 - h2 / 2 : imageSettings.y * scale;
  let excavation = null;
  if (imageSettings.excavate) {
    const floorX = Math.floor(x2);
    const floorY = Math.floor(y2);
    const ceilW = Math.ceil(w2 + x2 - floorX);
    const ceilH = Math.ceil(h2 + y2 - floorY);
    excavation = {
      x: floorX,
      y: floorY,
      w: ceilW,
      h: ceilH
    };
  }
  return {
    x: x2,
    y: y2,
    h: h2,
    w: w2,
    excavation
  };
}
function getMarginSize(includeMargin, marginSize) {
  if (marginSize != null) {
    return Math.floor(marginSize);
  }
  return includeMargin ? SPEC_MARGIN_SIZE : DEFAULT_MARGIN_SIZE;
}
const SUPPORTS_PATH2D = function() {
  try {
    new Path2D().addPath(new Path2D());
  } catch (e2) {
    return false;
  }
  return true;
}();
const QRCodeCanvas = defineComponent({
  name: "QRCodeCanvas",
  inheritAttrs: false,
  props: _extends$1(_extends$1({}, qrProps()), {
    level: String,
    bgColor: String,
    fgColor: String,
    marginSize: Number
  }),
  setup(props2, _ref) {
    let {
      attrs,
      expose
    } = _ref;
    const imgSrc = computed(() => {
      var _a2;
      return (_a2 = props2.imageSettings) === null || _a2 === void 0 ? void 0 : _a2.src;
    });
    const _canvas = shallowRef(null);
    const _image = shallowRef(null);
    const isImgLoaded = shallowRef(false);
    expose({
      toDataURL: (type4, quality) => {
        var _a2;
        return (_a2 = _canvas.value) === null || _a2 === void 0 ? void 0 : _a2.toDataURL(type4, quality);
      }
    });
    watchEffect(() => {
      const {
        value,
        size = DEFAULT_SIZE,
        level = DEFAULT_LEVEL,
        bgColor = DEFAULT_BGCOLOR,
        fgColor = DEFAULT_FGCOLOR,
        includeMargin = DEFAULT_INCLUDEMARGIN,
        marginSize,
        imageSettings
      } = props2;
      if (_canvas.value != null) {
        const canvas = _canvas.value;
        const ctx = canvas.getContext("2d");
        if (!ctx) {
          return;
        }
        let cells = qrcodegen.QrCode.encodeText(value, ERROR_LEVEL_MAP[level]).getModules();
        const margin = getMarginSize(includeMargin, marginSize);
        const numCells = cells.length + margin * 2;
        const calculatedImageSettings = getImageSettings(cells, size, margin, imageSettings);
        const image = _image.value;
        const haveImageToRender = isImgLoaded.value && calculatedImageSettings != null && image !== null && image.complete && image.naturalHeight !== 0 && image.naturalWidth !== 0;
        if (haveImageToRender) {
          if (calculatedImageSettings.excavation != null) {
            cells = excavateModules(cells, calculatedImageSettings.excavation);
          }
        }
        const pixelRatio = window.devicePixelRatio || 1;
        canvas.height = canvas.width = size * pixelRatio;
        const scale = size / numCells * pixelRatio;
        ctx.scale(scale, scale);
        ctx.fillStyle = bgColor;
        ctx.fillRect(0, 0, numCells, numCells);
        ctx.fillStyle = fgColor;
        if (SUPPORTS_PATH2D) {
          ctx.fill(new Path2D(generatePath(cells, margin)));
        } else {
          cells.forEach(function(row, rdx) {
            row.forEach(function(cell, cdx) {
              if (cell) {
                ctx.fillRect(cdx + margin, rdx + margin, 1, 1);
              }
            });
          });
        }
        if (haveImageToRender) {
          ctx.drawImage(image, calculatedImageSettings.x + margin, calculatedImageSettings.y + margin, calculatedImageSettings.w, calculatedImageSettings.h);
        }
      }
    }, {
      flush: "post"
    });
    watch(imgSrc, () => {
      isImgLoaded.value = false;
    });
    return () => {
      var _a2;
      const size = (_a2 = props2.size) !== null && _a2 !== void 0 ? _a2 : DEFAULT_SIZE;
      const canvasStyle = {
        height: `${size}px`,
        width: `${size}px`
      };
      let img = null;
      if (imgSrc.value != null) {
        img = createVNode("img", {
          "src": imgSrc.value,
          "key": imgSrc.value,
          "style": {
            display: "none"
          },
          "onLoad": () => {
            isImgLoaded.value = true;
          },
          "ref": _image
        }, null);
      }
      return createVNode(Fragment, null, [createVNode("canvas", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "style": [canvasStyle, attrs.style],
        "ref": _canvas
      }), null), img]);
    };
  }
});
const QRCodeSVG = defineComponent({
  name: "QRCodeSVG",
  inheritAttrs: false,
  props: _extends$1(_extends$1({}, qrProps()), {
    color: String,
    level: String,
    bgColor: String,
    fgColor: String,
    marginSize: Number,
    title: String
  }),
  setup(props2) {
    let cells = null;
    let margin = null;
    let numCells = null;
    let calculatedImageSettings = null;
    let fgPath = null;
    let image = null;
    watchEffect(() => {
      const {
        value,
        size = DEFAULT_SIZE,
        level = DEFAULT_LEVEL,
        includeMargin = DEFAULT_INCLUDEMARGIN,
        marginSize,
        imageSettings
      } = props2;
      cells = qrcodegen.QrCode.encodeText(value, ERROR_LEVEL_MAP[level]).getModules();
      margin = getMarginSize(includeMargin, marginSize);
      numCells = cells.length + margin * 2;
      calculatedImageSettings = getImageSettings(cells, size, margin, imageSettings);
      if (imageSettings != null && calculatedImageSettings != null) {
        if (calculatedImageSettings.excavation != null) {
          cells = excavateModules(cells, calculatedImageSettings.excavation);
        }
        image = createVNode("image", {
          "xlink:href": imageSettings.src,
          "height": calculatedImageSettings.h,
          "width": calculatedImageSettings.w,
          "x": calculatedImageSettings.x + margin,
          "y": calculatedImageSettings.y + margin,
          "preserveAspectRatio": "none"
        }, null);
      }
      fgPath = generatePath(cells, margin);
    });
    return () => {
      const bgColor = props2.bgColor && DEFAULT_BGCOLOR;
      const fgColor = props2.fgColor && DEFAULT_FGCOLOR;
      return createVNode("svg", {
        "height": props2.size,
        "width": props2.size,
        "viewBox": `0 0 ${numCells} ${numCells}`
      }, [!!props2.title && createVNode("title", null, [props2.title]), createVNode("path", {
        "fill": bgColor,
        "d": `M0,0 h${numCells}v${numCells}H0z`,
        "shape-rendering": "crispEdges"
      }, null), createVNode("path", {
        "fill": fgColor,
        "d": fgPath,
        "shape-rendering": "crispEdges"
      }, null), image]);
    };
  }
});
const QRCode = defineComponent({
  name: "AQrcode",
  inheritAttrs: false,
  props: qrcodeProps(),
  emits: ["refresh"],
  setup(props2, _ref) {
    let {
      emit,
      attrs,
      expose
    } = _ref;
    const [locale2] = useLocaleReceiver("QRCode");
    const {
      prefixCls
    } = useConfigInject("qrcode", props2);
    const [wrapSSR, hashId] = useStyle$2(prefixCls);
    const [, token2] = useToken$1();
    const qrCodeCanvas = ref();
    expose({
      toDataURL: (type4, quality) => {
        var _a2;
        return (_a2 = qrCodeCanvas.value) === null || _a2 === void 0 ? void 0 : _a2.toDataURL(type4, quality);
      }
    });
    const qrCodeProps = computed(() => {
      const {
        value,
        icon = "",
        size = 160,
        iconSize = 40,
        color = token2.value.colorText,
        bgColor = "transparent",
        errorLevel = "M"
      } = props2;
      const imageSettings = {
        src: icon,
        x: void 0,
        y: void 0,
        height: iconSize,
        width: iconSize,
        excavate: true
      };
      return {
        value,
        size: size - (token2.value.paddingSM + token2.value.lineWidth) * 2,
        level: errorLevel,
        bgColor,
        fgColor: color,
        imageSettings: icon ? imageSettings : void 0
      };
    });
    return () => {
      const pre = prefixCls.value;
      return wrapSSR(createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "style": [attrs.style, {
          width: `${props2.size}px`,
          height: `${props2.size}px`,
          backgroundColor: qrCodeProps.value.bgColor
        }],
        "class": [hashId.value, pre, {
          [`${pre}-borderless`]: !props2.bordered
        }]
      }), [props2.status !== "active" && createVNode("div", {
        "class": `${pre}-mask`
      }, [props2.status === "loading" && createVNode(Spin, null, null), props2.status === "expired" && createVNode(Fragment, null, [createVNode("p", {
        "class": `${pre}-expired`
      }, [locale2.value.expired]), createVNode(Button$1, {
        "type": "link",
        "onClick": (e2) => emit("refresh", e2)
      }, {
        default: () => [locale2.value.refresh],
        icon: () => createVNode(ReloadOutlined, null, null)
      })]), props2.status === "scanned" && createVNode("p", {
        "class": `${pre}-scanned`
      }, [locale2.value.scanned])]), props2.type === "canvas" ? createVNode(QRCodeCanvas, _objectSpread2$1({
        "ref": qrCodeCanvas
      }, qrCodeProps.value), null) : createVNode(QRCodeSVG, qrCodeProps.value, null)]));
    };
  }
});
const QRCode$1 = withInstall(QRCode);
const AppConfigContextKey = Symbol("appConfigContext");
const useProvideAppConfigContext = (appConfigContext) => {
  return provide(AppConfigContextKey, appConfigContext);
};
const useInjectAppConfigContext = () => {
  return inject(AppConfigContextKey, {});
};
const AppContextKey = Symbol("appContext");
const useProvideAppContext = (appContext) => {
  return provide(AppContextKey, appContext);
};
const defaultAppContext = reactive({
  message: {},
  notification: {},
  modal: {}
});
const useInjectAppContext = () => {
  return inject(AppContextKey, defaultAppContext);
};
const genBaseStyle = (token2) => {
  const {
    componentCls,
    colorText,
    fontSize,
    lineHeight,
    fontFamily
  } = token2;
  return {
    [componentCls]: {
      color: colorText,
      fontSize,
      lineHeight,
      fontFamily
    }
  };
};
const useStyle$1 = genComponentStyleHook("App", (token2) => [genBaseStyle(token2)]);
const AppProps = () => {
  return {
    rootClassName: String,
    message: objectType(),
    notification: objectType()
  };
};
const useApp = () => {
  return useInjectAppContext();
};
const App = defineComponent({
  name: "AApp",
  props: initDefaultProps(AppProps(), {}),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      prefixCls
    } = useConfigInject("app", props2);
    const [wrapSSR, hashId] = useStyle$1(prefixCls);
    const customClassName = computed(() => {
      return classNames(hashId.value, prefixCls.value, props2.rootClassName);
    });
    const appConfig = useInjectAppConfigContext();
    const mergedAppConfig = computed(() => ({
      message: _extends$1(_extends$1({}, appConfig.message), props2.message),
      notification: _extends$1(_extends$1({}, appConfig.notification), props2.notification)
    }));
    useProvideAppConfigContext(mergedAppConfig.value);
    const [messageApi, messageContextHolder] = useMessage(mergedAppConfig.value.message);
    const [notificationApi, notificationContextHolder] = useNotification(mergedAppConfig.value.notification);
    const [ModalApi, ModalContextHolder] = useModal();
    const memoizedContextValue = computed(() => ({
      message: messageApi,
      notification: notificationApi,
      modal: ModalApi
    }));
    useProvideAppContext(memoizedContextValue.value);
    return () => {
      var _a2;
      return wrapSSR(createVNode("div", {
        "class": customClassName.value
      }, [ModalContextHolder(), messageContextHolder(), notificationContextHolder(), (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]));
    };
  }
});
App.useApp = useApp;
App.install = function(app) {
  app.component(App.name, App);
};
const flexWrapValues = ["wrap", "nowrap", "wrap-reverse"];
const justifyContentValues = ["flex-start", "flex-end", "start", "end", "center", "space-between", "space-around", "space-evenly", "stretch", "normal", "left", "right"];
const alignItemsValues = ["center", "start", "end", "flex-start", "flex-end", "self-start", "self-end", "baseline", "normal", "stretch"];
const genClsWrap = (prefixCls, props2) => {
  const wrapCls = {};
  flexWrapValues.forEach((cssKey) => {
    wrapCls[`${prefixCls}-wrap-${cssKey}`] = props2.wrap === cssKey;
  });
  return wrapCls;
};
const genClsAlign = (prefixCls, props2) => {
  const alignCls = {};
  alignItemsValues.forEach((cssKey) => {
    alignCls[`${prefixCls}-align-${cssKey}`] = props2.align === cssKey;
  });
  alignCls[`${prefixCls}-align-stretch`] = !props2.align && !!props2.vertical;
  return alignCls;
};
const genClsJustify = (prefixCls, props2) => {
  const justifyCls = {};
  justifyContentValues.forEach((cssKey) => {
    justifyCls[`${prefixCls}-justify-${cssKey}`] = props2.justify === cssKey;
  });
  return justifyCls;
};
function createFlexClassNames(prefixCls, props2) {
  return classNames(_extends$1(_extends$1(_extends$1({}, genClsWrap(prefixCls, props2)), genClsAlign(prefixCls, props2)), genClsJustify(prefixCls, props2)));
}
const genFlexStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [componentCls]: {
      display: "flex",
      "&-vertical": {
        flexDirection: "column"
      },
      "&-rtl": {
        direction: "rtl"
      },
      "&:empty": {
        display: "none"
      }
    }
  };
};
const genFlexGapStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [componentCls]: {
      "&-gap-small": {
        gap: token2.flexGapSM
      },
      "&-gap-middle": {
        gap: token2.flexGap
      },
      "&-gap-large": {
        gap: token2.flexGapLG
      }
    }
  };
};
const genFlexWrapStyle = (token2) => {
  const {
    componentCls
  } = token2;
  const wrapStyle = {};
  flexWrapValues.forEach((value) => {
    wrapStyle[`${componentCls}-wrap-${value}`] = {
      flexWrap: value
    };
  });
  return wrapStyle;
};
const genAlignItemsStyle = (token2) => {
  const {
    componentCls
  } = token2;
  const alignStyle = {};
  alignItemsValues.forEach((value) => {
    alignStyle[`${componentCls}-align-${value}`] = {
      alignItems: value
    };
  });
  return alignStyle;
};
const genJustifyContentStyle = (token2) => {
  const {
    componentCls
  } = token2;
  const justifyStyle = {};
  justifyContentValues.forEach((value) => {
    justifyStyle[`${componentCls}-justify-${value}`] = {
      justifyContent: value
    };
  });
  return justifyStyle;
};
const useStyle = genComponentStyleHook("Flex", (token2) => {
  const flexToken = merge(token2, {
    flexGapSM: token2.paddingXS,
    flexGap: token2.padding,
    flexGapLG: token2.paddingLG
  });
  return [genFlexStyle(flexToken), genFlexGapStyle(flexToken), genFlexWrapStyle(flexToken), genAlignItemsStyle(flexToken), genJustifyContentStyle(flexToken)];
});
function isPresetSize(size) {
  return ["small", "middle", "large"].includes(size);
}
const flexProps = () => ({
  prefixCls: stringType(),
  vertical: booleanType(),
  wrap: stringType(),
  justify: stringType(),
  align: stringType(),
  flex: someType([Number, String]),
  gap: someType([Number, String]),
  component: anyType()
});
var __rest = function(s2, e2) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0) t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
    if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2])) t2[p[i2]] = s2[p[i2]];
  }
  return t2;
};
const AFlex = defineComponent({
  name: "AFlex",
  inheritAttrs: false,
  props: flexProps(),
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const {
      flex: ctxFlex,
      direction: ctxDirection
    } = useConfigContextInject();
    const {
      prefixCls
    } = useConfigInject("flex", props2);
    const [wrapSSR, hashId] = useStyle(prefixCls);
    const mergedCls = computed(() => {
      var _a2;
      return [prefixCls.value, hashId.value, createFlexClassNames(prefixCls.value, props2), {
        [`${prefixCls.value}-rtl`]: ctxDirection.value === "rtl",
        [`${prefixCls.value}-gap-${props2.gap}`]: isPresetSize(props2.gap),
        [`${prefixCls.value}-vertical`]: (_a2 = props2.vertical) !== null && _a2 !== void 0 ? _a2 : ctxFlex === null || ctxFlex === void 0 ? void 0 : ctxFlex.value.vertical
      }];
    });
    return () => {
      var _a2;
      const {
        flex,
        gap,
        component: Component = "div"
      } = props2, othersProps = __rest(props2, ["flex", "gap", "component"]);
      const mergedStyle = {};
      if (flex) {
        mergedStyle.flex = flex;
      }
      if (gap && !isPresetSize(gap)) {
        mergedStyle.gap = `${gap}px`;
      }
      return wrapSSR(createVNode(Component, _objectSpread2$1({
        "class": [attrs.class, mergedCls.value],
        "style": [attrs.style, mergedStyle]
      }, omit$1(othersProps, ["justify", "wrap", "align", "vertical"])), {
        default: () => [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]
      }));
    };
  }
});
const Flex = withInstall(AFlex);
const getAlphaColor = (baseColor, alpha) => new TinyColor(baseColor).setAlpha(alpha).toRgbString();
const getSolidColor = (baseColor, brightness) => {
  const instance = new TinyColor(baseColor);
  return instance.lighten(brightness).toHexString();
};
const generateColorPalettes = (baseColor) => {
  const colors = generate$1(baseColor, {
    theme: "dark"
  });
  return {
    1: colors[0],
    2: colors[1],
    3: colors[2],
    4: colors[3],
    5: colors[6],
    6: colors[5],
    7: colors[4],
    8: colors[6],
    9: colors[5],
    10: colors[4]
    // 8: colors[9],
    // 9: colors[8],
    // 10: colors[7],
  };
};
const generateNeutralColorPalettes = (bgBaseColor, textBaseColor) => {
  const colorBgBase = bgBaseColor || "#000";
  const colorTextBase = textBaseColor || "#fff";
  return {
    colorBgBase,
    colorTextBase,
    colorText: getAlphaColor(colorTextBase, 0.85),
    colorTextSecondary: getAlphaColor(colorTextBase, 0.65),
    colorTextTertiary: getAlphaColor(colorTextBase, 0.45),
    colorTextQuaternary: getAlphaColor(colorTextBase, 0.25),
    colorFill: getAlphaColor(colorTextBase, 0.18),
    colorFillSecondary: getAlphaColor(colorTextBase, 0.12),
    colorFillTertiary: getAlphaColor(colorTextBase, 0.08),
    colorFillQuaternary: getAlphaColor(colorTextBase, 0.04),
    colorBgElevated: getSolidColor(colorBgBase, 12),
    colorBgContainer: getSolidColor(colorBgBase, 8),
    colorBgLayout: getSolidColor(colorBgBase, 0),
    colorBgSpotlight: getSolidColor(colorBgBase, 26),
    colorBorder: getSolidColor(colorBgBase, 26),
    colorBorderSecondary: getSolidColor(colorBgBase, 19)
  };
};
const derivative$1 = (token2, mapToken) => {
  const colorPalettes = Object.keys(defaultPresetColors).map((colorKey) => {
    const colors = generate$1(token2[colorKey], {
      theme: "dark"
    });
    return new Array(10).fill(1).reduce((prev2, _2, i2) => {
      prev2[`${colorKey}-${i2 + 1}`] = colors[i2];
      return prev2;
    }, {});
  }).reduce((prev2, cur) => {
    prev2 = _extends$1(_extends$1({}, prev2), cur);
    return prev2;
  }, {});
  const mergedMapToken = mapToken !== null && mapToken !== void 0 ? mapToken : derivative$2(token2);
  return _extends$1(_extends$1(_extends$1({}, mergedMapToken), colorPalettes), genColorMapToken(token2, {
    generateColorPalettes,
    generateNeutralColorPalettes
  }));
};
function genSizeMapToken(token2) {
  const {
    sizeUnit,
    sizeStep
  } = token2;
  const compactSizeStep = sizeStep - 2;
  return {
    sizeXXL: sizeUnit * (compactSizeStep + 10),
    sizeXL: sizeUnit * (compactSizeStep + 6),
    sizeLG: sizeUnit * (compactSizeStep + 2),
    sizeMD: sizeUnit * (compactSizeStep + 2),
    sizeMS: sizeUnit * (compactSizeStep + 1),
    size: sizeUnit * compactSizeStep,
    sizeSM: sizeUnit * compactSizeStep,
    sizeXS: sizeUnit * (compactSizeStep - 1),
    sizeXXS: sizeUnit * (compactSizeStep - 1)
  };
}
const derivative = (token2, mapToken) => {
  const mergedMapToken = mapToken !== null && mapToken !== void 0 ? mapToken : derivative$2(token2);
  const fontSize = mergedMapToken.fontSizeSM;
  const controlHeight = mergedMapToken.controlHeight - 4;
  return _extends$1(_extends$1(_extends$1(_extends$1(_extends$1({}, mergedMapToken), genSizeMapToken(mapToken !== null && mapToken !== void 0 ? mapToken : token2)), genFontMapToken(fontSize)), {
    // controlHeight
    controlHeight
  }), genControlHeight(_extends$1(_extends$1({}, mergedMapToken), {
    controlHeight
  })));
};
function useToken() {
  const [theme2, token2, hashId] = useToken$1();
  return {
    theme: theme2,
    token: token2,
    hashId
  };
}
const theme = {
  /** @private Test Usage. Do not use in production. */
  defaultConfig,
  /** Default seedToken */
  defaultSeed: defaultConfig.token,
  useToken,
  defaultAlgorithm: derivative$2,
  darkAlgorithm: derivative$1,
  compactAlgorithm: derivative
};
export {
  CheckboxGroup as $,
  ApartmentOutlined as A,
  Button$1 as B,
  CalendarOutlined as C,
  DashboardOutlined as D,
  EnvironmentOutlined as E,
  Flex as F,
  GlobalOutlined as G,
  Dropdown as H,
  SettingOutlined as I,
  LogoutOutlined as J,
  KeyOutlined as K,
  LayoutContent as L,
  Menu as M,
  Space as N,
  Text as O,
  Pagination$2 as P,
  MenuUnfoldOutlined as Q,
  Result as R,
  Switch$1 as S,
  TeamOutlined as T,
  UserOutlined as U,
  MenuFoldOutlined as V,
  LayoutHeader as W,
  LayoutSider as X,
  Layout as Y,
  Title as Z,
  _extends$1 as _,
  isArray as a,
  Table as a0,
  Checkbox as a1,
  Calendar$1 as a2,
  FlagTwoTone as a3,
  BookTwoTone as a4,
  PhoneTwoTone as a5,
  PlusCircleTwoTone as a6,
  Divider$1 as a7,
  List as a8,
  ListItemMeta as a9,
  RotateLeftOutlined as aA,
  Image$1 as aB,
  Card as aC,
  TimePicker$1 as aD,
  Tooltip as aE,
  InputNumber$1 as aF,
  Radio as aG,
  CloseOutlined as aH,
  Slider$1 as aI,
  Drawer$1 as aJ,
  spinProps as aK,
  Spin as aL,
  UploadDragger as aM,
  InboxOutlined as aN,
  skeletonProps as aO,
  Skeleton as aP,
  Link as aa,
  ListItem$1 as ab,
  Tree as ac,
  DownOutlined as ad,
  Modal as ae,
  commonjsGlobal as af,
  InputSearch as ag,
  Popconfirm$1 as ah,
  Avatar as ai,
  Form as aj,
  FormItem as ak,
  Input as al,
  Cascader$1 as am,
  Select as an,
  DatePicker$1 as ao,
  Upload as ap,
  LoadingOutlined as aq,
  PlusOutlined as ar,
  Row as as,
  Col as at,
  ExclamationCircleOutlined as au,
  Textarea as av,
  cloneDeep as aw,
  QRCode$1 as ax,
  UploadOutlined as ay,
  RotateRightOutlined as az,
  isBuffer as b,
  isTypedArray as c,
  isArguments as d,
  isPrototype as e,
  baseKeys as f,
  getTag as g,
  api$1 as h,
  isArrayLike as i,
  getDefaultExportFromCjs as j,
  App as k,
  localeValues as l,
  ConfigProvider as m,
  dayjs as n,
  customParseFormat as o,
  Breadcrumb as p,
  Empty$1 as q,
  requireDayjs_min as r,
  Typography as s,
  theme as t,
  Tag as u,
  Tabs as v,
  TabPane$1 as w,
  Badge as x,
  BellOutlined as y,
  Popover$1 as z
};
